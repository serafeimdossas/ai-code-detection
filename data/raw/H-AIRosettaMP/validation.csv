task_url,task_name,task_description,language_name,code,target,set
http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",Python,"def fib(n):
    if n < 2:
        return n
    else:
        fib_n_1 = 1
        fib_n_2 = 0
        fib_n = 0
        for i in range(2, n + 1):
            fib_n = fib_n_1 + fib_n_2
            fib_n_2 = fib_n_1
            fib_n_1 = fib_n
        return fib_n",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Variables,Variables,"Task

Demonstrate a language's methods of:

   variable declaration
   initialization
   assignment
   datatypes
   scope 
   referencing,     and 
   other variable related facilities

",Python,"# these examples, respectively, refer to integer, float, boolean, and string objects
example1 = 3
example2 = 3.0
example3 = True
example4 = ""hello""
 
# example1 now refers to a string object.
example1 = ""goodbye""",Human_written,Python_from_C
http://rosettacode.org/wiki/Fusc_sequence,Fusc sequence,"

Definitions

The   fusc   integer sequence is defined as:

   fusc(0) = 0
   fusc(1) = 1
   for n>1,   the   nth   term is defined as:
   if   n   is even;     fusc(n) = fusc(n/2)
   if   n   is   odd;     fusc(n) = fusc((n-1)/2)   +   fusc((n+1)/2)


Note that MathWorld's definition starts with unity, not zero.   This task will be using the OEIS' version   (above).



An observation

   fusc(A) = fusc(B)
where   A   is some non-negative integer expressed in binary,   and
where   B   is the binary value of   A   reversed.



Fusc numbers are also known as:

   fusc function   (named by Dijkstra, 1982)
   Stern's Diatomic series   (although it starts with unity, not zero)
   Stern-Brocot sequence   (although it starts with unity, not zero)


Task

   show the first   61   fusc numbers (starting at zero) in a horizontal format.
   show the fusc number (and its index) whose length is greater than any previous fusc number length.
   (the length is the number of decimal digits when the fusc number is expressed in base ten.)
   show all numbers with commas   (if appropriate).
   show all output here.


Related task

   RosettaCode Stern-Brocot sequence


Also see

   the MathWorld entry:   Stern's Diatomic Series.
   the OEIS entry:   A2487.

",Python,"from collections import deque
from itertools import islice, count
 
 
def fusc():
    q = deque([1])
    yield 0
    yield 1
 
    while True:
        x = q.popleft()
        q.append(x)
        yield x
 
        x += q[0]
        q.append(x)
        yield x
 
 
def longest_fusc():
    sofar = 0
    for i, f in zip(count(), fusc()):
        if f >= sofar:
            yield(i, f)
            sofar = 10 * sofar or 10
 
 
print('First 61:')
print(list(islice(fusc(), 61)))
 
print('\nLength records:')
for i, f in islice(longest_fusc(), 6):
    print(f'fusc({i}) = {f}')",Human_written,Python_from_Rust
http://rosettacode.org/wiki/N%27th,N'th,"Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix.



Example

Returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th



Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs:
0..25, 250..265, 1000..1025


Note: apostrophes are now optional to allow correct apostrophe-less English.



",Python,"class Integer:
    def ordinalize(self):
        num = abs(self)
        ordinal = ""th""
        if (11 <= num % 100 <= 13):
            ordinal = ""th""
        elif (num % 10 == 1):
            ordinal = ""st""
        elif (num % 10 == 2):
            ordinal = ""nd""
        elif (num % 10 == 3):
            ordinal = ""rd""
        return str(self) + ordinal
 
for r in [(0, 25), (250, 265), (1000, 1025)]:
    print "", "".join(map(lambda x: x.ordinalize(), range(r[0], r[1] + 1)))
    print",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Musical_scale,Musical scale,"Task

Output the 8 notes of the C major diatonic scale to the default musical sound device on the system. Specifically, pitch must be tuned to 12-tone equal temperament (12TET) with the modern standard A=440Hz.

These are the notes ""C, D, E, F, G, A, B, C(1 octave higher)"", or ""Do, Re, Mi, Fa, Sol, La, Si/Ti, Do(1 octave higher)"" on Fixed do Solfège.

For the purpose of this task, Middle C (in the case of the above tuning, around 261.63 Hz) should be used as the starting note, and any note duration is allowed.

For languages that cannot utilize a sound device, it is permissible to output to a musical score sheet (or midi file), or the task can be omitted.
",Python,">>> import winsound
>>> for note in [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]:
	winsound.Beep(int(note+.5), 500)	
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Amb,Amb,"Define and give an example of the Amb operator.

The Amb operator (short for ""ambiguous"") expresses nondeterminism. This doesn't refer to randomness (as in ""nondeterministic universe"") but is closely related to the term as it is used in automata theory (""non-deterministic finite automaton"").

The Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.

Problems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.

Essentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other ""parallel universes"" somehow go away. Amb called with no arguments fails.

For simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.

A pseudo-code program which satisfies this constraint might look like:

let x = Amb(1, 2, 3)
let y = Amb(7, 6, 4, 5)
Amb(x * y = 8)
print x, y
The output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x * y = 8) produces a success.

Alternatively, failure could be represented using strictly Amb():

unless x * y = 8 do Amb()
Or else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:

let x = Ambsel(1, 2, 3)
let y = Ambsel(4, 5, 6)
Ambassert(x * y = 8)
print x, y
where Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.

The task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:

""the"" ""that"" ""a""
""frog"" ""elephant"" ""thing""
""walked"" ""treaded"" ""grows""
""slowly"" ""quickly""
The constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.

The only successful sentence is ""that thing grows slowly""; other combinations do not satisfy the constraint and thus fail.

The goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.
",Python,"import itertools as _itertools
 
class Amb(object):
    def __init__(self):
        self._names2values   = {}       # set of values for each global name
        self._func           = None     # Boolean constraint function
        self._valueiterator  = None     # itertools.product of names values
        self._funcargnames   = None     # Constraint parameter names
 
    def __call__(self, arg=None):
        if hasattr(arg, '__code__'):                
            ##
            ## Called with a constraint function. 
            ##
            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals
            # Names used in constraint
            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]
            for name in argv:
                if name not in self._names2values:
                    assert name in globls, \
                           ""Global name %s not found in function globals"" % name
                    self._names2values[name] = globls[name]
            # Gather the range of values of all names used in the constraint
            valuesets = [self._names2values[name] for name in argv]
            self._valueiterator = _itertools.product(*valuesets)
            self._func = arg
            self._funcargnames = argv
            return self
        elif arg is not None:
            ##
            ## Assume called with an iterable set of values
            ##
            arg = frozenset(arg)
            return arg
        else:
            ##
            ## blank call tries to return next solution
            ##
            return self._nextinsearch()
 
    def _nextinsearch(self):
        arg = self._func
        globls = arg.__globals__
        argv = self._funcargnames
        found = False
        for values in self._valueiterator:
            if arg(*values):
                # Set globals.
                found = True
                for n, v in zip(argv, values):
                    globls[n] = v
                break
        if not found: raise StopIteration
        return values
 
    def __iter__(self):
        return self
 
    def __next__(self):
        return self()
    next = __next__ # Python 2
 
if __name__ == '__main__':
    if True:
        amb = Amb()
 
        print(""\nSmall Pythagorean triples problem:"")
        x = amb(range(1,11))
        y = amb(range(1,11))
        z = amb(range(1,11))
 
        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):
            print ('%s %s %s' % (x, y, z))
 
 
    if True:
        amb = Amb()
 
        print(""\nRosetta Code Amb problem:"")
        w1 = amb([""the"", ""that"", ""a""])
        w2 = amb([""frog"", ""elephant"", ""thing""])
        w3 = amb([""walked"", ""treaded"", ""grows""])
        w4 = amb([""slowly"", ""quickly""])
 
        for _dummy in amb( lambda w1, w2, w3, w4: \
                             w1[-1] == w2[0] and \
                             w2[-1] == w3[0] and \
                             w3[-1] == w4[0] ):
            print ('%s %s %s %s' % (w1, w2, w3, w4))
 
    if True:
        amb = Amb()
 
        print(""\nAmb problem from ""
            ""http://www.randomhacks.net/articles/2005/10/11/amb-operator:"")
        x = amb([1, 2, 3])
        y = amb([4, 5, 6])
 
        for _dummy in amb( lambda x, y: x * y != 8 ):
            print ('%s %s' % (x, y))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",Python,"def maxsubseq(seq):
  return max((seq[begin:end] for begin in xrange(len(seq)+1)
                             for end in xrange(begin, len(seq)+1)),
             key=sum)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Search_a_list,Search a list,"Task[edit]
Find the index of a string (needle) in an indexable, ordered collection of strings (haystack).

Raise an exception if the needle is missing.

If there is more than one occurrence then return the smallest index to the needle.

Extra credit
Return the largest index to a needle that has multiple occurrences in the haystack.

See also
 Search a list of records
",Python,"haystack=[""Zig"",""Zag"",""Wally"",""Ronald"",""Bush"",""Krusty"",""Charlie"",""Bush"",""Bozo""]
 
for needle in (""Washington"",""Bush""):
  try:
    print haystack.index(needle), needle
  except ValueError, value_error:
    print needle,""is not in haystack""",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"import random
 
def bogosort(l):
    while not in_order(l):
        random.shuffle(l)
    return l
 
def in_order(l):
    if not l:
        return True
    last = l[0]
    for x in l[1:]:
        if x < last:
            return False
        last = x
    return True",Human_written,Python_from_C#
http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",Python,"#!/usr/bin/env python
# canonicalize a CIDR block specification:
# make sure none of the host bits are set
 
import sys
from socket import inet_aton, inet_ntoa
from struct import pack, unpack
 
args = sys.argv[1:]
if len(args) == 0:
    args = sys.stdin.readlines()
 
for cidr in args:
   # IP in dotted-decimal / bits in network part
   dotted, size_str = cidr.split('/')
   size = int(size_str)
 
   numeric = unpack('!I', inet_aton(dotted))[0]  # IP as an integer
   binary = f'{numeric:#034b}'                   # then as a padded binary string
   prefix = binary[:size + 2]                    # just the network part
                                                 #   (34 and +2 are to account
                                                 #    for leading '0b')
 
   canon_binary = prefix + '0' * (32 - size)     # replace host part with all zeroes
   canon_numeric = int(canon_binary, 2)          # convert back to integer
   canon_dotted = inet_ntoa(pack('!I',
                            (canon_numeric)))    # and then to dotted-decimal
   print(f'{canon_dotted}/{size}')               # output result",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Multifactorial,Multifactorial,"The factorial of a number, written as 



n
!


{\displaystyle n!}

, is defined as 



n
!
=
n
(
n
−
1
)
(
n
−
2
)
.
.
.
(
2
)
(
1
)


{\displaystyle n!=n(n-1)(n-2)...(2)(1)}

.

Multifactorials generalize factorials as follows:

 



n
!
=
n
(
n
−
1
)
(
n
−
2
)
.
.
.
(
2
)
(
1
)


{\displaystyle n!=n(n-1)(n-2)...(2)(1)}


 



n
!
!
=
n
(
n
−
2
)
(
n
−
4
)
.
.
.


{\displaystyle n!!=n(n-2)(n-4)...}


 



n
!
!
!
=
n
(
n
−
3
)
(
n
−
6
)
.
.
.


{\displaystyle n!!!=n(n-3)(n-6)...}


 



n
!
!
!
!
=
n
(
n
−
4
)
(
n
−
8
)
.
.
.


{\displaystyle n!!!!=n(n-4)(n-8)...}


 



n
!
!
!
!
!
=
n
(
n
−
5
)
(
n
−
10
)
.
.
.


{\displaystyle n!!!!!=n(n-5)(n-10)...}


In all cases, the terms in the products are positive integers.

If we define the degree of the multifactorial as the difference in successive terms that are multiplied together for a multifactorial (the number of exclamation marks), then the task is twofold:

 Write a function that given n and the degree, calculates the multifactorial.
 Use the function to generate and display here a table of the first ten members (1 to 10) of the first five degrees of multifactorial.

Note: The wikipedia entry on multifactorials gives a different formula. This task uses the Wolfram mathworld definition.
",Python,"from itertools import islice
from functools import reduce
from operator import mul
 
def multifactorial(number, degree):
    if degree < 1:
        raise ValueError(""degree"")
    count = 1 + (number - 1) // degree
    if count < 1:
        raise ValueError(""number"")
    return reduce(mul, range(number, number - degree * count, -degree))
 
print(""\n"".join("" "".join(str(multifactorial(number, degree)) for number in range(1, 11)) for degree in range(1, 6)))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Cantor_set,Cantor set,"Task

Draw a Cantor set.



See details at this Wikipedia webpage:   Cantor set
",Python,"import sys
 
WIDTH = 81
HEIGHT = 5
 
lines = []
 
def init():
    for i in range(HEIGHT):
        lines.append(['*'] * WIDTH)
 
def cantor(start, len, index):
    seg = len / 3
    if seg == 0:
        return
    for i in range(index, HEIGHT):
        for j in range(start + seg, start + seg * 2):
            lines[i][j] =''
    cantor(start, seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)
 
def print_lines():
    for i in range(HEIGHT):
        for j in range(WIDTH):
            sys.stdout.write(lines[i][j])
        sys.stdout.write('\n')
 
init()
cantor(0, WIDTH, 1)
print_lines()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",Python,"import decimal
import math
 
def safe_add(a, b, prec):
    a, b = decimal.Decimal(a), decimal.Decimal(b)
    rm = decimal.getcontext().rounding
    orig = decimal.getcontext().rounding
 
    decimal.getcontext().rounding = decimal.ROUND_FLOOR
    low = a + b
    decimal.getcontext().rounding = decimal.ROUND_CEILING
    high = a + b
    decimal.getcontext().rounding = orig
    return (low, high)
 
for a, b in [[""1"", ""2""],
 [""0.1"", ""0.2""],
 [""0.1"", ""0.00002""],
 [""0.1"", ""-0.00002""],
]:
    print(""%s + %s = %s"" % (a, b, safe_add(a, b, 3)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Constrained_random_points_on_a_circle,Constrained random points on a circle,"Task

Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that 




10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

. 
Then display/plot them. The outcome should be a ""fuzzy"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.

There are several possible approaches to accomplish this. Here are two possible algorithms.

1) Generate random pairs of integers and filter out those that don't satisfy this condition:





10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

.
2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.



",Python,"import random
import math
import png
 
points = [(int(round(10*math.cos(angle))), int(round(10*math.sin(angle)))) for angle in [random.random()*2*math.pi for i in range(100)]]
 
for row in range(-15,16):
    print """".join([""X"" if (row,col) in points else "" "" for col in range(-15,16)])
 
pixmap = [[0 for col in range(321)] for row in range(321)]
for (x,y) in points:
    pixmap[10*(x+16)][10*(y+16)] = 1
 
for row in range(321):
    for col in range(321):
        if math.sqrt((row-160)**2 + (col-160)**2) < 90:
            pixmap[row][col] = 1
        if math.sqrt((row-160)**2 + (col-160)**2) < 160:
            pixmap[row][col] = 1
 
pngfile = __file__
pngfile = pngfile.replace("".py"","".png"")
f = open(pngfile, 'wb')
w = png.Writer(321,321,greyscale=True)
w.write(f, pixmap)
f.close()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Atomic_updates,Atomic updates,"

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

 get the current value of any bucket
 remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

 As often as possible, pick two buckets and make their values closer to equal.
 As often as possible, pick two buckets and arbitrarily redistribute their values.
 At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.


The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.


This task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.



",Python,"from __future__ import with_statement # required for Python 2.5
import threading
import random
import time
 
terminate = threading.Event()
 
class Buckets:
    def __init__(self, nbuckets):
        self.nbuckets = nbuckets
        self.values = [random.randrange(10) for i in range(nbuckets)]
        self.lock = threading.Lock()
 
    def __getitem__(self, i):
        return self.values[i]
 
    def transfer(self, src, dst, amount):
        with self.lock:
            amount = min(amount, self.values[src])
            self.values[src] -= amount
            self.values[dst] += amount
 
    def snapshot(self):
        # copy of the current state (synchronized)
        with self.lock:
            return self.values[:]
 
def randomize(buckets):
    nbuckets = buckets.nbuckets
    while not terminate.isSet():
        src = random.randrange(nbuckets)
        dst = random.randrange(nbuckets)
        if dst!=src:
            amount = random.randrange(20)
            buckets.transfer(src, dst, amount)
 
def equalize(buckets):
    nbuckets = buckets.nbuckets
    while not terminate.isSet():
        src = random.randrange(nbuckets)
        dst = random.randrange(nbuckets)
        if dst!=src:
            amount = (buckets[src] - buckets[dst]) // 2
            if amount>=0: buckets.transfer(src, dst, amount)
            else: buckets.transfer(dst, src, -amount)
 
def print_state(buckets):
    snapshot = buckets.snapshot()
    for value in snapshot:
        print '%2d' % value,
    print '=', sum(snapshot)
 
# create 15 buckets
buckets = Buckets(15)
 
# the randomize thread
t1 = threading.Thread(target=randomize, args=[buckets])
t1.start()
 
# the equalize thread
t2 = threading.Thread(target=equalize, args=[buckets])
t2.start()
 
# main thread, display
try:
    while True:
        print_state(buckets)
        time.sleep(1)
except KeyboardInterrupt: # ^C to finish
    terminate.set()
 
# wait until all worker threads finish
t1.join()
t2.join()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player),Guess the number/With feedback (player),"Task

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.
The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.



Related tasks

   Guess the number/With Feedback
   Bulls and cows/Player

",Python,"#!/usr/bin/env python
 
DONE = RIGHT = 0
HIGH = 1
LOW = -1
 
def main():
    showInstructions()
    while guess(1, 100)!= DONE:
        pass
 
def guess(low, high):
    if low > high:
        print ""I can't guess it. Perhaps you changed your number.""
        return DONE
    g = int(round((low + high) / 2))
    result = getResult(g)
    if result == RIGHT:
        return DONE
    elif result == LOW:
        return guess(g + 1, high)
    elif result == HIGH:
        return guess(low, g - 1)
 
def getResult(g):
    while True:
        print 'Is it'+ str(g) + '? '
        ans = raw_input().upper().replace(' ', '') +''
        if ans[0] == 'R':
            print 'I got it! Thanks for the game.'
            return RIGHT
        elif ans[0] == 'L':
            return LOW
        elif ans[0] == 'H':
            return HIGH
        else:
            print 'Please tell me if I am ""high"", ""low"" or ""right"".'
 
def showInstructions():
    print 'Think of a number between 1 and 100 and I will try to guess it.'
    print 'After I guess, type ""low"", ""high"" or ""right"", and then press enter.'
    raw_input(""When you've thought of a number press enter."")
 
main()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/OpenWebNet_password,OpenWebNet password,"Calculate the password requested by ethernet gateways from the Legrand / Bticino MyHome OpenWebNet home automation system when the user's ip address is not in the gateway's whitelist

Note: Factory default password is '12345'. Changing it is highly recommended !

conversation goes as follows

← *#*1##
→ *99*0##
← *#603356072##
at which point a password should be sent back, calculated from the ""password open"" that is set in the gateway, and the nonce that was just sent

→ *#25280520##
← *#*1##",Python,"def ownCalcPass (password, nonce, test=False) :
    start = True    
    num1 = 0
    num2 = 0
    password = int(password)
    if test:
        print(""password: %08x"" % (password))
    for c in nonce :
        if c != ""0"":
            if start:
                num2 = password
            start = False
        if test:
            print(""c: %s num1: %08x num2: %08x"" % (c, num1, num2))
        if c == '1':
            num1 = (num2 & 0xFFFFFF80) >> 7
            num2 = num2 << 25
        elif c == '2':
            num1 = (num2 & 0xFFFFFFF0) >> 4
            num2 = num2 << 28
        elif c == '3':
            num1 = (num2 & 0xFFFFFFF8) >> 3
            num2 = num2 << 29
        elif c == '4':
            num1 = num2 << 1
            num2 = num2 >> 31
        elif c == '5':
            num1 = num2 << 5
            num2 = num2 >> 27
        elif c == '6':
            num1 = num2 << 12
            num2 = num2 >> 20
        elif c == '7':
            num1 = num2 & 0x0000FF00 | (( num2 & 0x000000FF ) << 24 ) | (( num2 & 0x00FF0000 ) >> 16 )
            num2 = ( num2 & 0xFF000000 ) >> 8
        elif c == '8':
            num1 = (num2 & 0x0000FFFF) << 16 | ( num2 >> 24 )
            num2 = (num2 & 0x00FF0000) >> 8
        elif c == '9':
            num1 = ~num2
        else :
            num1 = num2
 
        num1 &= 0xFFFFFFFF
        num2 &= 0xFFFFFFFF
        if (c not in ""09""):
            num1 |= num2
        if test:
            print(""     num1: %08x num2: %08x"" % (num1, num2))
        num2 = num1
    return num1
 
def test_passwd_calc(passwd, nonce, expected):
    res = ownCalcPass(passwd, nonce, False)
    m = passwd+' '+nonce+' '+str(res)+' '+str(expected)
    if res == int(expected) :
        print('PASS '+m)
    else :
        print('FAIL '+m)
 
if __name__ == '__main__':
    test_passwd_calc('12345','603356072','25280520')
    test_passwd_calc('12345','410501656','119537670')
    test_passwd_calc('12345','630292165','4269684735')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/String_case,String case,"Task

Take the string     alphaBETA     and demonstrate how to convert it to:

   upper-case     and 
   lower-case


Use the default encoding of a string literal or plain ASCII if there is no string literal in your language.

Note: In some languages alphabets toLower and toUpper is not reversable.

Show any additional case conversion functions   (e.g. swapping case, capitalizing the first letter, etc.)   that may be included in the library of your language.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ""alphaBETA""
print s.upper() # => ""ALPHABETA""
print s.lower() # => ""alphabeta""
 
print s.swapcase() # => ""ALPHAbeta""
 
print ""fOo bAR"".capitalize() # => ""Foo bar""
print ""fOo bAR"".title() # => ""Foo Bar""
 
import string
print string.capwords(""fOo bAR"") # => ""Foo Bar""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Haversine_formula,Haversine formula,"

 This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".



Task

Implement a great-circle distance function, or use a library function,
to show the great-circle distance between:

 Nashville International Airport (BNA)   in Nashville, TN, USA,   which is: 
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

 Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius. However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased). When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km. This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.





",Python,"from math import radians, sin, cos, sqrt, asin
 
 
def haversine(lat1, lon1, lat2, lon2):
    R = 6372.8  # Earth radius in kilometers
 
    dLat = radians(lat2 - lat1)
    dLon = radians(lon2 - lon1)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
 
    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2
    c = 2 * asin(sqrt(a))
 
    return R * c
 
>>> haversine(36.12, -86.67, 33.94, -118.40)
2887.2599506071106
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Python,"try:
    cmp     # Python 2 OK or NameError in Python 3
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              cmp=lambda x,y:cmp(y+x, x+y)))
except NameError:
    # Python 3
    from functools import cmp_to_key
    def cmp(x, y):
        return -1 if x<y else ( 0 if x==y else 1)
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y))))
 
for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:
    print('Numbers: %r\n  Largest integer: %15s' % (numbers, maxnum(numbers)))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Mouse_position,Mouse position,"Task

Get the current location of the mouse cursor relative to the active window.

Please specify if the window may be externally created.



",Python,"# version 1.1.2
import time
from pymouse import PyMouse
 
m = PyMouse()
 
for i in range(1, 6):
    time.sleep(1)
    p = m.position()
    print(f""{i}: x = {p[0]:4d} y = {p[1]:4d}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail,Strip whitespace from a string/Top and tail,"Task

Demonstrate how to strip leading and trailing whitespace from a string.

The solution should demonstrate how to achieve the following three results:

 String with leading whitespace removed
 String with trailing whitespace removed
 String with both leading and trailing whitespace removed


For the purposes of this task whitespace includes non printable characters such as the space character, the tab character, and other such characters that have no corresponding graphical representation.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> s = ' \t \r \n String with spaces  \t  \r  \n  '
>>> s
' \t \r \n String with spaces  \t  \r  \n  '
>>> s.lstrip()
'String with spaces  \t  \r  \n  '
>>> s.rstrip()
' \t \r \n String with spaces'
>>> s.strip()
'String with spaces'
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> def stripchars(s, chars):
...     return s.translate(None, chars)
... 
>>> stripchars(""She was a soul stripper. She took my heart!"", ""aei"")
'Sh ws  soul strppr. Sh took my hrt!'",Human_written,Python_from_Go
http://rosettacode.org/wiki/McNuggets_problem,McNuggets problem,"Wikipedia
The McNuggets version of the coin problem was introduced by Henri Picciotto,
who included it in his algebra textbook co-authored with Anita Wah. Picciotto
thought of the application in the 1980s while dining with his son at
McDonald's, working the problem out on a napkin. A McNugget number is
the total number of McDonald's Chicken McNuggets in any number of boxes.
In the United Kingdom, the original boxes (prior to the introduction of
the Happy Meal-sized nugget boxes) were of 6, 9, and 20 nuggets.

Task

Calculate (from 0 up to a limit of 100) the largest non-McNuggets
number (a number n which cannot be expressed with 6x + 9y + 20z = n
where x, y and z are natural numbers).



",Python,">>> from itertools import product
>>> nuggets = set(range(101))
>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):
	nuggets.discard(6*s + 9*n + 20*t)
 
 
>>> max(nuggets)
43
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Factorions,Factorions,"

Definition

A factorion is a natural number that equals the sum of the factorials of its digits.



Example
 
145   is a factorion in base 10 because:


          1! + 4! + 5!   =   1 + 24 + 120   =   145 





It can be shown (see talk page) that no factorion in base 10 can exceed   1,499,999.



Task

Write a program in your language to demonstrate, by calculating and printing out the factorions, that:

   There are   3   factorions in base   9
   There are   4   factorions in base 10
   There are   5   factorions in base 11 
   There are   2   factorions in base 12     (up to the same upper bound as for base 10)


See also

 Wikipedia article
 OEIS:A014080 - Factorions in base 10
 OEIS:A193163 - Factorions in base n

",Python,"fact = [1] # cache factorials from 0 to 11
for n in range(1, 12):
    fact.append(fact[n-1] * n)
 
for b in range(9, 12+1):
    print(f""The factorions for base {b} are:"")
    for i in range(1, 1500000):
        fact_sum = 0
        j = i
        while j > 0:
            d = j % b
            fact_sum += fact[d]
            j = j//b
        if fact_sum == i:
            print(i, end="" "")
    print(""\n"")",Human_written,Python_from_C++
http://rosettacode.org/wiki/Integer_sequence,Integer sequence,"Task

Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.



An example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.



",Python,"class Count:
    def main():
        i = 1
        while True:
            print(i)
            i += 1",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Abundant_odd_numbers,Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",Python,"#!/usr/bin/python
# Abundant odd numbers - Python
 
oddNumber  = 1
aCount  = 0
dSum  = 0
 
from math import sqrt
 
def divisorSum(n):
    sum = 1
    i = int(sqrt(n)+1)
 
    for d in range (2, i):
        if n % d == 0:
            sum += d
            otherD = n // d
            if otherD != d:
                sum += otherD
    return sum
 
print (""The first 25 abundant odd numbers:"")
while aCount  < 25:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
        print(""{0:5} proper divisor sum: {1}"". format(oddNumber ,dSum ))
    oddNumber  += 2
 
while aCount  < 1000:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
    oddNumber  += 2
print (""\n1000th abundant odd number:"")
print (""    "",(oddNumber - 2),"" proper divisor sum: "",dSum)
 
oddNumber  = 1000000001
found  = False
while not found :
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        found  = True
        print (""\nFirst abundant odd number > 1 000 000 000:"")
        print (""    "",oddNumber,"" proper divisor sum: "",dSum)
    oddNumber  += 2",Human_written,Python_from_C++
http://rosettacode.org/wiki/Write_entire_file,Write entire file,"Task

(Over)write a file so that it contains a string.



The reverse of Read entire file—for when you want to update or create a file which you would read in its entirety all at once.



",Python,"with open(fname, 'w') as f:
    f.write(str)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Python,"def myFuncSimple(funcParameter):
    """"""
    void myFuncSimple( void (*funcParameter)(void) )
    """"""
    #...
    funcParameter()
    #...",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",Python,"# version 1.2.0
 
def printBlock(data, len):
    a = [ord(x) - 48 for x in data]
    sumChars = sum(a)
    print(""\nblocks {}, cells {}"".format(a, len))
    if len - sumChars <= 0:
        print(""No solution"")
        return
    prep = [(""1"" * (x - 48)) for x in data]
    for r in genSequence(prep, len - sumChars + 1):
        print(r[1:])
 
def genSequence(ones, numZeros):
    if not ones:
        return [""0"" * numZeros]
    result = []
    for x in range(1, numZeros - len(ones) + 2):
        skipOne = ones[1:]
        for tail in genSequence(skipOne, numZeros - x):
            result.append(""0"" * x + ones[0] + tail)
    return result
 
def main():
    printBlock(""21"", 5)
    printBlock("""", 5)
    printBlock(""8"", 10)
    printBlock(""2323"", 15)
    printBlock(""23"", 5)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Special_variables,Special variables,"Special variables have a predefined meaning within a computer programming language.



Task

List the special variables used within the language.



",Python,"# version 1.0.6
 
class President:
    def __init__(self, name):
        self.name = name
        self.age = 0
    def set_age(self, value):
        if value in range(0, 125):
            self.age = value
        else:
            raise ValueError(f""{self.name}'s age must be between 0 and 125"")
 
def main():
    pres = President(""Donald"")
    pres.set_age(69)
    pres2 = President(""Jimmy"")
    pres2.set_age(91)
    presidents = [pres, pres2]
    for it in presidents:
        it.set_age(it.age + 1)
        print(f""President {it.name}'s age is currently {it.age}"")
    print()
    pres3 = President(""Theodore"")
    pres3.set_age(158)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Identity_matrix,Identity matrix,"Task

Build an   identity matrix   of a size known at run-time.



An identity matrix is a square matrix of size n × n,

where the diagonal elements are all 1s (ones),

and all the other elements are all 0s (zeroes).







I

n


=


[



1


0


0


⋯


0




0


1


0


⋯


0




0


0


1


⋯


0




⋮


⋮


⋮


⋱


⋮




0


0


0


⋯


1



]




{\displaystyle I_{n}={\begin{bmatrix}1&0&0&\cdots &0\\0&1&0&\cdots &0\\0&0&1&\cdots &0\\\vdots &\vdots &\vdots &\ddots &\vdots \\0&0&0&\cdots &1\\\end{bmatrix}}}





Related tasks

   Spiral matrix
   Zig-zag matrix 
   Ulam_spiral_(for_primes)

",Python,"def identity(size):
    matrix = [[0]*size for i in range(size)]
    #matrix = [[0] * size] * size    #Has a flaw. See http://stackoverflow.com/questions/240178/unexpected-feature-in-a-python-list-of-lists
 
    for i in range(size):
        matrix[i][i] = 1
 
    for rows in matrix:
        for elements in rows:
            print elements,
        print """"",Human_written,Python_from_Go
http://rosettacode.org/wiki/Knapsack_problem/Unbounded,Knapsack problem/Unbounded,"A traveler gets diverted and has to make an unscheduled stop in what turns out to be Shangri La.   Opting to leave, he is allowed to take as much as he likes of the following items, so long as it will fit in his knapsack, and he can carry it.

He knows that he can carry no more than   25   'weights' in total;   and that the capacity of his knapsack is   0.25   'cubic lengths'.

Looking just above the bar codes on the items he finds their weights and volumes.   He digs out his recent copy of a financial paper and gets the value of each item.

ItemExplanationValue (each)weightVolume (each)panacea
(vials of)Incredible healing properties30000.30.025ichor
(ampules of)Vampires blood18000.20.015gold
(bars)Shiney shiney25002.00.002KnapsackFor the carrying of-<=25<=0.25 



He can only take whole units of any item, but there is much more of any item than he could ever carry



Task

Show how many of each item does he take to maximize the value of items he is carrying away with him.



Note
 
   There are four solutions that maximize the value taken.   Only one need be given.


Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",Python,"# Define consts
weights <- c(panacea=0.3, ichor=0.2, gold=2.0)
volumes <- c(panacea=0.025, ichor=0.015, gold=0.002)
values <- c(panacea=3000, ichor=1800, gold=2500)
sack.weight <- 25
sack.volume <- 0.25
max.items <- floor(pmin(sack.weight/weights, sack.volume/volumes))
 
# Some utility functions
getTotalValue <- function(n) sum(n*values)
getTotalWeight <- function(n) sum(n*weights)
getTotalVolume <- function(n) sum(n*volumes)
willFitInSack <- function(n) getTotalWeight(n) <= sack.weight && getTotalVolume(n) <= sack.volume
 
# Find all possible combination, then eliminate those that won't fit in the sack
knapsack <- expand.grid(lapply(max.items, function(n) seq.int(0, n)))
ok <- apply(knapsack, 1, willFitInSack)
knapok <- knapsack[ok,]
 
# Find the solutions with the highest value
vals <- apply(knapok, 1, getTotalValue)
knapok[vals == max(vals),]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",Python,"import sys

SIZE = 1 << 4

def main():
	y = SIZE - 1
	while y >= 0:
		i = 0
		while i < y:
			sys.stdout.write(' ')
			i += 1
		x = 0
		while x + y < SIZE:
			if (x & y):
				sys.stdout.write('  ')
			else:
				sys.stdout.write('* ')
			x += 1
		sys.stdout.write('\n')
		y -= 1
	return 0

if __name__ == '__main__':
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Arbitrary-precision_integers_(included),Arbitrary-precision integers (included),"Using the in-built capabilities of your language, calculate the integer value of:

        
  
    
      
        
          5
          
            
              4
              
                
                  3
                  
                    2
                  
                
              
            
          
        
      
    
    {\displaystyle 5^{4^{3^{2}}}}
  


 Confirm that the first and last twenty digits of the answer are: 
     62060698786608744707...92256259918212890625

 Find and show the number of decimal digits in the answer.


Note: Do not submit an implementation of arbitrary precision arithmetic. The intention is to show the capabilities of the language as supplied. If a language has a single, overwhelming, library of varied modules that is endorsed by its home site – such as CPAN for Perl or Boost for C++ – then that may be used instead.
Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the only recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.


Related tasks

   Long multiplication
   Exponentiation order
   exponentiation operator
   Exponentiation with infix operators in (or operating on) the base

",Python,"from math import pow

x = pow(5, pow(4, pow(3, 2)))
y = str(x)
len = len(y)
print(""5^4^3^2 = "" + y[0:20] + ""..."" + y[len - 20:len] + "" and has "" + str(len) + "" digits"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",Python,"from __future__ import print_function
 
def getDifference(b1, b2):
	r = (b2 - b1) % 360.0
	# Python modulus has same sign as divisor, which is positive here,
	# so no need to consider negative case
	if r >= 180.0:
		r -= 360.0
	return r
 
if __name__ == ""__main__"":
	print (""Input in -180 to +180 range"")
	print (getDifference(20.0, 45.0))
	print (getDifference(-45.0, 45.0))
	print (getDifference(-85.0, 90.0))
	print (getDifference(-95.0, 90.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(29.4803, -88.6381))
	print (getDifference(-78.3251, -159.036))
 
	print (""Input in wider range"")
	print (getDifference(-70099.74233810938, 29840.67437876723))
	print (getDifference(-165313.6666297357, 33693.9894517456))
	print (getDifference(1174.8380510598456, -154146.66490124757))
	print (getDifference(60175.77306795546, 42213.07192354373))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Tree_traversal,Tree traversal,"Task

Implement a binary tree where each node carries an integer,   and implement:

   pre-order,
   in-order, 
   post-order,     and 
   level-order   traversal. 


Use those traversals to output the following tree:

         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9

The correct output should look like this:

preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9



See also

   Wikipedia article:   Tree traversal.

",Python,"from collections import namedtuple
 
Node = namedtuple('Node', 'data, left, right')
tree = Node(1,
            Node(2,
                 Node(4,
                      Node(7, None, None),
                      None),
                 Node(5, None, None)),
            Node(3,
                 Node(6,
                      Node(8, None, None),
                      Node(9, None, None)),
                 None))
 
def printwithspace(i):
    print(i, end=' ')
 
def dfs(order, node, visitor):
    if node is not None:
        for action in order:
            if action == 'N':
                visitor(node.data)
            elif action == 'L':
                dfs(order, node.left, visitor)
            elif action == 'R':
                dfs(order, node.right, visitor)
 
def preorder(node, visitor = printwithspace):
    dfs('NLR', node, visitor)
 
def inorder(node, visitor = printwithspace):
    dfs('LNR', node, visitor)
 
def postorder(node, visitor = printwithspace):
    dfs('LRN', node, visitor)
 
def ls(node, more, visitor, order='TB'):
    ""Level-based Top-to-Bottom or Bottom-to-Top tree search""
    if node:
        if more is None:
            more = []
        more += [node.left, node.right]
    for action in order:
        if action == 'B' and more:
            ls(more[0], more[1:], visitor, order)
        elif action == 'T' and node:
            visitor(node.data)
 
def levelorder(node, more=None, visitor = printwithspace):
    ls(node, more, visitor, 'TB') 
 
# Because we can
def reverse_preorder(node, visitor = printwithspace):
    dfs('RLN', node, visitor)
 
def bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):
    ls(node, more, visitor, 'BT')
 
 
if __name__ == '__main__':
    w = 10
    for traversal in [preorder, inorder, postorder, levelorder, 
                      reverse_preorder, bottom_up_order]:
        if traversal == reverse_preorder:
            w = 20
            print('\nThe generalisation of function dfs allows:')
        if traversal == bottom_up_order:
            print('The generalisation of function ls allows:')
        print(f""{traversal.__name__:>{w}}:"", end=' ')
        traversal(tree)
        print()",Human_written,Python_from_Java
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"import itertools

games = [""12"", ""13"", ""14"", ""23"", ""24"", ""34""]
results = ""000000""

def next_result():
    global results
    if results == ""222222"":
        return False
    res = int(results, 3) + 1
    results = str(res)
    while len(results) < 6:
        results = ""0"" + results
    return True

def main():
    points = [[0 for _ in range(10)] for _ in range(4)]
    while next_result():
        records = [0, 0, 0, 0]
        for i in range(6):
            if results[i] == ""2"":
                records[int(games[i][0]) - 1] += 3
            elif results[i] == ""1"":
                records[int(games[i][0]) - 1] += 1
                records[int(games[i][1]) - 1] += 1
            else:
                records[int(games[i][1]) - 1] += 3
        records.sort()
        points[0][records[0]] += 1
        points[1][records[1]] += 1
        points[2][records[2]] += 1
        points[3][records[3]] += 1
    print(""First place: "" + str(points[3]))
    print(""Second place: "" + str(points[2]))
    print(""Third place: "" + str(points[1]))
    print(""Fourth place: "" + str(points[0]))

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Detect_division_by_zero,Detect division by zero,"Task

Write a function to detect a   divide by zero error   without checking if the denominator is zero.



",Python,"def div_check(x, y):
  try:
    x / y
  except ZeroDivisionError:
    return True
  else:
    return False",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Calendar,Calendar,"Create a routine that will generate a text calendar for any year.
Test the calendar by generating a calendar for the year 1969, on a device of the time.
Choose one of the following devices:

 A line printer with a width of 132 characters.
 An IBM 3278 model 4 terminal (80×43 display with accented characters). Target formatting the months of the year to fit nicely across the 80 character width screen. Restrict number of lines in test output to 43.


(Ideally, the program will generate well-formatted calendars for any page width from 20 characters up.)

Kudos (κῦδος) for routines that also transition from Julian to Gregorian calendar.

This task is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

For further Kudos see task CALENDAR, where all code is to be in UPPERCASE.

For economy of size, do not actually include Snoopy generation in either the code or the output, instead just output a place-holder.



Related task

   Five weekends

",Python,">>> import calendar
>>> help(calendar.prcal)
Help on method pryear in module calendar:
 
pryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance
    Print a years calendar.
 
>>> calendar.prcal(1969)
                                  1969
 
      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2                      1  2
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9
13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16
20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23
27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30
                                                    31
 
       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                1  2  3  4                         1
 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8
14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15
21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22
28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29
                                                    30
 
        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7
 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14
14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21
21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28
28 29 30 31               25 26 27 28 29 30 31      29 30
 
      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2       1  2  3  4  5  6  7
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14
13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21
20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28
27 28 29 30 31            24 25 26 27 28 29 30      29 30 31",Human_written,Python_from_Go
http://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm,Bitmap/Bresenham's line algorithm,"Task

Using the data storage type defined on the Bitmap page for raster graphics images,

draw a line given two points with Bresenham's line algorithm.



",Python,"def line(x0, y0, x1, y1):
    dx = abs(x1-x0)
    sx = 1 if x0 < x1 else -1
    dy = abs(y1-y0)
    sy = 1 if y0 < y1 else -1
    err = (dx if dx > dy else -dy) / 2
    e2 = 0
    while True:
        setPixel(x0, y0)
        if x0 == x1 and y0 == y1:
            break
        e2 = err
        if e2 > -dx:
            err -= dy
            x0 += sx
        if e2 < dy:
            err += dx
            y0 += sy",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Speech_synthesis,Speech synthesis,"Render the text       This is an example of speech synthesis      as speech.



Related task

   using a speech engine to highlight words



",Python,"import pyttsx
 
engine = pyttsx.init()
engine.say(""It was all a dream."")
engine.runAndWait()",Human_written,Python_from_C
http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",Python,"def r2cf(n1,n2):
  while n2:
    n1, (t1, n2) = n2, divmod(n1, n2)
    yield t1
 
print(list(r2cf(1,2)))    # => [0, 2]
print(list(r2cf(3,1)))    # => [3]
print(list(r2cf(23,8)))    # => [2, 1, 7]
print(list(r2cf(13,11)))    # => [1, 5, 2]
print(list(r2cf(22,7)))    # => [3, 7]
print(list(r2cf(14142,10000)))    # => [1, 2, 2, 2, 2, 2, 1, 1, 29]
print(list(r2cf(141421,100000)))    # => [1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]
print(list(r2cf(1414214,1000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]
print(list(r2cf(14142136,10000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]",Human_written,Python_from_C++
http://rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters,Determine if a string has all unique characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are unique
   indicate if or which character is duplicated and where
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as unique
   process the strings from left─to─right
   if       unique,   display a message saying such
   if not unique,   then:
   display a message saying such
   display what character is duplicated
   only the 1st non─unique character need be displayed
   display where ""both"" duplicated characters are in the string
   the above messages can be part of a single message
   display the hexadecimal value of the duplicated character


Use (at least) these five test values   (strings):

   a string of length     0   (an empty string)
   a string of length     1   which is a single period   (.)
   a string of length     6   which contains:   abcABC
   a string of length     7   which contains a blank in the middle:   XYZ  ZYX
   a string of length   36   which   doesn't   contain the letter ""oh"":
 1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import itertools

input = ["""", ""."", ""abcABC"", ""XYZ ZYX"", ""1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ""]
for s in input:
    print(f'""{s}"" (Length {len(s)})'+
          ', '.join(
              [f""'{c}' (0X{ord(c):X})[{', '.join(map(str, [i for i, c2 in enumerate(s) if c2 == c]))}]""
               for c, g in itertools.groupby(s) if len(list(g)) > 1] +
              ['All characters are unique.']
          )
    )",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Knapsack_problem/Bounded,Knapsack problem/Bounded,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature.   So he needs some items during the trip.   Food, clothing, etc.   He has a good knapsack for carrying the things, but he knows that he can carry only 4 kg weight in his knapsack, because they will make the trip from morning to evening.

He creates a list of what he wants to bring for the trip, but the total weight of all items is too much.   He adds a value to each item.   The value represents how important the thing for the tourist.

The list contains which items are the wanted things for the trip, what is the weight and value of an item, and how many units does he have from each items.



This is the list:


 Table of potential knapsack items


 item 
 weight (dag) (each) 
 value (each) 
 piece(s)


 map 
 9 
 150 
 1


 compass 
 13 
 35 
 1


 water 
 153 
 200 
 2


 sandwich 
 50 
 60 
 2


 glucose 
 15 
 60 
 2


 tin 
 68 
 45 
 3


 banana 
 27 
 60 
 3


 apple 
 39 
 40 
 3


 cheese 
 23 
 30 
 1


 beer 
 52 
 10 
 3


 suntan cream 
 11 
 70 
 1


 camera 
 32 
 30 
 1


 T-shirt 
 24 
 15 
 2


 trousers 
 48 
 10 
 2


 umbrella 
 73 
 40 
 1


 waterproof trousers 
 42 
 70 
 1


 waterproof overclothes 
 43 
 75 
 1


 note-case 
 22 
 80 
 1


 sunglasses 
 7 
 20 
 1


 towel 
 18 
 12 
 2


 socks 
 4 
 50 
 1


 book 
 30 
 10 
 2


 knapsack 
 ≤400 dag 
 ? 
 ?



The tourist can choose to take any combination of items from the list, and some number of each item is available   (see the column   piece(s)   in the list above).

He may not cut the items, so he can only take whole units of any item.



Task

Show which items does the tourist carry in his knapsack so that their total weight does not exceed 4 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",Python,"import time
def knapSack(w1):
    init()
    change()
    n = len(w)
    K = [[0 for x in range(w1 + 1)] for x in range(n + 1)]
    for i in range(n):
        vi = v[i]
        wi = w[i]
        w0 = 1
        while w0 <= w1:
            x = K[i][w0]
            if wi <= w0:
                x = max(vi + K[i][w0 - wi], x)
            K[i + 1][w0] = x
            w0 += 1
    str = """"
    v1 = K[n][w1]
    while v1 > 0:
        if v1!= K[n - 1][w1]:
            v1 -= v[n - 1]
            w1 -= w[n - 1]
            str += items[n - 1] + ""\n""
        n -= 1
    return str
 
def max(a, b):
    if a > b:
        return a
    else:
        return b
 
w = []
v = []
items = []
p = [1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2]
 
def init():
    global w
    global v
    global items
    w = [9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11, 32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30]
    v = [150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70, 30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10]
    items = [""map"",""compass"",""water"",""sandwich"",""glucose"",""tin"", ""banana"",""apple"",""cheese"",""beer"",""suntan cream"", ""camera"",""T-shirt"",""trousers"",""umbrella"", ""waterproof trousers"",""waterproof overclothes"", ""note-case"",""sunglasses"",""towel"",""socks"",""book""]
 
def change():
    global w
    global v
    global items
    n = len(w)
    s = 0
    for i in range(n):
        s += p[i]
    x = [0 for x in range(s)]
    k = 0
    for i in range(n):
        xi = w[i]
        for j in range(p[i]):
            x[k] = xi
            k += 1
    w = x
    x = [0 for x in range(s)]
    k = 0
    for i in range(n):
        xi = v[i]
        for j in range(p[i]):
            x[k] = xi
            k += 1
    v = x
    pItems = ["""" for x in range(s)]
    for k in range(n):
        itemI = items[k]
        for j in range(p[k]):
            pItems[k] = itemI
    items = pItems
 
if __name__ == ""__main__"":
    start = time.time()
    print(knapSack(400))
    end = time.time()
    print(end - start)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Heapsort,Sorting algorithms/Heapsort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Heapsort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Heapsort is an in-place sorting algorithm with worst case and average complexity of   O(n logn).

The basic idea is to turn the array into a binary heap structure, which has the property that it allows efficient retrieval and removal of the maximal element.

We repeatedly ""remove"" the maximal element from the heap, thus building the sorted list from back to front.

A heap sort requires random access, so can only be used on an array-like data structure.

Pseudocode:

function heapSort(a, count) is
   input: an unordered array a of length count
 
   (first place a in max-heap order)
   heapify(a, count)
 
   end := count - 1
   while end > 0 do
      (swap the root(maximum value) of the heap with the
       last element of the heap)
      swap(a[end], a[0])
      (decrement the size of the heap so that the previous
       max value will stay in its proper place)
      end := end - 1
      (put the heap back in max-heap order)
      siftDown(a, 0, end)



function heapify(a,count) is
   (start is assigned the index in a of the last parent node)
   start := (count - 2) / 2
   
   while start ≥ 0 do
      (sift down the node at index start to the proper place
       such that all nodes below the start index are in heap
       order)
      siftDown(a, start, count-1)
      start := start - 1
   (after sifting down the root all nodes/elements are in heap order)
 
function siftDown(a, start, end) is
   (end represents the limit of how far down the heap to sift)
   root := start

   while root * 2 + 1 ≤ end do       (While the root has at least one child)
      child := root * 2 + 1           (root*2+1 points to the left child)
      (If the child has a sibling and the child's value is less than its sibling's...)
      if child + 1 ≤ end and a[child] < a[child + 1] then
         child := child + 1           (... then point to the right child instead)
      if a[root] < a[child] then     (out of max-heap order)
         swap(a[root], a[child])
         root := child                (repeat to continue sifting down the child now)
      else
         return



Write a function to sort a collection of integers using heapsort.



",Python,"def heap_sort(arr):
    heapify(arr)
    end = len(arr) - 1
    while end > 0:
        arr[end], arr[0] = arr[0], arr[end]
        end -= 1
        sift_down(arr, 0, end)
 
def heapify(arr):
    start = len(arr) // 2 - 1
    while start >= 0:
        sift_down(arr, start, len(arr) - 1)
        start -= 1
 
def sift_down(arr, start_pos, end_pos):
    root_pos = start_pos
    while root_pos * 2 + 1 <= end_pos:
        child_pos = root_pos * 2 + 1
        if child_pos + 1 <= end_pos and arr[child_pos] < arr[child_pos + 1]:
            child_pos += 1
        if arr[root_pos] < arr[child_pos]:
            arr[root_pos], arr[child_pos] = arr[child_pos], arr[root_pos]
            root_pos = child_pos
        else:
            return
 
arr = [12, 11, 15, 10, 9, 1, 2, 3, 13, 14, 4, 5, 6, 7, 8,]
heap_sort(arr)
print(arr)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import collections, sys
 
def filecharcount(openfile):
    return sorted(collections.Counter(c for l in openfile for c in l).items())
 
f = open(sys.argv[1])
print(filecharcount(f))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Rot-13,Rot-13,"

Task

Implement a   rot-13   function   (or procedure, class, subroutine, or other ""callable"" object as appropriate to your programming environment).

Optionally wrap this function in a utility program   (like tr,   which acts like a common UNIX utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line,   or (if no filenames are passed thereon) acting as a filter on its   ""standard input.""



(A number of UNIX scripting languages and utilities, such as   awk   and   sed   either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g.,   Perl   and   Python).

The   rot-13   encoding is commonly known from the early days of Usenet ""Netnews"" as a way of obfuscating text to prevent casual reading of   spoiler   or potentially offensive material.

Many news reader and mail user agent programs have built-in rot-13 encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.

The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is ""rotated"" 13 characters ""around"" the 26 letter alphabet from its normal cardinal position   (wrapping around from   z   to   a   as necessary).

Thus the letters   abc   become   nop   and so on.

Technically rot-13 is a   ""mono-alphabetic substitution cipher""   with a trivial   ""key"".

A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters
in the input stream through without alteration.



Related tasks

   Caesar cipher
   Substitution Cipher
   Vigenère Cipher/Cryptanalysis



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> u'foo'.encode('rot13')
'sbb'
>>> 'sbb'.decode('rot13')
u'foo'",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Apply_a_callback_to_an_array,Apply a callback to an array,"Task

Take a combined set of elements and apply a function to each element.



",Python,"def square(n):
    return n * n
 
numbers = [1, 3, 5, 7]
 
squares1 = [square(n) for n in numbers]     # list comprehension
 
squares2a = map(square, numbers)            # functional form
 
squares2b = map(lambda x: x*x, numbers)     # functional form with `lambda`
 
squares3 = [n * n for n in numbers]         # no need for a function,
                                            # anonymous or otherwise
 
isquares1 = (n * n for n in numbers)        # iterator, lazy
 
import itertools
isquares2 = itertools.imap(square, numbers) # iterator, lazy",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# convert a string to YAML
y = yaml.loads(s)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Executable_library,Executable library,"The general idea behind an executable library is to create a library
that when used as a library does one thing;
but has the ability to be run directly via command line.
Thus the API comes with a CLI in the very same source code file.

Task detail

 Create a library/module/dll/shared object/... for a programming language that contains a function/method called hailstone that is a function taking a positive integer and returns the Hailstone sequence for that number.
 The library, when executed directly should satisfy the remaining requirements of the Hailstone sequence task:
 2. Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 3. Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
 Create a second executable to calculate the following:
 Use the library's hailstone function, in the standard manner, (or document how this use deviates from standard use of a library), together with extra code in this executable, to find the hailstone length returned most often for 1 ≤ n < 100,000.
 Explain any extra setup/run steps needed to complete the task.
Notes:

 It is assumed that for a language that overwhelmingly ships in a compiled form, such as C, the library must also be an executable and the compiled user of that library is to do so without changing the compiled library. I.e. the compile tool-chain is assumed not to be present in the runtime environment.
 Interpreters are present in the runtime environment.",Python,"def hailstone(n):
    seq = [n]
    while n>1:
        n = 3*n + 1 if n & 1 else n//2
        seq.append(n)
    return seq
 
if __name__ == '__main__':
    h = hailstone(27)
    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]
    print(""Maximum length %i was found for hailstone(%i) for numbers <100,000"" %
          max((len(hailstone(i)), i) for i in range(1,100000)))",Human_written,Python_from_C
http://rosettacode.org/wiki/OpenGL,OpenGL,"

Task

Display a smooth shaded triangle with OpenGL.

 Triangle created using C example compiled with GCC 4.1.2 and freeglut3.

",Python,"#!/usr/bin/env python
#-*- coding: utf-8 -*-
 
from OpenGL.GL import *
from OpenGL.GLUT import *
 
def paint():
    glClearColor(0.3,0.3,0.3,0.0)
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
 
    glShadeModel(GL_SMOOTH)
 
    glLoadIdentity()
    glTranslatef(-15.0, -15.0, 0.0)
 
    glBegin(GL_TRIANGLES)
    glColor3f(1.0, 0.0, 0.0)
    glVertex2f(0.0, 0.0)
    glColor3f(0.0, 1.0, 0.0)
    glVertex2f(30.0, 0.0)
    glColor3f(0.0, 0.0, 1.0)
    glVertex2f(0.0, 30.0)
    glEnd()
 
    glFlush()
 
def reshape(width, height):
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)
    glMatrixMode(GL_MODELVIEW)
 
if __name__ == '__main__':
    glutInit(1, 1)
    glutInitWindowSize(640, 480)
    glutCreateWindow(""Triangle"")
 
    glutDisplayFunc(paint)
    glutReshapeFunc(reshape)
 
    glutMainLoop()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Tarjan,Tarjan,"

 This page uses content from Wikipedia. The original article was at Graph. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Tarjan's algorithm is an algorithm in graph theory for finding the strongly connected components of a graph.

It runs in linear time, matching the time bound for alternative methods including Kosaraju's algorithm and the path-based strong component algorithm.

Tarjan's Algorithm is named for its discoverer, Robert Tarjan.



References

 The article on Wikipedia.

",Python,"import collections
 
class Node:
    def __init__(self, n):
        self.n = n
        self.index = -1
        self.lowlink = 0
 
class Graph:
    def __init__(self):
        self.v = set()
        self.adj = collections.defaultdict(set)
 
    def tarjan(self):
        index = 0
        s = []
 
        def strong_connect(v):
            # Set the depth index for v to the smallest unused index
            v.index = index
            v.lowlink = index
 
            index += 1
            s.append(v)
 
            # Consider successors of v
            for w in self.adj[v]:
                if w.index < 0:
                    # Successor w has not yet been visited; recurse on it
                    strong_connect(w)
                    v.lowlink = min(v.lowlink, w.lowlink)
                elif w in s:
                    # Successor w is in stack S and hence in the current SCC
                    v.lowlink = min(v.lowlink, w.index)
 
            # If v is a root node, pop the stack and generate an SCC
            if v.lowlink == v.index:
                print(""SCC: "", end="""")
 
                w = s.pop()
                print(w.n, end="" "")
                while w!= v:
                    w = s.pop()
                    print(w.n, end="" "")
 
                print()
 
        for v in self.v:
            if v.index < 0:
                strong_connect(v)
 
g = Graph()
g.v = {Node(1), Node(2), Node(3), Node(4), Node(5), Node(6), Node(7)}
g.adj[g.v.pop()] = {g.v.pop(), g.v.pop()}
g.adj[g.v.pop()] = {g.v.pop()}
g.adj[g.v.pop()] = {g.v.pop(), g.v.pop()}
g.adj[g.v.pop()] = {g.v.pop(), g.v.pop()}
g.adj[g.v.pop()] = {g.v.pop()}
g.adj[g.v.pop()] = {g.v.pop()}
g.tarjan()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Summarize_primes,Summarize primes,"Task

Considering in order of length, n, all sequences of consecutive
primes, p, from 2 onwards, where p < 1000 and n>0, select those
sequences whose sum is prime, and for these display the length of the
sequence, the last item in the sequence, and the sum.



",Python,"def isPrime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    i = 5
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
        if n % i == 0:
            return False
        i += 4
    return True
 
START = 1
STOP = 1000
 
sum = 0
count = 0
sc = 0
 
for p in range(START, STOP + 1):
    if isPrime(p):
        count += 1
        sum += p
        if isPrime(sum):
            print ""The sum of %3d primes in [2, %3d] is %5d which is also prime\n"" % (count, p, sum)
            sc += 1
print ""There are %d summerized primes in [%d, %d]\n"" % (sc, START, STOP)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Hostname,Hostname,"Task

Find the name of the host on which the routine is running.



",Python,"import socket
host = socket.gethostname()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Spinning_rod_animation/Text,Spinning rod animation/Text,"Task

An animation with the following frames in the following order (if certain characters aren't available or can't be used correctly in the programming language, alternate characters can replace any of these frames) must animate with a delay of 0.25 seconds between each frame, with the previous frame being cleared before the next frame appears: 

   |
   /
   - or ─
   \



A stand-alone version that loops and/or a version that doesn't loop can be made. These examples can also be converted into a system used in game development which is called on a HUD or GUI element requiring it to be called each frame to output the text, and advance the frame when the frame delay has passed. You can also use alternate text such as the . animation ( . | .. | ... | .. | repeat from . ) or the logic can be updated to include a ping/pong style where the frames advance forward, reach the end and then play backwards and when they reach the beginning they start over ( technically, you'd stop one frame prior to prevent the first frame playing twice, or write it another way ).



There are many different ways you can incorporate text animations. Here are a few text ideas - each frame is in quotes. If you can think of any, add them to this page! There are 2 examples for several of these; the first is the base animation with only unique sets of characters. The second consists of the primary set from a - n and doubled, minus the first and last element ie: We only want the center. This way an animation can play forwards, and then in reverse ( ping ponging ) without having to code that feature. For the animations with 3 elements, we only add 1, the center. with 4, it becomes 6. with 10, it becomes 18.



We don't need the second option for some of the animations if they connect smoothly, when animated, back to the first element. ... doesn't connect with . cleanly - there is a large leap. The rotating pipe meets the first perfectly so it isn't necessary, etc..





   Dots - Option A requires ping / pong enabled script. Option B just adds the elements in the center.
   '.', '..', '...'
   '.', '..', '...', '..'
   Pipe - This has the uniform sideways pipe instead of a hyphen to prevent non-uniform sizing.
   '|', '/', '─', '\'
   Stars - Option A requires ping / pong enabled script. Option B just adds the elements from the center.
   '⁎', '⁑', '⁂'
   '⁎', '⁑', '⁂', '⁑'
   Clock - These need to be ordered. I haven't done this yet as the application I was testing the system in doesn't support these wingdings / icons. But this would look quite nice and you could set it up to go forward, or backward during an undo process, etc..
   '🕛', '🕧', '🕐', '🕜', '🕑', '🕝', '🕒', '🕞', '🕓', '🕟', '🕔', '🕠', '🕕', '🕖', '🕗', '🕘', '🕙', '🕚', '🕡', '🕢', '🕣', '🕤', '🕥', '🕦'
   Arrows:
   '⬍', '⬈', '➞', '⬊', '⬍', '⬋', '⬅', '⬉'
   Bird - This looks decent but may be missing something.
   '︷', '︵', '︹', '︺', '︶', '︸'
   '︷', '︵', '︹', '︺', '︶', '︸', '︶', '︺', '︹', '︵'
   Plants - This isn't quite complete
   '☘', '❀', '❁'
   '☘', '❀', '❁', '❀'
   Eclipse - From Raku Throbber post author
   '🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'

",Python,"import time
import sys

def main():
    i = 0
    j = 0
    ms = 250
    a = ""|/-\\"";
    start = time.time()
    while True:
        for i in range(0, 4):
            sys.stdout.write(""\033[2J"")
            sys.stdout.write(""\033[0;0H"")
            for j in range(0, 80):
                sys.stdout.write(a[i])
            sys.stdout.flush()
            time.sleep(ms/1000)
        if time.time() - start >= 20:
            break
    return 0

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Roots_of_unity,Roots of unity,"The purpose of this task is to explore working with   complex numbers.



Task

Given   n,   find the   nth   roots of unity.



",Python,"import cmath
 
 
class Complex(complex):
    def __repr__(self):
        rp = '%7.5f' % self.real if not self.pureImag() else ''
        ip = '%7.5fj' % self.imag if not self.pureReal() else ''
        conj = '' if (
            self.pureImag() or self.pureReal() or self.imag < 0.0
        ) else '+'
        return '0.0' if (
            self.pureImag() and self.pureReal()
        ) else rp + conj + ip
 
    def pureImag(self):
        return abs(self.real) < 0.000005
 
    def pureReal(self):
        return abs(self.imag) < 0.000005
 
 
def croots(n):
    if n <= 0:
        return None
    return (Complex(cmath.rect(1, 2 * k * cmath.pi / n)) for k in range(n))
    # in pre-Python 2.6:
    #   return (Complex(cmath.exp(2j*k*cmath.pi/n)) for k in range(n))
 
 
for nr in range(2, 11):
    print(nr, list(croots(nr)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sierpinski_pentagon,Sierpinski pentagon,"Produce a graphical or ASCII-art representation of a Sierpinski pentagon (aka a Pentaflake) of order 5. Your code should also be able to correctly generate representations of lower orders: 1 to 4.





See also
 Sierpinski pentagon

",Python,"import math
import svgwrite
 
def sierpinski_pentagon(dwg, x, y, side, order):
    degrees72 = 0.4 * math.pi
    angle = 3.0 * degrees72
    scale_factor = 1.0 / (2.0 + degrees72 * math.cos(2.0))
 
    if order == 1:
        points = []
        points.append((x, y))
        for _ in range(5):
            x += angle * side
            y -= angle * side
            angle += degrees72
            points.append((x, y))
        dwg.add(dwg.polygon(points, fill='blue', stroke='black', stroke_width=1))
    else:
        side *= scale_factor
        distance = side + side * degrees72 * math.cos(2.0)
        for _ in range(5):
            x += angle * distance
            y -= angle * distance
            angle += degrees72
            sierpinski_pentagon(dwg, x, y, side, order - 1)
 
def write_sierpinski_pentagon(file, size, order):
    margin = 5.0
    radius = (size) / 2.0 - 2.0 * margin
    side = radius * math.sin(0.2 * math.pi) * 2.0
    height = side * (math.sin(0.2 * math.pi) + math.sin(0.4 * math.pi))
    x = (size) / 2.0
    y = (size - height) / 2.0
 
    dwg = svgwrite.Drawing(filename=file, size=(size, size))
    dwg.add(dwg.rect((0, 0), (size, size), fill='white'))
    sierpinski_pentagon(dwg, x, y, side, order)
    dwg.save()
 
if __name__ == '__main__':
    write_sierpinski_pentagon('sierpinski_pentagon.svg', 600, 5)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/String_matching,String matching,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings, demonstrate the following three types of string matching:

   Determining if the first string starts with second string
   Determining if the first string contains the second string at any location
   Determining if the first string ends with the second string


Optional requirements:

   Print the location of the match for part 2
   Handle multiple occurrences of a string for part 2.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"c1='a'
s1=str(c1)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Brazilian_numbers,Brazilian numbers,"Brazilian numbers are so called as they were first formally presented at the 1994 math Olympiad Olimpiada Iberoamericana de Matematica in Fortaleza, Brazil.

Brazilian numbers are defined as:

The set of positive integer numbers where each number N has at least one natural number B where 1 < B < N-1 where the representation of N in base B has all equal digits.



E.G.

 1, 2 & 3 can not be Brazilian; there is no base B that satisfies the condition 1 < B < N-1.
 4 is not Brazilian; 4 in base 2 is 100. The digits are not all the same.
 5 is not Brazilian; 5 in base 2 is 101, in base 3 is 12. There is no representation where the digits are the same.
 6 is not Brazilian; 6 in base 2 is 110, in base 3 is 20, in base 4 is 12. There is no representation where the digits are the same.
 7 is Brazilian; 7 in base 2 is 111. There is at least one representation where the digits are all the same.
 8 is Brazilian; 8 in base 3 is 22. There is at least one representation where the digits are all the same.
 and so on...


All even integers 2P >= 8 are Brazilian because 2P = 2(P-1) + 2, which is 22 in base P-1 when P-1 > 2. That becomes true when P >= 4.

More common: for all all integers R and S, where R > 1 and also S-1 > R, then R*S is Brazilian because R*S = R(S-1) + R, which is RR in base S-1

The only problematic numbers are squares of primes, where R = S. Only 11^2 is brazilian to base 3.

All prime integers, that are brazilian, can only have the digit 1. Otherwise one could factor out the digit, therefore it cannot be a prime number. Mostly in form of 111 to base Integer(sqrt(prime number)). Must be an odd count of 1 to stay odd like primes > 2


Task

Write a routine (function, whatever) to determine if a number is Brazilian and use the routine to show here, on this page;

 the first 20 Brazilian numbers;
 the first 20 odd Brazilian numbers;
 the first 20 prime Brazilian numbers;


See also

 OEIS:A125134 - Brazilian numbers
 OEIS:A257521 - Odd Brazilian numbers
 OEIS:A085104 - Prime Brazilian numbers

",Python,"def sameDigits(n,b):
    f = n % b
    while (n /= b) > 0:
        if n % b != f:
            return False
    return True
 
def isBrazilian(n):
    if n < 7:
        return False
    if n % 2 == 0:
        return True
    for b in range(2, n - 2):
        if sameDigits(n, b):
            return True
    return False
 
def isPrime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0:
            return False
        d = d + 2
 
        if n % d == 0:
            return False
        d = d + 4
    return True
 
def main():
    for kind in ["""", ""odd "", ""prime ""]:
        quiet = False
        bigLim = 99999
        limit = 20
        print(""First %d %sBrazilian numbers:"" % (limit, kind))
        c = 0
        n = 7
        while c < bigLim:
            if isBrazilian(n):
                if not quiet:
                    print(""%d "" % (n), end="""")
                c = c + 1
                if c == limit:
                    print()
                    print()
                    quiet = True
            if quiet and kind != """":
                continue
            if kind == """":
                n = n + 1
            elif kind == ""odd "":
                n = n + 2
            elif kind == ""prime "":
                while True:
                    n = n + 2
                    if isPrime(n):
                        break
            else:
                raise ""Unexpected""
        if kind == """":
            print(""The %dth Brazillian number is: %d"" % (bigLim + 1, n))
            print()
 
main()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",Python,"def maxsubseq(seq):
  return max((seq[begin:end] for begin in xrange(len(seq)+1)
                             for end in xrange(begin, len(seq)+1)),
             key=sum)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Pythagoras_tree,Pythagoras tree,"
The Pythagoras tree is a fractal tree constructed from squares. It is named after Pythagoras because each triple of touching squares encloses a right triangle, in a configuration traditionally used to represent the Pythagorean theorem.




Task
Construct a Pythagoras tree of order 7 using only vectors (no rotation or trigonometric functions).




Related tasks
 Fractal tree

",Python,"import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from PIL import Image

width, height = 800, 600
maxDepth = 11
colFactor = 255 / maxDepth
fileName = ""pythagorasTree.png""

def main():
    img = Image.new('RGB', (width, height), color = (255, 255, 255))
    drawSquares(340, 550, 460, 550, img, 0)
    img.save(fileName)

def drawSquares(ax, ay, bx, by, img, depth):
    if depth > maxDepth:
        return
    dx, dy = bx-ax, ay-by
    x3, y3 = bx-dy, by-dx
    x4, y4 = ax-dy, ay-dx
    x5, y5 = x4+(dx-dy)/2, y4-(dx+dy)/2
    col = (0, depth * colFactor, 0)
    drawLine(ax, ay, bx, by, img, col)
    drawLine(bx, by, x3, y3, img, col)
    drawLine(x3, y3, x4, y4, img, col)
    drawLine(x4, y4, ax, ay, img, col)
    drawSquares(x4, y4, x5, y5, img, depth+1)
    drawSquares(x5, y5, x3, y3, img, depth+1)

def drawLine(x0, y0, x1, y1, img, col):
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx, sy = -1, -1
    if x0 < x1:
        sx = 1
    if y0 < y1:
        sy = 1
    err = dx - dy
    while True:
        img.putpixel((x0, y0), col)
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy

def abs(x):
    if x < 0:
        return -x
    return x

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed),Apply a digital filter (direct form II transposed),"Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the ""direct form II transposed"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]

Task

Filter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]

The signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]
",Python,"#!/bin/python
from __future__ import print_function
from scipy import signal
import matplotlib.pyplot as plt
 
if __name__==""__main__"":
	sig = [-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,
		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,
		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,
		0.0259303398477,0.490105989562,0.549391221511,0.9047198589]
 
	#Create an order 3 lowpass butterworth filter
	#Generated using b, a = signal.butter(3, 0.5)
	a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]
	b = [0.16666667, 0.5, 0.5, 0.16666667]
 
	#Apply the filter to signal
	filt = signal.lfilter(b, a, sig)
	print (filt)
 
	plt.plot(sig, 'b')
	plt.plot(filt, 'r--')
	plt.show()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",Python,"def Ackermann(m, n):
	if m == 0:
		return n + 1
	elif n == 0:
		return Ackermann(m - 1, 1)
	else:
		return Ackermann(m - 1, Ackermann(m, n - 1))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Long_year,Long year,"Most years have 52 weeks, some have 53, according to ISO8601.



Task

Write a function which determines if a given year is long (53 weeks) or not, and demonstrate it.



",Python,"'''Long Year ?'''
 
from datetime import date
 
 
# longYear :: Year Int -> Bool
def longYear(y):
    '''True if the ISO year y has 53 weeks.'''
    return 52 < date(y, 12, 28).isocalendar()[1]
 
 
# --------------------------TEST---------------------------
# main :: IO ()
def main():
    '''Longer (53 week) years in the range 2000-2100'''
    for year in [
            x for x in range(2000, 1 + 2100)
            if longYear(x)
    ]:
        print(year)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_C
http://rosettacode.org/wiki/Negative_base_numbers,Negative base numbers,"Negative base numbers are an alternate way to encode numbers without the need for a minus sign. Various negative bases may be used including negadecimal (base -10), negabinary (-2) and negaternary (-3).[1][2]



Task

Encode the decimal number 10 as negabinary (expect 11110)
Encode the decimal number 146 as negaternary (expect 21102)
Encode the decimal number 15 as negadecimal (expect 195)
In each of the above cases, convert the encoded number back to decimal.


extra credit

 supply an integer, that when encoded to base   -62   (or something ""higher""),   expresses the 
name of the language being used   (with correct capitalization).   If the computer language has 
non-alphanumeric characters,   try to encode them into the negatory numerals,   or use other 
characters instead.

",Python,"DIGITS = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""
 
def encode_neg_base(n, b):
    if b < -62 or b > -1:
        raise ValueError(""Parameter b is out of bounds"")
    if n == 0:
        return ""0""
    out = []
    nn = n
    while nn!= 0:
        rem = nn % b
        nn //= b
        if rem < 0:
            nn += 1
            rem -= b
        out.append(DIGITS[rem])
    out.reverse()
    return """".join(out)
 
def decode_neg_base(ns, b):
    if b < -62 or b > -1:
        raise ValueError(""Parameter b is out of bounds"")
    if ns == ""0"":
        return 0
    total = 0
    bb = 1
    for c in reversed(ns):
        total += DIGITS.index(c) * bb
        bb *= b
    return total
 
if __name__ == ""__main__"":
    nbl = [
        (10, -2),
        (146, -3),
        (15, -10),
        (-4393346, -62)
    ]
    for n, b in nbl:
        ns = encode_neg_base(n, b)
        print(f""{n:12d} encoded in base {b:3d} = {ns}"")
        n = decode_neg_base(ns, b)
        print(f""{ns:12s} decoded in base {b:3d} = {n:d}\n"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",Python,"from __future__ import division
from fractions import Fraction
from decimal import Decimal
 
class DC(int):
    def __str__(self):
        d = self // 100
        if self < 0:
            self = -self
        return '%d.%02d' % (d, self % 100)
 
    def extend(self, n):
        return self * n
 
def parse_dc(s):
    r = Fraction(s)
    r *= 100
    if r.denominator!= 1:
        return None
    return DC(r.numerator)
 
class TR(Fraction):
    def tax(self, dc):
        r = Fraction(dc, 1)
        r *= self
        r += Fraction(1, 2)
        return DC(r.numerator // r.denominator)
 
def main():
    hamburger_price = parse_dc('5.50')
    if hamburger_price is None:
        raise ValueError('Invalid hamburger price')
    milkshake_price = parse_dc('2.86')
    if milkshake_price is None:
        raise ValueError('Invalid milkshake price')
    tax_rate = TR('0.0765')
 
    total_before_tax = hamburger_price.extend(4000000000000000) + \
        milkshake_price.extend(2)
    tax = tax_rate.tax(total_before_tax)
    total = total_before_tax + tax
 
    print('Total before tax: %22s' % total_before_tax)
    print('             Tax: %22s' % tax)
    print('           Total: %22s' % total)
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/4-rings_or_4-squares_puzzle,4-rings or 4-squares puzzle,"4-rings or 4-squares puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Replace       a, b, c, d, e, f,   and
  g        with the decimal
digits   LOW   ───►   HIGH

such that the sum of the letters inside of each of the four large squares add up to
the same sum.

            ╔══════════════╗      ╔══════════════╗
            ║              ║      ║              ║
            ║      a       ║      ║      e       ║
            ║              ║      ║              ║
            ║          ┌───╫──────╫───┐      ┌───╫─────────┐
            ║          │   ║      ║   │      │   ║         │
            ║          │ b ║      ║ d │      │ f ║         │
            ║          │   ║      ║   │      │   ║         │
            ║          │   ║      ║   │      │   ║         │
            ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                       │       c      │      │      g      │
                       │              │      │             │
                       │              │      │             │
                       └──────────────┘      └─────────────┘

Show all output here.



   Show all solutions for each letter being unique with
        LOW=1     HIGH=7

   Show all solutions for each letter being unique with
        LOW=3     HIGH=9

   Show only the   number   of solutions when each letter can be non-unique
        LOW=0     HIGH=9



Related task

 Solve the no connection puzzle

",Python,"from itertools import combinations_with_replacement
 
def getCombs(low,high,unique):
	num = 0
	validCombs = []
	for comb in combinations_with_replacement(range(low,high+1),7):
		if validComb(comb):
			if not unique or isUnique(comb):
				num += 1
				validCombs.append(comb)
	return num,validCombs
 
def isUnique(comb):
	return len(set(comb)) == 7
 
def validComb(comb):
	square1 = comb[0] + comb[1]
	square2 = comb[1] + comb[2] + comb[3]
	square3 = comb[3] + comb[4] + comb[5]
	square4 = comb[5] + comb[6]
	return square1 == square2 and square2 == square3 and square3 == square4
 
if __name__ == '__main__':
	n, c = getCombs(1,7,True)
	print(""%d unique solutions in 1 to 7"" % n)
	print(c)
	n, c = getCombs(3,9,True)
	print(""%d unique solutions in 3 to 9"" % n)
	print(c)
	n, _ = getCombs(0,9,False)
	print(""%d non-unique solutions in 0 to 9"" % n)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Strip_block_comments,Strip block comments,"A block comment begins with a   beginning delimiter   and ends with a   ending delimiter,   including the delimiters.   These delimiters are often multi-character sequences.



Task

Strip block comments from program text (of a programming language much like classic C).

Your demos should at least handle simple, non-nested and multi-line block comment delimiters.

The block comment delimiters are the two-character sequences:

      /*      (beginning delimiter)
      */      (ending delimiter)


Sample text for stripping:

  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    }

Extra credit

Ensure that the stripping code is not hard-coded to the particular delimiters described above, but instead allows the caller to specify them.   (If your language supports them,   optional parameters   may be useful for this.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def _commentstripper(txt, delim):
    'Strips first nest of block comments'
 
    deliml, delimr = delim
    out = ''
    if deliml in txt:
        indx = txt.index(deliml)
        out += txt[:indx]
        txt = txt[indx+len(deliml):]
        txt = _commentstripper(txt, delim)
        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt
        indx = txt.index(delimr)
        out += txt[(indx+len(delimr)):]
    else:
        out = txt
    return out
 
def commentstripper(txt, delim=('/*', '*/')):
    'Strips nests of block comments'
 
    deliml, delimr = delim
    while deliml in txt:
        txt = _commentstripper(txt, delim)
    return txt",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Read_a_specific_line_from_a_file,Read a specific line from a file,"Some languages have special semantics for obtaining a known line number from a file.



Task

Demonstrate how to obtain the contents of a specific line within a file.

For the purpose of this task demonstrate how the contents of the seventh line of a file can be obtained,   and store it in a variable or in memory   (for potential future use within the program if the code were to become embedded).

If the file does not contain seven lines,   or the seventh line is empty,   or too big to be retrieved,   output an appropriate message.

If no special semantics are available for obtaining the required line,   it is permissible to read line by line.

Note that empty lines are considered and should still be counted.

Also note that for functional languages or languages without variables or storage,   it is permissible to output the extracted data to standard output.



",Python,"import io
 
def get_line_at(path, line_num):
    with open(path, 'r') as file:
        content = io.TextIOWrapper(file)
        lines = content.readlines()
        return lines[line_num]
 
if __name__ == '__main__':
    path = 'file.txt'
    line_num = 7
    line = get_line_at(path, line_num - 1)
    print(line)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Binary_strings,Binary strings,"Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.

This task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them.

If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.

In particular the functions you need to create are:

 String creation and destruction (when needed and if there's no garbage collection or similar mechanism)
 String assignment
 String comparison
 String cloning and copying
 Check if a string is empty
 Append a byte to a string
 Extract a substring from a string
 Replace every occurrence of a byte (or a string) in a string with another string
 Join strings


Possible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.



",Python,"# string creation
x = ""hello world""
 
# string destruction
x = None
 
# string assignment with a null byte
x = ""a\0b""
print(len(x))  # ==> 3
 
# string comparison
if x == ""hello"":
  print(""equal"")
else:
  print(""not equal"")
y = 'bc'
if x < y:
  print(f""{x} is lexicographically less than {y}"")
 
# string cloning 
xx = x.copy()
x == xx       # true, same length and content
x.equal?(xx)  # false, different objects
 
# check if empty
if x.empty():
  print(""is empty"")
 
# append a byte
p x << ""\07""
 
# substring
p xx = x[0..-2]
x[1,2] = ""XYZ""
p x
 
# replace bytes
p y = ""hello world"".tr(""l"", ""L"")
 
# join strings
a = ""hel""
b = ""lo w""
c = ""orld""
p d = a + b + c",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/File_modification_time,File modification time,"Task

Get and set the modification time of a file.



",Python,"import os
 
#Get modification time:
modtime = os.path.getmtime('filename')
 
#Set the access and modification times:
os.utime('path', (actime, mtime))
 
#Set just the modification time:
os.utime('path', (os.path.getatime('path'), mtime))
 
#Set the access and modification times to the current time:
os.utime('path', None)",Human_written,Python_from_C
http://rosettacode.org/wiki/Phrase_reversals,Phrase reversals,"Task

Given a string of space separated words containing the following phrase:

 rosetta code phrase reversal

 Reverse the characters of the string.
 Reverse the characters of each individual word in the string, maintaining original word order within the string.
 Reverse the order of each word of the string, maintaining the order of characters in each word.


Show your output here.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> phrase = ""rosetta code phrase reversal""
>>> phrase[::-1]					  # Reversed.
'lasrever esarhp edoc attesor'
>>> ' '.join(word[::-1] for word in phrase.split())	  # Words reversed.
'attesor edoc esarhp lasrever'
>>> ' '.join(phrase.split()[::-1])	                  # Word order reversed.
'reversal phrase code rosetta'
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Call_a_function,Call a function,"Task

Demonstrate the different syntax and semantics provided for calling a function.



This may include:

   Calling a function that requires no arguments
   Calling a function with a fixed number of arguments
   Calling a function with optional arguments
   Calling a function with a variable number of arguments
   Calling a function with named arguments
   Using a function in statement context
   Using a function in first-class context within an expression
   Obtaining the return value of a function
   Distinguishing built-in functions and user-defined functions
   Distinguishing subroutines and functions
   Stating whether arguments are passed by value or by reference
   Is partial application possible and how


This task is not about defining functions.



",Python,"def main():
    # Rust has a lot of neat things you can do with functions: let's go over the basics first
    def no_args():
        pass
    # Run function with no arguments
    no_args()
 
    # Calling a function with fixed number of arguments.
    # adds_one takes a 32-bit signed integer and returns a 32-bit signed integer
    def adds_one(num):
        # the final expression is used as the return value, though `return` may be used for early returns
        return num + 1
    adds_one(1)
 
    # Optional arguments
    # The language itself does not support optional arguments, however, you can take advantage of
    # Rust's algebraic types for this purpose
    def prints_argument(maybe):
        if maybe is not None:
            num = maybe
            print(num)
        else:
            print(""No value given"")
    prints_argument(3)
    prints_argument(None)
 
    # You could make this a bit more ergonomic by using Rust's Into trait
    def prints_argument_into(maybe):
        if maybe is not None:
            num = maybe
            print(num)
        else:
            print(""No value given"")
    prints_argument_into(3)
    prints_argument_into(None)
 
    # Rust does not support functions with variable numbers of arguments. Macros fill this niche
    # (println! as used above is a macro for example)
 
    # Rust does not support named arguments
 
    # We used the no_args function above in a no-statement context
 
    # Using a function in an expression context
    adds_one(1) + adds_one(5) # evaluates to eight
 
    # Obtain the return value of a function.
    two = adds_one(1)
 
    # In Rust there are no real built-in functions (save compiler intrinsics but these must be
    # manually imported)
 
    # In rust there are no such thing as subroutines
 
    # In Rust, there are three ways to pass an object to a function each of which have very important
    # distinctions when it comes to Rust's ownership model and move semantics. We may pass by
    # value, by immutable reference, or mutable reference.
 
    v = [1, 2, 3, 4, 5, 6]
 
    # By mutable reference
    def add_one_to_first_element(vector):
        vector[0] += 1
    add_one_to_first_element(v)
    # By immutable reference
    def print_first_element(vector):
        print(vector[0])
    print_first_element(v)
 
    # By value
    def consume_vector(vector):
        # We can do whatever we want to vector here
        pass
    consume_vector(v)
    # Due to Rust's move semantics, v is now inaccessible because it was moved into consume_vector
    # and was then dropped when it went out of scope
 
    # Partial application is not possible in rust without wrapping the function in another
    # function/closure e.g.:
    def average(x, y):
        return (x + y) / 2.0
    average_with_four = lambda y: average(4.0, y)
    average_with_four(2.0)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Euler%27s_identity,Euler's identity,"

 This page uses content from Wikipedia. The original article was at Euler's_identity. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, Euler's identity is the equality:

               ei
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 + 1 = 0

where

   e is Euler's number, the base of natural logarithms,
   i is the imaginary unit, which satisfies i2 = −1, and
   
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 is pi, the ratio of the circumference of a circle to its diameter.

Euler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:

   The number 0.
   The number 1.
   The number 
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 (
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 = 3.14159+),
   The number e (e = 2.71828+), which occurs widely in mathematical analysis.
   The number i, the imaginary unit of the complex numbers.

Task
Show in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.

Most languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.

If that is the case, or there is some other limitation, show
that ei



π


{\displaystyle \pi }

 + 1 is approximately equal to zero and
show the amount of error in the calculation.

If your language is capable of symbolic calculations, show
that ei



π


{\displaystyle \pi }

 + 1 is exactly equal to zero for bonus kudos points.



",Python,">>> import math
>>> math.e ** (math.pi * 1j) + 1
1.2246467991473532e-16j",Human_written,Python_from_C++
http://rosettacode.org/wiki/Hash_join,Hash join,"An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]
Implement the ""hash join"" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance
The ""hash join"" algorithm consists of two steps:

 Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

 The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
 Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.
 Join phase: Scan the other table, and find matching rows by looking in the multimap created before.


In pseudo-code, the algorithm could be expressed as follows:

let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

Test-case


 Input

 Output





 A =




 Age 
 Name


 27 
 Jonah


 18 
 Alan


 28 
 Glory


 18 
 Popeye


 28 
 Alan




 B =




 Character 
 Nemesis


 Jonah 
 Whales


 Jonah 
 Spiders


 Alan 
 Ghosts


 Alan 
 Zombies


 Glory 
 Buffy



 jA =

 Name (i.e. column 1)

 jB =

 Character (i.e. column 0)





 A.Age 
 A.Name 
 B.Character 
 B.Nemesis


 27 
 Jonah 
 Jonah 
 Whales


 27 
 Jonah 
 Jonah 
 Spiders


 18 
 Alan 
 Alan 
 Ghosts


 18 
 Alan 
 Alan 
 Zombies


 28 
 Glory 
 Glory 
 Buffy


 28 
 Alan 
 Alan 
 Ghosts


 28 
 Alan 
 Alan 
 Zombies


The order of the rows in the output table is not significant.

If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, ""Jonah""], [""Jonah"", ""Whales""]].



",Python,"from collections import defaultdict
 
def hashJoin(table1, index1, table2, index2):
    h = defaultdict(list)
    # hash phase
    for s in table1:
        h[s[index1]].append(s)
    # join phase
    return [(s, r) for r in table2 for s in h[r[index2]]]
 
table1 = [(27, ""Jonah""),
          (18, ""Alan""),
          (28, ""Glory""),
          (18, ""Popeye""),
          (28, ""Alan"")]
table2 = [(""Jonah"", ""Whales""),
          (""Jonah"", ""Spiders""),
          (""Alan"", ""Ghosts""),
          (""Alan"", ""Zombies""),
          (""Glory"", ""Buffy"")]
 
for row in hashJoin(table1, 1, table2, 0):
    print(row)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Knight%27s_tour,Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"import random
import time
 
# input, 0-based start position
startRow = 0
startCol = 0
 
def main():
    random.seed(time.time())
    while not knightTour():
        pass
 
moves = [
    (2, 1),
    (2, -1),
    (1, 2),
    (1, -2),
    (-1, 2),
    (-1, -2),
    (-2, 1),
    (-2, -1),
]
 
# Attempt knight tour starting at startRow, startCol using Warnsdorff's rule
# and random tie breaking.  If a tour is found, print it and return true.
# Otherwise no backtracking, just return false.
def knightTour():
    # 8x8 board.  squares hold 1-based visit order.  0 means unvisited.
    board = [[0] * 8 for _ in range(8)]
    r = startRow
    c = startCol
    board[r][c] = 1 # first move
    for move in range(2, 65):
        minNext = 8
        mr = mc = nm = 0
    candidateMoves:
        for cm in moves:
            cr = r + cm[0]
            if cr < 0 or cr >= 8: # off board
                continue
            cc = c + cm[1]
            if cc < 0 or cc >= 8: # off board
                continue
            if board[cr][cc] > 0: # already visited
                continue
            # cr, cc candidate legal move.
            p = 0 # count possible next moves.
            for m2 in moves:
                r2 = cr + m2[0]
                if r2 < 0 or r2 >= 8:
                    continue
                c2 = cc + m2[1]
                if c2 < 0 or c2 >= 8:
                    continue
                if board[r2][c2] > 0:
                    continue
                p += 1
                if p > minNext: # bail out as soon as it's eliminated
                    continue candidateMoves
            if p < minNext: # it's better.  keep it.
                minNext = p # new min possible next moves
                nm = 1      # number of candidates with this p
                mr = cr     # best candidate move
                mc = cc
                continue
            # it ties for best so far.
            # keep it with probability 1/(number of tying moves)
            nm += 1                    # number of tying moves
            if random.randint(0, nm) == 0: # one chance to keep it
                mr = cr
                mc = cc
        if nm == 0: # no legal move
            return False
        # make selected move
        r = mr
        c = mc
        board[r][c] = move
    # tour complete.  print board.
    for r in board:
        for m in r:
            print(f""{m:3d}"", end="""")
        print()
    return True
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Arithmetic_numbers,Arithmetic numbers,"Definition
A positive integer n is an arithmetic number if the average of its positive divisors is also an integer.

Clearly all odd primes p must be arithmetic numbers because their only divisors are 1 and p whose sum is even and hence their average must be an integer. However, the prime number 2 is not an arithmetic number because the average of its divisors is 1.5.

Example
30 is an arithmetic number because its 7 divisors are: [1, 2, 3, 5, 6, 10, 15, 30], their sum is 72 and average 9 which is an integer.

Task
Calculate and show here:

1. The first 100 arithmetic numbers.

2. The xth arithmetic number where x = 1,000 and x = 10,000.

3. How many of the first x arithmetic numbers are composite.

Note that, technically, the arithmetic number 1 is neither prime nor composite.

Stretch
Carry out the same exercise in 2. and 3. above for x = 100,000 and x = 1,000,000.

References
 Wikipedia: Arithmetic number
 OEIS:A003601 - Numbers n such that the average of the divisors of n is an integer



",Python,"def factors(n: int):
    f = set([1, n])
    i = 2
    while True:
        j = n // i
        if j < i:
            break
        if i * j == n:
            f.add(i)
            f.add(j)
        i += 1
    return f
 
arithmetic_count = 0
composite_count = 0
n = 1
while arithmetic_count <= 1000000:
    f = factors(n)
    if (sum(f)/len(f)).is_integer():
        arithmetic_count += 1
        if len(f) > 2:
            composite_count += 1
        if arithmetic_count <= 100:
            print(f'{n:3d} ', end='')
            if arithmetic_count % 10 == 0:
                print()
        if arithmetic_count in (1000, 10000, 100000, 1000000):
            print(f'\n{arithmetic_count}th arithmetic number is {n}')
            print(f'Number of composite arithmetic numbers <= {n}: {composite_count}')
    n += 1",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Flow-control_structures,Flow-control structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Task

Document common flow-control structures.



One common example of a flow-control structure is the    goto    construct.

Note that   Conditional Structures   and   Loop Structures   have their own articles/categories.



Related tasks

   Conditional Structures
   Loop Structures 

",Python,"# Search for an odd factor of a using brute force:
for i in range(n):
    if (n%2) == 0:
        continue
    if (n%i) == 0:
        result = i
        break
else:
    result = None
    print ""No odd factors found""",Human_written,Python_from_C++
http://rosettacode.org/wiki/Modular_inverse,Modular inverse,"From Wikipedia:

In modular arithmetic,   the modular multiplicative inverse of an integer    a    modulo    m    is an integer    x    such that





a

x
≡
1


(
mod

m
)

.


{\displaystyle a\,x\equiv 1{\pmod {m}}.}


Or in other words, such that:





∃
k
∈

Z

,

a

x
=
1
+
k

m


{\displaystyle \exists k\in \mathbb {Z} ,\qquad a\,x=1+k\,m}


It can be shown that such an inverse exists   if and only if    a    and    m    are coprime,   but we will ignore this for this task.



Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in
your language,   compute the modular inverse of   42 modulo 2017.



",Python,"#based on pseudo code from http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Iterative_method_2 and from translating the python implementation.
def extended_gcd(a, b):
    last_remainder, remainder = abs(a), abs(b)
    x, last_x, y, last_y = 0, 1, 1, 0
    while remainder:
        last_remainder, (quotient, remainder) = remainder, last_remainder % remainder
        x, last_x = last_x - quotient*x, x
        y, last_y = last_y - quotient*y, y
    return last_remainder, last_x * (-1 if a < 0 else 1)

def invmod(e, et):
    g, x = extended_gcd(e, et)
    if g!= 1:
        raise ValueError
    return x % et",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Entropy/Narcissist,Entropy/Narcissist,"
Task

Write a computer program that computes and shows its own   entropy.



Related Tasks

   Fibonacci_word
   Entropy

",Python,"import math
from collections import Counter
 
def entropy(s):
    p, lns = Counter(s), float(len(s))
    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
 
with open(__file__) as f:
    b=f.read()
 
print(entropy(b))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",Python,"# This function notation is sorta new, but useful here
# Part of the EcmaScript 6 Draft
# developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope
def poly(x):
    return x*x*x - 3*x*x + 2*x

def sign(x):
    return -1 if x < 0.0 else 1 if x > 0.0 else 0

def printRoots(f, lowerBound, upperBound, step):
    x = lowerBound
    ox = x
    y = f(x)
    oy = y
    s = sign(y)
    os = s

    for x in range(lowerBound, upperBound, step):
        s = sign(y = f(x))
        if s == 0:
            print(x)
        elif s!= os:
            dx = x - ox
            dy = y - oy
            cx = x - dx * (y / dy)
            print(""~"" + cx)
        ox = x
        oy = y
        os = s

printRoots(poly, -1.0, 4, 0.002)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Continued_fraction,Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",Python,"from decimal import *
 
# square root of 2
sqrt2 = object()
def sqrt2.a(n): return 1 if n == 1 else 2
def sqrt2.b(n): return 1
 
# Napier's constant
napier = object()
def napier.a(n): return 2 if n == 1 else n - 1
def napier.b(n): return 1 if n == 1 else n - 1
 
pi = object()
def pi.a(n): return 3 if n == 1 else 6
def pi.b(n): return (2*n - 1)**2
 
# Estimates the value of a continued fraction _cfrac_, to _prec_
# decimal digits of precision. Returns a Decimal. _cfrac_ must
# respond to _cfrac.a(n)_ and _cfrac.b(n)_ for integer _n_ >= 1.
def estimate(cfrac, prec):
  last_result = None
  terms = prec
 
  while True:
    # Estimate continued fraction for _n_ from 1 to _terms_.
    result = Decimal(cfrac.a(terms))
    for n in range(terms - 1, 0, -1):
      a = Decimal(cfrac.a(n))
      b = Decimal(cfrac.b(n))
      digits = max(b.div(result, 1).adjusted() + prec, 1)
      result = a + b.div(result, digits)
    result = result.quantize(Decimal(10) ** -prec)
 
    if result == last_result:
      return result
    else:
      # Double _terms_ and try again.
      last_result = result
      terms *= 2
 
print(estimate(sqrt2, 50))
print(estimate(napier, 50))
print(estimate(pi, 10))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Pick_random_element,Pick random element,"Demonstrate how to pick a random element from a list.



",Python,">>> import random
>>> random.choice(['foo', 'bar', 'baz'])
'baz'",Human_written,Python_from_C
http://rosettacode.org/wiki/SQL-based_authentication,SQL-based authentication,"This task has three parts:

 Connect to a MySQL database (connect_db)
 Create user/password records in the following table (create_user)
 Authenticate login requests against the table (authenticate_user)
This is the table definition:

CREATE TABLE users (
    userid INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(32) UNIQUE KEY NOT NULL,
    pass_salt tinyblob NOT NULL,
            -- a string of 16 random bytes
    pass_md5 tinyblob NOT NULL
            -- binary MD5 hash of pass_salt concatenated with the password
);
(pass_salt and pass_md5 would be binary(16) values, but MySQL versions before 5.0.15 strip trailing spaces when selecting them.)
",Python,"import mysql.connector 
import hashlib
 
import sys	 
import random	 
 
DB_HOST = ""localhost""	 
DB_USER = ""devel"" 
DB_PASS = ""devel""	 
DB_NAME = ""test""	 
 
def connect_db():	 
    ''' Try to connect DB and return DB instance, if not, return False '''	 
    try:	 
        return mysql.connector.connect(host=DB_HOST, user=DB_USER, passwd=DB_PASS, db=DB_NAME)	 
    except:	 
        return False	 
 
def create_user(username, passwd):	 
    ''' if user was successfully created, returns its ID; returns None on error '''	 
    db = connect_db()	 
    if not db:	 
        print ""Can't connect MySQL!""
        return None
 
    cursor = db.cursor()	 
 
    salt = randomValue(16)	 	 
    passwd_md5 = hashlib.md5(salt+passwd).hexdigest()	 
 
    # If username already taken, inform it	 
    try:	 
        cursor.execute(""INSERT INTO users (`username`, `pass_salt`, `pass_md5`) VALUES (%s, %s, %s)"", (username, salt, passwd_md5)) 
        cursor.execute(""SELECT userid FROM users WHERE username=%s"", (username,) ) 
        id = cursor.fetchone()
        db.commit()
        cursor.close()
        db.close()
        return id[0]	 
    except:	 
        print 'Username was already taken. Please select another'	 
        return None
 
def authenticate_user(username, passwd):	 
    db = connect_db()	 
    if not db:	 
        print ""Can't connect MySQL!""
        return False
 
    cursor = db.cursor()	 
 
    cursor.execute(""SELECT pass_salt, pass_md5 FROM users WHERE username=%s"", (username,))
 
    row = cursor.fetchone()
    cursor.close()
    db.close()
    if row is None:     # username not found
        return False
    salt = row[0]
    correct_md5 = row[1]
    tried_md5 = hashlib.md5(salt+passwd).hexdigest()
    return correct_md5 == tried_md5
 
def randomValue(length):	 
    ''' Creates random value with given length'''	 
    salt_chars = 'abcdefghijklmnopqrstuvwxyz0123456789'
 
    return ''.join(random.choice(salt_chars) for x in range(length))
 
if __name__ == '__main__':	 
    user = randomValue(10)
    passwd = randomValue(16)	 
 
    new_user_id = create_user(user, passwd)
    if new_user_id is None:
        print 'Failed to create user %s' % user
        sys.exit(1)
    auth = authenticate_user(user, passwd)	 
    if auth:	 
        print 'User %s authenticated successfully' % user	 
    else:	 
        print 'User %s failed' % user",Human_written,Python_from_Java
http://rosettacode.org/wiki/Extreme_floating_point_values,Extreme floating point values,"The IEEE floating point specification defines certain 'extreme' floating point values such as minus zero, -0.0, a value distinct from plus zero; not a number, NaN; and plus and minus infinity.

The task is to use expressions involving other 'normal' floating point values in your language to calculate these, (and maybe other), extreme floating point values in your language and assign them to variables.

Print the values of these variables if possible; and show some arithmetic with these values and variables.

If your language can directly enter these extreme floating point values then show it.



See also

   What Every Computer Scientist Should Know About Floating-Point Arithmetic


Related tasks

   Infinity
   Detect division by zero
   Literals/Floating point

",Python,"# version 1.0.5-2

inf = 1.0 / 0.0
negInf = -1.0 / 0.0
nan = 0.0 / 0.0
negZero = -1.0e-325

print(""*** Indirect ***\n"")
print(""Infinity          :  "", inf)
print(""Negative infinity :  "", negInf)
print(""Not a number      :  "", nan)
print(""Negative zero     :  "", negZero)

print(""\n*** Direct ***\n"")
print(""Infinity          :  "", float(""inf""))
print(""Negative infinity :  "", float(""-inf""))
print(""Not a number      :  "", float(""nan""))
print(""Negative zero     :  "", float(""-0.0""))

print(""\n*** Calculations ***\n"")
print(""inf * inf         :  "", inf * inf)
print(""inf + negInf      :  "", inf + negInf)
print(""nan / nan         :  "", nan / nan)
print(""negZero + 0.0     :  "", negZero + 0.0)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Execute_a_system_command,Execute a system command,"Task

Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.




Related task
  Get system command output

",Python,"import os
exit_code = os.system('ls')       # Just execute the command, return a success/fail code
output    = os.popen('ls').read() # If you want to get the output data. Deprecated.",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"import math
def ipow(base, exp):
    pow = base
    v = 1
    if exp < 0:
        assert (base!= 0)  # divide by zero
        return (base*base!= 1 and 0) or (exp&1 and base) or 1
    while exp > 0:
        if exp & 1:
            v *= pow
        pow *= pow
        exp >>= 1
    return v
 
def dpow(base, exp):
    v = 1.0
    pow = (exp < 0 and 1.0/base) or base
    if exp < 0:
        exp = -exp
    while exp > 0:
        if exp & 1:
            v *= pow
        pow *= pow
        exp >>= 1
    return v
 
print ""2^6 ="", ipow(2,6)
print ""2^-6 ="", ipow(2,-6)
print ""2.71^6 ="", dpow(2.71,6)
print ""2.71^-6 ="", dpow(2.71,-6)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"MULTIPLY = lambda x, y: x*y
 
class num(float):
    # the following method has complexity O(b)
    # rather than O(log b) via the rapid exponentiation
    def __pow__(self, b):
        return reduce(MULTIPLY, [self]*b, 1)
 
# works with ints as function or operator
print num(2).__pow__(3)
print num(2) ** 3
 
# works with floats as function or operator
print num(2.3).__pow__(8)
print num(2.3) ** 8",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Ordered_words,Ordered words,"An   ordered word   is a word in which the letters appear in alphabetic order.

Examples include   abbey   and   dirt.

Task[edit]
Find and display all the ordered words in the dictionary   unixdict.txt   that have the longest word length.

(Examples that access the dictionary file locally assume that you have downloaded this file yourself.)

The display needs to be shown on this page.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
import re

def main():
    # read into memory in one chunk
    with open(""unixdict.txt"", ""r"") as f:
        b = f.read()
    # split at line ends
    bss = b.split(""\n"")

    # accumulate result
    longest = 0
    list = []
    for bs in bss:
        # don't bother with words shorter than
        # our current longest ordered word
        if len(bs) < longest:
            continue
        # check for ordered property
        lastLetter = 0
        for i in range(len(bs)):
            # check next letter
            b = bs[i]
            if b < 'a' or b > 'z':
                continue # not a letter.  ignore.
            if b < lastLetter:
                break # word not ordered.
            # letter passes test
            lastLetter = b
        # end of word.  it's an ordered word.
        # save it and break from loop
        if len(bs) > longest:
            longest = len(bs)
            list = []
        list.append(bs)

    # print result
    for bs in list:
        print(bs)

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Assertions,Assertions,"Assertions are a way of breaking out of code when there is an error or an unexpected input.

Some languages throw exceptions and some treat it as a break point.



Task

Show an assertion in your language by asserting that an integer variable is equal to 42.



",Python,"def main():
    x = 43
    if x!= 42:
        raise Exception(42)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Take_notes_on_the_command_line,Take notes on the command line,"Take notes on the command line is part of Short Circuit's Console Program Basics selection.
Invoking NOTES without commandline arguments displays the current contents of the local NOTES.TXT if it exists.
If NOTES has arguments, the current date and time are appended to the local NOTES.TXT followed by a newline.
Then all the arguments, joined with spaces, prepended with a tab, and appended with a trailing newline, are written to NOTES.TXT.
If NOTES.TXT doesn't already exist in the current directory then a new NOTES.TXT file should be created.
",Python,"import os
import sys
import datetime
 
FILENAME = ""NOTES.TXT""
 
def show_notes():
    with open(FILENAME, ""r+"") as f:
        print(f.read())
 
def add_to_notes(note):
    with open(FILENAME, ""a+"") as f:
        f.write(f""{datetime.datetime.now()}\n\t{note}\n"")
 
if __name__ == ""__main__"":
    if len(sys.argv) == 1:
        show_notes()
    else:
        add_to_notes("" "".join(sys.argv[1:]))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/LZW_compression,LZW compression,"The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.

You can read a complete description of it in the   Wikipedia article   on the subject.   It was patented, but it entered the public domain in 2004.



",Python,"def compress(uncompressed):
    """"""Compress a string to a list of output symbols.""""""
 
    # Build the dictionary.
    dict_size = 256
    dictionary = dict((chr(i), i) for i in range(dict_size))
    # in Python 3: dictionary = {chr(i): i for i in range(dict_size)}
 
    w = """"
    result = []
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            # Add wc to the dictionary.
            dictionary[wc] = dict_size
            dict_size += 1
            w = c
 
    # Output the code for w.
    if w:
        result.append(dictionary[w])
    return result
 
 
def decompress(compressed):
    """"""Decompress a list of output ks to a string.""""""
    from io import StringIO
 
    # Build the dictionary.
    dict_size = 256
    dictionary = dict((i, chr(i)) for i in range(dict_size))
    # in Python 3: dictionary = {i: chr(i) for i in range(dict_size)}
 
    # use StringIO, otherwise this becomes O(N^2)
    # due to string concatenation in a loop
    result = StringIO()
    w = chr(compressed.pop(0))
    result.write(w)
    for k in compressed:
        if k in dictionary:
            entry = dictionary[k]
        elif k == dict_size:
            entry = w + w[0]
        else:
            raise ValueError('Bad compressed k: %s' % k)
        result.write(entry)
 
        # Add w+entry[0] to the dictionary.
        dictionary[dict_size] = w + entry[0]
        dict_size += 1
 
        w = entry
    return result.getvalue()
 
 
# How to use:
compressed = compress('TOBEORNOTTOBEORTOBEORNOT')
print (compressed)
decompressed = decompress(compressed)
print (decompressed)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",Python,"def mult(strNum1, strNum2):
    a1 = strNum1.split("""").reverse()
    a2 = strNum2.toString().split("""").reverse()
    aResult = []

    for iterNum1 in range(0, len(a1)):
        for iterNum2 in range(0, len(a2)):
            idxIter = iterNum1 + iterNum2
            aResult[idxIter] = a1[iterNum1] * a2[iterNum2] + (idxIter >= len(aResult)? 0 : aResult[idxIter])

            if aResult[idxIter] > 9:
                aResult[idxIter + 1] = math.floor(aResult[idxIter] / 10) + (idxIter + 1 >= len(aResult)? 0 : aResult[idxIter + 1])
                aResult[idxIter] %= 10

    return aResult.reverse().join("""")

mult('18446744073709551616', '18446744073709551616')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"import random
 
def shuffle(l):
    return sorted(l, key=lambda x: random.random())
 
def bogosort(l):
    l = shuffle(l)
    while not in_order(l):
        l = shuffle(l)
    return l
 
def in_order(l):
    return all(l[i] <= l[i+1] for i in range(len(l)-1))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",Python,"import random
import time
 
class shell:
    def __init__(self):
        self._gap = [1750, 701, 301, 132, 57, 23, 10, 4, 1]
        self._idx = 0
        self._cnt = 0
 
    def sort(self, a, count):
        self._cnt = count
        for x in range(0, 9):
            if count > self._gap[x]:
                self._idx = x
                break
 
        self.sortIt(a)
 
    def sortIt(self, arr):
        sorted = False
        while True:
            sorted = True
            st = 0
            for x in range(self._gap[self._idx], self._cnt):
                if arr[st] > arr[x]:
                    self.swap(arr[st], arr[x])
                    sorted = False
                st = x
            self._idx += 1
            if self._idx >= 8:
                self._idx = 8
            if sorted and self._idx == 8:
                break
 
    def swap(self, a, b):
        t = a
        a = b
        b = t
 
if __name__ == ""__main__"":
    arr = []
    for x in range(0, 126):
        arr.append(random.randint(0, 126) - random.randint(0, 126))
 
    print(""Before:"")
    print(""========"")
    for x in range(0, 7):
        for a in range(0, 18):
            print(arr[x * 18 + a], end="" "")
        print()
    print()
    s = shell()
    s.sort(arr, 126)
 
    print(""After:"")
    print(""======="")
    for x in range(0, 7):
        for a in range(0, 18):
            print(arr[x * 18 + a], end="" "")
        print()
    print()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Active_object,Active object,"In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.

A typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.

The task

Implement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.

In order to test the object:

 set its input to sin (2π f t), where the frequency f=0.5Hz. The phase is irrelevant.
 wait 2s
 set the input to constant 0
 wait 0.5s
Verify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.
",Python,"from time import time, sleep
from threading import Thread
 
class Integrator(Thread):
    'continuously integrate a function `K`, at each `interval` seconds'
    def __init__(self, K=lambda t:0, interval=1e-4):
        Thread.__init__(self)
        self.interval  = interval
        self.K   = K
        self.S   = 0.0
        self.__run = True
        self.start()
 
    def run(self):
        ""entry point for the thread""
        interval = self.interval
        start = time()
        t0, k0 = 0, self.K(0)
        while self.__run:
            sleep(interval)
            t1 = time() - start
            k1 = self.K(t1)
            self.S += (k1 + k0)*(t1 - t0)/2.0
            t0, k0 = t1, k1
 
    def join(self):
        self.__run = False
        Thread.join(self)
 
if __name__ == ""__main__"":
    from math import sin, pi
 
    ai = Integrator(lambda t: sin(pi*t))
    sleep(2)
    print(ai.S)
    ai.K = lambda t: 0
    sleep(0.5)
    print(ai.S)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Hash_from_two_arrays,Hash from two arrays,"Task

Using two Arrays of equal length, create a Hash object
where the elements from one array (the keys) are linked
to the elements of the other (the values)



Related task

   Associative arrays/Creation

",Python,"import java.util.HashMap;
def main():
	keys= [""a"", ""b"", ""c""]
	vals= [1, 2, 3]
	hash= {}
 
	for i in range(len(keys)):
	   hash[keys[i]]= vals[i]",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Number_names,Number names,"Task

Show how to spell out a number in English.

You can use a preexisting implementation or roll your own, but you should support inputs up to at least one million (or the maximum value of your language's default bounded integer type, if that's less).

Support for inputs other than positive integers (like zero, negative integers, and floating-point numbers) is optional.



Related task

   Spelling of ordinal numbers.

",Python,"TENS = [None, None, ""twenty"", ""thirty"", ""forty"",
        ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
SMALL = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"",
         ""six"", ""seven"", ""eight"", ""nine"", ""ten"", ""eleven"",
         ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
         ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""]
HUGE = [None, None] + [h + ""illion"" 
                       for h in (""m"", ""b"", ""tr"", ""quadr"", ""quint"", ""sext"", 
                                  ""sept"", ""oct"", ""non"", ""dec"")]
 
def nonzero(c, n, connect=''):
    return """" if n == 0 else connect + c + spell_integer(n)
 
def last_and(num):
    if ',' in num:
        pre, last = num.rsplit(',', 1)
        if ' and ' not in last:
            last = ' and' + last
        num = ''.join([pre, ',', last])
    return num
 
def big(e, n):
    if e == 0:
        return spell_integer(n)
    elif e == 1:
        return spell_integer(n) + "" thousand""
    else:
        return spell_integer(n) + "" "" + HUGE[e]
 
def base1000_rev(n):
    # generates the value of the digits of n in base 1000
    # (i.e. 3-digit chunks), in reverse.
    while n != 0:
        n, r = divmod(n, 1000)
        yield r
 
def spell_integer(n):
    if n < 0:
        return ""minus "" + spell_integer(-n)
    elif n < 20:
        return SMALL[n]
    elif n < 100:
        a, b = divmod(n, 10)
        return TENS[a] + nonzero(""-"", b)
    elif n < 1000:
        a, b = divmod(n, 100)
        return SMALL[a] + "" hundred"" + nonzero("" "", b, ' and')
    else:
        num = "", "".join([big(e, x) for e, x in
                         enumerate(base1000_rev(n)) if x][::-1])
        return last_and(num)
 
if __name__ == '__main__':
    # examples
    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):
        print('%+4i -> %s' % (n, spell_integer(n)))
    print('')  
 
    n = 201021002001
    while n:
        print('%-12i -> %s' % (n, spell_integer(n)))
        n //= -10
    print('%-12i -> %s' % (n, spell_integer(n)))
    print('')",Human_written,Python_from_C#
http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",Python,"class Delegator:
   def __init__(self):
      self.delegate = None
   def operation(self):
       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):
          return self.delegate.thing()
       return 'default implementation'
 
class Delegate:
   def thing(self):
      return 'delegate implementation'
 
if __name__ == '__main__':
 
   # No delegate
   a = Delegator()
   assert a.operation() == 'default implementation'
 
   # With a delegate that does not implement ""thing""
   a.delegate = 'A delegate may be any object'
   assert a.operation() == 'default implementation'
 
   # With delegate that implements ""thing""
   a.delegate = Delegate()
   assert a.operation() == 'delegate implementation'",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Make_directory_path,Make directory path,"Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect.
If the directory already exists, return successfully.
Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.



",Python,"import os
import sys
 
if len(sys.argv)!= 2:
	print(""usage: mkdir <path>"")
	sys.exit(-1)
 
pathToCreate = sys.argv[1]
 
if os.path.exists(pathToCreate):
	sys.exit(0)
 
try:
	os.makedirs(pathToCreate)
except OSError:
	print(""couldn't create directory: "" + pathToCreate)
	sys.exit(-1)
 
sys.exit(0)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Statistics/Basic,Statistics/Basic,"Statistics is all about large groups of numbers.
When talking about a set of sampled data, most frequently used is their mean value and standard deviation (stddev).
If you have set of data 




x

i




{\displaystyle x_{i}}

 where 



i
=
1
,
2
,
…
,
n




{\displaystyle i=1,2,\ldots ,n\,\!}

, the mean is 






x
¯



≡


1
n



∑

i



x

i




{\displaystyle {\bar {x}}\equiv {1 \over n}\sum _{i}x_{i}}

, while the stddev is 



σ
≡




1
n



∑

i




(

x

i


−



x
¯



)


2






{\displaystyle \sigma \equiv {\sqrt {{1 \over n}\sum _{i}\left(x_{i}-{\bar {x}}\right)^{2}}}}

.

When examining a large quantity of data, one often uses a histogram, which shows the counts of data samples falling into a prechosen set of intervals (or bins).
When plotted, often as bar graphs, it visually indicates how often each data value occurs.

Task Using your language's random number routine, generate real numbers in the range of [0, 1]. It doesn't matter if you chose to use open or closed range.
Create 100 of such numbers (i.e. sample size 100) and calculate their mean and stddev.
Do so for sample size of 1,000 and 10,000, maybe even higher if you feel like.
Show a histogram of any of these sets.
Do you notice some patterns about the standard deviation?

Extra Sometimes so much data need to be processed that it's impossible to keep all of them at once. Can you calculate the mean, stddev and histogram of a trillion numbers? (You don't really need to do a trillion numbers, just show how it can be done.)

Hint

For a finite population with equal probabilities at all points, one can derive:








(
x
−


x
¯



)

2



¯


=



x

2


¯


−



x
¯



2




{\displaystyle {\overline {(x-{\overline {x}})^{2}}}={\overline {x^{2}}}-{\overline {x}}^{2}}


Or, more verbosely:







1
N



∑

i
=
1


N


(

x

i


−


x
¯



)

2


=


1
N



(

∑

i
=
1


N



x

i


2


)

−



x
¯



2


.


{\displaystyle {\frac {1}{N}}\sum _{i=1}^{N}(x_{i}-{\overline {x}})^{2}={\frac {1}{N}}\left(\sum _{i=1}^{N}x_{i}^{2}\right)-{\overline {x}}^{2}.}


See also
 Statistics/Normal distribution
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"def sd1(numbers):
    if numbers:
        mean = sum(numbers) / len(numbers)
        sd = (sum((n - mean)**2 for n in numbers) / len(numbers))**0.5
        return sd, mean
    else:
        return 0, 0
 
def sd2(numbers):
    if numbers:
        sx = sxx = n = 0
        for x in numbers:
            sx += x
            sxx += x*x
            n += 1
        sd = (n * sxx - sx*sx)**0.5 / n
        return sd, sx / n
    else:
        return 0, 0
 
def histogram(numbers):
    h = [0] * 10
    maxwidth = 50 # characters
    for n in numbers:
        h[int(n*10)] += 1
    mx = max(h)
    print()
    for n, i in enumerate(h):
        print('%3.1f: %s' % (n / 10, '+' * int(i / mx * maxwidth)))
    print()
 
if __name__ == '__main__':
    import random
    for i in range(1, 6):
        n = [random.random() for j in range(10**i)]
        print(""\n##\n## %i numbers\n##"" % 10**i)
        print('  Naive  method: sd: %8.6f, mean: %8.6f' % sd1(n))
        print('  Second method: sd: %8.6f, mean: %8.6f' % sd2(n))
        histogram(n)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/K-d_tree,K-d tree,"

 This page uses content from Wikipedia. The original article was at K-d tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

A k-d tree (short for k-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches).
k-d trees are a special case of binary space partitioning trees.

k-d trees are not suitable, however, for efficiently finding the nearest neighbor in high dimensional spaces. As a general rule, if the dimensionality is k, the number of points in the data, N, should be N ≫ 2k.
Otherwise, when k-d trees are used with high-dimensional data, most of the points in the tree will be evaluated and the efficiency is no better than exhaustive search, and other methods such as approximate nearest-neighbor are used instead.

Task: Construct a k-d tree and perform a nearest neighbor search for two example data sets:

 The Wikipedia example data of [(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)].
 1000 3-d points uniformly distributed in a 3-d cube.
For the Wikipedia example, find the nearest neighbor to point (9, 2)
For the random data, pick a random location and find the nearest neighbor.

In addition, instrument your code to count the number of nodes visited in the nearest neighbor search. Count a node as visited if any field of it is accessed.

Output should show the point searched for, the point found,
the distance to the point, and the number of nodes visited.

There are variant algorithms for constructing the tree.
You can use a simple median strategy or implement something more efficient.
Variants of the nearest neighbor search include nearest N neighbors, approximate nearest neighbor, and range searches.
You do not have to implement these.
The requirement for this task is specifically the nearest single neighbor.
Also there are algorithms for inserting, deleting, and balancing k-d trees.
These are also not required for the task.
",Python,"import math
import random
 
class Node:
    def __init__(self, coords):
        self.coords = coords
        self.left = None
        self.right = None
 
    def distance(self, node):
        dist = 0
        for i in range(len(self.coords)):
            d = self.coords[i] - node.coords[i]
            dist += d * d
        return dist
 
    def __str__(self):
        return str(self.coords)
 
class KdTree:
    def __init__(self, dimensions, nodes):
        self.dimensions = dimensions
        self.root = self.make_tree(nodes, 0, len(nodes), 0)
 
    def find_nearest(self, target):
        if self.root is None:
            raise Exception(""Tree is empty!"")
        self.best = None
        self.visited = 0
        self.best_distance = 0
        self.nearest(self.root, target, 0)
        return self.best
 
    def visited(self):
        return self.visited
 
    def distance(self):
        return math.sqrt(self.best_distance)
 
    def nearest(self, root, target, index):
        if root is None:
            return
        self.visited += 1
        d = root.distance(target)
        if self.best is None or d < self.best_distance:
            self.best_distance = d
            self.best = root
        if self.best_distance == 0:
            return
        dx = root.coords[index] - target.coords[index]
        index = (index + 1) % self.dimensions
        self.nearest(root.left if dx > 0 else root.right, target, index)
        if dx * dx >= self.best_distance:
            return
        self.nearest(root.right if dx > 0 else root.left, target, index)
 
    def make_tree(self, nodes, begin, end, index):
        if end <= begin:
            return None
        n = begin + (end - begin) // 2
        node = quick_select(nodes, begin, end - 1, n, NodeComparator(index))
        index = (index + 1) % self.dimensions
        node.left = self.make_tree(nodes, begin, n, index)
        node.right = self.make_tree(nodes, n + 1, end, index)
        return node
 
class NodeComparator:
    def __init__(self, index):
        self.index = index
 
    def compare(self, n1, n2):
        return n1.coords[self.index] - n2.coords[self.index]
 
def quick_select(nodes, begin, end, n, comparator):
    while True:
        if begin == end:
            return nodes[begin]
        pivot = random.randint(begin, end)
        pivot = partition(nodes, begin, end, pivot, comparator)
        if n == pivot:
            return nodes[n]
        elif n < pivot:
            end = pivot - 1
        else:
            begin = pivot + 1
 
def partition(nodes, begin, end, pivot, comparator):
    pivot_value = nodes[pivot]
    nodes[pivot], nodes[end] = nodes[end], nodes[pivot]
    store_index = begin
    for i in range(begin, end):
        if comparator.compare(nodes[i], pivot_value) < 0:
            nodes[store_index], nodes[i] = nodes[i], nodes[store_index]
            store_index += 1
    nodes[end], nodes[store_index] = nodes[store_index], nodes[end]
    return store_index",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Python,"def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = _matrix[row][int(digit)] 
    return row == 0
 
_matrix = (
    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),
    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),
    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),
    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),
    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),
    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),
    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),
    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),
    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),
    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)
)
 
if __name__ == '__main__':
    for test in [5724, 5727, 112946]:
        print(f'{test}\t Validates as: {damm(test)}')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Array_concatenation,Array concatenation,"Task

Show how to concatenate two arrays in your language.



If this is as simple as array1 + array2, so be it.



",Python,"a = [1,2,3]
b = [4,5,6]
c = a + b
print(c)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Ordered_words,Ordered words,"An   ordered word   is a word in which the letters appear in alphabetic order.

Examples include   abbey   and   dirt.

Task[edit]
Find and display all the ordered words in the dictionary   unixdict.txt   that have the longest word length.

(Examples that access the dictionary file locally assume that you have downloaded this file yourself.)

The display needs to be shown on this page.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import urllib.request
 
url = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'
words = urllib.request.urlopen(url).read().decode(""utf-8"").split()
ordered = [word for word in words if word==''.join(sorted(word))]
maxlen = len(max(ordered, key=len))
maxorderedwords = [word for word in ordered if len(word) == maxlen]
print(' '.join(maxorderedwords))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Longest_common_substring,Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",Python,"s1 = ""thisisatest""
s2 = ""testing123testing""
len1, len2 = len(s1), len(s2)
ir, jr = 0, -1
for i1 in range(len1):
    i2 = s2.find(s1[i1])
    while i2 >= 0:
        j1, j2 = i1, i2
        while j1 < len1 and j2 < len2 and s2[j2] == s1[j1]:
            if j1-i1 >= jr-ir:
                ir, jr = i1, j1
            j1 += 1; j2 += 1
        i2 = s2.find(s1[i1], i2+1)
print (s1[ir:jr+1])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Animate_a_pendulum,Animate a pendulum,"
One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.

The classic such physical system is a simple gravity pendulum.



Task

Create a simple physical model of a pendulum and animate it.



",Python,"import pygame, sys
from pygame.locals import *
from math import sin, cos, radians
 
pygame.init()
 
WINDOWSIZE = 250
TIMETICK = 100
BOBSIZE = 15
 
window = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))
pygame.display.set_caption(""Pendulum"")
 
screen = pygame.display.get_surface()
screen.fill((255,255,255))
 
PIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)
SWINGLENGTH = PIVOT[1]*4
 
class BobMass(pygame.sprite.Sprite):
    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.theta = 45
        self.dtheta = 0
        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),
                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),
                                1,1)
        self.draw()
 
    def recomputeAngle(self):
        scaling = 3000.0/(SWINGLENGTH**2)
 
        firstDDtheta = -sin(radians(self.theta))*scaling
        midDtheta = self.dtheta + firstDDtheta
        midtheta = self.theta + (self.dtheta + midDtheta)/2.0
 
        midDDtheta = -sin(radians(midtheta))*scaling
        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2
        midtheta = self.theta + (self.dtheta + midDtheta)/2
 
        midDDtheta = -sin(radians(midtheta)) * scaling
        lastDtheta = midDtheta + midDDtheta
        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0
 
        lastDDtheta = -sin(radians(lasttheta)) * scaling
        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0
        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0
 
        self.dtheta = lastDtheta
        self.theta = lasttheta
        self.rect = pygame.Rect(PIVOT[0]-
                                SWINGLENGTH*sin(radians(self.theta)), 
                                PIVOT[1]+
                                SWINGLENGTH*cos(radians(self.theta)),1,1)
 
 
    def draw(self):
        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)
        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)
        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)
        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))
 
    def update(self):
        self.recomputeAngle()
        screen.fill((255,255,255))
        self.draw()
 
bob = BobMass()
 
TICK = USEREVENT + 2
pygame.time.set_timer(TICK, TIMETICK)
 
def input(events):
    for event in events:
        if event.type == QUIT:
            sys.exit(0)
        elif event.type == TICK:
            bob.update()
 
while True:
    input(pygame.event.get())
    pygame.display.flip()",Human_written,Python_from_C
http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",Python,"import sys
for i in xrange(5):
    for j in xrange(i+1):
        sys.stdout.write(""*"")
    print",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",Python,"import os
import sys
import struct
import string
import re
import types
 
# note that UID & GID are of type ""int""
class gecos_t:
    def __init__(self, fullname, office, extension, homephone, email):
        self.fullname = fullname
        self.office = office
        self.extension = extension
        self.homephone = homephone
        self.email = email
 
class passwd_t:
    def __init__(self, account, password, uid, gid, gecos, directory, shell):
        self.account = account
        self.password = 
        self.uid = uid
        self.gid = gid
        self.gecos = gecos
        self.directory = directory
        self.shell = shell
 
GECOS_FMT = ""%s,%s,%s,%s,%s""
PASSWD_FMT = ""%s:%s:%d:%d:"" + GECOS_FMT + "":%s:%s""
 
passwd_list = [
    passwd_t(""jsmith"", ""x"", 1001, 1000, gecos_t("""", ""Room 1007"", ""(234)555-8917"", ""(234)555-0077"", """"), ""/home/jsmith"", ""/bin/bash""),
    passwd_t(""jdoe"", ""x"", 1002, 1000, gecos_t("""", ""Room 1004"", ""(234)555-8914"", ""(234)555-0044"", """"), ""/home/jdoe"", ""/bin/bash"")
]
 
# Create a passwd text file
passwd_text = open(""passwd.txt"", ""w"")
for rec_num in range(len(passwd_list)):
    passwd_text.write(PASSWD_FMT % (passwd_list[rec_num].account, passwd_list[rec_num].password, passwd_list[rec_num].uid, passwd_list[rec_num].gid, passwd_list[rec_num].gecos.fullname, passwd_list[rec_num].gecos.office, passwd_list[rec_num].gecos.extension, passwd_list[rec_num].gecos.homephone, passwd_list[rec_num].gecos.email, passwd_list[rec_num].directory, passwd_list[rec_num].shell))
    passwd_text.write(""\n"")
passwd_text.close()
 
# Load text ready for appending
passwd_text = open(""passwd.txt"", ""a+"")
passwd_buf = PASSWD_FMT % (""xyz"", ""x"", 1003, 1000, ""X Yz"", ""Room 1003"", ""(234)555-8913"", ""(234)555-0033"", """", ""/home/xyz"", ""/bin/bash"")
passwd_text.write(passwd_buf)
passwd_text.write(""\n"")
passwd_text.close()
 
# Finally reopen and check record was appended
passwd_text = open(""passwd.txt"", ""r"")
passwd_buf = passwd_text.read()
if re.search(""xyz"", passwd_buf):
    print ""Appended record: %s"" % (passwd_buf)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Averages/Mode,Averages/Mode,"Task[edit]
Write a program to find the mode value of a collection.

The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.

If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,">>> from collections import defaultdict
>>> def modes(values):
	count = defaultdict(int)
	for v in values:
		count[v] +=1
	best = max(count.values())
	return [k for k,v in count.items() if v == best]
 
>>> modes([1,3,6,6,6,6,7,7,12,12,17])
[6]
>>> modes((1,1,2,4,4))
[1, 4]",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Metallic_ratios,Metallic ratios,"Many people have heard of the Golden ratio, phi (φ). Phi is just one of a series
of related ratios that are referred to as the ""Metallic ratios"".

The Golden ratio was discovered and named by ancient civilizations as it was
thought to be the most pure and beautiful (like Gold). The Silver ratio was was
also known to the early Greeks, though was not named so until later as a nod to
the Golden ratio to which it is closely related. The series has been extended to
encompass all of the related ratios and was given the general name Metallic ratios (or Metallic means).
Somewhat incongruously as the original Golden ratio referred to the adjective ""golden"" rather than the metal ""gold"".

Metallic ratios are the real roots of the general form equation:

         x2 - bx - 1 = 0 

where the integer b determines which specific one it is.

Using the quadratic equation:

         ( -b ± √(b2 - 4ac) ) / 2a = x 

Substitute in (from the top equation) 1 for a, -1 for c, and recognising that -b is negated we get:

         ( b ± √(b2 + 4) ) ) / 2 = x 

We only want the real root:

         ( b + √(b2 + 4) ) ) / 2 = x 

When we set b to 1, we get an irrational number: the Golden ratio.

         ( 1 + √(12 + 4) ) / 2  =  (1 + √5) / 2 = ~1.618033989... 

With b set to 2, we get a different irrational number: the Silver ratio.

         ( 2 + √(22 + 4) ) / 2  =  (2 + √8) / 2 = ~2.414213562... 

When the ratio b is 3, it is commonly referred to as the Bronze ratio, 4 and 5
are sometimes called the Copper and Nickel ratios, though they aren't as
standard. After that there isn't really any attempt at standardized names. They
are given names here on this page, but consider the names fanciful rather than
canonical.

Note that technically, b can be 0 for a ""smaller"" ratio than the Golden ratio.
We will refer to it here as the Platinum ratio, though it is kind-of a
degenerate case.

Metallic ratios where b > 0 are also defined by the irrational continued fractions:

         [b;b,b,b,b,b,b,b,b,b,b,b,b,b,b,b,b...] 



So, The first ten Metallic ratios are:


 Metallic ratios


Name
b
Equation
Value
Continued fraction
OEIS link


Platinum
0
(0 + √4) / 2
 1
-
-


Golden
1
(1 + √5) / 2
 1.618033988749895...
[1;1,1,1,1,1,1,1,1,1,1...]
OEIS:A001622


Silver
2
(2 + √8) / 2
 2.414213562373095...
[2;2,2,2,2,2,2,2,2,2,2...]
OEIS:A014176


Bronze
3
(3 + √13) / 2
 3.302775637731995...
[3;3,3,3,3,3,3,3,3,3,3...]
OEIS:A098316


Copper
4
(4 + √20) / 2
 4.23606797749979...
[4;4,4,4,4,4,4,4,4,4,4...]
OEIS:A098317


Nickel
5
(5 + √29) / 2
 5.192582403567252...
[5;5,5,5,5,5,5,5,5,5,5...]
OEIS:A098318


Aluminum
6
(6 + √40) / 2
 6.16227766016838...
[6;6,6,6,6,6,6,6,6,6,6...]
OEIS:A176398


Iron
7
(7 + √53) / 2
 7.140054944640259...
[7;7,7,7,7,7,7,7,7,7,7...]
OEIS:A176439


Tin
8
(8 + √68) / 2
 8.123105625617661...
[8;8,8,8,8,8,8,8,8,8,8...]
OEIS:A176458


Lead
9
(9 + √85) / 2
 9.109772228646444...
[9;9,9,9,9,9,9,9,9,9,9...]
OEIS:A176522




There are other ways to find the Metallic ratios; one, (the focus of this task)
is through successive approximations of Lucas sequences.

A traditional Lucas sequence is of the form:

   xn = P * xn-1 - Q * xn-2

and starts with the first 2 values 0, 1.

For our purposes in this task, to find the metallic ratios we'll use the form:

   xn = b * xn-1 + xn-2

( P is set to b and Q is set to -1. ) To avoid ""divide by zero"" issues we'll start the sequence with the first two terms 1, 1. The initial starting value has very little effect on the final ratio or convergence rate. Perhaps it would be more accurate to call it a Lucas-like sequence.

At any rate, when b = 1 we get:

   xn = xn-1 + xn-2

   1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144...

more commonly known as the Fibonacci sequence.

When b = 2:

   xn = 2 * xn-1 + xn-2

   1, 1, 3, 7, 17, 41, 99, 239, 577, 1393...



And so on.



To find the ratio by successive approximations, divide the (n+1)th term by the
nth. As n grows larger, the ratio will approach the b metallic ratio.

For b = 1 (Fibonacci sequence):

   1/1   = 1
   2/1   = 2
   3/2   = 1.5
   5/3   = 1.666667
   8/5   = 1.6
   13/8  = 1.625
   21/13 = 1.615385
   34/21 = 1.619048
   55/34 = 1.617647
   89/55 = 1.618182
   etc.

It converges, but pretty slowly. In fact, the Golden ratio has the slowest
possible convergence for any irrational number.



Task
For each of the first 10 Metallic ratios; b = 0 through 9:

 Generate the corresponding ""Lucas"" sequence.
 Show here, on this page, at least the first 15 elements of the ""Lucas"" sequence.
 Using successive approximations, calculate the value of the ratio accurate to 32 decimal places.
 Show the value of the approximation at the required accuracy.
 Show the value of n when the approximation reaches the required accuracy (How many iterations did it take?).
Optional, stretch goal - Show the value and number of iterations n, to approximate the Golden ratio to 256 decimal places.

You may assume that the approximation has been reached when the next iteration does not cause the value (to the desired places) to change.

See also
 Wikipedia: Metallic mean
 Wikipedia: Lucas sequence",Python,"from __future__ import print_function
from decimal import Decimal
 
names = [""Platinum"", ""Golden"", ""Silver"", ""Bronze"", ""Copper"", ""Nickel"", ""Aluminium"", ""Iron"", ""Tin"", ""Lead""]
 
def lucas(b, N):
    print(""Lucas sequence for"", names[b], ""ratio, where b ="", b, "":"")
    print(""First"", N, ""elements:"", end="" "")
    x0, x1 = 1, 1
    print(x0, x1, end="" "")
    for i in range(1, N - 1):
        x2 = b * x1 + x0
        print(x2, end="" "")
        x0, x1 = x1, x2
    print()
 
def metallic(b, P):
    x0, x1 = Decimal(1), Decimal(1)
    prev = Decimal(1).quantize(Decimal(10) ** -P)
    for i in range(1, 1000000):
        x2 = b * x1 + x0
        thiz = (x2 / x1).quantize(Decimal(10) ** -P)
        if prev == thiz:
            print(""Value after"", i, ""iteration"" + (""s"" if i!= 1 else """") + "":"", thiz)
            break
        prev = thiz
        x0, x1 = x1, x2
 
for b in range(10):
    lucas(b, 15)
    metallic(b, 32)
 
print(""Golden ratio, where b = 1:"")
metallic(1, 256)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Polymorphism,Polymorphism,"Task

Create two classes   Point(x,y)   and   Circle(x,y,r)   with a polymorphic function print, accessors for (x,y,r), copy constructor, assignment and destructor and every possible default constructors



",Python,"class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    def getX(self):
        return self.x
    def getY(self):
        return self.y
    def setX(self, x):
        self.x = x
    def setY(self, y):
        self.y = y
    def print(self):
        print(""Point x: "" + str(self.x) + "" y: "" + str(self.y))
 
class Circle(Point):
    def __init__(self, x=0, y=0, r=0):
        Point.__init__(self, x, y)
        self.r = r
    def getR(self):
        return self.r
    def setR(self, r):
        self.r = r
    def print(self):
        print(""Circle x: "" + str(self.x) + "" y: "" + str(self.y) + "" r: "" + str(self.r))
 
p = Point()
c = Circle()
p.print()
c.print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Numbers_with_equal_rises_and_falls,Numbers with equal rises and falls,"When a number is written in base 10,   adjacent digits may ""rise"" or ""fall"" as the number is read   (usually from left to right).



Definition

Given the decimal digits of the number are written as a series   d:

   A   rise   is an index   i   such that    d(i)  <  d(i+1)
   A   fall    is an index   i   such that    d(i)  >  d(i+1)


Examples

   The number   726,169   has   3   rises and   2   falls,   so it isn't in the sequence.
   The number     83,548   has   2   rises and   2   falls,   so it   is   in the sequence.


Task

   Print the first   200   numbers in the sequence 
   Show that the   10 millionth   (10,000,000th)   number in the sequence is   41,909,002


See also

   OEIS Sequence  A296712   describes numbers whose digit sequence in base 10 have equal ""rises"" and ""falls"".


Related tasks

   Esthetic numbers

",Python,"def equalRisesFalls():
    limit1 = 200
    limit2 = 10000000
    print(""The first %d numbers in the sequence are:"" % limit1)
    n = 0
    count = 0
    while count < limit2:
        n += 1
        if equalRisesAndFalls(n):
            count += 1
            if count <= limit1:
                print(""%3d"" % n, end=' ')
                if count % 20 == 0:
                    print()
    print(""\nThe %dth number in the sequence is %d."" % (limit2, n))
 
def equalRisesAndFalls(n):
    total = 0
    previousDigit = -1
    while n > 0:
        digit = n % 10
        if previousDigit > digit:
            total += 1
        elif previousDigit >= 0 and previousDigit < digit:
            total -= 1
        previousDigit = digit
        n //= 10
    return total == 0
 
equalRisesFalls()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Twin_primes,Twin primes,"Twin primes are pairs of natural numbers   (P1  and  P2)   that satisfy the following:

     P1   and   P2   are primes
     P1  +  2   =   P2


Task

Write a program that displays the number of pairs of twin primes that can be found under a user-specified number

(P1 < user-specified number & P2 < user-specified number).



Extension

 Find all twin prime pairs under 100000, 10000000 and 1000000000.
 What is the time complexity of the program? Are there ways to reduce computation time?


Examples

> Search Size: 100
> 8 twin prime pairs.

> Search Size: 1000
> 35 twin prime pairs.



Also see

   The OEIS entry: A001097: Twin primes. 
   The OEIS entry: A167874: The number of distinct primes < 10^n which are members of twin-prime pairs. 
   The OEIS entry: A077800: List of twin primes {p, p+2}, with repetition. 
   The OEIS entry: A007508: Number of twin prime pairs below 10^n. 

",Python,"import math
import time
 
res = [0] * 10
ri = 1
p = 10
count = 0
 
def TabulateTwinPrimes(bound):
    global count
    if bound < 5:
        return
    count += 1
    cl = (bound - 1) >> 1
    i = 1
    j = 0
    limit = int(math.sqrt(bound) - 1) >> 1
    comp = [False] * cl
    lp = False
    for j in range(3, cl, 3):
        comp[j] = True
    while i < limit:
        if not comp[i]:
            lp = True
            pr = (i << 1) + 3
            for j in range((pr * pr - 2) >> 1, cl, pr):
                comp[j] = True
        if not comp[i + 1]:
            pr = ((i + 1) << 1) + 3
            if lp:
                if pr > p:
                    res[ri] = count
                    ri += 1
                    p *= 10
                count += 1
                i += 1
            for j in range((pr * pr - 2) >> 1, cl, pr):
                comp[j] = True
        i += 1
    cl -= 1
    while i < cl:
        lp = not comp[i]
        i += 1
        if not comp[i] and lp:
            if ((i << 1) + 3) > p:
                res[ri] = count
                ri += 1
                p *= 10
            count += 1
        i += 1
    res[ri] = count
 
def Main():
    sw = time.time()
    fmt = ""{0,9:n0} twin primes below {1,-13:n0}""
    TabulateTwinPrimes(1_000_000_000)
    sw = time.time() - sw
    p = 1
    for j in range(1, ri + 1):
        print(fmt.format(res[j], p))
        p *= 10
    print(""{0} sec"".format(sw))
 
Main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Circles_of_given_radius_through_two_points,Circles of given radius through two points,"
Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.

Exceptions

 r==0.0 should be treated as never describing circles (except in the case where the points are coincident).
 If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point.
 If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language.
 If the points are too far apart then no circles can be drawn.


Task detail

 Write a function/subroutine/method/... that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned.
 Show here the output for the following inputs:
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0



Related task

   Total circles area.


See also

   Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel

",Python,"import math
 
class Point:
	def __init__(self,x,y):
		self.x = x
		self.y = y
 
def distance(p1,p2):
	return math.sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y))
 
def findCircles(p1,p2,radius):
	separation = distance(p1,p2)
	mirrorDistance = 0.0
 
	if(separation == 0.0):
		if(radius == 0.0):
			print(""\nNo circles can be drawn through (%.4f,%.4f)""%(p1.x,p1.y))
		else:
			print(""\nInfinitely many circles can be drawn through (%.4f,%.4f)""%(p1.x,p1.y))
 
	elif(separation == 2*radius):
		print(""\nGiven points are opposite ends of a diameter of the circle with center (%.4f,%.4f) and radius %.4f""%((p1.x+p2.x)/2,(p1.y+p2.y)/2,radius))
 
	elif(separation > 2*radius):
		print(""\nGiven points are farther away from each other than a diameter of a circle with radius %.4f""%radius)
 
	else:
		mirrorDistance = math.sqrt(pow(radius,2) - pow(separation/2,2))
 
		print(""\nTwo circles are possible."")
		print(""\nCircle C1 with center (%.4f,%.4f), radius %.4f and Circle C2 with center (%.4f,%.4f), radius %.4f""%((p1.x+p2.x)/2 + mirrorDistance*(p1.y-p2.y)/separation,(p1.y+p2.y)/2 + mirrorDistance*(p2.x-p1.x)/separation,radius,(p1.x+p2.x)/2 - mirrorDistance*(p1.y-p2.y)/separation,(p1.y+p2.y)/2 - mirrorDistance*(p2.x-p1.x)/separation,radius))
 
cases = [Point(0.1234, 0.9876),Point(0.8765, 0.2345),Point(0.0000, 2.0000),Point(0.0000, 0.0000),Point(0.1234, 0.9876),Point(0.1234, 0.9876),Point(0.1234, 0.9876),Point(0.8765, 0.2345),Point(0.1234, 0.9876),Point(0.1234, 0.9876)]
radii = [2.0,1.0,2.0,0.5,0.0]
 
for i in range(0,5):
	print(""\nCase %d)""%(i+1))
	findCircles(cases[2*i],cases[2*i+1],radii[i])",Ai_generated,Python_from_C
"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence","Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",Python,"def hofst_10k(n):
	memo = [1, 1]
 
	def a(n):
		result = memo[n-1]
		if not isinstance(result, int):
			result = a(a(n-1))+a(n-a(n-1))	
			memo[n-1] = result
		return result
	return a
 
def maxima_between_twos(exp):
	current_max = 0
	for i in range(2**exp+1, 2**(exp+1)):
		current_max = max(current_max, hofst_10k(i)/i)
	return current_max
 
for i in range(1, 21):
	print(""Maxima between 2^""+str(i)+""-2^""+str(i+1)+"" is: ""+str(maxima_between_twos(i))+""\n"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Diversity_prediction_theorem,Diversity prediction theorem,"The   wisdom of the crowd   is the collective opinion of a group of individuals rather than that of a single expert.

Wisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise,   an explanation that assumes independence of the individual judgments from each other.

Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.



Scott E. Page introduced the diversity prediction theorem:

 The squared error of the collective prediction equals the average squared error minus the predictive diversity. 


Therefore,   when the diversity in a group is large,   the error of the crowd is small.



Definitions

   Average Individual Error:   Average of the individual squared errors
   Collective Error:   Squared error of the collective prediction
   Prediction Diversity:   Average squared distance from the individual predictions to the collective prediction
   Diversity Prediction Theorem:   Given a crowd of predictive models,     then
   Collective Error   =   Average Individual Error   ─   Prediction Diversity
Task

For a given   true   value and a number of number of estimates (from a crowd),   show   (here on this page):

   the true value   and   the crowd estimates
   the average error
   the crowd error
   the prediction diversity


Use   (at least)   these two examples:

   a true value of   49   with crowd estimates of:    48   47   51
   a true value of   49   with crowd estimates of:    48   47   51   42


Also see

   Wikipedia entry:   Wisdom of the crowd
   University of Michigan: PDF paper         (exists on a web archive,   the Wayback Machine).

",Python,"'''Diversity prediction theorem'''
 
from itertools import chain
from functools import reduce
 
 
#  diversityValues :: Num a => a -> [a] ->
#  { mean-Error :: a, crowd-error :: a, diversity :: a }
def diversityValues(x):
    '''The mean error, crowd error and
       diversity, for a given observation x
       and a non-empty list of predictions ps.
    '''
    def go(ps):
        mp = mean(ps)
        return {
            'mean-error': meanErrorSquared(x)(ps),
            'crowd-error': pow(x - mp, 2),
            'diversity': meanErrorSquared(mp)(ps)
        }
    return go
 
 
# meanErrorSquared :: Num -> [Num] -> Num
def meanErrorSquared(x):
    '''The mean of the squared differences
       between the observed value x and
       a non-empty list of predictions ps.
    '''
    def go(ps):
        return mean([
            pow(p - x, 2) for p in ps
        ])
    return go
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    '''Observed value: 49,
       prediction lists: various.
    '''
 
    print(unlines(map(
        showDiversityValues(49),
        [
            [48, 47, 51],
            [48, 47, 51, 42],
            [50, '?', 50, {}, 50],  # Non-numeric values.
            []                      # Missing predictions.
        ]
    )))
    print(unlines(map(
        showDiversityValues('49'),  # String in place of number.
        [
            [50, 50, 50],
            [40, 35, 40],
        ]
    )))
 
 
# ---------------------- FORMATTING ----------------------
 
# showDiversityValues :: Num -> [Num] -> Either String String
def showDiversityValues(x):
    '''Formatted string representation
       of diversity values for a given
       observation x and a non-empty
       list of predictions p.
    '''
    def go(ps):
        def showDict(dct):
            w = 4 + max(map(len, dct.keys()))
 
            def showKV(a, kv):
                k, v = kv
                return a + k.rjust(w, ' ') + (
                    ' : ' + showPrecision(3)(v) + '\n'
                )
            return 'Predictions: ' + showList(ps) + ' ->\n' + (
                reduce(showKV, dct.items(), '')
            )
 
        def showProblem(e):
            return (
                unlines(map(indented(1), e)) if (
                    isinstance(e, list)
                ) else indented(1)(repr(e))
            ) + '\n'
 
        return 'Observation:  ' + repr(x) + '\n' + (
            either(showProblem)(showDict)(
                bindLR(numLR(x))(
                    lambda n: bindLR(numsLR(ps))(
                        compose(Right, diversityValues(n))
                    )
                )
            )
        )
    return go
 
 
# ------------------ GENERIC FUNCTIONS -------------------
 
# Left :: a -> Either a b
def Left(x):
    '''Constructor for an empty Either (option type) value
       with an associated string.
    '''
    return {'type': 'Either', 'Right': None, 'Left': x}
 
 
# Right :: b -> Either a b
def Right(x):
    '''Constructor for a populated Either (option type) value'''
    return {'type': 'Either', 'Left': None, 'Right': x}
 
 
# bindLR (>>=) :: Either a -> (a -> Either b) -> Either b
def bindLR(m):
    '''Either monad injection operator.
       Two computations sequentially composed,
       with any value produced by the first
       passed as an argument to the second.
    '''
    def go(mf):
        return (
            mf(m.get('Right')) if None is m.get('Left') else m
        )
    return go
 
 
# compose :: ((a -> a), ...) -> (a -> a)
def compose(*fs):
    '''Composition, from right to left,
       of a series of functions.
    '''
    def go(f, g):
        def fg(x):
            return f(g(x))
        return fg
    return reduce(go, fs, identity)
 
 
# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f):
    '''A concatenated list over which a function has been mapped.
       The list monad can be derived by using a function f which
       wraps its output in a list,
       (using an empty list to represent computational failure).
    '''
    def go(xs):
        return chain.from_iterable(map(f, xs))
    return go
 
 
# either :: (a -> c) -> (b -> c) -> Either a b -> c
def either(fl):
    '''The application of fl to e if e is a Left value,
       or the application of fr to e if e is a Right value.
    '''
    return lambda fr: lambda e: fl(e['Left']) if (
        None is e['Right']
    ) else fr(e['Right'])
 
 
# identity :: a -> a
def identity(x):
    '''The identity function.'''
    return x
 
 
# indented :: Int -> String -> String
def indented(n):
    '''String indented by n multiples
       of four spaces.
    '''
    return lambda s: (4 * ' ' * n) + s
 
# mean :: [Num] -> Float
def mean(xs):
    '''Arithmetic mean of a list
       of numeric values.
    '''
    return sum(xs) / float(len(xs))
 
 
# numLR :: a -> Either String Num
def numLR(x):
    '''Either Right x if x is a float or int,
       or a Left explanatory message.'''
    return Right(x) if (
        isinstance(x, (float, int))
    ) else Left(
        'Expected number, saw: ' + (
            str(type(x)) + ' ' + repr(x)
        )
    )
 
 
# numsLR :: [a] -> Either String [Num]
def numsLR(xs):
    '''Either Right xs if all xs are float or int,
       or a Left explanatory message.'''
    def go(ns):
        ls, rs = partitionEithers(map(numLR, ns))
        return Left(ls) if ls else Right(rs)
    return bindLR(
        Right(xs) if (
            bool(xs) and isinstance(xs, list)
        ) else Left(
            'Expected a non-empty list, saw: ' + (
                str(type(xs)) + ' ' + repr(xs)
            )
        )
    )(go)
 
 
# partitionEithers :: [Either a b] -> ([a],[b])
def partitionEithers(lrs):
    '''A list of Either values partitioned into a tuple
       of two lists, with all Left elements extracted
       into the first list, and Right elements
       extracted into the second list.
    '''
    def go(a, x):
        ls, rs = a
        r = x.get('Right')
        return (ls + [x.get('Left')], rs) if None is r else (
            ls, rs + [r]
        )
    return reduce(go, lrs, ([], []))
 
 
# showList :: [a] -> String
def showList(xs):
    '''Compact string representation of a list'''
    return '[' + ','.join(str(x) for x in xs) + ']'
 
 
# showPrecision :: Int -> Float -> String
def showPrecision(n):
    '''A string showing a floating point number
       at a given degree of precision.'''
    def go(x):
        return str(round(x, n))
    return go
 
 
# unlines :: [String] -> String
def unlines(xs):
    '''A single string derived by the intercalation
       of a list of strings with the newline character.'''
    return '\n'.join(xs)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Vampire_number,Vampire number,"A vampire number is a natural decimal number with an even number of digits,   that can be factored into two integers.

These two factors are called the   fangs,   and must have the following properties:

   they each contain half the number of the decimal digits of the original number
   together they consist of exactly the same decimal digits as the original number
   at most one of them has a trailing zero


An example of a vampire number and its fangs:    1260 : (21, 60) 



Task

 Print the first   25   vampire numbers and their fangs. 
 Check if the following numbers are vampire numbers and,   if so,   print them and their fangs: 
 16758243290880, 24959017348650, 14593825548650 



Note that a vampire number can have more than one pair of fangs.



See also

 numberphile.com.
 vampire search algorithm
 vampire numbers on OEIS

",Python,"from __future__ import division
 
import math
from operator import mul
from itertools import product
from functools import reduce
 
 
def fac(n):
    '''\
    return the prime factors for n
    >>> fac(600)
    [5, 5, 3, 2, 2, 2]
    >>> fac(1000)
    [5, 5, 5, 2, 2, 2]
    >>>  
    '''
    step = lambda x: 1 + x*4 - (x//2)*2
    maxq = int(math.floor(math.sqrt(n)))
    d = 1
    q = n % 2 == 0 and 2 or 3 
    while q <= maxq and n % q != 0:
        q = step(d)
        d += 1
    res = []
    if q <= maxq:
        res.extend(fac(n//q))
        res.extend(fac(q)) 
    else: res=[n]
    return res
 
def fact(n):
    '''\
    return the prime factors and their multiplicities for n
    >>> fact(600)
    [(2, 3), (3, 1), (5, 2)]
    >>> fact(1000)
    [(2, 3), (5, 3)]
    >>> 
    '''
    res = fac(n)
    return [(c, res.count(c)) for c in set(res)]
 
def divisors(n):
    'Returns all the divisors of n'
    factors = fact(n)   # [(primefactor, multiplicity), ...]
    primes, maxpowers = zip(*factors)
    powerranges = (range(m+1) for m in maxpowers)
    powers = product(*powerranges)
    return (
        reduce(mul,
               (prime**power for prime, power in zip(primes, powergroup)),
               1)
        for powergroup in powers)
 
def vampire(n):
    fangsets = set( frozenset([d, n//d])
                    for d in divisors(n)
                    if (len(str(d)) == len(str(n))/2.
                        and sorted(str(d) + str(n//d)) == sorted(str(n))
                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )
    return sorted(tuple(sorted(fangs)) for fangs in fangsets)
 
 
if __name__ == '__main__':
    print('First 25 vampire numbers')
    count = n = 0
    while count <25:
        n += 1
        fangpairs = vampire(n)
        if fangpairs:
            count += 1
            print('%i: %r' % (n, fangpairs))
    print('\nSpecific checks for fangpairs')
    for n in (16758243290880, 24959017348650, 14593825548650):
        fangpairs = vampire(n)
        print('%i: %r' % (n, fangpairs))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Averages/Median,Averages/Median,"Task[edit]
Write a program to find the   median   value of a vector of floating-point numbers.

The program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.

There are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.

Sorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.

See also
Quickselect_algorithm

Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,"import numpy as np

# inputs must be random-access iterators of doubles
# Note: this function modifies the input range
def median(begin, end):
    # this is middle for odd-length, and ""upper-middle"" for even length
    middle = begin + (end - begin) / 2

    # This function runs in O(n) on average, according to the standard
    np.sort(begin, middle, end)

    if ((end - begin) % 2!= 0): # odd length
        return middle
    else: # even length
        # the ""lower middle"" is the max of the lower half
        lower_middle = np.max(begin, middle)
        return (middle + lower_middle) / 2.0

a = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]
b = [4.1, 7.2, 1.7, 9.3, 4.4, 3.2]

print(median(a[0], a[len(a)])) # 4.4
print(median(b[0], b[len(b)])) # 4.25",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Stern-Brocot_sequence,Stern-Brocot sequence,"For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the Fibonacci sequence.

 The first and second members of the sequence are both 1:
     1, 1
 Start by considering the second member of the sequence
 Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the sequence:
     1, 1, 2
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1
 Consider the next member of the series, (the third member i.e. 2)
 GOTO 3
 
         ─── Expanding another loop we get: ───

 Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the sequence:
     1, 1, 2, 1, 3
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1, 3, 2
 Consider the next member of the series, (the fourth member i.e. 1)


The task is to

 Create a function/method/subroutine/procedure/... to generate the Stern-Brocot sequence of integers using the method outlined above.
 Show the first fifteen members of the sequence. (This should be: 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4)
 Show the (1-based) index of where the numbers 1-to-10 first appears in the sequence.
 Show the (1-based) index of where the number 100 first appears in the sequence.
 Check that the greatest common divisor of all the two consecutive members of the series up to the 1000th member, is always one.

Show your output on this page.



Related tasks

   Fusc sequence.
   Continued fraction/Arithmetic


Ref

 Infinite Fractions - Numberphile (Video).
 Trees, Teeth, and Time: The mathematics of clock making. 
 A002487 The On-Line Encyclopedia of Integer Sequences.

",Python,"#include <iostream>
#include <iomanip>
#include <algorithm>
#include <vector>
 
unsigned gcd( unsigned i, unsigned j ) {
    return i? i < j? gcd( j % i, i ) : gcd( i % j, j ) : j;
}
def createSequence( seq, c ):
    if( 1500 == seq.size() ):
        return
    t = seq.at( c ) + seq.at( c + 1 )
    seq.push_back( t )
    seq.push_back( seq.at( c + 1 ) )
    createSequence( seq, c + 1 )
 
seq = [1, 1]
createSequence( seq, 0 )
 
print( ""First fifteen members of the sequence:\n    "" )
for x in range( 0, 15 ):
    print( seq[x], end = "" "" )
 
print( ""\n\n"" )
for x in range( 1, 11 ):
    i = seq.find( x )
    if( i!= seq.end() ):
        print( ""{:3} is at pos. #{}"".format( x, 1 + distance( seq.begin(), i ) ) )
 
print( ""\n"" )
i = seq.find( 100 )
if( i!= seq.end() ):
    print( ""100 is at pos. #{}"".format( 1 + distance( seq.begin(), i ) ) )
 
print( ""\n"" )
g = 0
f = False
for x in range( 0, 1000 ):
    y = x + 1
    g = gcd( seq[x], seq[y] )
    if( g!= 1 ):
        f = True
    print( ""{:4}: GCD ({}, {}) = {}"".format( x + 1, seq[x], seq[y], g ) )
    if( g!= 1 ):
        print( "" <-- ERROR\n"" )
 
print( ""\n"" + ( ""THERE WERE ERRORS --- NOT ALL GCDs ARE '1'!"" if f else ""CORRECT: ALL GCDs ARE '1'!"" ) + ""\n\n"" )",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]",Human_written,Python_from_C++
http://rosettacode.org/wiki/Two_bullet_roulette,Two bullet roulette,"The following is supposedly a question given to mathematics graduates seeking jobs on Wall Street:


 A revolver handgun has a revolving cylinder with six chambers for bullets.
 It is loaded with the following procedure:
 1. Check the first chamber to the right of the trigger for a bullet. If a bullet
is seen, the cylinder is rotated one chamber clockwise and the next chamber
checked until an empty chamber is found.
 2. A cartridge containing a bullet is placed in the empty chamber.
 3. The cylinder is then rotated one chamber clockwise.
 To randomize the cylinder's position, the cylinder is spun, which causes the cylinder to take
a random position from 1 to 6 chamber rotations clockwise from its starting position.
 When the trigger is pulled the gun will fire if there is a bullet in position 0, which is just
counterclockwise from the loading position.
 The gun is unloaded by removing all cartridges from the cylinder.
 According to the legend, a suicidal Russian imperial military officer plays a game of Russian
roulette by putting two bullets in a six-chamber cylinder and pulls the trigger twice.
If the gun fires with a trigger pull, this is considered a successful suicide.
 The cylinder is always spun before the first shot, but it may or may not be spun after putting
in the first bullet and may or may not be spun after taking the first shot.
 Which of the following situations produces the highest probability of suicide?
 A. Spinning the cylinder after loading the first bullet, and spinning again after the first shot.
 B. Spinning the cylinder after loading the first bullet only.
 C. Spinning the cylinder after firing the first shot only.
 D. Not spinning the cylinder either after loading the first bullet or after the first shot.
 E. The probability is the same for all cases.


Task

 Run a repeated simulation of each of the above scenario, calculating the percentage of suicide with a randomization of the four spinning, loading and firing order scenarios.
 Show the results as a percentage of deaths for each type of scenario.
 The hand calculated probabilities are 5/9, 7/12, 5/9, and 1/2. A correct program should produce results close enough to those to allow a correct response to the interview question. 


Reference

Youtube video on the Russian 1895 Nagant revolver [[1]]



",Python,"import random
import time
 
cylinder = [False] * 6
 
def rshift():
    t = cylinder[5]
    for i in range(4, -1, -1):
        cylinder[i+1] = cylinder[i]
    cylinder[0] = t
 
def unload():
    for i in range(6):
        cylinder[i] = False
 
def load():
    while cylinder[0]:
        rshift()
    cylinder[0] = True
    rshift()
 
def spin():
    lim = 1 + random.randint(0, 5)
    for i in range(1, lim):
        rshift()
 
def fire():
    shot = cylinder[0]
    rshift()
    return shot
 
def method(s):
    unload()
    for c in s:
        if c == 'L':
            load()
        elif c == 'S':
            spin()
        elif c == 'F':
            if fire():
                return 1
    return 0
 
def mstring(s):
    l = []
    for c in s:
        if c == 'L':
            l.append(""load"")
        elif c == 'S':
            l.append(""spin"")
        elif c == 'F':
            l.append(""fire"")
    return "", "".join(l)
 
random.seed(time.time())
tests = 100000
for m in [""LSLSFSF"", ""LSLSFF"", ""LLSFSF"", ""LLSFF""]:
    sum = 0
    for t in range(1, tests+1):
        sum += method(m)
    pc = float(sum) * 100 / float(tests)
    print(""%-40s produces %6.3f%% deaths."" % (mstring(m), pc))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",Python,"import time

print(""How long should we sleep in milliseconds?"")

sleep_string = input()

sleep_timer = int(sleep_string)

sleep_duration = time.sleep(sleep_timer)

print(""Sleeping..."")
time.sleep(sleep_duration)
print(""Awake!"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",Python,"array = []
 
array.append(1)
array.append(3)
 
array[0] = 2
 
print array[0]",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Water_collected_between_towers,Water collected between towers,"Task

In a two-dimensional world, we begin with any bar-chart (or row of close-packed 'towers', each of unit width), and then it rains,
completely filling all convex enclosures in the chart with water.



9               ██           9               ██    
8               ██           8               ██    
7     ██        ██           7     ██≈≈≈≈≈≈≈≈██    
6     ██  ██    ██           6     ██≈≈██≈≈≈≈██    
5 ██  ██  ██  ████           5 ██≈≈██≈≈██≈≈████    
4 ██  ██  ████████           4 ██≈≈██≈≈████████    
3 ██████  ████████           3 ██████≈≈████████    
2 ████████████████  ██       2 ████████████████≈≈██
1 ████████████████████       1 ████████████████████


In the example above, a bar chart representing the values [5, 3, 7, 2, 6, 4, 5, 9, 1, 2] has filled, collecting 14 units of water.

Write a function, in your language, from a given array of heights, to the number of water units that can be held in this way, by a corresponding bar chart.

Calculate the number of water units that could be collected by bar charts representing each of the following seven series:

   [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]


See, also:

 Four Solutions to a Trivial Problem – a Google Tech Talk by Guy Steele
 Water collected between towers on Stack Overflow, from which the example above is taken)
 An interesting Haskell solution, using the Tardis monad, by Phil Freeman in a Github gist.

",Python,"wta = [
    [1, 5, 3, 7, 2],   [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],    [5, 6, 7, 8],
    [8, 7, 7, 6],    [6, 7, 10, 7, 6]]
blk = """"
lf = ""\n""
tb = ""██""
wr = ""≈≈""
mt = ""  ""
for i in range(len(wta)):
    bpf = 0
    blk = """"
    while bpf > 0:
        floor = """"
        bpf = 0
        for j in range(len(wta[i])):
            if wta[i][j] > 0:
                floor += tb
                wta[i][j] -= 1
                bpf += 1
            else:
                floor += (j > 0 and j < len(wta[i]) - 1) and wr or mt
        if bpf > 0:
            blk = floor + lf + blk
    while blk.find(mt + wr) >= 0:
        blk = blk.replace(mt + wr, mt + mt)
    while blk.find(wr + mt) >= 0:
        blk = blk.replace(wr + mt, mt + mt)
    if len(sys.argv) > 0:
        print(""\n{0}"".format(blk))
    print(""Block {0} retains {1,2} water units."".format(i + 1, (len(blk) - blk.replace(wr, """").count(wr)) / 2))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",Python,"for i in range(1, 6):
    for j in range(1, i+1):
        print(""*"", end="""")
    print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Memory_layout_of_a_data_structure,Memory layout of a data structure,"It is often useful to control the memory layout of fields in a data structure to match an interface control definition, or to interface with hardware. Define a data structure matching the RS-232 Plug Definition. Use the 9-pin definition for brevity.

Pin Settings for Plug
(Reverse order for socket.)
__________________________________________
1  2  3  4  5  6  7  8  9  10 11 12 13
 14 15 16 17 18 19 20 21 22 23 24 25
_________________
1  2  3  4  5
6  7  8  9
25 pin                        9 pin
1 - PG   Protective ground
2 - TD   Transmitted data     3
3 - RD   Received data        2
4 - RTS  Request to send      7
5 - CTS  Clear to send        8
6 - DSR  Data set ready       6
7 - SG   Signal ground        5
8 - CD   Carrier detect       1
9 - + voltage (testing)
10 - - voltage (testing)
11 -
12 - SCD  Secondary CD
13 - SCS  Secondary CTS
14 - STD  Secondary TD
15 - TC   Transmit clock
16 - SRD  Secondary RD
17 - RC   Receiver clock
18 -
19 - SRS  Secondary RTS            
20 - DTR  Data terminal ready      4
21 - SQD  Signal quality detector
22 - RI   Ring indicator           9
23 - DRS  Data rate select
24 - XTC  External clock
25 -
",Python,"from ctypes import Structure, c_int
 
rs232_9pin  = ""_0 CD RD TD DTR SG DSR RTS CTS RI"".split()
rs232_25pin = ( ""_0  PG  TD  RD  RTS CTS DSR SG  CD  pos neg""
                ""_11 SCD SCS STD TC  SRD RC""
                ""_18 SRS DTR SQD RI DRS XTC"" ).split()
 
class RS232_9pin(Structure):
    _fields_ = [(__, c_int, 1) for __ in rs232_9pin]
 
 
class RS232_25pin(Structure):
    _fields_ = [(__, c_int, 1) for __ in rs232_25pin]",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Machine_code,Machine code,"The task requires poking machine code directly into memory and executing it. The machine code is the architecture-specific opcodes which have the simple task of adding two unsigned bytes together and making the result available to the high-level language.

For example, the following assembly language program is given for x86 (32 bit) architectures:

mov EAX, [ESP+4]
add EAX, [ESP+8]
ret
This would translate into the following opcode bytes:

139 68 36 4 3 68 36 8 195
Or in hexadecimal:

8B 44 24 04 03 44 24 08 C3
Task

If different than 32-bit x86, specify the target architecture of the machine code for your example. It may be helpful to also include an assembly version of the machine code for others to reference and understand what is being executed. Then, implement the following in your favorite programming language:

 Poke the necessary opcodes into a memory location.
 Provide a means to pass two values to the machine code.
 Execute the machine code with the following arguments: unsigned-byte argument of value 7; unsigned-byte argument of value 12; The result would be 19.
 Perform any clean up actions that are appropriate for your chosen language (free the pointer or memory allocations, etc.)

",Python,"import ctypes
import os
from ctypes import c_ubyte, c_int
 
code = bytes([0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3])
 
code_size = len(code)
# copy code into an executable buffer
if (os.name == 'posix'):
    import mmap
    executable_map = mmap.mmap(-1, code_size, mmap.MAP_PRIVATE | mmap.MAP_ANON, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)
    # we must keep a reference to executable_map until the call, to avoid freeing the mapped memory
    executable_map.write(code)
    # the mmap object won't tell us the actual address of the mapping, but we can fish it out by allocating
    # some ctypes object over its buffer, then asking the address of that
    func_address = ctypes.addressof(c_ubyte.from_buffer(executable_map))
elif (os.name == 'nt'):
    # the mmap module doesn't support protection flags on Windows, so execute VirtualAlloc instead
    code_buffer = ctypes.create_string_buffer(code)
    PAGE_EXECUTE_READWRITE = 0x40  # Windows constants that would usually come from header files
    MEM_COMMIT = 0x1000
    executable_buffer_address = ctypes.windll.kernel32.VirtualAlloc(0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)
    if (executable_buffer_address == 0):
        print('Warning: Failed to enable code execution, call will likely cause a protection fault.')
        func_address = ctypes.addressof(code_buffer)
    else:
        ctypes.memmove(executable_buffer_address, code_buffer, code_size)
        func_address = executable_buffer_address
else:
    # for other platforms, we just hope DEP isn't enabled
    code_buffer = ctypes.create_string_buffer(code)
    func_address = ctypes.addressof(code_buffer)
 
prototype = ctypes.CFUNCTYPE(c_int, c_ubyte, c_ubyte) # build a function prototype from return type and argument types
func = prototype(func_address)                        # build an actual function from the prototype by specifying the address
res = func(7,12)
print(res)",Human_written,Python_from_C
http://rosettacode.org/wiki/Permutations_by_swapping,Permutations by swapping,"Task

Generate permutations of n items in which successive permutations differ from each other by the swapping of any two items.

Also generate the sign of the permutation which is +1 when the permutation is generated from an even number of swaps from the initial state, and -1 for odd.

Show the permutations and signs of three items, in order of generation here.

Such data are of use in generating the determinant of a square matrix and any functions created should bear this in mind.

Note: The Steinhaus–Johnson–Trotter algorithm generates successive permutations where adjacent items are swapped, but from this discussion adjacency is not a requirement.



References

 Steinhaus–Johnson–Trotter algorithm
 Johnson-Trotter Algorithm Listing All Permutations
 Heap's algorithm
 [1] Tintinnalogia


Related tasks

   Matrix arithmetic
   Gray code

",Python,"# Implementation of Heap's algorithm.
# See https://en.wikipedia.org/wiki/Heap%27s_algorithm#Details_of_the_algorithm
def generate(a, output):
    n = len(a)
    c = [0] * n
    i = 1
    sign = 1
    output(a, sign)
    while i < n:
        if c[i] < i:
            if (i & 1) == 0:
                a[0], a[i] = a[i], a[0]
            else:
                a[c[i]], a[i] = a[i], a[c[i]]
            sign = -sign
            output(a, sign)
            c[i] += 1
            i = 1
        else:
            c[i] = 0
            i += 1
 
def print_permutation(a, sign):
    print(a, sign)
 
print(""Permutations and signs for three items:"")
a = [0, 1, 2]
generate(a, print_permutation)
 
print(""\nPermutations and signs for four items:"")
b = [0, 1, 2, 3]
generate(b, print_permutation)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",Python,">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))
>>> [ Y(fac)(i) for i in range(10) ]
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))
>>> [ Y(fib)(i) for i in range(10) ]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",Human_written,Python_from_Go
http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",Python,"from prime import is_prime
from prime import prime_factors
from prime import prime_factors_mult
from prime import digits
from prime import sum_digits
 
def is_smith(n):
    if is_prime(n):
        return False
    return sum_digits(n) == sum(sum_digits(p) * m for p, m in prime_factors_mult(n))
 
n = 10000
res = [i for i in range(1, n) if is_smith(i)]
 
print(f""{len(res)} smith numbers below {n}:
{', '.join(map(str, res[:5]))},... {', '.join(map(str, res[-5:]))}"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import fileinput
 
changerow, changecolumn, changevalue = 2, 4, '""Spam""'
 
with fileinput.input('csv_data_manipulation.csv', inplace=True) as f:
    for line in f:
        if fileinput.filelineno() == changerow:
            fields = line.rstrip().split(',')
            fields[changecolumn-1] = changevalue
            line = ','.join(fields) + '\n'
        print(line, end='')",Human_written,Python_from_Go
http://rosettacode.org/wiki/Amb,Amb,"Define and give an example of the Amb operator.

The Amb operator (short for ""ambiguous"") expresses nondeterminism. This doesn't refer to randomness (as in ""nondeterministic universe"") but is closely related to the term as it is used in automata theory (""non-deterministic finite automaton"").

The Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.

Problems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.

Essentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other ""parallel universes"" somehow go away. Amb called with no arguments fails.

For simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.

A pseudo-code program which satisfies this constraint might look like:

let x = Amb(1, 2, 3)
let y = Amb(7, 6, 4, 5)
Amb(x * y = 8)
print x, y
The output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x * y = 8) produces a success.

Alternatively, failure could be represented using strictly Amb():

unless x * y = 8 do Amb()
Or else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:

let x = Ambsel(1, 2, 3)
let y = Ambsel(4, 5, 6)
Ambassert(x * y = 8)
print x, y
where Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.

The task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:

""the"" ""that"" ""a""
""frog"" ""elephant"" ""thing""
""walked"" ""treaded"" ""grows""
""slowly"" ""quickly""
The constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.

The only successful sentence is ""that thing grows slowly""; other combinations do not satisfy the constraint and thus fail.

The goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.
",Python,"from typing import List, Optional, Tuple
class Amb:
    def __init__(self, list: List[List[str]]):
        self.list = list
    def do_amb(self, level: int, last_char: str) -> Optional[str]:
        if not self.list:
            raise Exception(""No word list"")
        if len(self.list) <= level:
            return """"
        res = """"
        word_list = self.list[level]
        for word in word_list:
            if word[0] == last_char or last_char == """":
                res += word + "" ""
                answ = self.do_amb(level + 1, word[-1])
                if answ:
                    res += answ
                    return res
                res = """"
        return None
if __name__ == ""__main__"":
    amb = Amb([
        [""the"", ""that"", ""a""],
        [""frog"", ""elephant"", ""thing""],
        [""walked"", ""treaded"", ""grows""],
        [""slowly"", ""quickly""],
    ])
    print(amb.do_amb(0, """"))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Semordnilap,Semordnilap,"A semordnilap is a word (or phrase) that spells a different word (or phrase) backward. ""Semordnilap"" is a word that itself is a semordnilap.

Example: lager and regal

Task
This task does not consider semordnilap phrases, only single words.
Using only words from this list, report the total number of unique semordnilap pairs, and print 5 examples.
Two matching semordnilaps, such as lager and regal, should be counted as one unique pair.
(Note that the word ""semordnilap"" is not in the above dictionary.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.2.0
 
import os
 
def main():
    words = set(open(os.path.join(os.path.dirname(__file__), 'unixdict.txt')).read().split())
    pairs = [ (w, w[::-1]) for w in words if w[::-1] in words and w < w[::-1] ]
    print(""Found %d semordnilap pairs"" % len(pairs))
    print(pairs[:5])
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape,Create a file on magnetic tape,"The task is to create a new file called ""TAPE.FILE"" of any size on Magnetic Tape.
",Python,"import sys
 
fp = open(""TAPE.FILE"",""w"")
 
fp.write(""This code should be able to write a file to magnetic tape.\n"")
fp.write(""The Wikipedia page on Magnetic tape data storage shows that magnetic tapes are still in use.\n"")
fp.write(""In fact, the latest format, at the time of writing this code is TS1155 released in 2017.\n"")
fp.write(""And since C is already 44, maybe 45, years old in 2017, I am sure someone somewhere did use a C compiler on magnetic tapes.\n"")
fp.write(""If you happen to have one, please try to compile and execute me on that system.\n"")
fp.write(""My creator tested me on an i5 machine with SSD and RAM that couldn't have even been dreamt of by.\n"")
fp.write(""Who knows ? Maybe he did foresee today, after all he created something which is still young after 44-45 years and counting...\n"")
fp.write(""EOF"")
 
fp.close()
 
sys.exit(0)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call,Exceptions/Catch an exception thrown in a nested call,"Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.

   Create two user-defined exceptions,   U0   and   U1. 
   Have function   foo   call function   bar   twice.
   Have function   bar   call function   baz. 
   Arrange for function   baz   to raise, or throw exception   U0   on its first call, then exception   U1   on its second.
   Function   foo   should catch only exception   U0,   not   U1.


Show/describe what happens when the program is run.



",Python,"class U0(Exception): pass
class U1(Exception): pass
 
def foo():
    for i in range(2):
        try:
            bar(i)
        except U0:
            print(""Function foo caught exception U0"")
 
def bar(i):
    baz(i) # Nest those calls
 
def baz(i):
    raise U1 if i else U0
 
foo()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",Python,"T = [[""79"", ""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""],
     ["""",   ""H"", ""O"", ""L"", """",  ""M"", ""E"", ""S"", """",  ""R"", ""T""],
     [""3"",  ""A"", ""B"", ""C"", ""D"", ""F"", ""G"", ""I"", ""J"", ""K"", ""N""],
     [""7"",  ""P"", ""Q"", ""U"", ""V"", ""W"", ""X"", ""Y"", ""Z"", ""."", ""/""]]
 
def straddle(s):
    return """".join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L)
 
def unstraddle(s):
    s = iter(s)
    for c in s:
        if c in [T[2][0], T[3][0]]:
            i = [T[2][0], T[3][0]].index(c)
            n = T[2 + i][T[0].index(s.next())]
            yield s.next() if n == ""/"" else n
        else:
            yield T[1][T[0].index(c)]
 
O = ""One night-it was on the twentieth of March, 1888-I was returning""
print ""Encoded:"", straddle(O)
print ""Decoded:"", """".join(unstraddle(straddle(O)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Successive_prime_differences,Successive prime differences,"The series of increasing prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

The task applies a filter to the series returning groups of successive primes, (s'primes), that differ from the next by a given value or values.

Example 1: Specifying that the difference between s'primes be 2 leads to the groups:

(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), ...

(Known as Twin primes or Prime pairs)

Example 2: Specifying more than one difference between s'primes leads to groups of size one greater than the number of differences. Differences of 2, 4 leads to the groups:

(5, 7, 11), (11, 13, 17), (17, 19, 23), (41, 43, 47), .... 

In the first group 7 is two more than 5 and 11 is four more than 7; as well as 5, 7, and 11 being successive primes.
Differences are checked in the order of the values given, (differences of 4, 2 would give different groups entirely).

Task

 In each case use a list of primes less than 1_000_000
 For the following Differences show the first and last group, as well as the number of groups found:
 Differences of 2.
 Differences of 1.
 Differences of 2, 2.
 Differences of 2, 4.
 Differences of 4, 2.
 Differences of 6, 4, 2.
 Show output here.

Note: Generation of a list of primes is a secondary aspect of the task. Use of a built in function, well known library, or importing/use of prime generators from other Rosetta Code tasks is encouraged.

references
https://pdfs.semanticscholar.org/78a1/7349819304863ae061df88dbcb26b4908f03.pdf
https://www.primepuzzles.net/puzzles/puzz_011.htm
https://matheplanet.de/matheplanet/nuke/html/viewtopic.php?topic=232720&start=0",Python,"# https://docs.sympy.org/latest/index.html
from sympy import Sieve
 
def nsuccprimes(count, mx):
    ""return tuple of <count> successive primes <= mx (generator)""
    sieve = Sieve()
    sieve.extend(mx)
    primes = sieve._list
    return zip(*(primes[n:] for n in range(count)))
 
def check_value_diffs(diffs, values):
    ""Differences between successive values given by successive items in diffs?""
    return all(v[1] - v[0] == d 
               for d, v in zip(diffs, zip(values, values[1:])))
 
def successive_primes(offsets=(2, ), primes_max=1_000_000):
    return (sp for sp in nsuccprimes(len(offsets) + 1, primes_max) 
            if check_value_diffs(offsets, sp))
 
if __name__ == '__main__':
    for offsets, mx in [((2,),      1_000_000), 
                        ((1,),      1_000_000),
                        ((2, 2),    1_000_000),
                        ((2, 4),    1_000_000),
                        ((4, 2),    1_000_000),
                        ((6, 4, 2), 1_000_000),
                       ]:
        print(f""## SETS OF {len(offsets)+1} SUCCESSIVE PRIMES <={mx:_} WITH ""
              f""SUCCESSIVE DIFFERENCES OF {str(list(offsets))[1:-1]}"")
        for count, last in enumerate(successive_primes(offsets, mx), 1):
            if count == 1:
                first = last
        print(""  First group:"", str(first)[1:-1])
        print(""   Last group:"", str(last)[1:-1])
        print(""        Count:"", count)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII,Write language name in 3D ASCII,"Task

Write/display a language's name in 3D ASCII.



(We can leave the definition of ""3D ASCII"" fuzzy,
so long as the result is interesting or amusing,
not a cheap hack to satisfy the task.)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 draw a Deathstar

",Python,"for i in range(5):
    for j in range(5):
        if i == 0 or i == 4 or j == 0 or j == 4:
            print(""*"", end="""")
        else:
            print("" "", end="""")
    print()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Execute_HQ9%2B,Execute HQ9+,"Task

Implement a    HQ9+    interpreter or compiler.



",Python,"$ ""bottles.qky"" loadfile ( if required, the source code for this can be found at 
                           http://rosettacode.org/wiki/99_bottles_of_beer#Quackery )
 
[ stack ]                  is accumulator (   --> s ) 
 
[ stack ]                  is sourcecode  (   --> s ) 
 
[ say ""Hello, world!"" cr ] is H.HQ9+      (   -->   )
 
[ sourcecode share 
  echo$ cr ]               is Q.HQ9+      (   -->   )
 
[ 99 song echo$ ]          is 9.HQ9+      (   -->   )
 
[ 1 accumulator tally ]    is +.HQ9+      (   -->   )
 
[ dup sourcecode put
  0 accumulator put
  witheach
    [ $ "".HQ9+"" join
      quackery ]
  sourcecode release
  cr say ""Accumulator = ""
  accumulator take echo ]  is HQ9+        ( $ -->   )
 
$ ""HH+QQQQ+"" HQ9+",Human_written,Python_from_C
http://rosettacode.org/wiki/Knapsack_problem/Continuous,Knapsack problem/Continuous,"

A thief burgles a butcher's shop, where he can select from some items.

The thief knows the weights and prices of each items.   Because he has a knapsack with 15 kg maximal capacity, he wants to select the items such that he would have his profit maximized.   He may cut the items;   the item has a reduced price after cutting that is proportional to the original price by the ratio of masses.   That means:   half of an item has half the price of the original.



This is the item list in the butcher's shop:


 Table of potential knapsack items


 Item 
 Weight (kg) 
 Price (Value)


 beef 
 3.8 
 36


 pork 
 5.4 
 43


 ham 
 3.6 
 90


 greaves 
 2.4 
 45


 flitch 
 4.0 
 30


 brawn 
 2.5 
 56


 welt 
 3.7 
 67


 salami 
 3.0 
 95


 sausage 
 5.9 
 98


 Knapsack 
 <=15 kg 
 ?



Task

Show which items the thief carries in his knapsack so that their total weight does not exceed 15 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/0-1


See also

   Wikipedia article:   continuous knapsack.

",Python,"#        NAME, WEIGHT, VALUE (for this weight)
items = [(""beef"",    3.8, 36.0),
         (""pork"",    5.4, 43.0),
         (""ham"",     3.6, 90.0),
         (""greaves"", 2.4, 45.0),
         (""flitch"",  4.0, 30.0),
         (""brawn"",   2.5, 56.0),
         (""welt"",    3.7, 67.0),
         (""salami"",  3.0, 95.0),
         (""sausage"", 5.9, 98.0)]
 
MAXWT = 15.0
 
sorted_items = sorted(((value/amount, amount, name)
                       for name, amount, value in items),
                      reverse = True)
wt = val = 0
bagged = []
for unit_value, amount, name in sorted_items:
    portion = min(MAXWT - wt, amount)
    wt     += portion
    addval  = portion * unit_value
    val    += addval
    bagged += [(name, portion, addval)]
    if wt >= MAXWT:
        break
 
print(""    ITEM   PORTION VALUE"")
print(""\n"".join(""%10s %6.2f %6.2f"" % item for item in bagged))
print(""\nTOTAL WEIGHT: %5.2f\nTOTAL VALUE: %5.2f"" % (wt, val))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Modular_arithmetic,Modular arithmetic,"Modular arithmetic is a form of arithmetic (a calculation technique involving the concepts of addition and multiplication) which is done on numbers with a defined equivalence relation called congruence.

For any positive integer 



p


{\displaystyle p}

 called the congruence modulus,
two numbers 



a


{\displaystyle a}

 and 



b


{\displaystyle b}

 are said to be congruent modulo p whenever there exists an integer 



k


{\displaystyle k}

 such that:





a
=
b
+
k

p


{\displaystyle a=b+k\,p}


The corresponding set of equivalence classes forms a ring denoted 






Z


p

Z






{\displaystyle {\frac {\mathbb {Z} }{p\mathbb {Z} }}}

.

Addition and multiplication on this ring have the same algebraic structure as in usual arithmetics, so that a function such as a polynomial expression could receive a ring element as argument and give a consistent result.

The purpose of this task is to show, if your programming language allows it,
how to redefine operators so that they can be used transparently on modular integers.
You can do it either by using a dedicated library, or by implementing your own class.

You will use the following function for demonstration:





f
(
x
)
=

x

100


+
x
+
1


{\displaystyle f(x)=x^{100}+x+1}


You will use 



13


{\displaystyle 13}

 as the congruence modulus and you will compute 



f
(
10
)


{\displaystyle f(10)}

.

It is important that the function 



f


{\displaystyle f}

 is agnostic about whether or not its argument is modular; it should behave the same way with normal and modular integers.
In other words, the function is an algebraic expression that could be used with any ring, not just integers.



",Python,"import operator
import functools
 
@functools.total_ordering
class Mod:
    __slots__ = ['val','mod']
 
    def __init__(self, val, mod):
        if not isinstance(val, int):
            raise ValueError('Value must be integer')
        if not isinstance(mod, int) or mod<=0:
            raise ValueError('Modulo must be positive integer')
        self.val = val % mod
        self.mod = mod
 
    def __repr__(self):
        return 'Mod({}, {})'.format(self.val, self.mod)
 
    def __int__(self):
        return self.val
 
    def __eq__(self, other):
        if isinstance(other, Mod):
            if self.mod == other.mod:
                return self.val==other.val
            else:
                return NotImplemented
        elif isinstance(other, int):
            return self.val == other
        else:
            return NotImplemented
 
    def __lt__(self, other):
        if isinstance(other, Mod):
            if self.mod == other.mod:
                return self.val<other.val
            else:
                return NotImplemented
        elif isinstance(other, int):
            return self.val < other
        else:
            return NotImplemented
 
    def _check_operand(self, other):
        if not isinstance(other, (int, Mod)):
            raise TypeError('Only integer and Mod operands are supported')
        if isinstance(other, Mod) and self.mod != other.mod:
            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))
 
    def __pow__(self, other):
        self._check_operand(other)
        # We use the built-in modular exponentiation function, this way we can avoid working with huge numbers.
        return Mod(pow(self.val, int(other), self.mod), self.mod)
 
    def __neg__(self):
        return Mod(self.mod - self.val, self.mod)
 
    def __pos__(self):
        return self # The unary plus operator does nothing.
 
    def __abs__(self):
        return self # The value is always kept non-negative, so the abs function should do nothing.
 
# Helper functions to build common operands based on a template.
# They need to be implemented as functions for the closures to work properly.
def _make_op(opname):
    op_fun = getattr(operator, opname)  # Fetch the operator by name from the operator module
    def op(self, other):
        self._check_operand(other)
        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)
    return op
 
def _make_reflected_op(opname):
    op_fun = getattr(operator, opname)
    def op(self, other):
        self._check_operand(other)
        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)
    return op
 
# Build the actual operator overload methods based on the template.
for opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:
    setattr(Mod, opname, _make_op(opname))
    setattr(Mod, reflected_opname, _make_reflected_op(opname))
 
def f(x):
    return x**100+x+1
 
print(f(Mod(10,13)))
# Output: Mod(1, 13)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Use_another_language_to_call_a_function,Use another language to call a function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
This task is inverse to the task Call foreign language function. Consider the following C program:

#include <stdio.h>
 
extern int Query (char * Data, size_t * Length);
 
int main (int argc, char * argv [])
{
   char     Buffer [1024];
   size_t   Size = sizeof (Buffer);
 
   if (0 == Query (Buffer, &Size))
   {
      printf (""failed to call Query\n"");
   }
   else
   {
      char * Ptr = Buffer;
      while (Size-- > 0) putchar (*Ptr++);
      putchar ('\n');
   }
}
Implement the missing Query function in your language, and let this C program call it. The function should place the string Here am I into the buffer which is passed to it as the parameter Data. The buffer size in bytes is passed as the parameter Length. When there is no room in the buffer, Query shall return 0. Otherwise it overwrites the beginning of Buffer, sets the number of overwritten bytes into Length and returns 1.
",Python,"# store this in file rc_embed.py
# store this in file rc_embed.py
def query(buffer_length):
    message = b'Here am I'
    L = len(message)
    return message[0:L*(L <= buffer_length)]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Benford%27s_law,Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",Python,"from __future__ import division
from itertools import islice, count
from collections import Counter
from math import log10
from random import randint
 
expected = [log10(1+1/d) for d in range(1,10)]
 
def fib():
    a,b = 1,1
    while True:
        yield a
        a,b = b,a+b
 
# powers of 3 as a test sequence
def power_of_threes():
    return (3**k for k in count(0))
 
def heads(s):
    for a in s: yield int(str(a)[0])
 
def show_dist(title, s):
    c = Counter(s)
    size = sum(c.values())
    res = [c[d]/size for d in range(1,10)]
 
    print(""\n%s Benfords deviation"" % title)
    for r, e in zip(res, expected):
        print(""%5.1f%% %5.1f%%  %5.1f%%"" % (r*100., e*100., abs(r - e)*100.))
 
def rand1000():
    while True: yield randint(1,9999)
 
if __name__ == '__main__':
    show_dist(""fibbed"", islice(heads(fib()), 1000))
    show_dist(""threes"", islice(heads(power_of_threes()), 1000))
 
    # just to show that not all kind-of-random sets behave like that
    show_dist(""random"", islice(heads(rand1000()), 10000))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",Python,"from itertools import permutations
from numpy import array, linalg
 
class Matrix(object):
    def __init__(self, matrix):
        self.matrix = matrix
        self.rows = len(matrix)
        self.cols = len(matrix[0])
        self.shape = (self.rows, self.cols)
    def __repr__(self):
        return str(self.matrix)
    def __getitem__(self, key):
        return self.matrix[key]
    def determinant(self):
        return linalg.det(self.matrix)
    def permanent(self):
        r = range(self.rows)
        return sum(sum(self[row, col] for col, row in enumerate(sigma))
                   for sigma in permutations(r))
 
m1 = Matrix([[1,2],[3,4]]) # testcases from Python version
 
m2 = Matrix([[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]])
 
m3 = Matrix([[0, 1, 2, 3, 4],
             [5, 6, 7, 8, 9],
             [10, 11, 12, 13, 14],
             [15, 16, 17, 18, 19], 
             [20, 21, 22, 23, 24]])
 
for m in [m1, m2, m3]:
    print ""determinant:\t"", m.determinant()
    print ""permanent:\t"", m.permanent()
    print",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",Python,"import sys
 
m = {}
 
def initMap():
    global m
    m = {}
    m[1] = 1
    m[2] = 1
 
def q(n):
    global m
    if n in m:
        return m[n]
    else:
        r = q(n-q(n-1)) + q(n-q(n-2))
        m[n] = r
        return r
 
def main():
    initMap()
    # task
    for n in range(1, 11):
        showQ(n)
    # task
    showQ(1000)
    # extra credit
    count, p = 0, 1
    for n in range(2, 100001):
        qn = q(n)
        if qn < p:
            count += 1
        p = qn
    print(""count:"", count)
    # extra credit
    initMap()
    showQ(1000000)
 
def showQ(n):
    print(""Q(%d) = %d"" % (n, q(n)))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Anonymous_recursion,Anonymous recursion,"While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.

This is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.

So we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:

   You have to think up a name, which then pollutes the namespace
   Function is created which is called from nowhere else
   The program flow in the source code is interrupted
Some languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.

Anonymous recursion can also be accomplished using the   Y combinator.



Task

If possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.



",Python,"def fib(n):
    def actual_fib(n):
        if n < 2:
            return n
        else:
            return actual_fib(n - 1) + actual_fib(n - 2)
    if n < 0:
        return None
    else:
        return actual_fib(n)
 
def main():
    print(""Fib(-1) ="", fib(-1))
    print(""Fib(0) ="", fib(0))
    print(""Fib(1) ="", fib(1))
    print(""Fib(2) ="", fib(2))
    print(""Fib(3) ="", fib(3))
    print(""Fib(4) ="", fib(4))
    print(""Fib(5) ="", fib(5))
    print(""Fib(10) ="", fib(10))
 
def test_fib():
    assert fib(0) == 0
    assert fib(1) == 1
    assert fib(2) == 1
    assert fib(3) == 2
    assert fib(4) == 3
    assert fib(5) == 5
    assert fib(10) == 55
 
def test_invalid_argument():
    assert fib(-1) == None
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Numeric_error_propagation,Numeric error propagation,"If   f,   a,   and   b   are values with uncertainties   σf,   σa,   and   σb,   and   c   is a constant;

then if   f   is derived from   a,   b,   and   c   in the following ways,

then   σf   can be calculated as follows:

Addition/Subtraction
 If   f = a ± c,   or   f = c ± a   then   σf = σa
 If   f = a ± b   then   σf2 = σa2 + σb2
Multiplication/Division
 If   f = ca   or   f = ac       then   σf = |cσa|
 If   f = ab   or   f = a / b   then   σf2 = f2( (σa / a)2 + (σb / b)2)
Exponentiation
 If   f = ac   then   σf = |fc(σa / a)|


Caution:

This implementation of error propagation does not address issues of dependent and independent values.   It is assumed that   a   and   b   are independent and so the formula for multiplication should not be applied to   a*a   for example.   See   the talk page   for some of the implications of this issue.


Task details

 Add an uncertain number type to your language that can support addition, subtraction, multiplication, division, and exponentiation between numbers with an associated error term together with 'normal' floating point numbers without an associated error term. 
Implement enough functionality to perform the following calculations.
 Given coordinates and their errors:
x1 = 100 ± 1.1
y1 = 50 ± 1.2
x2 = 200 ± 2.2
y2 = 100 ± 2.3
 if point p1 is located at (x1, y1) and p2 is at (x2, y2); calculate the distance between the two points using the classic Pythagorean formula: 
  d = √   (x1 - x2)²   +   (y1 - y2)²    
 Print and display both    d    and its error.


References

 A Guide to Error Propagation B. Keeney, 2005.
 Propagation of uncertainty Wikipedia.


Related task

   Quaternion type

",Python,"from collections import namedtuple
import math
 
class I(namedtuple('Imprecise', 'value, delta')):
    'Imprecise type: I(value=0.0, delta=0.0)' 
 
    __slots__ = () 
 
    def __new__(_cls, value=0.0, delta=0.0):
        'Defaults to 0.0 ± delta'
        return super().__new__(_cls, float(value), abs(float(delta)))
 
    def reciprocal(self):
        return I(1. / self.value, self.delta / (self.value**2)) 
 
    def __str__(self):
        'Shorter form of Imprecise as string'
        return 'I(%g, %g)' % self
 
    def __neg__(self):
        return I(-self.value, self.delta)
 
    def __add__(self, other):
        if type(other) == I:
            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )
        try:
            c = float(other)
        except:
            return NotImplemented
        return I(self.value + c, self.delta)
 
    def __sub__(self, other):
        return self + (-other)
 
    def __radd__(self, other):
        return I.__add__(self, other)
 
    def __mul__(self, other):
        if type(other) == I:
            #if id(self) == id(other):    
            #    return self ** 2
            a1,b1 = self
            a2,b2 = other
            f = a1 * a2
            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )
        try:
            c = float(other)
        except:
            return NotImplemented
        return I(self.value * c, self.delta * c)
 
    def __pow__(self, other):
        if type(other) == I:
            return NotImplemented
        try:
            c = float(other)
        except:
            return NotImplemented
        f = self.value ** c
        return I(f, f * c * (self.delta / self.value))
 
    def __rmul__(self, other):
        return I.__mul__(self, other)
 
    def __truediv__(self, other):
        if type(other) == I:
            return self.__mul__(other.reciprocal())
        try:
            c = float(other)
        except:
            return NotImplemented
        return I(self.value / c, self.delta / c)
 
    def __rtruediv__(self, other):
        return other * self.reciprocal()
 
    __div__, __rdiv__ = __truediv__, __rtruediv__
 
Imprecise = I
 
def distance(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5
 
x1 = I(100, 1.1)
x2 = I(200, 2.2)
y1 = I( 50, 1.2)
y2 = I(100, 2.3)
 
p1, p2 = (x1, y1), (x2, y2)
print(""Distance between points\n  p1: %s\n  and p2: %s\n  = %r"" % (
      p1, p2, distance(p1, p2)))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"i = 0
while i < 10:
  print(i)
  i = i + 1",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Fibonacci_sequence,Fibonacci sequence,"The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:

      F0 = 0 
      F1 = 1 
      Fn = Fn-1 + Fn-2, if n>1 



Task

Write a function to generate the    nth    Fibonacci number.

Solutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).

The sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:

      Fn = Fn+2 - Fn+1, if n<0   

support for negative      n      in the solution is optional.



Related tasks

   Fibonacci n-step number sequences‎
   Leonardo numbers


References

   Wikipedia, Fibonacci number
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,"from math import *
 
def analytic_fibonacci(n):
  sqrt_5 = sqrt(5);
  p = (1 + sqrt_5) / 2;
  q = 1/p;
  return int( (p**n + q**n) / sqrt_5 + 0.5 )
 
for i in range(1,31):
  print analytic_fibonacci(i),",Human_written,Python_from_C#
http://rosettacode.org/wiki/Active_Directory/Connect,Active Directory/Connect,"The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.
",Python,"import ldap
 
l = ldap.initialize(""ldap://ldap.example.com"")
try:
    l.protocol_version = ldap.VERSION3
    l.set_option(ldap.OPT_REFERRALS, 0)
 
    bind = l.simple_bind_s(""me@example.com"", ""password"")
finally:
    l.unbind()",Human_written,Python_from_C
http://rosettacode.org/wiki/Perfect_shuffle,Perfect shuffle,"A perfect shuffle (or faro/weave shuffle) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:



 7♠ 8♠ 9♠ J♠ Q♠ K♠→7♠  8♠  9♠
  J♠  Q♠  K♠→7♠ J♠ 8♠ Q♠ 9♠ K♠


When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:





 original: 

1
2
3
4
5
6
7
8



 after 1st shuffle: 

1
5
2
6
3
7
4
8



 after 2nd shuffle: 

1
3
5
7
2
4
6
8



 after 3rd shuffle: 

1
2
3
4
5
6
7
8




The Task
 Write a function that can perform a perfect shuffle on an even-sized list of values.
 Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under ""Test Cases"" below.
 You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all ""cards"" are unique within each deck.
 Print out the resulting shuffle counts, to demonstrate that your program passes the test-cases.
Test Cases


 input (deck size) 
 output (number of shuffles required)


 8 
 3


 24 
 11


 52 
 8


 100 
 30


 1020 
 1018


 1024 
 10


 10000 
 300


",Python,"from itertools import count
 
def perfect_shuffle(n):
    if n % 2!= 0:
        raise ValueError(""n must be even"")
    if n == 0:
        return []
    if n == 2:
        return [1, 2]
    return perfect_shuffle(n // 2) + perfect_shuffle(n // 2)[::-1]
 
for n in [8, 24, 52, 100, 1020, 1024, 10000]:
    print(n, ""cards:"", len(perfect_shuffle(n)))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Semordnilap,Semordnilap,"A semordnilap is a word (or phrase) that spells a different word (or phrase) backward. ""Semordnilap"" is a word that itself is a semordnilap.

Example: lager and regal

Task
This task does not consider semordnilap phrases, only single words.
Using only words from this list, report the total number of unique semordnilap pairs, and print 5 examples.
Two matching semordnilaps, such as lager and regal, should be counted as one unique pair.
(Note that the word ""semordnilap"" is not in the above dictionary.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> with open('unixdict.txt') as f:
	wordset = set(f.read().strip().split())
 
>>> revlist = (''.join(word[::-1]) for word in wordset)
>>> pairs   = set((word, rev) for word, rev in zip(wordset, revlist) 
                  if word < rev and rev in wordset)
>>> len(pairs)
158
>>> sorted(pairs, key=lambda p: (len(p[0]), p))[-5:]
[('damon', 'nomad'), ('lager', 'regal'), ('leper', 'repel'), ('lever', 'revel'), ('kramer', 'remark')]
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Check_that_file_exists,Check that file exists,"Task

Verify that a file called     input.txt     and   a directory called     docs     exist.



This should be done twice:  

   once for the current working directory,   and
   once for a file and a directory in the filesystem root.


Optional criteria (May 2015):   verify it works with:

   zero-length files
   an unusual filename:     `Abdu'l-Bahá.txt  

",Python,"import os
 
os.path.isfile(""input.txt"")
os.path.isfile(""/input.txt"")
os.path.isdir(""docs"")
os.path.isdir(""/docs"")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",Python,"def bubble_sort(seq):
    """"""Inefficiently sort the mutable sequence (list) in place.
       seq MUST BE A MUTABLE SEQUENCE.
 
       As with list.sort() and random.shuffle this does NOT return 
    """"""
    changed = True
    while changed:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i]
                changed = True
    return seq
 
if __name__ == ""__main__"":
   """"""Sample usage and simple test suite""""""
 
   from random import shuffle
 
   testset = [_ for _ in range(100)]
   testcase = testset.copy() # make a copy
   shuffle(testcase)
   assert testcase != testset  # we've shuffled it
   bubble_sort(testcase)
   assert testcase == testset  # we've unshuffled it back into a copy",Human_written,Python_from_C++
http://rosettacode.org/wiki/Knuth_shuffle,Knuth shuffle,"The   Knuth shuffle   (a.k.a. the Fisher-Yates shuffle)   is an algorithm for randomly shuffling the elements of an array.



Task

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).



Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

       for i from last downto 1 do:
           let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 j 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 i
           swap items[i] with items[j]

Notes

   It modifies the input array in-place. 
   If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
   The algorithm can also be amended to iterate from left to right, if that is more convenient.


Test cases



 Input array

 Possible output arrays


 []

 []


 [10]

 [10]


 [10, 20]

 [10, 20]
[20, 10]


 [10, 20, 30]

 [10, 20, 30]
[10, 30, 20]
[20, 10, 30]
[20, 30, 10]
[30, 10, 20]
[30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)



Related task

 Sattolo cycle



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import random
 
def knuth_shuffle(v):
    l = len(v)
 
    for n in range(l):
        i = random.randrange(l - n)
        v[i], v[l - n - 1] = v[l - n - 1], v[i]
 
v = list(range(10))
 
print(""before:"", v)
knuth_shuffle(v)
print(""after: "", v)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Mouse_position,Mouse position,"Task

Get the current location of the mouse cursor relative to the active window.

Please specify if the window may be externally created.



",Python,"from browser import document, window

def mousemove(event):
    position = {'x': event.clientX, 'y': event.clientY}

document.bind('mousemove', mousemove)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",Python,"import math

print(min(1, 2)) #Minimum
print(max(1, 2)) #Maximum
print(math.copysign(1, 2)) #Sign
print(round(1.5)) #Round
print(math.trunc(1.5)) #Truncate
print(math.mul(1, 2)) #Multiply High
print(divmod(1, 2)) #Divide Remainder
print(divmod(1, 2)[1]) #Remainder",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Greyscale_bars/Display,Greyscale bars/Display,"The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.

For the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)

For the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).

Halfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.
",Python,"#!/usr/bin/env python
#four gray scaled stripes 8:16:32:64 in Python 2.7.1
 
from livewires import *
 
horiz=640; vert=480; pruh=vert/4; dpp=255.0
begin_graphics(width=horiz,height=vert,title=""Gray stripes"",background=Colour.black)
 
def ty_pruhy(each):
	hiy=each[0]*pruh; loy=hiy-pruh
	krok=horiz/each[1]; piecol=255.0/(each[1]-1)
	for x in xrange(0,each[1]):
		barva=Colour(piecol*x/dpp,piecol*x/dpp,piecol*x/dpp ); set_colour(barva)
		if each[2]:
			box(x*krok,hiy,x*krok+krok,loy,filled=1)
		else:
			box(horiz-x*krok,hiy,horiz-((x+1)*krok),loy,filled=1)
 
# main
source=[[4,8,True],[3,16,False],[2,32,True],[1,64,False]]
for each in source:
	ty_pruhy(each)
 
while keys_pressed() != [' ']: # press spacebar to close window
	pass",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Ethiopian_multiplication,Ethiopian multiplication,"Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.


Method:

 Take two numbers to be multiplied and write them down at the top of two columns.
 In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
 In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
 Examine the table produced and discard any row where the value in the left column is even.
 Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.



Task

The task is to define three named functions/methods/procedures/subroutines:

 one to halve an integer,
 one to double an integer, and
 one to state if an integer is even.


Use these functions to create a function that does Ethiopian multiplication.



References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication

",Python,"tutor = True
 
def halve(x):
    return x // 2
 
def double(x):
    return x * 2
 
def even(x):
    return not x % 2
 
def ethiopian(multiplier, multiplicand):
    if tutor:
        print(""Ethiopian multiplication of %i and %i"" %
              (multiplier, multiplicand))
    result = 0
    while multiplier >= 1:
        if even(multiplier):
            if tutor:
                print(""%4i %6i STRUCK"" %
                      (multiplier, multiplicand))
        else:
            if tutor:
                print(""%4i %6i KEPT"" %
                      (multiplier, multiplicand))
            result += multiplicand
        multiplier   = halve(multiplier)
        multiplicand = double(multiplicand)
    if tutor:
        print()
    return result",Human_written,Python_from_Java
http://rosettacode.org/wiki/Jacobi_symbol,Jacobi symbol,"The Jacobi symbol is a multiplicative function that generalizes the Legendre symbol. Specifically, the Jacobi symbol (a | n) equals the product of the Legendre symbols (a | p_i)^(k_i), where n = p_1^(k_1)*p_2^(k_2)*...*p_i^(k_i) and the Legendre symbol (a | p) denotes the value of a ^ ((p-1)/2) (mod p)

 (a | p) ≡   1     if a is a square (mod p)
 (a | p) ≡ -1     if a is not a square (mod p)
 (a | p) ≡   0     if a ≡ 0 
If n is prime, then the Jacobi symbol (a | n) equals the Legendre symbol (a | n).

Task

Calculate the Jacobi symbol (a | n).

Reference

 Wikipedia article on Jacobi symbol.",Python,"def jacobiSymbol(k, n):
    if k < 0 or n % 2 == 0:
        raise ValueError(""Invalid value. k = "" + str(k) + "", n = "" + str(n))
    k %= n
    jacobi = 1
    while k > 0:
        while k % 2 == 0:
            k /= 2
            r = n % 8
            if r == 3 or r == 5:
                jacobi = -jacobi
        temp = n
        n = k
        k = temp
        if k % 4 == 3 and n % 4 == 3:
            jacobi = -jacobi
        k %= n
    if n == 1:
        return jacobi
    return 0
 
max = 30
print(""n\\k "", end="""")
for k in range(1, max + 1):
    print(""%2d  "" % k, end="""")
print()
for n in range(1, max + 1, 2):
    print(""%2d  "" % n, end="""")
    for k in range(1, max + 1):
        print(""%2d  "" % jacobiSymbol(k, n), end="""")
    print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Five_weekends,Five weekends,"The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.



Task

 Write a program to show all months that have this same characteristic of five full weekends from the year 1900 through 2100 (Gregorian calendar). 
 Show the number of months with this property (there should be 201).
 Show at least the first and last five dates, in order.

Algorithm suggestions

 Count the number of Fridays, Saturdays, and Sundays in every month.
 Find all of the 31-day months that begin on Friday.

Extra credit

Count and/or show all of the years which do not have at least one five-weekend month (there should be 29).



Related tasks
 Day of the week
 Last Friday of each month
 Find last sunday of each month

",Python,"import datetime
 
FIRST_YEAR = 1900
LAST_YEAR = 2100
_31_MONTHS = [1, 3, 5, 7, 8, 10, 12]
 
totalNum = 0
totalNo5Weekends = 0
 
for year in range(FIRST_YEAR, LAST_YEAR + 1):
    has5Weekends = False
 
    for month in _31_MONTHS:
        firstDay = datetime.date(year, month, 1)
        if firstDay.weekday() == 4:
            totalNum += 1
            has5Weekends = True
            print(firstDay.strftime(""%Y - %B""))
 
    if not has5Weekends:
        totalNo5Weekends += 1
 
print(""Total 5-weekend months between {0} and {1}: {2}"".format(FIRST_YEAR, LAST_YEAR, totalNum))
print(""Total number of years with no 5-weekend months {0}"".format(totalNo5Weekends))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Generate_random_chess_position,Generate random chess position,"Task
 
Generate a random chess position in FEN format.

The position does not have to be realistic or even balanced,  but it must comply to the following rules:

 there is one and only one king of each color  (one black king and one white king);
 the kings must not be placed on adjacent squares;
 there can not be any pawn in the promotion square  (no white pawn in the eighth rank, and no black pawn in the first rank);
 including the kings, up to 32 pieces of either color can be placed. 
 There is no requirement for material balance between sides. 
 The picking of pieces does not have to comply to a regular chess set --- there can be five knights, twenty rooks, whatever ... as long as the total number of pieces do not exceed thirty-two. 
 it is white's turn.
 It's assumed that both sides have lost castling rights and that there is no possibility for   en passant   (the FEN should thus end in w - - 0 1).


No requirement is made regarding the probability distribution of your method, but your program should be able to span a reasonably representative sample of all possible positions. For instance, programs that would always generate positions with say five pieces on the board, or with kings on a corner, would not be considered truly random.



",Python,"import random
import string
 
grid = [[0 for x in range(8)] for x in range(8)]
 
def placeKings():
    r1 = random.randint(0, 7)
    c1 = random.randint(0, 7)
    r2 = random.randint(0, 7)
    c2 = random.randint(0, 7)
    while r1 == r2 or abs(r1 - r2) <= 1 or abs(c1 - c2) <= 1:
        r1 = random.randint(0, 7)
        c1 = random.randint(0, 7)
        r2 = random.randint(0, 7)
        c2 = random.randint(0, 7)
    grid[r1][c1] = 'K'
    grid[r2][c2] = 'k'
 
def placePieces(pieces, isPawn):
    numToPlace = random.randint(0, len(pieces))
    for n in range(numToPlace):
        r = random.randint(0, 7)
        c = random.randint(0, 7)
        while grid[r][c]!= 0 or (isPawn and (r == 7 or r == 0)):
            r = random.randint(0, 7)
            c = random.randint(0, 7)
        grid[r][c] = pieces[n]
 
def toFen():
    fen = """"
    countEmpty = 0
    for r in range(8):
        for c in range(8):
            ch = grid[r][c]
            if ch == 0:
                countEmpty += 1
            else:
                if countEmpty > 0:
                    fen += str(countEmpty)
                    countEmpty = 0
                fen += ch
        if countEmpty > 0:
            fen += str(countEmpty)
            countEmpty = 0
        fen += '/'
    fen += "" w - - 0 1""
    print(fen)
 
def createFen():
    placeKings()
    placePieces(""PPPPPPPP"", True)
    placePieces(""pppppppp"", True)
    placePieces(""RNBQBNR"", False)
    placePieces(""rnbqbnr"", False)
    toFen()
 
createFen()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Gray_code,Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",Python,"def gray_encode(n):
    return n ^ n >> 1
 
def gray_decode(n):
    m = n >> 1
    while m:
        n ^= m
        m >>= 1
    return n
 
 
if __name__ == '__main__':
    print(""DEC,   BIN =>  GRAY => DEC"")
    for i in range(32):
        gray = gray_encode(i)
        dec = gray_decode(gray)
        print(f"" {i:>2d}, {i:>05b} => {gray:>05b} => {dec:>2d}"")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Assertions,Assertions,"Assertions are a way of breaking out of code when there is an error or an unexpected input.

Some languages throw exceptions and some treat it as a break point.



Task

Show an assertion in your language by asserting that an integer variable is equal to 42.



",Python,"a = 5
#...input or change a here
assert a == 42 # throws an AssertionError when a is not 42
assert a == 42, ""Error message"" # throws an AssertionError
       # when a is not 42 with ""Error message"" for the message
       # the error message can be any expression",Human_written,Python_from_Java
http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously,First-class functions/Use numbers analogously,"In First-class functions, a language is showing how its manipulation of functions is similar to its manipulation of other types.

This tasks aim is to compare and contrast a language's implementation of first class functions, with its normal handling of numbers.



Write a program to create an ordered collection of a mixture of literally typed and expressions producing a real number, together with another ordered collection of their multiplicative inverses. Try and use the following pseudo-code to generate the numbers for the ordered collections:

  x  = 2.0
  xi = 0.5
  y  = 4.0
  yi = 0.25
  z  = x + y
  zi = 1.0 / ( x + y )

Create a function multiplier, that given two numbers as arguments returns a function that when called with one argument, returns the result of multiplying the two arguments to the call to multiplier that created it and the argument in the call:

 new_function = multiplier(n1,n2)
 # where new_function(m) returns the result of n1 * n2 * m

Applying the multiplier of a number and its inverse from the two ordered collections of numbers in pairs, show that the result in each case is one.

Compare and contrast the resultant program with the corresponding entry in First-class functions. They should be close.

To paraphrase the task description: Do what was done before, but with numbers rather than functions
",Python,"IDLE 2.6.1      
>>> # Number literals
>>> x,xi, y,yi = 2.0,0.5, 4.0,0.25
>>> # Numbers from calculation
>>> z  = x + y
>>> zi = 1.0 / (x + y)
>>> # The multiplier function is similar to 'compose' but with numbers
>>> multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)
>>> # Numbers as members of collections
>>> numlist = [x, y, z]
>>> numlisti = [xi, yi, zi]
>>> # Apply numbers from list
>>> [multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)]
[0.5, 0.5, 0.5]
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Thue-Morse,Thue-Morse,"Task

Create a Thue-Morse sequence.



See also
   YouTube entry: The Fairest Sharing Sequence Ever
   YouTube entry: Math and OCD - My story with the Thue-Morse sequence
   Task: Fairshare between two and more

",Python,"def thueMorse(n):
    sb0 = ""0""
    sb1 = ""1""
    for i in range(n):
        tmp = sb0
        sb0 += sb1
        sb1 += tmp
    return sb0
 
for i in range(7):
    print(f""{i} : {thueMorse(i)}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Walk_a_directory/Non-recursively,Walk a directory/Non-recursively,"Task

Walk a given directory and print the names of files matching a given pattern.

(How is ""pattern"" defined? substring match? DOS pattern? BASH pattern? ZSH pattern? Perl regular expression?)


Note: This task is for non-recursive methods.   These tasks should read a single directory, not an entire directory tree.

Note: Please be careful when running any code presented here.



Related task

   Walk Directory Tree   (read entire directory tree). 

",Python,"import re
import os
 
def walkDirectory(dir, re_pattern):
    print(""Files in %s matching '%s':"" % (dir, re_pattern))
    walkDirectoryFilter(os.listdir(dir), re_pattern)
 
    print(""Folders in %s matching '%s':"" % (dir, re_pattern))
    walkDirectoryFilter(os.listdir(dir), re_pattern)
 
def walkDirectoryFilter(items, re_pattern):
    for item in items:
        if re.match(re_pattern, item):
            print(item)
 
walkDirectory('test_folder', '\\.txt$')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def strip_characters(original, to_strip):
    result = """"
    for c in original:
        if c not in to_strip:
            result += c
    return result",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Numerical_integration,Numerical integration,"Write functions to calculate the definite integral of a function  ƒ(x)  using all five of the following methods:

 rectangular
 left
 right
 midpoint
 trapezium
 Simpson's
 composite
Your functions should take in the upper and lower bounds (a and b), and the number of approximations to make in that range (n).

Assume that your example already has a function that gives values for  ƒ(x) .

Simpson's method is defined by the following pseudo-code:


 Pseudocode: Simpson's method, composite



procedure quad_simpson_composite(f, a, b, n)
    h := (b - a) / n
    sum1 := f(a + h/2)
    sum2 := 0

    loop on i from 1 to (n - 1)
        sum1 := sum1 + f(a + h * i + h/2)
        sum2 := sum2 + f(a + h * i)
                                            
    answer := (h / 6) * (f(a) + f(b) + 4*sum1 + 2*sum2)




Demonstrate your function by showing the results for:

   ƒ(x) = x3,       where   x   is     [0,1],       with           100 approximations.   The exact result is     0.25               (or 1/4)
   ƒ(x) = 1/x,     where   x   is   [1,100],     with        1,000 approximations.   The exact result is     4.605170+     (natural log of 100)
   ƒ(x) = x,         where   x   is   [0,5000],   with 5,000,000 approximations.   The exact result is   12,500,000
   ƒ(x) = x,         where   x   is   [0,6000],   with 6,000,000 approximations.   The exact result is   18,000,000


See also

   Active object for integrating a function of real time.
   Special:PrefixIndex/Numerical integration for other integration methods.

",Python,"from fractions import Fraction
 
def left_rect(f,x,h):
  return f(x)
 
def mid_rect(f,x,h):
  return f(x + h/2)
 
def right_rect(f,x,h):
  return f(x+h)
 
def trapezium(f,x,h):
  return (f(x) + f(x+h))/2.0
 
def simpson(f,x,h):
  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0
 
def cube(x):
  return x*x*x
 
def reciprocal(x):
  return 1/x
 
def identity(x):
  return x
 
def integrate( f, a, b, steps, meth):
   h = (b-a)/steps
   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))
   return ival  
 
# Tests
for a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               integrate( func, a, b, steps, rule)))
    a, b = Fraction.from_float(a), Fraction.from_float(b)
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps and fractions) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               float(integrate( func, a, b, steps, rule))))
 
# Extra tests (compute intensive)
for a, b, steps, func in ((0., 5000., 5000000, identity),
                          (0., 6000., 6000000, identity)):
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               integrate( func, a, b, steps, rule)))
    a, b = Fraction.from_float(a), Fraction.from_float(b)
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps and fractions) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               float(integrate( func, a, b, steps, rule))))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Parallel_calculations,Parallel calculations,"Many programming languages allow you to specify computations to be run in parallel.
While Concurrent computing is focused on concurrency,
the purpose of this task is to distribute time-consuming calculations
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one
with the largest minimal prime factor
(that is, the one that contains relatively large factors).
To speed up the search, the factorization should be done
in parallel using separate threads or processes,
to take advantage of multi-core CPUs.

Show how this can be formulated in your language.
Parallelize the factorization of those numbers,
then search the returned list of numbers and factors
for the largest minimal factor,
and return that number and its prime factors.

For the prime number decomposition
you may use the solution of the Prime decomposition task.
",Python,"from __future__ import print_function
from math import sqrt
from itertools import count, islice
 
def primes():
    """"""
    Generate an infinite sequence of prime numbers.
    """"""
    # Maps composites to primes witnessing their compositeness.
    # This is memory efficient, as the sieve is not ""run forward""
    # indefinitely, but only as long as required by the current
    # number being tested.
    #
    D = {}
 
    # The running integer that's checked for primeness
    q = 2
 
    while True:
        if q not in D:
            # q is a new prime.
            # Yield it and mark its first multiple that isn't
            # already marked in previous iterations
            #
            yield q
            D[q * q] = [q]
        else:
            # q is composite. D[q] is the list of primes that
            # divide it. Since we've reached q, we no longer
            # need it in the map, but we'll mark the next
            # multiples of its witnesses to prepare for larger
            # numbers
            #
            for p in D[q]:
                D.setdefault(p + q, []).append(p)
            del D[q]
        q += 1
 
def prime_factors(n):
    """"""
    Return prime factors of n.
    """"""
    return [p for p in islice(primes(), 0, int(sqrt(n))) if n % p == 0]
 
def largest_minimal_factor(numbers):
    """"""
    Return the largest minimal factor of the given numbers.
    """"""
    return max(prime_factors(min(numbers)))
 
if __name__ == '__main__':
    numbers = [12757923, 12878611, 12878893, 12757923, 12878611, 12878893]
    print('largest minimal factor:', largest_minimal_factor(numbers))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort,Sorting algorithms/Counting sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Counting sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Counting sort.   This is a way of sorting integers when the minimum and maximum value are known.



Pseudocode

function countingSort(array, min, max):
    count: array of (max - min + 1) elements
    initialize count with 0
    for each number in array do
        count[number - min] := count[number - min] + 1
    done
    z := 0
    for i from min to max do
        while ( count[i - min] > 0 ) do
            array[z] := i
            z := z+1
            count[i - min] := count[i - min] - 1
        done
    done

The min and max can be computed apart, or be known a priori.


Note:   we know that, given an array of integers,   its maximum and minimum values can be always found;   but if we imagine the worst case for an array that can hold up to 32 bit integers,   we see that in order to hold the counts,   an array of up to 232 elements may be needed.   I.E.:   we need to hold a count value up to 232-1,   which is a little over 4.2 Gbytes.   So the counting sort is more practical when the range is (very) limited,   and minimum and maximum values are known   a priori.     (However, as a counterexample,   the use of   sparse arrays   minimizes the impact of the memory usage,   as well as removing the need of having to know the minimum and maximum values   a priori.)



",Python,"import random
import sys
 
MAX = 30
 
class cSort:
    def sort(self, arr, len):
        mi, mx, z = self.findMinMax(arr, len)
        nlen = (mx - mi) + 1
        temp = [0] * nlen
        for i in range(len):
            temp[arr[i] - mi] += 1
        for i in range(mi, mx + 1):
            while temp[i - mi]:
                arr[z] = i
                z += 1
                temp[i - mi] -= 1
 
    def findMinMax(self, arr, len):
        mi = sys.maxint
        mx = 0
        for i in range(len):
            if arr[i] > mx:
                mx = arr[i]
            if arr[i] < mi:
                mi = arr[i]
        return mi, mx
 
if __name__ == ""__main__"":
    arr = [random.randint(-40, 140) for i in range(MAX)]
    print arr
    s = cSort()
    s.sort(arr, MAX)
    print arr",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bitwise_IO,Bitwise IO,"The aim of this task is to write functions (or create a class if your
language is Object Oriented and you prefer) for reading and writing sequences of
bits, most significant bit first. While the output of a asciiprint ""STRING"" is the ASCII byte sequence
""S"", ""T"", ""R"", ""I"", ""N"", ""G"", the output of a ""print"" of the bits sequence
0101011101010 (13 bits) must be 0101011101010; real I/O is performed always
quantized by byte (avoiding endianness issues and relying on underlying
buffering for performance), therefore you must obtain as output the bytes
0101 0111 0101 0000 (bold bits are padding bits), i.e. in hexadecimal 57 50.

As test, you can implement a rough (e.g. don't care about error handling or
other issues) compression/decompression program for ASCII sequences
of bytes, i.e. bytes for which the most significant bit is always unused, so that you can write
seven bits instead of eight (each 8 bytes of input, we write 7 bytes of output).

These bit oriented I/O functions can be used to implement compressors and
decompressors; e.g. Dynamic and Static Huffman encodings use variable length
bits sequences, while LZW (see LZW compression) use fixed or variable words
nine (or more) bits long.

 Limits in the maximum number of bits that can be written/read in a single read/write operation are allowed.
 Errors handling is not mandatory

",Python,"class BitWriter(object):
    def __init__(self, f):
        self.accumulator = 0
        self.bcount = 0
        self.out = f
 
    def __enter__(self):
        return self
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.flush()
 
    def __del__(self):
        try:
            self.flush()
        except ValueError:   # I/O operation on closed file.
            pass
 
    def _writebit(self, bit):
        if self.bcount == 8:
            self.flush()
        if bit > 0:
            self.accumulator |= 1 << 7-self.bcount
        self.bcount += 1
 
    def writebits(self, bits, n):
        while n > 0:
            self._writebit(bits & 1 << n-1)
            n -= 1
 
    def flush(self):
        self.out.write(bytearray([self.accumulator]))
        self.accumulator = 0
        self.bcount = 0
 
 
class BitReader(object):
    def __init__(self, f):
        self.input = f
        self.accumulator = 0
        self.bcount = 0
        self.read = 0
 
    def __enter__(self):
        return self
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
 
    def _readbit(self):
        if not self.bcount:
            a = self.input.read(1)
            if a:
                self.accumulator = ord(a)
            self.bcount = 8
            self.read = len(a)
        rv = (self.accumulator & (1 << self.bcount-1)) >> self.bcount-1
        self.bcount -= 1
        return rv
 
    def readbits(self, n):
        v = 0
        while n > 0:
            v = (v << 1) | self._readbit()
            n -= 1
        return v
 
if __name__ == '__main__':
    import os
    import sys
    # Determine this module's name from it's file name and import it.
    module_name = os.path.splitext(os.path.basename(__file__))[0]
    bitio = __import__(module_name)
 
    with open('bitio_test.dat', 'wb') as outfile:
        with bitio.BitWriter(outfile) as writer:
            chars = '12345abcde'
            for ch in chars:
                writer.writebits(ord(ch), 7)
 
    with open('bitio_test.dat', 'rb') as infile:
        with bitio.BitReader(infile) as reader:
            chars = []
            while True:
                x = reader.readbits(7)
                if not reader.read:  # End-of-file?
                    break
                chars.append(chr(x))
            print(''.join(chars))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import deque
stack = deque()
stack.append(value) # pushing
value = stack.pop()
not stack # is empty?",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Extensible_prime_generator,Extensible prime generator,"Task

Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.

The routine should demonstrably rely on either:

 Being based on an open-ended counter set to count without upper limit other than system or programming language limits. In this case, explain where this counter is in the code.
 Being based on a limit that is extended automatically. In this case, choose a small limit that ensures the limit will be passed when generating some of the values to be asked for below.
 If other methods of creating an extensible prime generator are used, the algorithm's means of extensibility/lack of limits should be stated.


The routine should be used to:

 Show the first twenty primes.
 Show the primes between 100 and 150.
 Show the number of primes between 7,700 and 8,000.
 Show the 10,000th prime.


Show output on this page.

Note: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).

Note 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).

Note 3:The task is written so it may be useful in solving the task   Emirp primes   as well as others (depending on its efficiency).





Reference

 Prime Numbers. Website with large count of primes.

",Python,"def isPrime(n):
    if n < 2: return False
    if n % 2 == 0: return n == 2
    if n % 3 == 0: return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0: return False
        d += 2
        if n % d == 0: return False
        d += 4
    return True
 
def generatePrimes():
    yield 2
    p = 3
    while p <= 2147483647:
        if isPrime(p): yield p
        p += 2
 
primes = generatePrimes()
print(""First 20 primes : "", list(next(primes) for _ in range(20)))
print(""Primes between 100 and 150 : "", list(p for p in primes if 100 <= p <= 150))
print(""Number of primes between 7700 and 8000 = "", len(list(p for p in primes if 7700 <= p <= 8000)))
print(""10,000th prime = "", next(primes for _ in range(10000)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Solve_the_no_connection_puzzle,Solve the no connection puzzle,"You are given a box with eight holes labelled   A-to-H,   connected by fifteen straight lines in the pattern as shown below:

             A   B
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         C───D───E───F
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             G   H

You are also given eight pegs numbered   1-to-8.



Objective

Place the eight pegs in the holes so that the (absolute) difference between any two numbers connected by any line is greater than one.



Example

In this attempt:

             4   7
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         8───1───6───2
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             3   5

Note that   7   and   6   are connected and have a difference of   1,   so it is   not   a solution.



Task
Produce and show here   one   solution to the puzzle.



Related tasks

   A* search algorithm
   Solve a Holy Knight's tour
   Knight's tour
   N-queens problem
   Solve a Hidato puzzle
   Solve a Holy Knight's tour
   Solve a Hopido puzzle
   Solve a Numbrix puzzle
   4-rings or 4-squares puzzle


See also
No Connection Puzzle (youtube).



",Python,"from __future__ import print_function
from itertools import permutations
from enum import Enum
 
A, B, C, D, E, F, G, H = Enum('Peg', 'A, B, C, D, E, F, G, H')
 
connections = ((A, C), (A, D), (A, E),
               (B, D), (B, E), (B, F),
               (G, C), (G, D), (G, E),
               (H, D), (H, E), (H, F),
               (C, D), (D, E), (E, F))
 
 
def ok(conn, perm):
    """"""Connected numbers ok?""""""
    this, that = (c.value - 1 for c in conn)
    return abs(perm[this] - perm[that]) != 1
 
 
def solve():
    return [perm for perm in permutations(range(1, 9))
            if all(ok(conn, perm) for conn in connections)]
 
 
if __name__ == '__main__':
    solutions = solve()
    print(""A, B, C, D, E, F, G, H ="", ', '.join(str(i) for i in solutions[0]))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Deal_cards_for_FreeCell,Deal cards for FreeCell,"Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. 

This version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)

As the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. 

These deals are numbered from 1 to 32000.
Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.

The algorithm uses this linear congruential generator from Microsoft C:

 



s
t
a
t

e

n
+
1


≡
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}\equiv 214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.
 Rosetta Code has another task, linear congruential generator, with code for this RNG in several languages.


The algorithm follows:

 Seed the RNG with the number of the deal.
 Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.
 Until the array is empty:
 Choose a random card at index ≡ next random number (mod array length).
 Swap this random card with the last card of the array.
 Remove this random card from the array. (Array length goes down by 1.)
 Deal this random card.
 Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.


 Order to deal cards

 Game #1

 Game #617


  1  2  3  4  5  6  7  8
 9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52

 JD 2D 9H JC 5D 7H 7C 5H
KD KC 9S 5S AD QC KH 3H
2S KS 9D QD JS AS AH 3C
4C 5C TS QH 4H AC 4D 7S
3S TD 4S TH 8H 2C JH 7D
6D 8S 8D QS 6C 3D 8C TC
6S 9C 2H 6H

 7D AD 5C 3S 5S 8C 2D AH
TD 7S QD AC 6D 8H AS KH
TH QC 3H 9D 6S 8D 3D TC
KD 5H 9S 3C 8S 7H 4D JS
4C QS 9C 9H 7C 6H 2C 2S
4S TS 2H 5D JC 6C JH QH
JD KS KC 4H

Deals can also be checked against FreeCell solutions to 1000000 games.
(Summon a video solution, and it displays the initial deal.)

Write a program to take a deal number and deal cards in the same order as this algorithm.
The program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.

Related tasks:

 Playing cards
 Card shuffles
 War Card_Game
 Poker hand_analyser
 Go Fish

",Python,"def randomGenerator(seed=1):
    max_int32 = (1 << 31) - 1
    seed = seed & max_int32
 
    while True:
        seed = (seed * 214013 + 2531011) & max_int32
        yield seed >> 16
 
def deal(seed):
    nc = 52
    cards = list(range(nc - 1, -1, -1))
    rnd = randomGenerator(seed)
    for i, r in zip(range(nc), rnd):
        j = (nc - 1) - r % (nc - i)
        cards[i], cards[j] = cards[j], cards[i]
    return cards
 
def show(cards):
    l = [""A23456789TJQK""[int(c/4)] + ""CDHS""[c%4] for c in cards]
    for i in range(0, len(cards), 8):
        print("" "".join(l[i : i+8]))
 
if __name__ == '__main__':
    from sys import argv
    seed = int(argv[1]) if len(argv) == 2 else 11982
    print(""Hand {}"".format(seed))
    deck = deal(seed)
    show(deck)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Penney%27s_game,Penney's game,"Penney's game is a game where two players bet on being the first to see a particular sequence of heads or tails in consecutive tosses of a fair coin.

It is common to agree on a sequence length of three then one player will openly choose a sequence, for example:

 Heads,  Tails,  Heads, or HTH for short.

The other player on seeing the first players choice will choose his sequence. The coin is tossed and the first player to see his sequence in the sequence of coin tosses wins.



Example

One player might choose the sequence HHT and the other THT.

Successive coin tosses of HTTHT gives the win to the second player as the last three coin tosses are his sequence.



Task
Create a program that tosses the coin, keeps score and plays Penney's game against a human opponent.

 Who chooses and shows their sequence of three should be chosen randomly.
 If going first, the computer should randomly choose its sequence of three.
 If going second, the computer should automatically play the optimum sequence.
 Successive coin tosses should be shown.


Show output of a game where the computer chooses first and a game where the user goes first here on this page.



See also
 The Penney Ante Part 1 (Video).
 The Penney Ante Part 2 (Video).

",Python,"from __future__ import print_function
import random
from time import sleep
 
first = random.choice([True, False])
 
you = ''
if first:
    me = ''.join(random.sample('HT'*3, 3))
    print('I choose first and will win on first seeing {} in the list of tosses'.format(me))
    while len(you) != 3 or any(ch not in 'HT' for ch in you) or you == me:
        you = input('What sequence of three Heads/Tails will you win with: ')
else:
    while len(you) != 3 or any(ch not in 'HT' for ch in you):
        you = input('After you: What sequence of three Heads/Tails will you win with: ')
    me = ('H' if you[1] == 'T' else 'T') + you[:2]
    print('I win on first seeing {} in the list of tosses'.format(me))
 
print('Rolling:\n  ', end='')
rolled = ''
while True:
    rolled += random.choice('HT')
    print(rolled[-1], end='')
    if rolled.endswith(you):
        print('\n  You win!')
        break
    if rolled.endswith(me):
        print('\n  I win!')
        break
    sleep(1)    # For dramatic effect",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"import os
 
print(os.getenv(""HOME""))
print()
for k, v in filter(lambda x: x[0].startswith('P'), os.environ.items()):
    print(f""{k}: {v}"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Execute_a_Markov_algorithm,Execute a Markov algorithm,"Execute a Markov algorithm

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Create an interpreter for a Markov Algorithm.

Rules have the syntax:

<ruleset> ::= ((<comment> | <rule>) <newline>+)*
<comment> ::= # {<any character>}
<rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement>
<whitespace> ::= (<tab> | <space>) [<whitespace>]

There is one rule per line.

If there is a   .   (period)   present before the   <replacement>,   then this is a terminating rule in which case the interpreter must halt execution.

A ruleset consists of a sequence of rules, with optional comments.


 Rulesets 

Use the following tests on entries:



Ruleset 1

# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

  I bought a B of As from T S. 
Should generate the output:

  I bought a bag of apples from my brother. 


Ruleset 2

A test of the terminating rule

# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
Sample text of:

 I bought a B of As from T S.
Should generate:

 I bought a bag of apples from T shop.


Ruleset 3

This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.

# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

 I bought a B of As W my Bgage from T S.
Should generate:

 I bought a bag of apples with my money from T shop.


Ruleset 4

This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.   It implements a general unary multiplication engine.   (Note that the input expression must be placed within underscores in this implementation.)

### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 

Sample text of:

  _1111*11111_ 
should generate the output:

  11111111111111111111 


Ruleset 5

A simple Turing machine,
implementing a three-state busy beaver.

The tape consists of 0s and 1s,   the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.
All parts of the initial tape the machine operates on have to be given in the input.

Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.

# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11

This ruleset should turn

  000000A000000 
into

  00011H1111000 

",Python,"import sys
import re
 
class Rule:
    def __init__(self, pattern, replacement, terminal):
        self.pattern = pattern
        self.replacement = replacement
        self.terminal = terminal
 
def is_whitespace(c):
    return c in "" \t""
 
def read_rules(rulefile):
    rules = []
    for line in rulefile:
        # remove comments
        pos = line.find('#')
        if pos!= -1:
            line = line[:pos]
 
        # ignore lines consisting only of whitespace
        if not line.strip():
            continue
 
        # find ""->"" surrounded by whitespace
        pos = line.find(""->"")
        while pos!= -1 and (pos == 0 or not is_whitespace(line[pos-1])):
            pos = line.find(""->"", pos+1)
 
        if pos == -1 or len(line) < pos+3 or not is_whitespace(line[pos+2]):
            sys.stderr.write(""invalid rule: %s\n"" % line)
            sys.exit(1)
 
        pattern = line[:pos-1]
        replacement = line[pos+3:]
 
        # remove additional separating whitespace
        pattern = pattern.rstrip()
        replacement = replacement.lstrip()
 
        # test for terminal rule
        terminal = replacement and replacement[0] == '.'
        if terminal:
            replacement = replacement[1:]
 
        rules.append(Rule(pattern, replacement, terminal))
 
    return rules
 
def markov(rules, input):
    output = input
    for rule in rules:
        pos = output.find(rule.pattern)
        if pos!= -1:
            output = output[:pos] + rule.replacement + output[pos+len(rule.pattern):]
            if rule.terminal:
                break
 
    return output
 
if __name__ == ""__main__"":
    if len(sys.argv)!= 3:
        sys.stderr.write(""usage:\n %s rulefile text\n"" % sys.argv[0])
        sys.exit(1)
 
    rulefile = open(sys.argv[1])
    rules = read_rules(rulefile)
 
    input = sys.argv[2]
    output = markov(rules, input)
 
    print output",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Speech_synthesis,Speech synthesis,"Render the text       This is an example of speech synthesis      as speech.



Related task

   using a speech engine to highlight words



",Python,"import win32com.client

voice = win32com.client.Dispatch(""SAPI.SpVoice"")
voice.Speak(""This is an example of speech synthesis."")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Successive_prime_differences,Successive prime differences,"The series of increasing prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

The task applies a filter to the series returning groups of successive primes, (s'primes), that differ from the next by a given value or values.

Example 1: Specifying that the difference between s'primes be 2 leads to the groups:

(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), ...

(Known as Twin primes or Prime pairs)

Example 2: Specifying more than one difference between s'primes leads to groups of size one greater than the number of differences. Differences of 2, 4 leads to the groups:

(5, 7, 11), (11, 13, 17), (17, 19, 23), (41, 43, 47), .... 

In the first group 7 is two more than 5 and 11 is four more than 7; as well as 5, 7, and 11 being successive primes.
Differences are checked in the order of the values given, (differences of 4, 2 would give different groups entirely).

Task

 In each case use a list of primes less than 1_000_000
 For the following Differences show the first and last group, as well as the number of groups found:
 Differences of 2.
 Differences of 1.
 Differences of 2, 2.
 Differences of 2, 4.
 Differences of 4, 2.
 Differences of 6, 4, 2.
 Show output here.

Note: Generation of a list of primes is a secondary aspect of the task. Use of a built in function, well known library, or importing/use of prime generators from other Rosetta Code tasks is encouraged.

references
https://pdfs.semanticscholar.org/78a1/7349819304863ae061df88dbcb26b4908f03.pdf
https://www.primepuzzles.net/puzzles/puzz_011.htm
https://matheplanet.de/matheplanet/nuke/html/viewtopic.php?topic=232720&start=0",Python,"# https://docs.sympy.org/latest/index.html
from sympy import Sieve
 
def nsuccprimes(count, mx):
    ""return tuple of <count> successive primes <= mx (generator)""
    sieve = Sieve()
    sieve.extend(mx)
    primes = sieve._list
    return zip(*(primes[n:] for n in range(count)))
 
def check_value_diffs(diffs, values):
    ""Differences between successive values given by successive items in diffs?""
    return all(v[1] - v[0] == d 
               for d, v in zip(diffs, zip(values, values[1:])))
 
def successive_primes(offsets=(2, ), primes_max=1_000_000):
    return (sp for sp in nsuccprimes(len(offsets) + 1, primes_max) 
            if check_value_diffs(offsets, sp))
 
if __name__ == '__main__':
    for offsets, mx in [((2,),      1_000_000), 
                        ((1,),      1_000_000),
                        ((2, 2),    1_000_000),
                        ((2, 4),    1_000_000),
                        ((4, 2),    1_000_000),
                        ((6, 4, 2), 1_000_000),
                       ]:
        print(f""## SETS OF {len(offsets)+1} SUCCESSIVE PRIMES <={mx:_} WITH ""
              f""SUCCESSIVE DIFFERENCES OF {str(list(offsets))[1:-1]}"")
        for count, last in enumerate(successive_primes(offsets, mx), 1):
            if count == 1:
                first = last
        print(""  First group:"", str(first)[1:-1])
        print(""   Last group:"", str(last)[1:-1])
        print(""        Count:"", count)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Long_year,Long year,"Most years have 52 weeks, some have 53, according to ISO8601.



Task

Write a function which determines if a given year is long (53 weeks) or not, and demonstrate it.



",Python,"'''Long Year ?'''
 
from datetime import date
 
 
# longYear :: Year Int -> Bool
def longYear(y):
    '''True if the ISO year y has 53 weeks.'''
    return 52 < date(y, 12, 28).isocalendar()[1]
 
 
# --------------------------TEST---------------------------
# main :: IO ()
def main():
    '''Longer (53 week) years in the range 2000-2100'''
    for year in [
            x for x in range(2000, 1 + 2100)
            if longYear(x)
    ]:
        print(year)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Best_shuffle,Best shuffle,"Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

original string, shuffled string, (score) 

The score gives the number of positions whose character value did not change.



Example

tree, eetr, (0)



Test cases

abracadabra
seesaw
elk
grrrrrr
up
a



Related tasks
   Anagrams/Deranged anagrams
   Permutations/Derangements



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import random
 
def best_shuffle(s1):
    s2 = list(s1)
    shuffle(s2)
    for i in range(len(s2)):
        if s2[i]!= s1[i]:
            continue
        for j in range(len(s2)):
            if s2[i]!= s2[j] and s2[i]!= s1[j] and s2[j]!= s1[i]:
                s2[i], s2[j] = s2[j], s2[i]
                break
    return s1 + "" "" + """".join(s2) + "" ("" + str(count(s1, s2)) + "")""
 
def shuffle(text):
    for i in range(len(text) - 1, 0, -1):
        r = random.randint(0, i)
        text[i], text[r] = text[r], text[i]
 
def count(s1, s2):
    count = 0
    for i in range(len(s2)):
        if s1[i] == s2[i]:
            count += 1
    return count
 
if __name__ == ""__main__"":
    words = [""abracadabra"", ""seesaw"", ""grrrrrr"", ""pop"", ""up"", ""a""]
    for w in words:
        print(best_shuffle(w))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Array_length,Array length,"Task

Determine the amount of elements in an array.



As an example use an array holding the strings 'apple' and 'orange'.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def main(args):
    print(len([""apple"", ""orange""]))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Terminal_control/Hiding_the_cursor,Terminal control/Hiding the cursor,"The task is to hide the cursor and show it again.



",Python,"print(""\x1b[?25l"") # hidden
print(""\x1b[?25h"") # shown",Human_written,Python_from_C
http://rosettacode.org/wiki/Search_a_list_of_records,Search a list of records,"Many programming languages provide convenient ways to look for a known value in a simple list of strings or numbers.

But what if the elements of the list are themselves compound records/objects/data-structures, and the search condition is more complex than a simple equality test?

Task[edit]
Write a function/method/etc. that can find the first element in a given list matching a given condition.

It should be as generic and reusable as possible.

(Of course if your programming language already provides such a feature, you can use that instead of recreating it.)

Then to demonstrate its functionality, create the data structure specified under #Data set, and perform on it the searches specified under #Test cases.

Data set
The data structure to be used contains the names and populations (in millions) of the 10 largest metropolitan areas in Africa, and looks as follows when represented in JSON:

[
  { ""name"": ""Lagos"",                ""population"": 21.0  },
  { ""name"": ""Cairo"",                ""population"": 15.2  },
  { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
  { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
  { ""name"": ""Mogadishu"",            ""population"":  5.85 },
  { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
  { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
  { ""name"": ""Alexandria"",           ""population"":  4.58 },
  { ""name"": ""Abidjan"",              ""population"":  4.4  },
  { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
However, you shouldn't parse it from JSON, but rather represent it natively in your programming language.

 The top-level data structure should be an ordered collection (i.e. a list, array, vector, or similar).
 Each element in this list should be an associative collection that maps from keys to values (i.e. a struct, object, hash map, dictionary, or similar).
 Each of them has two entries: One string value with key ""name"", and one numeric value with key ""population"".
 You may rely on the list being sorted by population count, as long as you explain this to readers.


If any of that is impossible or unreasonable in your programming language, then feel free to deviate, as long as you explain your reasons in a comment above your solution.

Test cases


 Search

 Expected result


 Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""

 6


 Find the name of the first city in this list whose population is less than 5 million

 Khartoum-Omdurman


 Find the population of the first city in this list whose name starts with the letter ""A""

 4.58

Guidance
If your programming language supports higher-order programming, then the most elegant way to implement the requested functionality in a generic and reusable way, might be to write a function (maybe called ""find_index"" or similar), that takes two arguments:

 The list to search through.
 A function/lambda/closure (the so-called ""predicate""), which will be applied in turn to each element in the list, and whose boolean return value defines whether that element matches the search requirement.
If this is not the approach which would be most natural or idiomatic in your language, explain why, and show what is.

Related tasks
 Search a list
",Python,"from typing import List
 
class city:
    def __init__(self, name, population):
        self.name = name
        self.population = population
 
def main():
    cities = [
        city(""Lagos"", 21),
        city(""Cairo"", 15.2),
        city(""Kinshasa-Brazzaville"", 11.3),
        city(""Greater Johannesburg"", 7.55),
        city(""Mogadishu"", 5.85),
        city(""Khartoum-Omdurman"", 4.98),
        city(""Dar Es Salaam"", 4.7),
        city(""Alexandria"", 4.58),
        city(""Abidjan"", 4.4),
        city(""Casablanca"", 3.98),
    ]
 
    i1 = next((i for i, c in enumerate(cities) if c.name == ""Dar Es Salaam""), None)
    if i1 is not None:
        print(i1)
 
    i2 = next((c for c in cities if c.population < 5.0), None)
    if i2 is not None:
        print(i2.name)
 
    i3 = next((c for c in cities if c.name.length() > 0 and c.name[0] == 'A'), None)
    if i3 is not None:
        print(i3.population)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Runtime_evaluation/In_an_environment,Runtime evaluation/In an environment,"x
x
x


Do so in a way which:

 does not involve string manipulation of the input source code
 is plausibly extensible to a runtime-chosen set of bindings rather than just x
 does not make x a global variable


or note that these are impossible.



See also

 For more general examples and language-specific details, see Eval.
 Dynamic variable names is a similar task.

",Python,">>> def eval_with_x(code, a, b):
	return eval(code, {'x':b}) - eval(code, {'x':a})
 
>>> eval_with_x('2 ** x', 3, 5)
24",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Multiple_distinct_objects,Multiple distinct objects,"Create a sequence (array, list, whatever) consisting of n distinct, initialized items of the same type. n should be determined at runtime.

By distinct we mean that if they are mutable, changes to one do not affect all others; if there is an appropriate equality operator they are considered unequal; etc. The code need not specify a particular kind of distinction, but do not use e.g. a numeric-range generator which does not generalize.

By initialized we mean that each item must be in a well-defined state appropriate for its type, rather than e.g. arbitrary previous memory contents in an array allocation. Do not show only an initialization technique which initializes only to ""zero"" values (e.g. calloc() or int a[n] = {}; in C), unless user-defined types can provide definitions of ""zero"" for that type.

This task was inspired by the common error of intending to do this, but instead creating a sequence of n references to the same mutable object; it might be informative to show the way to do that as well, both as a negative example and as how to do it when that's all that's actually necessary.

This task is most relevant to languages operating in the pass-references-by-value style (most object-oriented, garbage-collected, and/or 'dynamic' languages).

See also: Closures/Value capture
",Python,[Foo()] * n # here Foo() can be any expression that returns a new object,Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail,Strip whitespace from a string/Top and tail,"Task

Demonstrate how to strip leading and trailing whitespace from a string.

The solution should demonstrate how to achieve the following three results:

 String with leading whitespace removed
 String with trailing whitespace removed
 String with both leading and trailing whitespace removed


For the purposes of this task whitespace includes non printable characters such as the space character, the tab character, and other such characters that have no corresponding graphical representation.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
def rtrim(s):
  return re.sub(r'\s+$', '', s)
 
def ltrim(s):
  return re.sub(r'^\s+', '', s)
 
def trim(s):
  return re.sub(r'^\s+|\s+$', '', s)
 
a = ""     this is a string      ""
 
b = rtrim(a)
c = ltrim(a)
d = trim(a)
 
print ""'%s'\n'%s'\n'%s'"" % (b, c, d)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Comments,Comments,"Task

Show all ways to include text in a language source file
that's completely ignored by the compiler or interpreter.



Related tasks

   Documentation
   Here_document


See also

   Wikipedia
   xkcd (Humor: hand gesture denoting // for ""commenting out"" people.)

",Python,"# This is a comment
foo = 5 # You can also append comments to statements",Human_written,Python_from_C
http://rosettacode.org/wiki/Elementary_cellular_automaton/Infinite_length,Elementary cellular automaton/Infinite length,"The purpose of this task is to create a version of an Elementary cellular automaton whose number of cells is only limited by the memory size of the computer.

To be precise, consider the state of the automaton to be made of an infinite number of cells, but with a bounded support. In other words, to describe the state of the automaton, you need a finite number of adjacent cells, along with their individual state, and you then consider that the individual state of each of all other cells is the negation of the closest individual cell among the previously defined finite number of cells.

Examples:

1        ->   ..., 0, 0,      1,      0, 0, ...
0, 1     ->   ..., 1, 1,   0, 1,      0, 0, ...
1, 0, 1  ->   ..., 0, 0,   1, 0, 1,   0, 0, ...

More complex methods can be imagined, provided it is possible to somehow encode the infinite sections. But for this task we will stick to this simple version.
",Python,"def _notcell(c):
    return '0' if c == '1' else '1'
 
def eca_infinite(cells, rule):
    lencells = len(cells)
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    c = cells
    while True:
        yield c
        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    # Extend and pad the ends
 
        c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))
        #yield c[1:-1]
 
if __name__ == '__main__':
    lines = 25
    for rule in (90, 30):
        print('\nRule: %i' % rule)
        for i, c in zip(range(lines), eca_infinite('1', rule)):
            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '#')))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Permutation_test,Permutation test,"Permutation test

You are encouraged to solve this task according to the task description, using any language you may know.
A new medical treatment was tested on a population of 



n
+
m


{\displaystyle n+m}


volunteers, with each volunteer randomly assigned either to a group of




n


{\displaystyle n}

 treatment subjects, or to a group of 



m


{\displaystyle m}

 control subjects.

Members of the treatment group were given the treatment,
and members of the control group were given a placebo.
The effect of the treatment or placebo on each volunteer
was measured and reported in this table.


 Table of experimental results


 Treatment group 
 Control group


 85 
 68


 88 
 41


 75 
 10


 66 
 49


 25 
 16


 29 
 65


 83 
 32


 39 
 92


 97 
 28


 
 98

Write a program that performs a
permutation test to judge
whether the treatment had a significantly stronger effect than the
placebo.

 Do this by considering every possible alternative assignment from the same pool of volunteers to a treatment group of size 



n


{\displaystyle n}

 and a control group of size 



m


{\displaystyle m}

 (i.e., the same group sizes used in the actual experiment but with the group members chosen differently), while assuming that each volunteer's effect remains constant regardless.
 Note that the number of alternatives will be the binomial coefficient 







(



n
+
m

n


)






{\displaystyle {\tbinom {n+m}{n}}}

.
 Compute the mean effect for each group and the difference in means between the groups in every case by subtracting the mean of the control group from the mean of the treatment group.
 Report the percentage of alternative groupings for which the difference in means is less or equal to the actual experimentally observed difference in means, and the percentage for which it is greater.
 Note that they should sum to 100%.


Extremely dissimilar values are evidence of an effect not entirely due
to chance, but your program need not draw any conclusions.

You may assume the experimental data are known at compile time if
that's easier than loading them at run time. Test your solution on the
data given above.



",Python,"data = [
    85, 88, 75, 66, 25, 29, 83, 39, 97,
    68, 41, 10, 49, 16, 65, 32, 92, 28, 98
]

def pick(at, remain, accu, treat):
    if remain == 0:
        return 1 if accu > treat else 0
    return pick(at - 1, remain - 1, accu + data[at - 1], treat) + \
        (0 if at > remain else pick(at - 1, remain, accu, treat))

def main():
    treat = 0
    total = 1.0
    for i in range(0, 9):
        treat += data[i]
    for i in range(19, 10, -1):
        total *= i
    for i in range(9, 0, -1):
        total /= i
    gt = pick(19, 9, 0, treat)
    le = int(total - gt)
    print(""<= : %f%%  %d"" % (100.0 * le / total, le))
    print("" > : %f%%  %d"" % (100.0 * gt / total, gt))

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def sort(arr):
	sorted = arr[:]
	sorted.sort()
	return sorted",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Text_processing/2,Text processing/2,"The following task concerns data that came from a pollution monitoring station with twenty-four instruments monitoring twenty-four aspects of pollution in the air. Periodically a record is added to the file, each record being a line of 49 fields separated by white-space, which can be one or more space or tab characters.

The fields (from the left) are:

 DATESTAMP [ VALUEn FLAGn ] * 24

i.e. a datestamp followed by twenty-four repetitions of a floating-point instrument value and that instrument's associated integer flag. Flag values are >= 1 if the instrument is working and < 1 if there is some problem with it, in which case that instrument's value should be ignored.

A sample from the full data file readings.txt, which is also used in the Text processing/1 task, follows:

Data is no longer available at that link. Zipped mirror available here

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Task

 Confirm the general field format of the file.
 Identify any DATESTAMPs that are duplicated.
 Report the number of records that have good readings for all instruments.

",Python,"import re
import zipfile
import StringIO
 
def munge2(readings):
 
   datePat = re.compile(r'\d{4}-\d{2}-\d{2}')
   valuPat = re.compile(r'[-+]?\d+\.\d+')
   statPat = re.compile(r'-?\d+')
   allOk, totalLines = 0, 0
   datestamps = set([])
   for line in readings:
      totalLines += 1
      fields = line.split('\t')
      date = fields[0]
      pairs = [(fields[i],fields[i+1]) for i in range(1,len(fields),2)]
 
      lineFormatOk = datePat.match(date) and \
         all( valuPat.match(p[0]) for p in pairs ) and \
         all( statPat.match(p[1]) for p in pairs )
      if not lineFormatOk:
         print 'Bad formatting', line
         continue
 
      if len(pairs)!=24 or any( int(p[1]) < 1 for p in pairs ):
         print 'Missing values', line
         continue
 
      if date in datestamps:
         print 'Duplicate datestamp', line
         continue
      datestamps.add(date)
      allOk += 1
 
   print 'Lines with all readings: ', allOk
   print 'Total records: ', totalLines
 
#zfs = zipfile.ZipFile('readings.zip','r')
#readings = StringIO.StringIO(zfs.read('readings.txt'))
readings = open('readings.txt','r')
munge2(readings)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",Python,">>> def strcat(sequence):
    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1]
 
>>> for seq in ([], [""ABC""], [""ABC"", ""DEF""], [""ABC"", ""DEF"", ""G"", ""H""]):
    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))
 
 
Input: []                       -> Output: '{}'
Input: ['ABC']                  -> Output: '{ABC}'
Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'
Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"from itertools import product, combinations, izip
 
scoring = [0, 1, 3]
histo = [[0] * 10 for _ in xrange(4)]
 
for results in product(range(3), repeat=6):
    s = [0] * 4
    for r, g in izip(results, combinations(range(4), 2)):
        s[g[0]] += scoring[r]
        s[g[1]] += scoring[2 - r]
 
    for h, v in izip(histo, sorted(s)):
        h[v] += 1
 
for x in reversed(histo):
    print x",Human_written,Python_from_C++
http://rosettacode.org/wiki/Compare_a_list_of_strings,Compare a list of strings,"Task

Given a   list   of arbitrarily many strings, show how to:

   test if they are all lexically equal
   test if every string is lexically less than the one after it (i.e. whether the list is in strict ascending order)


Each of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.

If the input list has less than two elements, the tests should always return true.

There is no need to provide a complete program and output.

Assume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.

Try to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.

If you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Raku for a solution that gets away with simply using a built-in language feature. 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import java.util.Arrays;

public class CompareListOfStrings {

    public static void main(String[] args) {
        String[][] arr = {{""AA"", ""AA"", ""AA"", ""AA""}, {""AA"", ""ACB"", ""BB"", ""CC""}};
        for (String[] a : arr) {
            System.out.println(Arrays.toString(a));
            System.out.println(Arrays.stream(a).distinct().count() < 2);
            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));
        }
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Check_input_device_is_a_terminal,Check input device is a terminal,"Task

Demonstrate how to check whether the input device is a terminal or not.



Related task

   Check output device is a terminal

",Python,"from sys import stdin
if stdin.isatty():
    print(""Input comes from tty."")
else:
    print(""Input doesn't come from tty."")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/OLE_automation,OLE automation,"OLE Automation   is an inter-process communication mechanism based on   Component Object Model   (COM) on Microsoft Windows.



Task

Provide an automation server implementing objects that can be accessed by a client running in a separate process.

The client gets a proxy-object that can call methods on the object.

The communication should be able to handle conversions of variants to and from the native value types.



",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
import win32com.client
from win32com.server.util import wrap, unwrap
from win32com.server.dispatcher import DefaultDebugDispatcher
from ctypes import *
import commands
import pythoncom
import winerror
from win32com.server.exception import Exception
 
clsid = ""{55C2F76F-5136-4614-A397-12214CC011E5}""
iid = pythoncom.MakeIID(clsid)
appid = ""python.server""
 
class VeryPermissive:
    def __init__(self):
        self.data = []
        self.handle = 0
        self.dobjects = {}        
    def __del__(self):
        pythoncom.RevokeActiveObject(self.handle)
    def _dynamic_(self, name, lcid, wFlags, args):
        if wFlags & pythoncom.DISPATCH_METHOD:
            return getattr(self,name)(*args)
        if wFlags & pythoncom.DISPATCH_PROPERTYGET:
            try:
                # to avoid problems with byref param handling, tuple results are converted to lists.
                ret = self.__dict__[name]
                if type(ret)==type(()):
                    ret = list(ret)
                return ret
            except KeyError: # Probably a method request.
                raise Exception(scode=winerror.DISP_E_MEMBERNOTFOUND)
        if wFlags & (pythoncom.DISPATCH_PROPERTYPUT | pythoncom.DISPATCH_PROPERTYPUTREF):
            setattr(self, name, args[0])
            return
        raise Exception(scode=winerror.E_INVALIDARG, desc=""invalid wFlags"")
    def write(self, x):
        print x
        return 0
import win32com.server.util, win32com.server.policy
child = VeryPermissive()
ob = win32com.server.util.wrap(child, usePolicy=win32com.server.policy.DynamicPolicy)
try:
    handle = pythoncom.RegisterActiveObject(ob, iid, 0)
except pythoncom.com_error, details:
    print ""Warning - could not register the object in the ROT:"", details
    handle = None    
child.handle = handle  
 
ahk = win32com.client.Dispatch(""ahkdemo.ahk"")
ahk.aRegisterIDs(clsid, appid)
# autohotkey.exe ahkside.ahk
# python /c/Python26/Scripts/ipython.py -wthread -i pythonside.py
# must use -wthread otherwise calling com client hangs",Human_written,Python_from_Go
http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",Python,"from __future__ import print_function
from math import sqrt
 
def gcd(m, n):
    while n:
        m, n = n, m % n
    return m
 
def main():
    max_p = 100
    pytha = 0
    prim = 0
    for a in range(1, max_p // 3 + 1):
        print(""a = %d\r"" % a, end="""")
        for b in range(a + 1, max_p // 2):
            for c in range(b + 1, max_p // 2):
                if a + b + c > max_p:
                    break
                if a + b < c:
                    break
                if a * a + b * b == c * c:
                    pytha += 1
                    if gcd(a, b) == 1:
                        prim += 1
    print(""Up to %d, there are %d triples, of which %d are primitive"" % (max_p, pytha, prim))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Kronecker_product_based_fractals,Kronecker product based fractals,"This task is based on    Kronecker product   of two matrices.

If your language has no a built-in function for such product then you need to implement it first.

The essence of fractals is self-replication (at least, self-similar replications).

So, using   n   times self-product of the matrix   (filled with 0/1)   we will have a fractal of the   nth   order.

Actually, ""self-product"" is a Kronecker power of the matrix.

In other words: for a matrix   M   and a power   n   create a function like   matkronpow(M, n),

which returns   MxMxMx...   (n   times product).

A formal recurrent algorithm of creating Kronecker power of a matrix is the following:



Algorithm


Let M is an initial matrix, and Rn is a resultant block matrix of the Kronecker power, where n is the power (a.k.a. order).
Self-product of M, i.e., M x M producing R2 (resultant matrix with order/power 2).
To receive the next order/power matrix use this recurrent formula: Rn = R(n-1) x M.
Plot this Rn matrix to produce the nth order fractal.



Even just looking at the resultant matrix you can see what will be plotted.

There are virtually infinitely many fractals of this type. You are limited only by your creativity and
the power of your computer.



Task

Using  Kronecker product implement and show two popular and well-known fractals, i.e.:

  Vicsek fractal;
  Sierpinski carpet fractal.


The last one ( Sierpinski carpet) is already here on RC, but built using different approaches.




Test cases

These 2 fractals (each order/power 4 at least) should be built using the following 2 simple matrices:

          │ 0 1 0 │    and    │ 1 1 1 │
          │ 1 1 1 │           │ 1 0 1 │
          │ 0 1 0 │           │ 1 1 1 │

Note

 Output could be a graphical or ASCII-art representation, but if an order is set > 4 then printing is not suitable.
 The orientation and distortion of the fractal could be your language/tool specific.
 It would be nice to see one additional fractal of your choice, e.g., based on using a single (double) letter(s) of an alphabet, any sign(s) or already made a resultant matrix of the Kronecker product.


See implementations and results below in JavaScript, PARI/GP and R languages. They have additional samples of ""H"", ""+"" and checkerboard fractals.



",Python,"import os
from PIL import Image
 
 
def imgsave(path, arr):
    w, h = len(arr), len(arr[0])
    img = Image.new('1', (w, h))
    for x in range(w):
        for y in range(h):
            img.putpixel((x, y), arr[x][y])
    img.save(path)
 
 
def get_shape(mat):
    return len(mat), len(mat[0])
 
 
def kron(matrix1, matrix2):
    """"""
    Calculate the kronecker product of two matrices
    """"""
    final_list = []
 
    count = len(matrix2)
 
    for elem1 in matrix1:
        for i in range(count):
            sub_list = []
            for num1 in elem1:
                for num2 in matrix2[i]:
                    sub_list.append(num1 * num2)
            final_list.append(sub_list)
 
    return final_list
 
 
def kronpow(mat):
    """"""
    Generate an arbitrary number of kronecker powers
    """"""
    matrix = mat
    while True:
        yield matrix
        matrix = kron(mat, matrix)
 
 
def fractal(name, mat, order=6):
    """"""
    Save fractal as jpg to 'fractals/name'
    """"""
    path = os.path.join('fractals', name)
    os.makedirs(path, exist_ok=True)
 
    fgen = kronpow(mat)
    print(name)
    for i in range(order):
        p = os.path.join(path, f'{i}.jpg')
        print('Calculating n =', i, end='\t', flush=True)
 
        mat = next(fgen)
        imgsave(p, mat)
 
        x, y = get_shape(mat)
        print('Saved as', x, 'x', y, 'image', p)
 
 
test1 = [
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
]
 
test2 = [
    [1, 1, 1],
    [1, 0, 1],
    [1, 1, 1]
]
 
test3 = [
    [1, 0, 1],
    [0, 1, 0],
    [1, 0, 1]
]
 
fractal('test1', test1)
fractal('test2', test2)
fractal('test3', test3)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks,Rosetta Code/Find unimplemented tasks,"Task

Given the name of a language on Rosetta Code, find all tasks which are not implemented in that language.



Note: Implementations should allow for fetching more data than can be returned in one request to Rosetta Code.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",Python,"""""""
Given the name of a language on Rosetta Code,
finds all tasks which are not implemented in that language.
""""""
from operator import attrgetter
from typing import Iterator
 
import mwclient
 
URL = 'www.rosettacode.org'
API_PATH = '/mw/'
 
 
def unimplemented_tasks(language: str,
                        *,
                        url: str,
                        api_path: str) -> Iterator[str]:
    """"""Yields all unimplemented tasks for a specified language""""""
    site = mwclient.Site(url, path=api_path)
    all_tasks = site.categories['Programming Tasks']
    language_tasks = site.categories[language]
    name = attrgetter('name')
    all_tasks_names = map(name, all_tasks)
    language_tasks_names = set(map(name, language_tasks))
    for task in all_tasks_names:
        if task not in language_tasks_names:
            yield task
 
 
if __name__ == '__main__':
    tasks = unimplemented_tasks('Python', url=URL, api_path=API_PATH)
    print(*tasks, sep='\n')",Human_written,Python_from_JavaScript
"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def shortest_abbreviation_length(line, list_size):
    words = line.split()
    word_count = len(words)
    # Can't give true answer with unexpected number of entries
    if word_count != list_size:
        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')
 
    # Find the small slice length that gives list_size unique values
    abbreviation_length = 1
    abbreviations = set()
    while(True):
        abbreviations = {word[:abbreviation_length] for word in words}
        if len(abbreviations) == list_size:
            return abbreviation_length
        abbreviation_length += 1
        abbreviations.clear()
 
def automatic_abbreviations(filename, words_per_line):
    with open(filename) as file:
        for line in file:
            line = line.rstrip()
            if len(line) > 0:
                length = shortest_abbreviation_length(line, words_per_line)
                print(f'{length:2} {line}')
            else:
                print()
 
automatic_abbreviations('daysOfWeek.txt', 7)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Monads/Maybe_monad,Monads/Maybe monad,"Demonstrate in your programming language the following:

Construct a Maybe Monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that Monad (or just use what the language already has implemented)
Make two functions, each which take a number and return a monadic number, e.g. Int -> Maybe Int and Int -> Maybe String
Compose the two functions with bind


A Monad is a single type which encapsulates several other types, eliminating boilerplate code. In practice it acts like a dynamically typed computational sequence, though in many cases the type issues can be resolved at compile time.

A Maybe Monad is a monad which specifically encapsulates the type of an undefined value.
",Python,"""""""A Maybe Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
 
from typing import Any
from typing import Callable
from typing import Generic
from typing import Optional
from typing import TypeVar
from typing import Union
 
 
T = TypeVar(""T"")
 
 
class Maybe(Generic[T]):
    def __init__(self, value: Union[Optional[T], Maybe[T]] = None):
        if isinstance(value, Maybe):
            self.value: Optional[T] = value.value
        else:
            self.value = value
 
    def __rshift__(self, func: Callable[[Optional[T]], Maybe[Any]]):
        return self.bind(func)
 
    def bind(self, func: Callable[[Optional[T]], Maybe[Any]]) -> Maybe[Any]:
        return func(self.value)
 
    def __str__(self):
        return f""{self.__class__.__name__}({self.value!r})""
 
 
def plus_one(value: Optional[int]) -> Maybe[int]:
    if value is not None:
        return Maybe[int](value + 1)
    return Maybe[int](None)
 
 
def currency(value: Optional[int]) -> Maybe[str]:
    if value is not None:
        return Maybe[str](f""${value}.00"")
    return Maybe[str](None)
 
 
if __name__ == ""__main__"":
    test_cases = [1, 99, None, 4]
 
    for case in test_cases:
        m_int = Maybe[int](case)
        result = m_int >> plus_one >> currency
        # or..
        # result = m_int.bind(plus_one).bind(currency)
        print(f""{str(case):<4} -> {result}"")",Human_written,Python_from_C
http://rosettacode.org/wiki/Dragon_curve,Dragon curve,"

Create and display a dragon curve fractal.

(You may either display the curve directly or write it to an image file.)



Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

 Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle. And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
 The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
 The curl direction right or left can be a parameter instead of two separate routines.
 Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
 This can be seen in the SVG example. This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
 Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
 Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side. If the segment is an even position then on the left. The process is then repeated on the new doubled list of segments. This constructs a full set of line segments before any drawing.
 The effect of the splitting is a kind of bottom-up version of the recursions. See the Asymptote example for code doing this.
 Iteratively the curve always turns 90-degrees left or right at each point. The direction of the turn is given by the bit above the lowest 1-bit of n. Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
 The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
 If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead. This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
 Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
 If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
 Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
 This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
 Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate. This is done in the gnuplot code. This might suit things similar to Gnuplot which want to calculate each point independently.
 Predicate test for whether a given X,Y point or segment is on the curve can be done. This might suit line-by-line output rather than building an entire image before printing. See M4 for an example of this.
 A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient. Why it works is slightly subtle but the calculation is not difficult. (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1. Check vertex by whether the segment either East or West is on the curve.)
 The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points. The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
 As a Lindenmayer system of expansions. The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above. Read more at for instance Joel Castellanos' L-system page.

Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.

The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 


",Python,"import math
from tkinter import *
 
class DragonCurve(Frame):
 
    def __init__(self, master, iter):
        Frame.__init__(self, master)
        self.master = master
        self.iter = iter
        self.turns = self.getSequence(iter)
        self.startingAngle = -iter * (math.pi / 4)
        self.side = 400 / math.pow(2, iter / 2.0)
        self.pack(fill=BOTH, expand=1)
        self.canvas = Canvas(self)
        self.canvas.pack(fill=BOTH, expand=1)
        self.canvas.create_line(230, 350, 230 + math.cos(self.startingAngle) * self.side, 350 + math.sin(self.startingAngle) * self.side)
        self.draw(230, 350, self.startingAngle)
 
    def getSequence(self, iter):
        turnSequence = []
        for i in range(iter):
            copy = turnSequence[:]
            copy.reverse()
            turnSequence.append(1)
            for turn in copy:
                turnSequence.append(-turn)
        return turnSequence
 
    def draw(self, x1, y1, angle):
        for turn in self.turns:
            angle += turn * (math.pi / 2)
            x2 = x1 + math.cos(angle) * self.side
            y2 = y1 + math.sin(angle) * self.side
            self.canvas.create_line(x1, y1, x2, y2)
            x1 = x2
            y1 = y2
 
root = Tk()
root.geometry(""800x600+300+300"")
app = DragonCurve(root, 14)
root.mainloop()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Rep-string,Rep-string,"Given a series of ones and zeroes in a string, define a repeated string or rep-string as a string which is created by repeating a substring of the first N characters of the string truncated on the right to the length of the input string, and in which the substring appears repeated at least twice in the original.

For example, the string 10011001100 is a rep-string as the leftmost four characters of 1001 are repeated three times and truncated on the right to give the original string.

Note that the requirement for having the repeat occur two or more times means that the repeating unit is never longer than half the length of the input string.



Task

 Write a function/subroutine/method/... that takes a string and returns an indication of if it is a rep-string and the repeated string.   (Either the string that is repeated, or the number of repeated characters would suffice). 
 There may be multiple sub-strings that make a string a rep-string - in that case an indication of all, or the longest, or the shortest would suffice.
 Use the function to indicate the repeating substring if any, in the following:

1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1


 Show your output on this page.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_repeated(text):
    'check if the first part of the string is repeated throughout the string'
    for x in range(len(text)//2, 0, -1):
        if text.startswith(text[x:]): return x
    return 0
 
matchstr = """"""\
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
""""""
for line in matchstr.split():
    ln = is_repeated(line)
    print('%r has a repetition length of %i i.e. %s' 
           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))",Human_written,Python_from_C++
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"q)3*2+1
9
q)(3*2)+1    / Brackets give the usual order of precedence
7
q)x:5
q)(x+5; x:20; x-5)
25 20 0",Human_written,Python_from_Java
http://rosettacode.org/wiki/Best_shuffle,Best shuffle,"Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

original string, shuffled string, (score) 

The score gives the number of positions whose character value did not change.



Example

tree, eetr, (0)



Test cases

abracadabra
seesaw
elk
grrrrrr
up
a



Related tasks
   Anagrams/Deranged anagrams
   Permutations/Derangements



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import random
 
def count(w1,wnew):
    return sum(c1==c2 for c1,c2 in zip(w1, wnew))
 
def best_shuffle(w):
    wnew = list(w)
    n = len(w)
    rangelists = (list(range(n)), list(range(n)))
    for r in rangelists:
        random.shuffle(r)
    rangei, rangej = rangelists
    for i in rangei:
        for j in rangej:
            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:
                wnew[j], wnew[i] = wnew[i], wnew[j]
                break
    wnew = ''.join(wnew)
    return wnew, count(w, wnew)
 
 
if __name__ == '__main__':
    test_words = ('tree abracadabra seesaw elk grrrrrr up a ' 
                  + 'antidisestablishmentarianism hounddogs').split()
    test_words += ['aardvarks are ant eaters', 'immediately', 'abba']
    for w in test_words:
        wnew, c = best_shuffle(w)
        print(""%29s, %-29s ,(%i)"" % (w, wnew, c))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Comments,Comments,"Task

Show all ways to include text in a language source file
that's completely ignored by the compiler or interpreter.



Related tasks

   Documentation
   Here_document


See also

   Wikipedia
   xkcd (Humor: hand gesture denoting // for ""commenting out"" people.)

",Python,"# A single line comment
 
""""""
    This is a multi-line (aka block) comment
 
 *  containing nested multi-line comment
    (nesting supported since 0.9-pre https://github.com/mozilla/rust/issues/9468)
""""""
 
# Outer single line Rustdoc comments apply to the next item.
 
""""""
    Outer multi-line Rustdoc comments.
 
 *  Leading asterisk (*) in multi-line Rustdoc comments
 *  is not considered to be part of the comment text,
 *  blanks and tabs preceding the initial asterisk (*) are also stripped.
""""""
 
def example():
 
    # Inner single line Rustdoc comments apply to their enclosing item.
 
    """"""
        Inner multi-line Rustdoc comments.
        See also https://github.com/mozilla/rust/wiki/Doc-using-rustdoc
    """"""
 
example.__doc__ = """"""Unsugared outer Rustdoc comments.
        (outer attributes are not terminated by a semi-colon)""""""
 
def example():
    example.__doc__ = """"""Unsugared inner Rustdoc comments.
            (inner attributes are terminated by a semi-colon)
            See also https://github.com/mozilla/rust/blob/master/doc/rust.md#attributes""""""",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sparkline_in_unicode,Sparkline in unicode,"A sparkline is a graph of successive values laid out horizontally
where the height of the line is proportional to the values in succession.



Task

Use the following series of Unicode characters to create a program
that takes a series of numbers separated by one or more whitespace or comma characters
and generates a sparkline-type bar graph of the values on a single line of output.

The eight characters: '▁▂▃▄▅▆▇█'

(Unicode values U+2581 through U+2588).

Use your program to show sparklines for the following input,
here on this page:

 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1
 1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 
(note the mix of separators in this second case)!
Notes
 
 A space is not part of the generated sparkline.
 The sparkline may be accompanied by simple statistics of the data such as its range.
 A suggestion emerging in later discussion (see Discussion page) is that the bounds between bins should ideally be set to yield the following results for two particular edge cases:
 ""0, 1, 19, 20"" -> ▁▁██
 (Aiming to use just two spark levels)
 ""0, 999, 4000, 4999, 7000, 7999"" -> ▁▁▅▅██
 (Aiming to use just three spark levels)
 It may be helpful to include these cases in output tests.
 You may find that the unicode sparklines on this page are rendered less noisily by Google Chrome than by Firefox or Safari.

",Python,"# -*- coding: utf-8 -*-
 
# Unicode: 9601, 9602, 9603, 9604, 9605, 9606, 9607, 9608
bar = '▁▂▃▄▅▆▇█'
barcount = len(bar)
 
def sparkline(numbers):
    mn, mx = min(numbers), max(numbers)
    extent = mx - mn
    sparkline = ''.join(bar[min([barcount - 1,
                                 int((n - mn) / extent * barcount)])]
                        for n in numbers)
    return mn, mx, sparkline
 
if __name__ == '__main__':
    import re
 
    for line in (""0 0 1 1; 0 1 19 20; 0 999 4000 4999 7000 7999;""
                 ""1 2 3 4 5 6 7 8 7 6 5 4 3 2 1;""
                 ""1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 "").split(';'):
        print(""\nNumbers:"", line)
        numbers = [float(n) for n in re.split(r'[\s,]+', line.strip())]
        mn, mx, sp = sparkline(numbers)
        print('  min: %5f; max: %5f' % (mn, mx))
        print(""  "" + sp)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",Python,"class Thingable(object):
    def thing(self):
        raise NotImplementedError()
 
class Delegator(object):
    def __init__(self, thing):
        self.thing = thing
 
class Delegate(Thingable):
    def thing(self):
        return ""Delegate implementation""
 
def thing(self):
    if self.thing is None:
        return ""Default implementation""
    else:
        return self.thing.thing()
 
d = Delegator(None)
print(d.thing())
 
d = Delegator(Delegate())
print(d.thing())",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Color_wheel,Color wheel,"Task

Write a function to draw a HSV color wheel completely with code.

This is strictly for learning purposes only. It's highly recommended that you use an image in an actual application to actually draw the color wheel   (as procedurally drawing is super slow). This does help you understand how color wheels work and this can easily be used to determine a color value based on a position within a circle.


",Python,"# colorwheelwidget.py
from PySide2.QtWidgets import QWidget
from PySide2.QtGui import QPainter, QColor, QRadialGradient, QBrush, QPen
from PySide2.QtCore import Qt
from PySide2.QtGui import QPaintEvent
from math import fmod, fabs, min
 
def hsvToRgb(h, s, v):
    hp = h/60.0
    c = s * v
    x = c * (1 - fabs(fmod(hp, 2) - 1))
    m = v - c
    r = 0
    g = 0
    b = 0
    if hp <= 1:
        r = c
        g = x
    elif hp <= 2:
        r = x
        g = c
    elif hp <= 3:
        g = c
        b = x
    elif hp <= 4:
        g = x
        b = c
    elif hp <= 5:
        r = x
        b = c
    else:
        r = c
        b = x
    r += m
    g += m
    b += m
    return QColor(int(r * 255), int(g * 255), int(b * 255))
 
class ColorWheelWidget(QWidget):
    def __init__(self, parent=None):
        super(ColorWheelWidget, self).__init__(parent)
        self.setWindowTitle(""Color Wheel"")
        self.resize(400, 400)
 
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        backgroundColor = QColor(0, 0, 0)
        white = QColor(255, 255, 255)
        painter.fillRect(event.rect(), backgroundColor)
        margin = 10
        diameter = min(self.width(), self.height()) - 2*margin
        center = QPointF(self.width()/2.0, self.height()/2.0)
        rect = QRectF(center.x() - diameter/2.0, center.y() - diameter/2.0,
                      diameter, diameter)
        for angle in range(360):
            color = hsvToRgb(angle, 1.0, 1.0)
            gradient = QRadialGradient(center, diameter/2.0)
            gradient.setColorAt(0, white)
            gradient.setColorAt(1, color)
            brush = QBrush(gradient)
            pen = QPen(brush, 1.0)
            painter.setPen(pen)
            painter.setBrush(brush)
            painter.drawPie(rect, angle * 16, 16)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",Python,"csv = ""Character,Speech\n"" + \
      ""The multitude,The messiah! Show us the messiah!\n"" + \
      ""Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>\n"" + \
      ""The multitude,Who are you?\n"" + \
      ""Brians mother,I'm his mother; that's who!\n"" + \
      ""The multitude,Behold his mother! Behold his mother!""
 
lines = csv.replace('&', '&amp;') \
          .replace('<', '&lt;') \
          .replace('>', '&gt;') \
          .replace('""', '&quot;') \
          .split('\n') \
          .map(lambda line: line.split(',')) \
          .map(lambda row: '\t\t<tr><td>' + row[0] + '</td><td>' + row[1] + '</td></tr>')
 
print('<table>\n\t<thead>\n' + lines[0] + \
      '\n\t</thead>\n\t<tbody>\n' + '\n'.join(lines[1:]) + \
      '\t</tbody>\n</table>')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Huffman_coding,Huffman coding,"Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:


 Create a leaf node for each symbol and add it to the priority queue.
 While there is more than one node in the queue:
 Remove the node of highest priority (lowest probability) twice to get two nodes.
 Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
 Add the new node to the queue.
 The remaining node is the root node and the tree is complete.


Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:



Task

Using the characters and their frequency from the string:

     this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.



",Python,"from heapq import heappush, heappop, heapify
from collections import defaultdict
 
def encode(symb2freq):
    """"""Huffman encode the given dict mapping symbols to weights""""""
    heap = [[wt, [sym, """"]] for sym, wt in symb2freq.items()]
    heapify(heap)
    while len(heap) > 1:
        lo = heappop(heap)
        hi = heappop(heap)
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])
    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))
 
txt = ""this is an example for huffman encoding""
symb2freq = defaultdict(int)
for ch in txt:
    symb2freq[ch] += 1
# in Python 3.1+:
# symb2freq = collections.Counter(txt)
huff = encode(symb2freq)
print ""Symbol\tWeight\tHuffman Code""
for p in huff:
    print ""%s\t%s\t%s"" % (p[0], symb2freq[p[0]], p[1])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Memory_allocation,Memory allocation,"Task

Show how to explicitly allocate and deallocate blocks of memory in your language.

Show access to different types of memory (i.e., heap, stack, shared, foreign) if applicable.



",Python,"import java.nio.ByteBuffer;
import java.nio.IntBuffer;

// we have to use `unsafe` here because 
// we will be dereferencing a raw pointer
unsafe {
    // define a layout of a block of memory
    var int_layout = Integer.SIZE / 8;
 
    // memory is allocated here
    var ptr = ByteBuffer.allocate(int_layout);
 
    // let us point to some data
    ((IntBuffer) ptr.asIntBuffer()).put(123);
    Assert.AreEqual(((IntBuffer) ptr.asIntBuffer()).get(), 123);
 
    // deallocate `ptr` with associated layout `int_layout`
    ptr.clear();
}",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Nth_root,Nth root,"Task

Implement the algorithm to compute the principal   nth   root   





A

n





{\displaystyle {\sqrt[{n}]{A}}}

   of a positive real number   A,   as explained at the   Wikipedia page.


",Python,"from decimal import Decimal, getcontext
 
def nthroot (n, A, precision):
    getcontext().prec = precision
 
    n = Decimal(n)
    x_0 = A / n #step 1: make a while guess.
    x_1 = 1     #need it to exist before step 2
    while True:
        #step 2:
        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))
        if x_0 == x_1:
            return x_1",Human_written,Python_from_C
http://rosettacode.org/wiki/IBAN,IBAN,"

 This page uses content from Wikipedia. The original article was at IBAN. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   International Bank Account Number (IBAN)   is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.

The IBAN consists of up to 34 alphanumeric characters:

   first the two-letter ISO 3166-1 alpha-2 country code, 
   then two check digits, and 
   finally a country-specific Basic Bank Account Number (BBAN). 


The check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.



Task

Validate the following fictitious IBAN:    GB82 WEST 1234 5698 7654 32 



Details of the algorithm can be found on the Wikipedia page.



",Python,"import re
 
_country2length = dict(
    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,
    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,
    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,
    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,
    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,
    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,
    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,
    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 )
 
def valid_iban(iban):
    # Ensure upper alphanumeric input.
    iban = iban.replace(' ','').replace('\t','')
    if not re.match(r'^[\dA-Z]+$', iban): 
        return False
    # Validate country code against expected length.
    if len(iban) != _country2length[iban[:2]]:
        return False
    # Shift and convert.
    iban = iban[4:] + iban[:4]
    digits = int(''.join(str(int(ch, 36)) for ch in iban)) #BASE 36: 0..9,A..Z -> 0..35
    return digits % 97 == 1
 
if __name__ == '__main__':
    for account in [""GB82 WEST 1234 5698 7654 32"", ""GB82 TEST 1234 5698 7654 32""]:
        print('%s validation is: %s' % (account, valid_iban(account)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sum_of_a_series,Sum of a series,"Compute the   nth   term of a series,   i.e. the sum of the   n   first terms of the corresponding sequence.

Informally this value, or its limit when   n   tends to infinity, is also called the sum of the series, thus the title of this task.

For this task, use:

 




S

n


=

∑

k
=
1


n




1

k

2






{\displaystyle S_{n}=\sum _{k=1}^{n}{\frac {1}{k^{2}}}}




 and compute   




S

1000




{\displaystyle S_{1000}}




This approximates the   zeta function   for   S=2,   whose exact value

 



ζ
(
2
)
=



π

2


6




{\displaystyle \zeta (2)={\pi ^{2} \over 6}}


is the solution of the Basel problem.



",Python,"print ( sum(1.0 / (x * x) for x in range(1, 1001)) )",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Simulate_input/Keyboard,Simulate input/Keyboard,"Task

Send simulated keystrokes to a GUI window, or terminal.

You should specify whether the target may be externally created
(i.e., if the keystrokes are going to an application
other than the application that is creating them).



",Python,"import autopilot
autopilot.key.type_string(""Hello, world!"", None, None, [])",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Conway%27s_Game_of_Life,Conway's Game of Life,"The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.

Conway's game of life is described   here:

A cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.

We calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:

   C   N                 new C
   1   0,1             ->  0  # Lonely
   1   4,5,6,7,8       ->  0  # Overcrowded
   1   2,3             ->  1  # Lives
   0   3               ->  1  # It takes three to give birth!
   0   0,1,2,4,5,6,7,8 ->  0  # Barren

Assume cells beyond the boundary are always dead.

The ""game"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.



Task

Although you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.



References

   Its creator John Conway, explains   the game of life.   Video from numberphile on youtube.
   John Conway   Inventing Game of Life   - Numberphile video.


Related task

   Langton's ant   - another well known cellular automaton.

",Python,"import random
from collections import defaultdict
 
printdead, printlive = '-#'
maxgenerations = 3
cellcount = 3,3
celltable = defaultdict(int, {
 (1, 2): 1,
 (1, 3): 1,
 (0, 3): 1,
 } ) # Only need to populate with the keys leading to life
 
##
## Start States
##
# blinker
u = universe = defaultdict(int)
u[(1,0)], u[(1,1)], u[(1,2)] = 1,1,1
 
## toad
#u = universe = defaultdict(int)
#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1
#u[(6,6)], u[(6,7)], u[(6,8)] = 1,1,1
 
## glider
#u = universe = defaultdict(int)
#maxgenerations = 16
#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1
#u[(6,5)] = 1
#u[(7,6)] = 1
 
## random start
#universe = defaultdict(int, 
#                       # array of random start values
#                       ( ((row, col), random.choice((0,1)))
#                         for col in range(cellcount[0])
#                         for row in range(cellcount[1])
#                       ) )  # returns 0 for out of bounds
 
for i in range(maxgenerations):
    print(""\nGeneration %3i:"" % ( i, ))
    for row in range(cellcount[1]):
        print(""  "", ''.join(str(universe[(row,col)])
                            for col in range(cellcount[0])).replace(
                                '0', printdead).replace('1', printlive))
    nextgeneration = defaultdict(int)
    for row in range(cellcount[1]):
        for col in range(cellcount[0]):
            nextgeneration[(row,col)] = celltable[
                ( universe[(row,col)],
                  -universe[(row,col)] + sum(universe[(r,c)]
                                             for r in range(row-1,row+2)
                                             for c in range(col-1, col+2) )
                ) ]
    universe = nextgeneration",Human_written,Python_from_C
http://rosettacode.org/wiki/Rosetta_Code/Find_bare_lang_tags,Rosetta Code/Find bare lang tags,"Task

Find all    <lang>    tags without a language specified in the text of a page.

Display counts by language section:

Description

<lang>Pseudocode</lang>

=={{header|C}}==
<lang C>printf(""Hello world!\n"");</lang>

=={{header|Perl}}==
<lang>print ""Hello world!\n""</lang>

should display something like

2 bare language tags.

1 in perl
1 in no language



Extra credit

Allow multiple files to be read.   Summarize all results by language:

5 bare language tags.

2 in c ([[Foo]], [[Bar]])
1 in perl ([[Foo]])
2 in no language ([[Baz]])



Extra extra credit

Use the   Media Wiki API   to test actual RC tasks.



",Python,"""""""Count bare `lang` tags in wiki markup. Requires Python >=3.6.
 
Uses the Python standard library `urllib` to make MediaWiki API requests.
""""""
 
from __future__ import annotations
 
import functools
import gzip
import json
import logging
import platform
import re
 
from collections import Counter
from collections import defaultdict
 
from typing import Any
from typing import Iterator
from typing import Iterable
from typing import List
from typing import Mapping
from typing import NamedTuple
from typing import Optional
from typing import Tuple
 
from urllib.parse import urlencode
from urllib.parse import urlunparse
from urllib.parse import quote_plus
 
import urllib.error
import urllib.request
 
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
 
 
# Parse wiki markup with these regular expression patterns. Any headings and
# `lang` tags found inside `nowiki`, `pre` or other `lang` tags (bare or not)
# should not count as ""bare"".
#
# NOTE: The order of these patterns is significant.
RE_SPEC = [
    (""NOWIKI"", r""<\s*nowiki\s*>.*?</\s*nowiki\s*>""),
    (""PRE"", r""<\s*pre\s*>.*?</\s*pre\s*>""),
    (""LANG"", r""<\s*lang\s+.+?>.*?</\s*lang\s*>""),
    (""HEAD"", r""==\{\{\s*header\s*\|\s*(?P<header>.+?)\s*}}==""),
    (""BARE"", r""<\s*lang\s*>.*?</\s*lang\s*>""),
]
 
RE_BARE_LANG = re.compile(
    ""|"".join(rf""(?P<{name}>{pattern})"" for name, pattern in RE_SPEC),
    re.DOTALL | re.IGNORECASE,
)
 
# Some wiki headings look like this ""=={{header|Some}} / {{header|Other}}=="".
# We'll use this regular expression to strip out the markup.
RE_MULTI_HEADER = re.compile(r""(}|(\{\{\s*header\s*\|\s*))"", re.IGNORECASE)
 
 
def find_bare_lang_section_headers(wiki_text: str) -> Iterator[str]:
    """"""Generate a sequence of wiki section headings that contain bare
    'lang' tags.
 
    If there are multiple bare lang tags in a section, that section
    heading will appear multiple times in the sequence.
    """"""
    current_heading = ""no language""
 
    for match in RE_BARE_LANG.finditer(wiki_text):
        kind = match.lastgroup
 
        if kind == ""HEAD"":
            current_heading = RE_MULTI_HEADER.sub("""", match.group(""header""))
        elif kind == ""BARE"":
            yield current_heading
 
 
class Error(Exception):
    """"""Exception raised when we get an unexpected response from the MediaWiki API.""""""
 
 
class TagCounter:
    """"""Count bare `lang` tags in wiki markup. Group them by heading and
    remember what page they're in.""""""
 
    def __init__(self):
        self.counter = Counter()
        self.pages = defaultdict(set)
        self.total = 0
 
    def __len__(self):
        return len(self.counter)
 
    @classmethod
    def from_section_headers(
        cls, page_title: str, section_headers: Iterable[str]
    ) -> TagCounter:
        """"""Return a new `TagCounter` initialized with the given section
        headings.""""""
        counter = cls()
 
        for heading in section_headers:
            counter.add(page_title, heading)
 
        return counter
 
    @classmethod
    def from_wiki_text(cls, page_title: str, wiki_text: str) -> TagCounter:
        """"""Return a new `TagCounter` initialized with bare lang tags from the
        given wiki text.""""""
        return cls.from_section_headers(
            page_title,
            find_bare_lang_section_headers(wiki_text),
        )
 
    def add(self, page_title: str, section_heading: str):
        """"""Increment the counter by one for the given section heading an
        page.""""""
        self.counter[section_heading] += 1
        self.pages[section_heading].add(page_title)
        self.total += 1
 
    def update(self, other):
        """"""Union this counter with `other`, another counter.""""""
        assert isinstance(other, TagCounter)
 
        self.counter.update(other.counter)
 
        for section_heading, pages in other.pages.items():
            self.pages[section_heading].update(pages)
 
        self.total += other.total
 
    def most_common(self, n=None) -> str:
        """"""Return a formatted string of the most common wiki sections to have
        bare lang tags.""""""
        buf = [f""{sum(self.counter.values())} bare lang tags.\n""]
 
        for section_heading, count in self.counter.most_common(n=n):
            pages = list(self.pages[section_heading])
            buf.append(f""{count} in {section_heading} {pages}"")
 
        return ""\n"".join(buf)
 
 
def quote_underscore(string, safe="""", encoding=None, errors=None):
    """"""Like urllib.parse.quote but replaces spaces with underscores.""""""
    string = quote_plus(string, safe, encoding, errors)
    return string.replace(""+"", ""_"")
 
 
class URL(NamedTuple):
    """"""A `urllib.parse.urlunparse` compatible Tuple with some helper methods.
    We'll use this to build and pass around our MediaWiki API URLs.
    """"""
 
    scheme: str
    netloc: str
    path: str
    params: str
    query: str
    fragment: str
 
    def __str__(self):
        return urlunparse(self)
 
    def with_query(self, query: Mapping[str, Any]) -> URL:
        query_string = urlencode(query, safe="":"", quote_via=quote_underscore)
        return self._replace(query=query_string)
 
 
API_BASE_URL = URL(
    scheme=""http"",
    netloc=""rosettacode.org"",
    path=""/mw/api.php"",
    params="""",
    query="""",
    fragment="""",
)
 
UGLY_RAW_URL = URL(
    scheme=""http"",
    netloc=""rosettacode.org"",
    path=""/mw/index.php"",
    params="""",
    query="""",
    fragment="""",
)
 
# NOTE: Cloudflare was blocking requests with the default user agent.
DEFAULT_HEADERS = {
    ""User-agent"": f""python/{platform.python_version()}"",
    ""Accept-encoding"": ""gzip, deflate"",
    ""Accept"": ""*/*"",
    ""Connection"": ""keep-alive"",
}
 
 
class Response(NamedTuple):
    headers: Mapping[str, str]
    body: bytes
 
 
def get(url: URL, headers=DEFAULT_HEADERS) -> Response:
    """"""Make an HTTP GET request to the given URL.""""""
    logger.debug(f""GET {url}"")
    request = urllib.request.Request(str(url), headers=headers)
 
    try:
        with urllib.request.urlopen(request) as response:
            return Response(
                headers=dict(response.getheaders()),
                body=response.read(),
            )
    except urllib.error.HTTPError as e:
        logging.debug(e.code)
        logging.debug(gzip.decompress(e.read()))
        raise
 
 
def raise_for_header(headers: Mapping[str, str], header: str, expect: str):
    got = headers.get(header)
    if got != expect:
        raise Error(f""expected '{expect}', got '{got}'"")
 
 
raise_for_content_type = functools.partial(raise_for_header, header=""Content-Type"")
 
 
class CMContinue(NamedTuple):
    continue_: str
    cmcontinue: str
 
 
Pages = Tuple[List[str], Optional[CMContinue]]
 
 
def get_wiki_page_titles(chunk_size: int = 500, continue_: CMContinue = None) -> Pages:
    """"""Return a list of wiki page titles and any continuation information.""""""
    query = {
        ""action"": ""query"",
        ""list"": ""categorymembers"",
        ""cmtitle"": ""Category:Programming_Tasks"",
        ""cmlimit"": chunk_size,
        ""format"": ""json"",
        ""continue"": """",
    }
 
    if continue_:
        query[""continue""] = continue_.continue_
        query[""cmcontinue""] = continue_.cmcontinue
 
    response = get(API_BASE_URL.with_query(query))
 
    # Fail early if the response is not what we are expecting.
    raise_for_content_type(response.headers, expect=""application/json; charset=utf-8"")
    raise_for_header(response.headers, ""Content-Encoding"", ""gzip"")
 
    data = json.loads(gzip.decompress(response.body))
    page_titles = [p[""title""] for p in data[""query""][""categorymembers""]]
 
    if data.get(""continue"", {}).get(""cmcontinue""):
        _continue = CMContinue(
            data[""continue""][""continue""],
            data[""continue""][""cmcontinue""],
        )
    else:
        _continue = None
 
    return (page_titles, _continue)
 
 
def get_wiki_page_markup(page_title: str) -> str:
    """"""Return raw MediaWiki markup from the page `page_title`.""""""
    query = {""action"": ""raw"", ""title"": page_title}
    response = get(UGLY_RAW_URL.with_query(query))
 
    # Fail early if the response is not what we are expecting.
    raise_for_content_type(response.headers, expect=""text/x-wiki; charset=UTF-8"")
 
    return response.body.decode()
 
 
def example(limit=30):
    # Get the first chunk of wiki page titles from the MediaWiki API
    page_titles, continue_ = get_wiki_page_titles()
 
    # Get more chunks if there are any.
    while continue_ is not None:
        more_page_titles, continue_ = get_wiki_page_titles(continue_=continue_)
        page_titles.extend(more_page_titles)
 
    # Aggregate counts from all pages.
    counter = TagCounter()
 
    for i, page_title in enumerate(page_titles):
        if i > limit:
            break
 
        # Read and parse raw wiki page markup.
        wiki_text = get_wiki_page_markup(page_title)
        counts = TagCounter.from_wiki_text(page_title, wiki_text)
        counter.update(counts)
 
    # Dump the results to stdout.
    print(counter.most_common())
 
 
if __name__ == ""__main__"":
    logging.basicConfig(format=""%(asctime)s %(message)s"", level=logging.DEBUG)
    example()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"from pprint import pprint as pp
 
def pascal_upp(n):
    s = [[0] * n for _ in range(n)]
    s[0] = [1] * n
    for i in range(1, n):
        for j in range(i, n):
            s[i][j] = s[i-1][j-1] + s[i][j-1]
    return s
 
def pascal_low(n):
    # transpose of pascal_upp(n)
    return [list(x) for x in zip(*pascal_upp(n))]
 
def pascal_sym(n):
    s = [[1] * n for _ in range(n)]
    for i in range(1, n):
        for j in range(1, n):
            s[i][j] = s[i-1][j] + s[i][j-1]
    return s
 
 
if __name__ == ""__main__"":
    n = 5
    print(""\nUpper:"")
    pp(pascal_upp(n))
    print(""\nLower:"")
    pp(pascal_low(n))
    print(""\nSymmetric:"")
    pp(pascal_sym(n))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Index_finite_lists_of_positive_integers,Index finite lists of positive integers,"It is known that the set of finite lists of positive integers is    countable.

This means that there exists a subset of natural integers which can be mapped to the set of finite lists of positive integers.



Task

Implement such a mapping:

   write a function     rank     which assigns an integer to any finite, arbitrarily long list of arbitrary large positive integers.
   write a function   unrank   which is the   rank    inverse function.


Demonstrate your solution by:

   picking a random-length list of random positive integers
   turn it into an integer,   and 
   get the list back.


There are many ways to do this.   Feel free to choose any one you like.



Extra credit

Make the   rank   function as a    bijection   and show   unrank(n)   for   n   varying from   0   to   10.



",Python,"def rank(x): return int('a'.join(map(str, [1] + x)), 11)
 
def unrank(n):
	s = ''
	while n: s,n = ""0123456789a""[n%11] + s, n//11
	return map(int, s.split('a'))[1:]
 
l = [1, 2, 3, 10, 100, 987654321]
print l
n = rank(l)
print n
l = unrank(n)
print l",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",Python,"#!/usr/bin/env python
 
try:
    from msvcrt import getch
except ImportError:
    def getch():
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
 
print ""Press Y or N to continue""
while True:
    char = getch()
    if char.lower() in (""y"", ""n""):
        print char
        break",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Numeric_error_propagation,Numeric error propagation,"If   f,   a,   and   b   are values with uncertainties   σf,   σa,   and   σb,   and   c   is a constant;

then if   f   is derived from   a,   b,   and   c   in the following ways,

then   σf   can be calculated as follows:

Addition/Subtraction
 If   f = a ± c,   or   f = c ± a   then   σf = σa
 If   f = a ± b   then   σf2 = σa2 + σb2
Multiplication/Division
 If   f = ca   or   f = ac       then   σf = |cσa|
 If   f = ab   or   f = a / b   then   σf2 = f2( (σa / a)2 + (σb / b)2)
Exponentiation
 If   f = ac   then   σf = |fc(σa / a)|


Caution:

This implementation of error propagation does not address issues of dependent and independent values.   It is assumed that   a   and   b   are independent and so the formula for multiplication should not be applied to   a*a   for example.   See   the talk page   for some of the implications of this issue.


Task details

 Add an uncertain number type to your language that can support addition, subtraction, multiplication, division, and exponentiation between numbers with an associated error term together with 'normal' floating point numbers without an associated error term. 
Implement enough functionality to perform the following calculations.
 Given coordinates and their errors:
x1 = 100 ± 1.1
y1 = 50 ± 1.2
x2 = 200 ± 2.2
y2 = 100 ± 2.3
 if point p1 is located at (x1, y1) and p2 is at (x2, y2); calculate the distance between the two points using the classic Pythagorean formula: 
  d = √   (x1 - x2)²   +   (y1 - y2)²    
 Print and display both    d    and its error.


References

 A Guide to Error Propagation B. Keeney, 2005.
 Propagation of uncertainty Wikipedia.


Related task

   Quaternion type

",Python,"import math
 
class Unc:
    def __init__(self, n, s):
        self.n = n
        self.s = s * s
 
    def errorTerm(self):
        return math.sqrt(self.s)
 
    def addC(self, a, c):
        self.n = a.n + c
        return self
 
    def subC(self, a, c):
        self.n = a.n - c
        return self
 
    def addU(self, a, b):
        self.n = a.n + b.n
        self.s = a.s + b.s
        return self
 
    def subU(self, a, b):
        self.n = a.n - b.n
        self.s = a.s + b.s
        return self
 
    def mulC(self, a, c):
        self.n = a.n * c
        self.s = a.s * c * c
        return self
 
    def divC(self, a, c):
        self.n = a.n / c
        self.s = a.s / (c * c)
        return self
 
    def mulU(self, a, b):
        prod = a.n * b.n
        self.n = prod
        self.s = prod * prod * (a.s / (a.n * a.n) + b.s / (b.n * b.n))
        return self
 
    def divU(self, a, b):
        quot = a.n / b.n
        self.n = quot
        self.s = quot * quot * (a.s / (a.n * a.n) + b.s / (b.n * b.n))
        return self
 
    def expC(self, a, c):
        f = math.pow(a.n, c)
        g = f * c / a.n
        self.n = f
        self.s = a.s * g * g
        return self
 
x1 = Unc(100, 1.1)
x2 = Unc(200, 2.2)
y1 = Unc(50, 1.2)
y2 = Unc(100, 2.3)
d = Unc(0, 0)
d2 = Unc(0, 0)
d.expC(d.addU(d.expC(d.subU(x1, x2), 2), d2.expC(d2.subU(y1, y2), 2)),.5)
print(""d:    "", d.n)
print(""error:"", d.errorTerm())",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible,Determine if a string is collapsible,"Determine if a character string is   collapsible.

And if so,   collapse the string   (by removing   immediately repeated   characters).



If a character string has   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



An   immediately repeated   character is any character that is   immediately   followed by an
identical character (or characters).   Another word choice could've been   duplicated character,   but that
might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around November 2019)   PL/I   BIF:   collapse.}



Examples

In the following character string:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   t,   e, and   l   are repeated characters,   indicated
by underscores (above),   even though they (those characters) appear elsewhere in the character string.



So, after collapsing the string, the result would be:

 The beter the 4-whel drive, the further you'l be from help when ya get stuck! 





Another example:
In the following character string:

 headmistressship 



The ""collapsed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to
locate   repeated   characters and   collapse   (delete)   them from the character
string.   The character string can be processed from either direction.



Show all output here, on this page:

   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

 string
 number
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗   ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║
   5    ║                                                    --- Harry S Truman  ║   ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import groupby
 
def collapser(txt):
    return ''.join(item for item, grp in groupby(txt))
 
if __name__ == '__main__':
    strings = [
            """",
            '""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ',
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                   ---  Harry S Truman  "",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""aardvark"",
            ""😍😀🙌💃😍😍😍🙌"",
            ]
    for txt in strings:
        this = ""Original""
        print(f""\n{this:14} Size: {len(txt)} «««{txt}»»»"" )
        this = ""Collapsed""
        sqz = collapser(txt)
        print(f""{this:>14} Size: {len(sqz)} «««{sqz}»»»"" )",Human_written,Python_from_C++
http://rosettacode.org/wiki/Pell%27s_equation,Pell's equation,"Pell's equation   (also called the Pell–Fermat equation)   is a   Diophantine equation   of the form:

   x2   -   ny2   =   1  
with integer solutions for   x   and   y,   where   n   is a given non-square positive integer.



Task requirements

   find the smallest solution in positive integers to Pell's equation for   n = {61, 109, 181, 277}.


See also

   Wikipedia entry: Pell's equation.

",Python,"from math import sqrt
 
def fun(a, b, c):
    t = a
    a = b
    b = b * c + t
    return a, b
 
def solve_pell(n):
    x = int(sqrt(n))
    y = x
    z = 1
    r = x << 1
    e1 = 1
    e2 = 0
    f1 = 0
    f2 = 1
    while True:
        y = r * z - y
        z = (n - y * y) / z
        r = (x + y) / z
        e1, e2 = fun(e1, e2, r)
        f1, f2 = fun(f1, f2, r)
        a = f2
        b = e2
        a, b = fun(b, a, x)
        if a * a - n * b * b == 1:
            return a, b
 
for n in [61, 109, 181, 277]:
    x, y = solve_pell(n)
    print(""x^2 - {0,3} * y^2 = 1 for x = {1,27:n0} and y = {2,25:n0}"".format(n, x, y))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import fileinput
 
changerow, changecolumn, changevalue = 2, 4, '""Spam""'
 
with fileinput.input('csv_data_manipulation.csv', inplace=True) as f:
    for line in f:
        if fileinput.filelineno() == changerow:
            fields = line.rstrip().split(',')
            fields[changecolumn-1] = changevalue
            line = ','.join(fields) + '\n'
        print(line, end='')",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Perlin_noise,Perlin noise,"The   Perlin noise   is a kind of   gradient noise   invented by   Ken Perlin   around the end of the twentieth century and still currently heavily used in   computer graphics,   most notably to procedurally generate textures or heightmaps.

The Perlin noise is basically a   pseudo-random   mapping of   





R


d




{\displaystyle \mathbb {R} ^{d}}

   into   




R



{\displaystyle \mathbb {R} }

   with an integer   



d


{\displaystyle d}

   which can be arbitrarily large but which is usually   2,   3,   or   4.

Either by using a dedicated library or by implementing the algorithm, show that the Perlin noise   (as defined in 2002 in the Java implementation below)   of the point in 3D-space with coordinates     3.14,   42,   7     is     0.13691995878400012.


Note: this result assumes 64 bit IEEE-754 floating point calculations. If your language uses a different floating point representation, make a note of it and calculate the value accurate to 15 decimal places, or your languages accuracy threshold if it is less. Trailing zeros need not be displayed.
",Python,"def perlin_noise(x, y, z):
    X = int(x) & 255                  # FIND UNIT CUBE THAT
    Y = int(y) & 255                  # CONTAINS POINT.
    Z = int(z) & 255
    x -= int(x)                                # FIND RELATIVE X,Y,Z
    y -= int(y)                                # OF POINT IN CUBE.
    z -= int(z)
    u = fade(x)                                # COMPUTE FADE CURVES
    v = fade(y)                                # FOR EACH OF X,Y,Z.
    w = fade(z)
    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      # HASH COORDINATES OF
    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      # THE 8 CUBE CORNERS,
 
    return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  # AND ADD
                                   grad(p[BA  ], x-1, y  , z   )), # BLENDED
                           lerp(u, grad(p[AB  ], x  , y-1, z   ),  # RESULTS
                                   grad(p[BB  ], x-1, y-1, z   ))),# FROM  8
                   lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  # CORNERS
                                   grad(p[BA+1], x-1, y  , z-1 )), # OF CUBE
                           lerp(u, grad(p[AB+1], x  , y-1, z-1 ),
                                   grad(p[BB+1], x-1, y-1, z-1 ))))
 
def fade(t): 
    return t ** 3 * (t * (t * 6 - 15) + 10)
 
def lerp(t, a, b):
    return a + t * (b - a)
 
def grad(hash, x, y, z):
    h = hash & 15                      # CONVERT LO 4 BITS OF HASH CODE
    u = x if h<8 else y                # INTO 12 GRADIENT DIRECTIONS.
    v = y if h<4 else (x if h in (12, 14) else z)
    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v)
 
p = [None] * 512
permutation = [151,160,137,91,90,15,
   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]
for i in range(256):
    p[256+i] = p[i] = permutation[i]
 
if __name__ == '__main__':
    print(""%1.17f"" % perlin_noise(3.14, 42, 7))",Human_written,Python_from_C
http://rosettacode.org/wiki/Execute_a_system_command,Execute a system command,"Task

Run either the   ls   system command   (dir   on Windows),   or the   pause   system command.




Related task
  Get system command output

",Python,"import os
exit_code = os.system('ls')       # Just execute the command, return a success/fail code
output    = os.popen('ls').read() # If you want to get the output data. Deprecated.",Human_written,Python_from_C
http://rosettacode.org/wiki/Greatest_common_divisor,Greatest common divisor,"Greatest common divisor

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Find the greatest common divisor   (GCD)   of two integers.


Greatest common divisor   is also known as   greatest common factor (gcf)   and   greatest common measure.



Related task

   least common multiple.


See also

   MathWorld entry:   greatest common divisor.
   Wikipedia entry:     greatest common divisor.

",Python,from fractions import gcd,Human_written,Python_from_C++
http://rosettacode.org/wiki/Pseudo-random_numbers/Xorshift_star,Pseudo-random numbers/Xorshift star,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
Xorshift_star Generator (pseudo-code)

   /* Let u64 denote an unsigned 64 bit integer type. */
   /* Let u32 denote an unsigned 32 bit integer type. */



   class Xorshift_star
       u64 state       /* Must be seeded to non-zero initial value */
       u64 const = HEX '2545F4914F6CDD1D'

       method seed(u64 num):
           state =  num
       end method
       
       method next_int():
           u64 x = state
           x = x ^ (x >> 12)
           x = x ^ (x << 25)
           x = x ^ (x >> 27)
           state = x
           u32 answer = ((x * const) >> 32)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / (1 << 32)
       end method
       
   end class
       

Xorshift use

   random_gen = instance Xorshift_star
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 3540625527 */
   print(random_gen.next_int())   /* 2750739987 */
   print(random_gen.next_int())   /* 4037983143 */
   print(random_gen.next_int())   /* 1993361440 */
   print(random_gen.next_int())   /* 3809424708 */

Task

 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers genrated with the seed 1234567
are as shown above

 Show that for an initial seed of 987654321, the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20103, 1: 19922, 2: 19937, 3: 20031, 4: 20007

 Show your output here, on this page.

",Python,"class XorShiftStar:
    def __init__(self):
        self.MAGIC = 0x2545F4914F6CDD1D
        self.state = 0
 
    def seed(self, num):
        self.state = num
 
    def nextInt(self):
        x = self.state
        x = x ^ (x >> 12)
        x = x ^ (x << 25)
        x = x ^ (x >> 27)
        self.state = x
        answer = (x * self.MAGIC) >> 32
 
        return answer
 
    def nextFloat(self):
        return self.nextInt() / (1 << 32)
 
if __name__ == ""__main__"":
    rng = XorShiftStar()
    rng.seed(1234567)
    print(rng.nextInt())
    print(rng.nextInt())
    print(rng.nextInt())
    print(rng.nextInt())
    print(rng.nextInt())
    print()
 
    counts = [0, 0, 0, 0, 0]
    rng.seed(987654321)
    for i in range(100_000):
        j = int(rng.nextFloat() * 5)
        counts[j] += 1
    for i in range(len(counts)):
        print(f""{i}: {counts[i]}"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",Python,"def hofq(q, x):
    cur_len=len(q)-1
    i=x
    if i>cur_len:
        # extend storage
        for j in range(cur_len+1, i+1):
            qj=q[j-q[j-1]]+q[j-q[j-2]]
            q.append(qj)
    return q[i]
 
def main():
    q_memo=[0,1,1]
    q=lambda i: hofq(q_memo, i)
    for i in range(1,11):
        print(""Q({})={}"".format(i, q(i)))
    print(""Q(1000)={}"".format(q(1000)))
    q100001=q(100_000) # precompute all
    print(""Q(100000)={}"".format(q100000))
    nless=sum(1 for i in range(1,100_000) if q(i+1)<q(i))
    print(""Term is less than preceding term {} times"".format(nless))
 
if __name__==""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Solve_a_Holy_Knight%27s_tour,Solve a Holy Knight's tour,"
Chess coaches have been known to inflict a kind of torture on beginners by taking a chess board, placing pennies on some squares and requiring that a Knight's tour be constructed that avoids the squares with pennies.

This kind of knight's tour puzzle is similar to   Hidato.

The present task is to produce a solution to such problems. At least demonstrate your program by solving the following:



Example

  0 0 0 
  0   0 0 
  0 0 0 0 0 0 0
0 0 0     0   0
0   0     0 0 0
1 0 0 0 0 0 0
    0 0   0
      0 0 0

Note that the zeros represent the available squares, not the pennies.

Extra credit is available for other interesting examples.



Related tasks

 A* search algorithm
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"from sys import stdout
moves = [
    [-1, -2], [1, -2], [-1, 2], [1, 2],
    [-2, -1], [-2, 1], [2, -1], [2, 1]
]
 
 
def solve(pz, sz, sx, sy, idx, cnt):
    if idx > cnt:
        return 1
 
    for i in range(len(moves)):
        x = sx + moves[i][0]
        y = sy + moves[i][1]
        if sz > x > -1 and sz > y > -1 and pz[x][y] == 0:
            pz[x][y] = idx
            if 1 == solve(pz, sz, x, y, idx + 1, cnt):
                return 1
            pz[x][y] = 0
 
    return 0
 
 
def find_solution(pz, sz):
    p = [[-1 for j in range(sz)] for i in range(sz)]
    idx = x = y = cnt = 0
    for j in range(sz):
        for i in range(sz):
            if pz[idx] == ""x"":
                p[i][j] = 0
                cnt += 1
            elif pz[idx] == ""s"":
                p[i][j] = 1
                cnt += 1
                x = i
                y = j
            idx += 1
 
    if 1 == solve(p, sz, x, y, 2, cnt):
        for j in range(sz):
            for i in range(sz):
                if p[i][j] != -1:
                    stdout.write("" {:0{}d}"".format(p[i][j], 2))
                else:
                    stdout.write(""   "")
            print()
    else:
        print(""Cannot solve this puzzle!"")
 
 
# entry point
find_solution("".xxx.....x.xx....xxxxxxxxxx..x.xx.x..xxxsxxxxxx...xx.x.....xxx.."", 8)
print()
find_solution("".....s.x..........x.x.........xxxxx.........xxx.......x..x.x..x..xxxxx...xxxxx..xx.....xx..xxxxx...xxxxx..x..x.x..x.......xxx.........xxxxx.........x.x..........x.x....."", 13)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Loops/Break,Loops/Break,"Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive).

If a number is 10, stop the loop after printing it, and do not generate any further numbers.

Otherwise, generate and print a second random number before restarting the loop.

If the number 10 is never generated as the first number in a loop, loop forever.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges

",Python,"import random
import time
 
random.seed(time.time())
while True:
	a = random.randint(0, 19)
	print(a)
	if a == 10:
		break
	b = random.randint(0, 19)
	print(b)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"import gtk
 
window = gtk.Window()
window.set_title('Goodbye, World')
window.connect('delete-event', lambda w,e: gtk.main_quit())
window.show_all()
 
gtk.main()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/100_doors,100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",Python,"doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print(""Door %d:"" % (i+1), 'open' if doors[i] else 'close')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Polyspiral,Polyspiral,"A Polyspiral is a spiral made of multiple line segments, whereby each segment is larger (or smaller) than the previous one by a given amount. Each segment also changes direction at a given angle.



Task
Animate a series of polyspirals, by drawing a complete spiral then incrementing the angle, and (after clearing the background) drawing the next, and so on. Every spiral will be a frame of the animation. The animation may stop as it goes full circle or continue indefinitely. The given input values may be varied.

If animation is not practical in your programming environment, you may show a single frame instead.



Pseudo code
    set incr to 0.0

    // animation loop
    WHILE true 

        incr = (incr + 0.05) MOD 360
        x = width / 2
        y = height / 2
        length = 5
        angle = incr

        // spiral loop
        FOR 1 TO 150
            drawline
            change direction by angle
            length = length + 3
            angle = (angle + incr) MOD 360
        ENDFOR
    


",Python,"# Polyspiral.py
# Basic function for family of Polyspirals
# Where: rng - range (prime parameter), w2 - half of canvas width,
#        d - direction (1 - clockwise, -1 - counter clockwise).
def ppsp(ctx, rng, w2, d):
  # Note: coefficients c, it, sc, sc2, sc3 are selected to fit canvas.
  c=math.pi*rng; it=c/w2; sc=2; sc2=50; sc3=0.1; t=0; x=0; y=0
  print(""Polyspiral PARs rng,w2,d:"", rng, ""/"", w2, ""/"", d)
  if rng>1000: sc=sc3
  ctx.beginPath()
  for i in range(sc2*c):
    t=it*i
    x = sc*t*math.cos(d*t)+w2; y = sc*t*math.sin(d*t)+w2
    ctx.lineTo(x, y)
  ctx.stroke()
# ******************************************
# pspiral() - Generating and plotting Polyspirals
def pspiral():
  # Setting basic vars for canvas and inpu parameters
  cvs = document.getElementById('cvsId')
  ctx = cvs.getContext(""2d"")
  w = cvs.width; h = cvs.height
  w2=w/2
  clr = document.getElementById(""color"").value # color
  d = document.getElementById(""dir"").value     # direction
  rng = document.getElementById(""rng"").value   # range
  rng=Number(rng)
  ctx.fillStyle=""white""; ctx.fillRect(0,0,w,h)
  ctx.strokeStyle=clr
  # Plotting spiral.
  ppsp(ctx, rng, w2, d)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",Python,"from fractions import gcd
 
 
def pt1(maxperimeter=100):
    '''
# Naive method
    '''
    trips = []
    for a in range(1, maxperimeter):
        aa = a*a
        for b in range(a, maxperimeter-a+1):
            bb = b*b
            for c in range(b, maxperimeter-b-a+1):
                cc = c*c
                if a+b+c > maxperimeter or cc > aa + bb: break
                if aa + bb == cc:
                    trips.append((a,b,c, gcd(a, b) == 1))
    return trips
 
def pytrip(trip=(3,4,5),perim=100, prim=1):
    a0, b0, c0 = a, b, c = sorted(trip)
    t, firstprim = set(), prim>0
    while a + b + c <= perim:
        t.add((a, b, c, firstprim>0))
        a, b, c, firstprim = a+a0, b+b0, c+c0, False
    #
    t2 = set()
    for a, b, c, firstprim in t:
        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7
        if  a5 - b5 + c7 <= perim:
            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)
        if  a5 + b5 + c7 <= perim:
            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)
        if -a5 + b5 + c7 <= perim:
            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)
    return t | t2
 
def pt2(maxperimeter=100):
    '''
# Parent/child relationship method:
# http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples#XI.
    '''
    trips = pytrip((3,4,5), maxperimeter, 1)
    return trips
 
def printit(maxperimeter=100, pt=pt1):
    trips = pt(maxperimeter)
    print(""  Up to a perimeter of %i there are %i triples, of which %i are primitive""
          % (maxperimeter,
             len(trips),
             len([prim for a,b,c,prim in trips if prim])))
 
for algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):
    print(algo.__doc__)
    for maxperimeter in range(mn, mx+1, mn):
        printit(maxperimeter, algo)",Human_written,Python_from_C
http://rosettacode.org/wiki/Extend_your_language,Extend your language,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are ""true""). In a C-like language this could look like the following:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.
",Python,"# version 1.0.6
 
class IfBoth:
    def __init__(self, cond1, cond2):
        self.cond1 = cond1
        self.cond2 = cond2
 
    def elseFirst(self, func):
        if self.cond1 and not self.cond2:
            func()
        return self
 
    def elseSecond(self, func):
        if self.cond2 and not self.cond1:
            func()
        return self
 
    def elseNeither(self, func):
        if not self.cond1 and not self.cond2:
            func()
        return self  # in case it's called out of order
 
def ifBoth(cond1, cond2, func):
    if cond1 and cond2:
        func()
    return IfBoth(cond1, cond2)
 
def main():
    a = 0
    b = 1
    ifBoth(a == 1, b == 3, lambda: print(""a = 1 and b = 3"")) \
       .elseFirst(lambda: print(""a = 1 and b <> 3"")) \
       .elseSecond(lambda: print(""a <> 1 and b = 3"")) \
       .elseNeither(lambda: print(""a <> 1 and b <> 3""))
 
    # It's also possible to omit any (or all) of the 'else' clauses or to call them out of order
    a = 1
    b = 0
    ifBoth(a == 1, b == 3, lambda: print(""a = 1 and b = 3"")) \
       .elseNeither(lambda: print(""a <> 1 and b <> 3"")) \
       .elseFirst(lambda: print(""a = 1 and b <> 3""))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,">>> def sort_disjoint_sublist(data, indices):
	indices = sorted(indices)
	values  = sorted(data[i] for i in indices)
	for index, value in zip(indices, values):
		data[index] = value
 
 
>>> d = [7, 6, 5, 4, 3, 2, 1, 0]
>>> i = set([6, 1, 7])
>>> sort_disjoint_sublist(d, i)
>>> d
[7, 0, 5, 4, 3, 2, 1, 6]
>>> # Which could be more cryptically written as:
>>> def sort_disjoint_sublist(data, indices):
	for index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value
 
 
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion,Doubly-linked list/Element insertion,"Doubly-Linked List (element)
This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Python,"class DoublyLinkedList:
    def __init__(self, value, prev, next):
        self.value = value
        self.prev = prev
        self.next = next

    def insertAfter(self, searchValue, nodeToInsert):
        if self.value == searchValue:
            after = self.next
            self.next = nodeToInsert
            nodeToInsert.prev = self
            nodeToInsert.next = after
            after.prev = nodeToInsert
        elif self.next == None:
            raise ValueError(""value '"" + searchValue + ""' not found in linked list."")
        else:
            self.next.insertAfter(searchValue, nodeToInsert)

list = DoublyLinkedList('A', None, DoublyLinkedList('B', None, None))
list.insertAfter('A', DoublyLinkedList('C', None, None))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice,Seven-sided dice from five-sided dice,"Task

(Given an equal-probability generator of one of the integers 1 to 5
as dice5),   create dice7 that generates a pseudo-random integer from
1 to 7 in equal probability using only dice5 as a source of random
numbers,   and check the distribution for at least one million calls using the function created in   Simple Random Distribution Checker.


Implementation suggestion:
dice7 might call dice5 twice, re-call if four of the 25
combinations are given, otherwise split the other 21 combinations
into 7 groups of three, and return the group index from the rolls.

(Task adapted from an answer here)
",Python,"from random import randint
 
def dice5():
    return randint(1, 5)
 
def dice7():
    r = dice5() + dice5() * 5 - 6
    return (r % 7) + 1 if r < 21 else dice7()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",Python,"import math
 
MAX = 120
 
def extract_prime_factor(num):
    i = 0
    if is_prime(num):
        return None
    while True:
        prime = primes[i]
        if num % prime == 0:
            return (prime, num // prime)
        i += 1
 
def factorize(num):
    factorized = []
    rest = num
    while True:
        prime_factor = extract_prime_factor(rest)
        if prime_factor is None:
            break
        factorized.append(prime_factor[0])
        rest = prime_factor[1]
    factorized.append(rest)
    return factorized
 
def is_prime(num):
    if num == 1:
        return False
    if num == 2:
        return True
    if num % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(num)) + 1, 2):
        if num % i == 0:
            return False
    return True
 
primes = [2]
for i in range(3, MAX + 1, 2):
    if is_prime(i):
        primes.append(i)
 
output = []
for num in range(4, MAX + 1):
    if is_prime(len(factorize(num))):
        output.append(num)
print(output)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",Python,"def isPrime(n):
    if not n % 2 or not n % 3:
        return False
 
    p = 1
    while p * p < n:
        if n % (p += 4) == 0 or n % (p += 2) == 0:
            return False
    return True
 
def isEmirp(n):
    s = str(n)
    r = s[::-1]
    return r!= s and isPrime(n) and isPrime(r)
 
def main():
    c = 0
    x = 11
    last = None
    str = None
 
    while c < 10000:
        if isEmirp(x):
            c += 1
 
            # first twenty emirps
            if c == 1:
                str = str(x)
            elif c < 20:
                str += "" "" + str(x)
            elif c == 20:
                print(str + "" "" + str(x))
 
            # all emirps between 7,700 and 8,000
            elif 7700 <= x <= 8001:
                if last < 7700:
                    str = str(x)
                else:
                    str += "" "" + str(x)
            elif x > 7700 and last < 8001:
                print(str)
 
            # the 10,000th emirp
            elif c == 10000:
                print(str(x))
 
            last = x
        x += 2
 
main()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Two_bullet_roulette,Two bullet roulette,"The following is supposedly a question given to mathematics graduates seeking jobs on Wall Street:


 A revolver handgun has a revolving cylinder with six chambers for bullets.
 It is loaded with the following procedure:
 1. Check the first chamber to the right of the trigger for a bullet. If a bullet
is seen, the cylinder is rotated one chamber clockwise and the next chamber
checked until an empty chamber is found.
 2. A cartridge containing a bullet is placed in the empty chamber.
 3. The cylinder is then rotated one chamber clockwise.
 To randomize the cylinder's position, the cylinder is spun, which causes the cylinder to take
a random position from 1 to 6 chamber rotations clockwise from its starting position.
 When the trigger is pulled the gun will fire if there is a bullet in position 0, which is just
counterclockwise from the loading position.
 The gun is unloaded by removing all cartridges from the cylinder.
 According to the legend, a suicidal Russian imperial military officer plays a game of Russian
roulette by putting two bullets in a six-chamber cylinder and pulls the trigger twice.
If the gun fires with a trigger pull, this is considered a successful suicide.
 The cylinder is always spun before the first shot, but it may or may not be spun after putting
in the first bullet and may or may not be spun after taking the first shot.
 Which of the following situations produces the highest probability of suicide?
 A. Spinning the cylinder after loading the first bullet, and spinning again after the first shot.
 B. Spinning the cylinder after loading the first bullet only.
 C. Spinning the cylinder after firing the first shot only.
 D. Not spinning the cylinder either after loading the first bullet or after the first shot.
 E. The probability is the same for all cases.


Task

 Run a repeated simulation of each of the above scenario, calculating the percentage of suicide with a randomization of the four spinning, loading and firing order scenarios.
 Show the results as a percentage of deaths for each type of scenario.
 The hand calculated probabilities are 5/9, 7/12, 5/9, and 1/2. A correct program should produce results close enough to those to allow a correct response to the interview question. 


Reference

Youtube video on the Russian 1895 Nagant revolver [[1]]



",Python,"import random
 
cylinder = [False] * 6
 
def rShift():
    t = cylinder[-1]
    for i in range(len(cylinder) - 1, 0, -1):
        cylinder[i] = cylinder[i - 1]
    cylinder[0] = t
 
def unload():
    for i in range(len(cylinder)):
        cylinder[i] = False
 
def load():
    while cylinder[0]:
        rShift()
    cylinder[0] = True
    rShift()
 
def spin():
    lim = random.randint(0, 5) + 1
    for i in range(1, lim + 1):
        rShift()
 
def fire():
    shot = cylinder[0]
    rShift()
    return shot
 
def method(s):
    unload()
    for c in s:
        if c == 'L':
            load()
        elif c == 'S':
            spin()
        elif c == 'F':
            if fire():
                return 1
    return 0
 
def mString(s):
    buf = []
    for c in s:
        if c == 'L':
            buf.append(""load"")
        elif c == 'S':
            buf.append(""spin"")
        elif c == 'F':
            buf.append(""fire"")
    return "", "".join(buf)
 
def test(src):
    tests = 100000
    sum = 0
 
    for t in range(tests):
        sum += method(src)
 
    str = mString(src)
    pc = 100.0 * sum / tests
    print(""%-40s produces %6.3f%% deaths."" % (str, pc))
 
test(""LSLSFSF"")
test(""LSLSFF"")
test(""LLSFSF"")
test(""LLSFF"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Perfect_totient_numbers,Perfect totient numbers,"Generate and show here, the first twenty Perfect totient numbers.



Related task

   Totient function


Also see

   the OEIS entry for   perfect totient numbers.
   mrob   list of the first 54

",Python,"# Version 1.3.21
 
def totient(n):
    tot = n
    nn = n
    i = 2
    while i * i <= nn:
        if nn % i == 0:
            while nn % i == 0:
                nn //= i
            tot -= tot // i
        if i == 2:
            i = 1
        i += 2
    if nn > 1:
        tot -= tot // nn
    return tot
 
def main():
    perfect = []
    n = 1
    while len(perfect) < 20:
        tot = n
        sum = 0
        while tot!= 1:
            tot = totient(tot)
            sum += tot
        if sum == n:
            perfect.append(n)
        n += 2
    print(""The first 20 perfect totient numbers are:"")
    print(perfect)
 
main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII,Write language name in 3D ASCII,"Task

Write/display a language's name in 3D ASCII.



(We can leave the definition of ""3D ASCII"" fuzzy,
so long as the result is interesting or amusing,
not a cheap hack to satisfy the task.)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 draw a Deathstar

",Python,"py = '''\
 #####    #   #   #####  #    #   ####   #    #
 #    #    # #      #    #    #  #    #  ##   #
 #    #     #       #    ######  #    #  # #  #
 #####      #       #    #    #  #    #  #  # #
 #          #       #    #    #  #    #  #   ##
 #          #       #    #    #   ####   #    #
'''
 
lines = py.replace('#', '<<<').replace(' ','X').replace('X', '   ').replace('\n', ' Y').replace('< ', '<>').split('Y')
for i, l in enumerate(lines): 
    print( '   ' * (len(lines) - i) + l)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Pinstripe/Display,Pinstripe/Display," Sample image
The task is to demonstrate the creation of a series of vertical pinstripes across the entire width of the display.

 in the first quarter the pinstripes should alternate one pixel white, one pixel black = 1 pixel wide vertical pinestripes
 Quarter of the way down the display, we can switch to a wider 2 pixel wide vertical pinstripe pattern, alternating two pixels white, two pixels black. 
 Half way down the display, we switch to 3 pixels wide, 
 for the lower quarter of the display we use 4 pixels.


c.f. Colour_pinstripe/Display
",Python,"from PIL import Image

def make_pinstripe_image(width, height):
    image = Image.new(""RGB"", (width, height))
    quarter_height = height / 4

    for y in range(height):
        stripe_width = (y / quarter_height) + 1

        for x in range(width):
            color = ((x / stripe_width) % 2) == 0 and (255, 255, 255) or (0, 0, 0)
            image.putpixel((x, y), color)

    return image

if __name__ == ""__main__"":
    pinstripe = make_pinstripe_image(1366, 768)
    pinstripe.save(""pinstripe.png"")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Cheryl%27s_birthday,Cheryl's birthday,"Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.

Cheryl gave them a list of ten possible dates:

     May 15,     May 16,     May 19
     June 17,    June 18
     July 14,    July 16
     August 14,  August 15,  August 17

Cheryl then tells Albert the   month   of birth,   and Bernard the   day   (of the month)   of birth.

 1)  Albert:   I don't know when Cheryl's birthday is, but I know that Bernard does not know too.
 2)  Bernard:  At first I don't know when Cheryl's birthday is, but I know now.
 3)  Albert:   Then I also know when Cheryl's birthday is.



Task
Write a computer program to deduce, by successive elimination, Cheryl's birthday.



Related task

 Sum and Product Puzzle


References
 Wikipedia article of the same name.
 Tuple Relational Calculus

",Python,"from enum import Enum
 
class Month(Enum):
    MAY = 1
    JUNE = 2
    JULY = 3
    AUGUST = 4
 
class Birthday:
    def __init__(self, month, day):
        self.month = month
        self.day = day
 
    def month_unique_in(self, birthdays):
        return len([birthday for birthday in birthdays if birthday.month == self.month]) == 1
 
    def day_unique_in(self, birthdays):
        return len([birthday for birthday in birthdays if birthday.day == self.day]) == 1
 
    def month_with_unique_day_in(self, birthdays):
        return any([birthday for birthday in birthdays if self.month == birthday.month and birthday.day_unique_in(birthdays)])
 
def solution():
    choices = [
        Birthday(Month.MAY, 15),
        Birthday(Month.MAY, 16),
        Birthday(Month.MAY, 19),
        Birthday(Month.JUNE, 17),
        Birthday(Month.JUNE, 18),
        Birthday(Month.JULY, 14),
        Birthday(Month.JULY, 16),
        Birthday(Month.AUGUST, 14),
        Birthday(Month.AUGUST, 15),
        Birthday(Month.AUGUST, 17),
    ]
 
    # Albert knows the month but doesn't know the day.
    # So the month can't be unique within the choices.
    choices = [birthday for birthday in choices if not birthday.month_unique_in(choices)]
 
    # Albert also knows that Bernard doesn't know the answer.
    # So the month can't have a unique day.
    choices = [birthday for birthday in choices if not birthday.month_with_unique_day_in(choices)]
 
    # Bernard now knows the answer.
    # So the day must be unique within the remaining choices.
    choices = [birthday for birthday in choices if birthday.day_unique_in(choices)]
 
    # Albert now knows the answer too.
    # So the month must be unique within the remaining choices.
    choices = [birthday for birthday in choices if birthday.month_unique_in(choices)]
 
    if len(choices) == 1:
        return choices[0]
    else:
        return None
 
if __name__ == ""__main__"":
    solution = solution()
    if solution:
        print(""Cheryl's birthday is {}"".format(solution))
    else:
        print(""Didn't work!"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort,Sorting algorithms/Sleep sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.
",Python,"from time import sleep
from threading import Timer
 
def sleepsort(values):
    sleepsort.result = []
    def add1(x):
        sleepsort.result.append(x)
    mx = values[0]
    for v in values:
        if mx < v: mx = v
        Timer(v, add1, [v]).start()
    sleep(mx+1)
    return sleepsort.result
 
if __name__ == '__main__':
    x = [3,2,4,7,3,6,9,1]
    if sleepsort(x) == sorted(x):
        print('sleep sort worked for:',x)
    else:
        print('sleep sort FAILED for:',x)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"Python 3.2.3 (default, May  3 2012, 15:54:42) 
[GCC 4.6.3] on linux2
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> help('pprint.pprint')
Help on function pprint in pprint:
 
pprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)
    Pretty-print a Python object to a stream [default is sys.stdout].
 
>>> from pprint import pprint
>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),
	          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),
	          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:
	print(""\nTree %r can be pprint'd as:"" % (tree, ))
	pprint(tree, indent=1, width=1)
 
 
 
Tree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:
(1,
 2,
 3,
 4,
 5,
 6,
 7,
 8)
 
Tree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:
(1,
 ((2,
   3),
  (4,
   (5,
    ((6,
      7),
     8)))))
 
Tree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:
((((1,
    2),
   3),
  4),
 5,
 6,
 7,
 8)
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Interactive_programming_(repl),Interactive programming (repl),"Many language implementations come with an interactive mode.

This is a command-line interpreter that reads lines from the user and evaluates these lines as statements or expressions.

An interactive mode may also be known as a command mode,   a read-eval-print loop (REPL),   or a shell.



Task

Show how to start this mode.

Then, as a small example of its use, interactively create a function of two strings and a separator that returns the strings separated by two concatenated instances of the separator   (the 3rd argument).



Example

             f('Rosetta',  'Code',  ':')   

should return

             'Rosetta::Code'               



Note

This task is   not   about creating your own interactive mode.



",Python,"def f(string1, string2, separator):
    return string1 + separator + string2

print(f('Rosetta', 'Code', ':'))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Arithmetic-geometric_mean,Arithmetic-geometric mean,"

 This page uses content from Wikipedia. The original article was at Arithmetic-geometric mean. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Write a function to compute the arithmetic-geometric mean of two numbers.



The arithmetic-geometric mean of two numbers can be (usefully) denoted as 




a
g
m

(
a
,
g
)


{\displaystyle \mathrm {agm} (a,g)}

, and is equal to the limit of the sequence:

 




a

0


=
a
;


g

0


=
g


{\displaystyle a_{0}=a;\qquad g_{0}=g}


 




a

n
+
1


=



1
2



(

a

n


+

g

n


)
;


g

n
+
1


=



a

n



g

n




.


{\displaystyle a_{n+1}={\tfrac {1}{2}}(a_{n}+g_{n});\quad g_{n+1}={\sqrt {a_{n}g_{n}}}.}


Since the limit of 




a

n


−

g

n




{\displaystyle a_{n}-g_{n}}

 tends (rapidly) to zero with iterations, this is an efficient method.

Demonstrate the function by calculating:






a
g
m

(
1
,
1

/



2


)


{\displaystyle \mathrm {agm} (1,1/{\sqrt {2}})}




Also see

   mathworld.wolfram.com/Arithmetic-Geometric Mean

",Python,"def agm(a0, g0):
    an = (a0 + g0) / 2
    gn = (a0 * g0) ** 0.5
    while abs(an - gn) > tolerance:
        an = (an + gn) / 2
        gn = (an * gn) ** 0.5
    return an

agm(1, 1 / 2 ** 0.5)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,"import numpy as np

# givens
values = np.array([7, 6, 5, 4, 3, 2, 1, 0])
indices = {6: 0, 1: 0, 7: 0}

orderedValues = np.zeros(len(indices))
orderedIndices = np.zeros(len(indices))
i = 0
for j in indices:
    # validate that indices are within list boundaries
    if j < 0 or j >= len(values):
        print(""Invalid index: "", j)
        return
    # extract elements to sort
    orderedValues[i] = values[j]
    orderedIndices[i] = j
    i += 1
# sort
orderedValues = np.sort(orderedValues)
orderedIndices = np.sort(orderedIndices)

print(""initial:"", values)
# replace sorted values
for i, v in enumerate(orderedValues):
    values[orderedIndices[i]] = v
print(""sorted: "", values)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Non-decimal_radices/Input,Non-decimal radices/Input,"It is common to have a string containing a number written in some format, with the most common ones being decimal, hexadecimal, octal and binary. Such strings are found in many places (user interfaces, configuration files, XML data, network protocols, etc.)

This task requires parsing of such a string (which may be assumed to contain nothing else) using the language's built-in facilities if possible. Parsing of decimal strings is required, parsing of other formats is optional but should be shown (i.e., if the language can parse in base-19 then that should be illustrated).

The solutions may assume that the base of the number in the string is known. In particular, if your language has a facility to guess the base of a number by looking at a prefix (e.g. ""0x"" for hexadecimal) or other distinguishing syntax as it parses it, please show that.

The reverse operation is in task Non-decimal radices/Output

For general number base conversion, see Non-decimal radices/Convert.
",Python,">>> text = '100'
>>> for base in range(2,21):
    print (""String '%s' in base %i is  %i in base 10"" 
           % (text, base, int(text, base)))
 
 
String '100' in base 2 is  4 in base 10
String '100' in base 3 is  9 in base 10
String '100' in base 4 is  16 in base 10
String '100' in base 5 is  25 in base 10
String '100' in base 6 is  36 in base 10
String '100' in base 7 is  49 in base 10
String '100' in base 8 is  64 in base 10
String '100' in base 9 is  81 in base 10
String '100' in base 10 is  100 in base 10
String '100' in base 11 is  121 in base 10
String '100' in base 12 is  144 in base 10
String '100' in base 13 is  169 in base 10
String '100' in base 14 is  196 in base 10
String '100' in base 15 is  225 in base 10
String '100' in base 16 is  256 in base 10
String '100' in base 17 is  289 in base 10
String '100' in base 18 is  324 in base 10
String '100' in base 19 is  361 in base 10
String '100' in base 20 is  400 in base 10",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Benford%27s_law,Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",Python,"from __future__ import division
from itertools import islice, count
from collections import Counter
from math import log10
from random import randint
 
expected = [log10(1+1/d) for d in range(1,10)]
 
def fib():
    a,b = 1,1
    while True:
        yield a
        a,b = b,a+b
 
# powers of 3 as a test sequence
def power_of_threes():
    return (3**k for k in count(0))
 
def heads(s):
    for a in s: yield int(str(a)[0])
 
def show_dist(title, s):
    c = Counter(s)
    size = sum(c.values())
    res = [c[d]/size for d in range(1,10)]
 
    print(""\n%s Benfords deviation"" % title)
    for r, e in zip(res, expected):
        print(""%5.1f%% %5.1f%%  %5.1f%%"" % (r*100., e*100., abs(r - e)*100.))
 
def rand1000():
    while True: yield randint(1,9999)
 
if __name__ == '__main__':
    show_dist(""fibbed"", islice(heads(fib()), 1000))
    show_dist(""threes"", islice(heads(power_of_threes()), 1000))
 
    # just to show that not all kind-of-random sets behave like that
    show_dist(""random"", islice(heads(rand1000()), 10000))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",Python,"class PythagoranTriplesCounter:
    def __init__(self, limit):
        self.limit = limit
        self.total = 0
        self.primitives = 0
        self.generate_triples(3, 4, 5)

    def generate_triples(self, a, b, c):
        perim = a + b + c
        if perim > self.limit:
            return

        self.primitives += 1
        self.total += self.limit / perim

        self.generate_triples(a - 2 * b + 2 * c, 2 * a - b + 2 * c, 2 * a - 2 * b + 3 * c)
        self.generate_triples(a + 2 * b + 2 * c, 2 * a + b + 2 * c, 2 * a + 2 * b + 3 * c)
        self.generate_triples(-a + 2 * b + 2 * c, -2 * a + b + 2 * c, -2 * a + 2 * b + 3 * c)

perim = 10
while perim <= 100_000_000:
    c = PythagoranTriplesCounter(perim)
    print([perim, c.total, c.primitives])
    perim *= 10",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"import sys
print(sys.getrecursionlimit())",Human_written,Python_from_Java
http://rosettacode.org/wiki/Anagrams,Anagrams,"When two or more words are composed of the same characters, but in a different order, they are called anagrams.

Task[edit]
Using the word list at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

find the sets of words that share the same characters that contain the most words in them.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import unicodedata
import collections
import itertools
 
def main():
    with open(""unixdict.txt"") as f:
        words = [line.strip() for line in f]
 
    anagrams = collections.defaultdict(list)
    for word in words:
        # Codepoints:
        # key = tuple(sorted(word))
        # Bytes:
        # key = tuple(sorted(word.encode('utf-8')))
        # Graphemes:
        key = tuple(sorted(unicodedata.normalize('NFD', word)))
        anagrams[key].append(word)
 
    max_len = max(len(v) for v in anagrams.values())
    for v in anagrams.values():
        if len(v) == max_len:
            print(' '.join(v))
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"class ABC_block_checker:
    def run(self):
        print(""\""\"": "" + self.blocks.canMakeWord(""""))
        for w in self.words:
            print(w + "": "" + self.blocks.canMakeWord(w))

    def swap(self, i, j):
        tmp = self.blocks[i]
        self.blocks[i] = self.blocks[j]
        self.blocks[j] = tmp

    def canMakeWord(self, word):
        if len(word) == 0:
            return True

        c = word[0].upper()
        i = 0
        for b in self.blocks:
            if b[0].upper() == c or b[1].upper() == c:
                self.swap(0, i)
                if self.canMakeWord(word[1:]):
                    return True
                self.swap(0, i)
            i += 1

        return False

    blocks = [""BO"", ""XK"", ""DQ"", ""CP"", ""NA"", ""GT"", ""RE"", ""TG"", ""QD"", ""FS"", ""JW"", ""HU"", ""VI"", ""AN"", ""OB"", ""ER"", ""FS"", ""LY"", ""PC"", ""ZM""]
    words = [""A"", ""BARK"", ""book"", ""treat"", ""COMMON"", ""SQuAd"", ""CONFUSE""]

if __name__ == ""__main__"":
    ABC_block_checker().run()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Terminal_control/Ringing_the_terminal_bell,Terminal control/Ringing the terminal bell,"

Task

Make the terminal running the program ring its ""bell"".



On modern terminal emulators, this may be done by playing some other sound which might or might not be configurable, or by flashing the title bar or inverting the colors of the screen, but was classically a physical bell within the terminal.   It is usually used to indicate a problem where a wrong character has been typed.

In most terminals, if the   Bell character   (ASCII code 7,    \a  in C)   is printed by the program, it will cause the terminal to ring its bell.   This is a function of the terminal, and is independent of the programming language of the program, other than the ability to print a particular character to standard out.



",Python,"print ""\a""",Human_written,Python_from_Go
http://rosettacode.org/wiki/Search_a_list,Search a list,"Task[edit]
Find the index of a string (needle) in an indexable, ordered collection of strings (haystack).

Raise an exception if the needle is missing.

If there is more than one occurrence then return the smallest index to the needle.

Extra credit
Return the largest index to a needle that has multiple occurrences in the haystack.

See also
 Search a list of records
",Python,"haystack=[""Zig"",""Zag"",""Wally"",""Ronald"",""Bush"",""Krusty"",""Charlie"",""Bush"",""Bozo""]
 
for needle in (""Washington"",""Bush""):
  try:
    print haystack.index(needle), needle
  except ValueError, value_error:
    print needle,""is not in haystack""",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sierpinski_arrowhead_curve,Sierpinski arrowhead curve,"Task
Produce a graphical or ASCII-art representation of a  Sierpinski arrowhead curve  of at least order  3.



",Python,"import math
import svgwrite
 
def sierpinski_arrowhead_next(points):
    size = len(points)
    output = [None] * (3 * (size - 1) + 1)
    x0, y0, x1, y1 = 0, 0, 0, 0
    j = 0
    for i in range(size - 1):
        x0 = points[i][0]
        y0 = points[i][1]
        x1 = points[i + 1][0]
        y1 = points[i + 1][1]
        dx = x1 - x0
        output[j] = (x0, y0)
        if y0 == y1:
            d = dx * math.sqrt(3) / 2
            if d < 0:
                d = -d
            output[j + 1] = (x0 + dx / 4, y0 - d)
            output[j + 2] = (x1 - dx / 4, y0 - d)
        elif y1 < y0:
            output[j + 1] = (x1, y0)
            output[j + 2] = (x1 + dx / 2, (y0 + y1) / 2)
        else:
            output[j + 1] = (x0 - dx / 2, (y0 + y1) / 2)
            output[j + 2] = (x0, y1)
        j += 3
    output[j] = (x1, y1)
    return output
 
def write_sierpinski_arrowhead(filename, size, iterations):
    dwg = svgwrite.Drawing(filename, (size, size))
    dwg.add(dwg.rect((0, 0), (size, size), fill='white'))
    path = dwg.path(stroke_width=1, stroke='black', fill='none')
    margin = 20
    side = size - 2 * margin
    x = margin
    y = 0.5 * size + 0.5 * math.sqrt(3) * side
    points = [(x, y), (x + side, y)]
    for i in range(iterations):
        points = sierpinski_arrowhead_next(points)
    d = 'M'
    for x, y in points:
        d += '%s,%s'% (x, y)
    path.d = d
    dwg.add(path)
    dwg.save()
 
if __name__ == '__main__':
    write_sierpinski_arrowhead('sierpinski_arrowhead.svg', 600, 8)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Quadratic,Bitmap/Bézier curves/Quadratic,"Using the data storage type defined on this page for raster images, and the draw_line function defined in this one, draw a quadratic bezier curve
(definition on Wikipedia).
",Python,"# Version 1.2.40
 
from PIL import Image, ImageDraw
from math import abs
 
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
class BasicBitmapStorage:
    def __init__(self, width, height):
        self.image = Image.new(""RGB"", (width, height))
        self.draw = ImageDraw.Draw(self.image)
 
    def fill(self, c):
        self.draw.rectangle((0, 0, self.image.width, self.image.height), fill=c)
 
    def setPixel(self, x, y, c):
        self.image.putpixel((x, y), c)
 
    def getPixel(self, x, y):
        return self.image.getpixel((x, y))
 
    def drawLine(self, x0, y0, x1, y1, c):
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        xx = x0
        yy = y0
        e1 = (dx if dx > dy else -dy) / 2
        e2 = 0
        while True:
            self.setPixel(xx, yy, c)
            if xx == x1 and yy == y1:
                break
            e2 = e1
            if e2 > -dx:
                e1 -= dy
                xx += sx
            if e2 < dy:
                e1 += dx
                yy += sy
 
    def quadraticBezier(self, p1, p2, p3, clr, n):
        pts = [Point(0, 0) for _ in range(n + 1)]
        for i in range(n + 1):
            t = i / n
            u = 1.0 - t
            a = u * u
            b = 2.0 * t * u
            c = t * t
            pts[i].x = int(a * p1.x + b * p2.x + c * p3.x)
            pts[i].y = int(a * p1.y + b * p2.y + c * p3.y)
            self.setPixel(pts[i].x, pts[i].y, clr)
        for i in range(n):
            j = i + 1
            self.drawLine(pts[i].x, pts[i].y, pts[j].x, pts[j].y, clr)
 
def main():
    width = 320
    height = 320
    bbs = BasicBitmapStorage(width, height)
    with bbs:
        bbs.fill((0, 255, 255))
        p1 = Point(10, 100)
        p2 = Point(250, 270)
        p3 = Point(150, 20)
        bbs.quadraticBezier(p1, p2, p3, (0, 0, 0), 20)
        qbFile = ""quadratic_bezier.jpg""
        bbs.image.save(qbFile)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",Python,"import re
 
def csvToHTML( csvtext ):
   #the order of the regexes and the replacements is decisive!
   regexes = [ ""<"", "">"", ""^(.+?)\\b"", "","", ""\n"" ]
   replacements = [ ""&lt;"", ""&gt;"", ""    <TR><TD>$1"", ""</TD><TD>"", ""</TD></TR>\n""  ]
   tabletext = re.sub( regexes[ 0 ], replacements[ 0 ], csvtext, re.MULTILINE )
   for i in range( 1, 5 ):
      tabletext = re.sub( regexes[ i ], replacements[ i ], tabletext, re.MULTILINE )
   tabletext = ""<TABLE>\n"" + tabletext
   tabletext += ""</TABLE>\n""
   return tabletext
 
if __name__ == ""__main__"":
   text = ""Character,Speech\n"" + \
          ""The multitude,The messiah! Show us the messiah!\n"" + \
          ""Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>\n"" + \
          ""The multitude,Who are you?\n"" + \
          ""Brians mother,I'm his mother; that's who!\n"" + \
          ""The multitude,Behold his mother! Behold his mother!\n""
   print csvToHTML( text )",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Statistics/Normal_distribution,Statistics/Normal distribution,"The Normal (or Gaussian) distribution is a frequently used distribution in statistics. While most programming languages provide a uniformly distributed random number generator, one can derive normally distributed random numbers from a uniform generator.



The task

 Take a uniform random number generator and create a large (you decide how large) set of numbers that follow a normal (Gaussian) distribution. Calculate the dataset's mean and standard deviation, and show a histogram of the data.
 Mention any native language support for the generation of normally distributed random numbers.


Reference

 You may refer to code in Statistics/Basic if available.

",Python,"# Class to implement a Normal distribution, generated from a Uniform distribution.
# Uses the Marsaglia polar method.

class NormalFromUniform:
    # Initialize an instance.
    def __init__(self):
        self.next = None

    # Generate and return the next Normal distribution value.
    def rand(self):
        if self.next:
            retval, self.next = self.next, None
            return retval
        else:
            u = v = s = None
            while True:
                u = random.uniform(-1.0, 1.0)
                v = random.uniform(-1.0, 1.0)
                s = u**2 + v**2
                if (s > 0.0) and (s <= 1.0):
                    break
            f = math.sqrt(-2.0 * math.log(s) / s)
            self.next = v * f
            return u * f",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Palindrome_dates,Palindrome dates,"Today   (2020-02-02,   at the time of this writing)   happens to be a palindrome,   without the hyphens,   not only for those countries which express their dates in the   yyyy-mm-dd   format but,   unusually,   also for countries which use the   dd-mm-yyyy   format.



Task
Write a program which calculates and shows the next 15 palindromic dates for those countries which express their dates in the   yyyy-mm-dd   format.



",Python,"'''Palindrome dates'''
 
from datetime import datetime
from itertools import chain
 
 
# palinDay :: Int -> [ISO Date]
def palinDay(y):
    '''A possibly empty list containing the palindromic
       date for the given year, if such a date exists.
    '''
    s = str(y)
    r = s[::-1]
    iso = '-'.join([s, r[0:2], r[2:]])
    try:
        datetime.strptime(iso, '%Y-%m-%d')
        return [iso]
    except ValueError:
        return []
 
 
# --------------------------TEST---------------------------
# main :: IO ()
def main():
    '''Count and samples of palindromic dates [2021..9999]
    '''
    palinDates = list(chain.from_iterable(
        map(palinDay, range(2021, 10000))
    ))
    for x in [
            'Count of palindromic dates [2021..9999]:',
            len(palinDates),
            '\nFirst 15:',
            '\n'.join(palinDates[0:15]),
            '\nLast 15:',
            '\n'.join(palinDates[-15:])
    ]:
        print(x)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Python,"print('Enter width and height: ')
w = int(input())
arr = [[0 for x in range(w)] for y in range(int(input()))]
arr[1][3] = 5
print(arr[1][3])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Boolean_values,Boolean values,"Task

Show how to represent the boolean states ""true"" and ""false"" in a language.

If other objects represent ""true"" or ""false"" in conditionals, note it.



Related tasks

   Logical operations

",Python,"# Rust contains a single boolean type: `bool`, represented by the keywords `true` and `false`.
# Expressions inside `if` and `while` statements must result in type `bool`. There is no
# automatic conversion to the boolean type.
 
true_value = True
if true_value:
    print(""foo is {}."".format(true_value))
 
false_value = False
if not false_value:
    print(""bar is {}."".format(false_value))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",Python,"def maxsubseq(seq):
  return max((seq[begin:end] for begin in xrange(len(seq)+1)
                             for end in xrange(begin, len(seq)+1)),
             key=sum)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Loops/Infinite,Loops/Infinite,"Task

Print out        SPAM        followed by a   newline   in an infinite loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"while True:
    print(""SPAM"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Pernicious_numbers,Pernicious numbers,"A   pernicious number   is a positive integer whose   population count   is a prime.

The   population count   is the number of   ones   in the binary representation of a non-negative integer.



Example
22   (which is   10110   in binary)   has a population count of   3,   which is prime,   and therefore

22   is a pernicious number.



Task
 display the first   25   pernicious numbers   (in decimal).
 display all pernicious numbers between   888,888,877   and   888,888,888   (inclusive).
 display each list of integers on one line   (which may or may not include a title).


See also
 Sequence   A052294 pernicious numbers on The On-Line Encyclopedia of Integer Sequences.
 Rosetta Code entry   population count, evil numbers, odious numbers.

",Python,">>> def popcount(n): return bin(n).count(""1"")
 
>>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}
>>> p, i = [], 0
>>> while len(p) < 25:
        if popcount(i) in primes: p.append(i)
        i += 1
 
 
>>> p
[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]
>>> p, i = [], 888888877
>>> while i <= 888888888:
        if popcount(i) in primes: p.append(i)
        i += 1
 
 
>>> p
[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Gamma_function,Gamma function,"Task

Implement one algorithm (or more) to compute the Gamma (



Γ


{\displaystyle \Gamma }

) function (in the real field only).

If your language has the function as built-in or you know a library which has it, compare your implementation's results with the results of the built-in/library function.

The Gamma function can be defined as:

  



Γ
(
x
)
=


∫

0


∞



t

x
−
1



e

−
t


d
t



{\displaystyle \Gamma (x)=\displaystyle \int _{0}^{\infty }t^{x-1}e^{-t}dt}


This suggests a straightforward (but inefficient) way of computing the 



Γ


{\displaystyle \Gamma }

 through numerical integration.



Better suggested methods:

 Lanczos approximation
 Stirling's approximation

",Python,"import math

class GammaFunction:
	def st_gamma(self, x):
		return math.sqrt(2*math.pi/x)*math.pow((x/math.e), x)

	def la_gamma(self, x):
		p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
			     	  771.32342877765313, -176.61502916214059, 12.507343278686905,
			     	  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7]
		g = 7
		if(x < 0.5):
			return math.pi / (math.sin(math.pi * x)*self.la_gamma(1-x))

		x -= 1
		a = p[0]
		t = x+g+0.5
		for i in range(1, len(p)):
			a += p[i]/(x+i)

		return math.sqrt(2*math.pi)*math.pow(t, x+0.5)*math.exp(-t)*a

if __name__ == ""__main__"":
	test = GammaFunction()
	print(""Gamma \t\tStirling \t\tLanczos"")
	for i in range(1, 21):
		print(str(i/10.0) + ""\t\t"" + str(test.st_gamma(i/10.0)) + ""\t"" + str(test.la_gamma(i/10.0)))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Monte_Carlo_methods,Monte Carlo methods,"A Monte Carlo Simulation is a way of approximating the value of a function
where calculating the actual value is difficult or impossible. 

It uses random sampling to define constraints on the value
and then makes a sort of ""best guess.""

A simple Monte Carlo Simulation can be used to calculate the value for 



π


{\displaystyle \pi }

.

If you had a circle and a square where the length of a side of the square
was the same as the diameter of the circle, the ratio of the area of the circle
to the area of the square would be 



π

/

4


{\displaystyle \pi /4}

.

So, if you put this circle inside the square and select many random points
inside the square, the number of points inside the circle
divided by the number of points inside the square and the circle
would be approximately 



π

/

4


{\displaystyle \pi /4}

.



Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number 



π


{\displaystyle \pi }

 is not built-in,
we give 



π


{\displaystyle \pi }

 as a number of digits:

            3.141592653589793238462643383280


",Python,">>> import random, math
>>> throws = 1000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1520000000000001
>>> throws = 1000000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1396359999999999
>>> throws = 100000000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1415666400000002",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Chinese_remainder_theorem,Chinese remainder theorem,"Suppose   




n

1




{\displaystyle n_{1}}

,   




n

2




{\displaystyle n_{2}}

,   



…


{\displaystyle \ldots }

,   




n

k




{\displaystyle n_{k}}

   are positive integers that are pairwise co-prime.  

Then, for any given sequence of integers   




a

1




{\displaystyle a_{1}}

,   




a

2




{\displaystyle a_{2}}

,   



…


{\displaystyle \dots }

,   




a

k




{\displaystyle a_{k}}

,   there exists an integer   



x


{\displaystyle x}

   solving the following system of simultaneous congruences:

 







x



≡

a

1




(
mod


n

1


)





x



≡

a

2




(
mod


n

2


)








 
 
⋮




x



≡

a

k




(
mod


n

k


)







{\displaystyle {\begin{aligned}x&\equiv a_{1}{\pmod {n_{1}}}\\x&\equiv a_{2}{\pmod {n_{2}}}\\&{}\ \ \vdots \\x&\equiv a_{k}{\pmod {n_{k}}}\end{aligned}}}


Furthermore, all solutions   



x


{\displaystyle x}

   of this system are congruent modulo the product,   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

.



Task

Write a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.

If the system of equations cannot be solved, your program must somehow indicate this.

(It may throw an exception or return a special false value.)

Since there are infinitely many solutions, the program should return the unique solution   



s


{\displaystyle s}

   where   



0
≤
s
≤

n

1



n

2


…

n

k




{\displaystyle 0\leq s\leq n_{1}n_{2}\ldots n_{k}}

.


Show the functionality of this program by printing the result such that the   



n


{\displaystyle n}

's   are   



[
3
,
5
,
7
]


{\displaystyle [3,5,7]}

   and the   



a


{\displaystyle a}

's   are   



[
2
,
3
,
2
]


{\displaystyle [2,3,2]}

.


Algorithm:   The following algorithm only applies if the   




n

i




{\displaystyle n_{i}}

's   are pairwise co-prime.

Suppose, as above, that a solution is required for the system of congruences:

 



x
≡

a

i




(
mod


n

i


)



f
o
r


i
=
1
,
…
,
k


{\displaystyle x\equiv a_{i}{\pmod {n_{i}}}\quad \mathrm {for} \;i=1,\ldots ,k}


Again, to begin, the product   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

   is defined.

Then a solution   



x


{\displaystyle x}

   can be found as follows:

For each   



i


{\displaystyle i}

,   the integers   




n

i




{\displaystyle n_{i}}

   and   



N

/


n

i




{\displaystyle N/n_{i}}

   are co-prime.

Using the   Extended Euclidean algorithm,   we can find integers   




r

i




{\displaystyle r_{i}}

   and   




s

i




{\displaystyle s_{i}}

   such that   




r

i



n

i


+

s

i


N

/


n

i


=
1


{\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}

.

Then, one solution to the system of simultaneous congruences is:

 



x
=

∑

i
=
1


k



a

i



s

i


N

/


n

i




{\displaystyle x=\sum _{i=1}^{k}a_{i}s_{i}N/n_{i}}


and the minimal solution,

 



x


(
mod

N
)



{\displaystyle x{\pmod {N}}}

.

",Python,"def mul_inv(a, b):
	b0 = b
	x0, x1 = 0, 1
	if b == 1: return 1
	while a > 1:
		q = a / b
		a, b = b, a%b
		x0, x1 = x1 - q * x0, x0
	if x1 < 0: x1 += b0
	return x1
 
def chinese_remainder(n, a):
	prod = reduce(lambda a, b: a*b, n)
	sum = 0
	for n_i, a_i in zip(n, a):
		p = prod / n_i
		sum += a_i * mul_inv(p, n_i) * p
	return sum % prod
 
n = [3,5,7]
a = [2,3,2]
print chinese_remainder(n, a)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Chinese_zodiac,Chinese zodiac,"Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the ""celestial stems"") and one of length 12 (the ""terrestrial branches""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known ""Chinese zodiac"", assigning each year to a given animal. For example, Tuesday, February 1, 2022 CE (in the common Gregorian calendar) will begin the lunisolar Year of the Tiger.

The celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.

Thus, 2022 is also the yang year of Water. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the specifically-male English animal name and the female aspect denoted by yin.

Task
 Create a subroutine or program that will return or output the animal, yin/yang association, and element for the lunisolar year that begins in a given CE year.
You may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).

Requisite information

 The animal cycle runs in this order: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.
 The element cycle runs in this order: Wood, Fire, Earth, Metal, Water.
 The yang year precedes the yin year within each element.
 The current 60-year cycle began in 1984 CE; the first cycle of the Common Era began in 4 CE.
Thus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2022 - which, as already noted, is the year of the Water Tiger (yang) - is the 39th year of the current cycle.

Information for optional task

 The ten celestial stems are 甲 jiă, 乙 yĭ, 丙 bĭng, 丁 dīng, 戊 wù, 己 jĭ, 庚 gēng, 辛 xīn, 壬 rén, and 癸 gŭi. With the ASCII version of Pinyin tones, the names are written ""jia3"", ""yi3"", ""bing3"", ""ding1"", ""wu4"", ""ji3"", ""geng1"", ""xin1"", ""ren2"", and ""gui3"".
 The twelve terrestrial branches are 子 zĭ, 丑 chŏu, 寅 yín, 卯 măo, 辰 chén, 巳 sì, 午 wŭ, 未 wèi, 申 shēn, 酉 yŏu, 戌 xū, 亥 hài. In ASCII Pinyin, those are ""zi3"", ""chou3"", ""yin2"", ""mao3"", ""chen2"", ""si4"", ""wu3"", ""wei4"", ""shen1"", ""you3"", ""xu1"", and ""hai4"".
Therefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2022 is 壬寅 (rén-yín or ren2-yin2).
",Python,"# coding: utf-8
 
from __future__ import print_function
from datetime import datetime
 
pinyin = {
  '甲': 'jiă',
  '乙': 'yĭ',
  '丙': 'bĭng',
  '丁': 'dīng',
  '戊': 'wù',
  '己': 'jĭ',
  '庚': 'gēng',
  '辛': 'xīn',
  '壬': 'rén',
  '癸': 'gŭi',
 
  '子': 'zĭ',
  '丑': 'chŏu',
  '寅': 'yín',
  '卯': 'măo',
  '辰': 'chén',
  '巳': 'sì',
  '午': 'wŭ',
  '未': 'wèi',
  '申': 'shēn',
  '酉': 'yŏu',
  '戌': 'xū',
  '亥': 'hài'
}
 
animals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',
           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']
elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
celestial = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']
terrestrial = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']
aspects = ['yang', 'yin']
 
 
def calculate(year):
    BASE = 4
    year = int(year)
    cycle_year = year - BASE
    stem_number = cycle_year % 10
    stem_han = celestial[stem_number]
    stem_pinyin = pinyin[stem_han]
    element_number = stem_number // 2
    element = elements[element_number]
    branch_number = cycle_year % 12
    branch_han = terrestrial[branch_number]
    branch_pinyin = pinyin[branch_han]
    animal = animals[branch_number]
    aspect_number = cycle_year % 2
    aspect = aspects[aspect_number]
    index = cycle_year % 60 + 1
    print(""{}: {}{} ({}-{}, {} {}; {} - year {} of the cycle)""
          .format(year, stem_han, branch_han,
                  stem_pinyin, branch_pinyin, element, animal, aspect, index))
 
 
current_year = datetime.now().year
years = [1935, 1938, 1968, 1972, 1976, current_year]
for year in years:
    calculate(year)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Python,"from turtle import *
from math import *
color(""blue"")
down()
for i in range(200):
    t = i / 20 * pi
    x = (1 + 5 * t) * cos(t)
    y = (1 + 5 * t) * sin(t)
    goto(x, y)
up()
done()",Human_written,Python_from_C
http://rosettacode.org/wiki/Jensen%27s_Device,Jensen's Device,"Jensen's Device

You are encouraged to solve this task according to the task description, using any language you may know.
This task is an exercise in call by name.

Jensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.

The following program was proposed to illustrate the technique. It computes the 100th harmonic number:

begin
   integer i;
   real procedure sum (i, lo, hi, term);
      value lo, hi;
      integer i, lo, hi;
      real term;
      comment term is passed by-name, and so is i;
   begin
      real temp;
      temp := 0;
      for i := lo step 1 until hi do
         temp := temp + term;
      sum := temp
   end;
   comment note the correspondence between the mathematical notation and the call to sum;
   print (sum (i, 1, 100, 1/i))
end

The above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.

Moreover, the first parameter to sum, representing the ""bound"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.
(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)

Donald Knuth later proposed the Man or Boy Test as a more rigorous exercise.



",Python,"class Ref(object):
    def __init__(self, value=None):
        self.value = value
 
def harmonic_sum(i, lo, hi, term):
    # term is passed by-name, and so is i
    temp = 0
    i.value = lo
    while i.value <= hi:  # Python ""for"" loop creates a distinct which
        temp += term() # would not be shared with the passed ""i""
        i.value += 1   # Here the actual passed ""i"" is incremented.
    return temp
 
i = Ref()
 
# note the correspondence between the mathematical notation and the
# call to sum it's almost as good as sum(1/i for i in range(1,101))
print harmonic_sum(i, 1, 100, lambda: 1.0/i.value)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape,Create a file on magnetic tape,"The task is to create a new file called ""TAPE.FILE"" of any size on Magnetic Tape.
",Python,">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\n')
... 
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Pythagorean_quadruples,Pythagorean quadruples,"

One form of   Pythagorean quadruples   is   (for positive integers   a,   b,   c,   and   d):



    a2   +   b2   +   c2     =     d2 


An example:

    22   +   32   +   62     =     72 
 which is:
    4    +   9    +   36     =     49 


Task

For positive integers up   2,200   (inclusive),   for all values of   a,  
b,   c,   and   d,

find   (and show here)   those values of   d   that   can't   be represented.

Show the values of   d   on one line of output   (optionally with a title).



Related tasks

   Euler's sum of powers conjecture. 
   Pythagorean triples.


Reference

   the Wikipedia article:   Pythagorean quadruple.

",Python,"def quad(top=2200):
    r = [False] * top
    ab = [False] * (top * 2)**2
    for a in range(1, top):
        for b in range(a, top):
            ab[a * a + b * b] = True
    s = 3
    for c in range(1, top):
        s1, s, s2 = s, s + 2, s + 2
        for d in range(c + 1, top):
            if ab[s1]:
                r[d] = True
            s1 += s2
            s2 += 2
    return [i for i, val in enumerate(r) if not val and i]
 
if __name__ == '__main__':
    n = 2200
    print(f""Those values of d in 1..{n} that can't be represented: {quad(n)}"")",Human_written,Python_from_Java
http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import deque
stack = deque()
stack.append(value) # pushing
value = stack.pop()
not stack # is empty?",Human_written,Python_from_Go
http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",Python,"class Doc(object):
   """"""
   This is a class docstring. Traditionally triple-quoted strings are used because
   they can span multiple lines and you can include quotation marks without escaping.
   """"""
   def method(self, num):
      """"""This is a method docstring.""""""
      pass",Human_written,Python_from_C
http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"for i in range(32,128):
    if i == 32 or i == 127:
        s = ""Spc"" if i == 32 else ""Del""
        print(""%3d: %s "" % (i, s), end="""")
    else:
        print(""%3d: %c   "" % (i, i), end="""")
    if (i-1) % 6 == 0:
        print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sleeping_Beauty_problem,Sleeping Beauty problem,"Background on the task
In decision theory, The Sleeping Beauty Problem
is a problem invented by Arnold Zoboff and first publicized on Usenet. The experimental
subject, named Sleeping Beauty, agrees to an experiment as follows:
Sleeping Beauty volunteers to be put into a deep sleep on a Sunday. There is then a fair coin toss.
If this coin toss comes up heads, Sleeping Beauty wakes once (on Monday) and is asked to
estimate the probability that the coin toss was heads. Her estimate is recorded and she is
then put back to sleep for 2 days until Wednesday, at which time the experiment's results are tallied.



If instead the coin toss is tails, Sleeping Beauty wakes as before on Monday and asked to
estimate the probability the coin toss was heads, but is then given a drug which makes her forget
that she had been woken on Monday before being put back to sleep again. She then wakes only 1 day
later, on Tuesday. She is then asked (on Tuesday) again to guess the probability that the coin toss
was heads or tails. She is then put back to sleep and awakes as before 1 day later, on Wednesday.



Some decision makers have argued that since the coin toss was fair Sleeping Beauty should always
estimate the probability of heads as 1/2, since she does not have any additional information. Others
have disagreed, saying that if Sleeping Beauty knows the study design she also knows that she is twice
as likely to wake up and be asked to estimate the coin flip on tails than on heads, so the estimate
should be 1/3 heads.

Task
Given the above problem, create a Monte Carlo estimate of the actual results. The program should find the
proportion of heads on waking and asking Sleeping Beauty for an estimate, as a credence or as a percentage of the times Sleeping Beauty
is asked the question.


",Python,"import random
import rcu
 
def sleeping_beauty(reps):
    wakings = 0
    heads = 0
    for i in range(reps):
        coin = random.randint(0, 1)
        wakings += 1
        if coin == 0:
            heads += 1
        else:
            wakings += 1
    print(""Wakings over {} repetitions = {}"".format(rcu.commatize(reps), rcu.commatize(wakings)))
    return heads / wakings * 100
 
if __name__ == ""__main__"":
    pc = sleeping_beauty(1000000)
    print(""Percentage probability of heads on waking = {}%"".format(pc))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Conway%27s_Game_of_Life,Conway's Game of Life,"The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.

Conway's game of life is described   here:

A cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.

We calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:

   C   N                 new C
   1   0,1             ->  0  # Lonely
   1   4,5,6,7,8       ->  0  # Overcrowded
   1   2,3             ->  1  # Lives
   0   3               ->  1  # It takes three to give birth!
   0   0,1,2,4,5,6,7,8 ->  0  # Barren

Assume cells beyond the boundary are always dead.

The ""game"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.



Task

Although you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.



References

   Its creator John Conway, explains   the game of life.   Video from numberphile on youtube.
   John Conway   Inventing Game of Life   - Numberphile video.


Related task

   Langton's ant   - another well known cellular automaton.

",Python,"import random
from collections import defaultdict
 
printdead, printlive = '-#'
maxgenerations = 3
cellcount = 3,3
celltable = defaultdict(int, {
 (1, 2): 1,
 (1, 3): 1,
 (0, 3): 1,
 } ) # Only need to populate with the keys leading to life
 
##
## Start States
##
# blinker
u = universe = defaultdict(int)
u[(1,0)], u[(1,1)], u[(1,2)] = 1,1,1
 
## toad
#u = universe = defaultdict(int)
#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1
#u[(6,6)], u[(6,7)], u[(6,8)] = 1,1,1
 
## glider
#u = universe = defaultdict(int)
#maxgenerations = 16
#u[(5,5)], u[(5,6)], u[(5,7)] = 1,1,1
#u[(6,5)] = 1
#u[(7,6)] = 1
 
## random start
#universe = defaultdict(int, 
#                       # array of random start values
#                       ( ((row, col), random.choice((0,1)))
#                         for col in range(cellcount[0])
#                         for row in range(cellcount[1])
#                       ) )  # returns 0 for out of bounds
 
for i in range(maxgenerations):
    print(""\nGeneration %3i:"" % ( i, ))
    for row in range(cellcount[1]):
        print(""  "", ''.join(str(universe[(row,col)])
                            for col in range(cellcount[0])).replace(
                                '0', printdead).replace('1', printlive))
    nextgeneration = defaultdict(int)
    for row in range(cellcount[1]):
        for col in range(cellcount[0]):
            nextgeneration[(row,col)] = celltable[
                ( universe[(row,col)],
                  -universe[(row,col)] + sum(universe[(r,c)]
                                             for r in range(row-1,row+2)
                                             for c in range(col-1, col+2) )
                ) ]
    universe = nextgeneration",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",Python,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char *s = ""Hello World!"";
    printf(""%s\n"", s);
    return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Floyd%27s_triangle,Floyd's triangle,"Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where

 the first row is   1     (unity)
 successive rows start towards the left with the next number followed by successive naturals listing one more number than the line above.


The first few lines of a Floyd triangle looks like this:

 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15



Task

 Write a program to generate and display here the first   n   lines of a Floyd triangle. 
(Use   n=5   and   n=14   rows).
 Ensure that when displayed in a mono-space font, the numbers line up in vertical columns as shown and that only one space separates numbers of the last row.

",Python,">>> def floyd(rowcount=5):
	rows = [[1]]
	while len(rows) < rowcount:
		n = rows[-1][-1] + 1
		rows.append(list(range(n, n + len(rows[-1]) + 1)))
	return rows
 
>>> floyd()
[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]
>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):
	colspace = [len(str(n)) for n in rows[-1]]
	for row in rows:
		print( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))
 
 
>>> pfloyd()
1
2 3
4 5 6
7 8 9 10
>>> pfloyd(floyd(5))
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
>>> pfloyd(floyd(14))
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35 36
37 38 39 40 41 42 43 44  45
46 47 48 49 50 51 52 53  54  55
56 57 58 59 60 61 62 63  64  65  66
67 68 69 70 71 72 73 74  75  76  77  78
79 80 81 82 83 84 85 86  87  88  89  90  91
92 93 94 95 96 97 98 99 100 101 102 103 104 105
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Combinations_and_permutations,Combinations and permutations,"

 This page uses content from Wikipedia. The original article was at Combination. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



 This page uses content from Wikipedia. The original article was at Permutation. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the combination    (nCk)    and permutation    (nPk)    operators in the target language:

 






n



C

k


=



(


n
k


)



=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle ^{n}\operatorname {C} _{k}={\binom {n}{k}}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}


 






n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




See the Wikipedia articles for a more detailed description.

To test, generate and print examples of:

   A sample of permutations from 1 to 12 and Combinations from 10 to 60 using exact Integer arithmetic.
   A sample of permutations from 5 to 15000 and Combinations from 100 to 1000 using approximate Floating point arithmetic.
 This 'floating point' code could be implemented using an approximation, e.g., by calling the Gamma function.


Related task

   Evaluate binomial coefficients



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"from __future__ import division
from gmpy2 import mpz, comb, fac
 
def p(n, p):
    r = mpz(1)
    k = n - p
    while n > k:
        r *= n
        n -= 1
    return r
 
def c(n, k):
    r = p(n, k)
    while k:
        r //= k
        k -= 1
    return r
 
for i in range(1, 12):
    print ""P(12, %d) = %d"" % (i, p(12, i))
for i in range(10, 60, 10):
    print ""C(60, %d) = %d"" % (i, c(60, i))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Jacobsthal_numbers,Jacobsthal numbers,"Jacobsthal numbers are an integer sequence related to Fibonacci numbers. Similar to Fibonacci, where each term is the sum of the previous two terms, each term is the sum of the previous, plus twice the one before that. Traditionally the sequence starts with the given terms 0, 1.


   J0 = 0
   J1 = 1
   Jn = Jn-1 + 2 × Jn-2


Terms may be calculated directly using one of several possible formulas:


   Jn = ( 2n - (-1)n ) / 3



Jacobsthal-Lucas numbers are very similar. They have the same recurrence relationship, the only difference is an initial starting value J0 = 2 rather than J0 = 0.

Terms may be calculated directly using one of several possible formulas:

   
   JLn = 2n + (-1)n
   

Jacobsthal oblong numbers is the sequence obtained from multiplying each Jacobsthal number Jn by its direct successor Jn+1.


Jacobsthal primes are Jacobsthal numbers that are prime.



Task
 Find and display the first 30 Jacobsthal numbers
 Find and display the first 30 Jacobsthal-Lucas numbers
 Find and display the first 20 Jacobsthal oblong numbers
 Find and display at least the first 10 Jacobsthal primes


See also
 Wikipedia: Jacobsthal number
 Numbers Aplenty - Jacobsthal number
 OEIS:A001045 - Jacobsthal sequence (or Jacobsthal numbers)
 OEIS:A014551 - Jacobsthal-Lucas numbers.
 OEIS:A084175 - Jacobsthal oblong numbers
 OEIS:A049883 - Primes in the Jacobsthal sequence
 Related task: Fibonacci sequence
 Related task: Leonardo numbers



",Python,"#!/usr/bin/python
from math import floor, pow
 
def isPrime(n):
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False        
    return True
 
def odd(n):
    return n and 1 != 0
 
def jacobsthal(n):
    return floor((pow(2,n)+odd(n))/3)
 
def jacobsthal_lucas(n):
    return int(pow(2,n)+pow(-1,n))
 
def jacobsthal_oblong(n):
    return jacobsthal(n)*jacobsthal(n+1)
 
 
if __name__ == '__main__':
    print(""First 30 Jacobsthal numbers:"")
    for j in range(0, 30):
        print(jacobsthal(j), end=""  "")
 
    print(""\n\nFirst 30 Jacobsthal-Lucas numbers: "")
    for j in range(0, 30):
        print(jacobsthal_lucas(j), end = '\t')
 
    print(""\n\nFirst 20 Jacobsthal oblong numbers: "")
    for j in range(0, 20):
        print(jacobsthal_oblong(j), end=""  "")
 
    print(""\n\nFirst 10 Jacobsthal primes: "")
    for j in range(3, 33):
        if isPrime(jacobsthal(j)):
            print(jacobsthal(j))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Repeat_a_string,Repeat a string,"Take a string and repeat it some number of times.

Example: repeat(""ha"", 5)   =>   ""hahahahaha""

If there is a simpler/more efficient way to repeat a single “character” (i.e. creating a string filled with a certain character), you might want to show that as well (i.e. repeat-char(""*"", 5) => ""*****"").




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def main(args):
    print(""ha"".repeat(5))

def repeat(s, n):
    return """".join([s] * n)

def repeat(s, n, sep):
    return sep.join([s] * n)

def repeat(s, n, sep, prefix):
    return sep.join([prefix + s] * n)

def repeat(s, n, sep, prefix, postfix):
    return sep.join([prefix + s + postfix] * n)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Terminal_control/Display_an_extended_character,Terminal control/Display an extended character,"Task

Display an extended (non ASCII) character onto the terminal.

Specifically, display a    £    (GBP currency sign).



",Python,print u'\u00a3',Human_written,Python_from_C#
http://rosettacode.org/wiki/Multisplit,Multisplit,"It is often necessary to split a string into pieces
based on several different (potentially multi-character) separator strings,
while still retaining the information about which separators were present in the input.

This is particularly useful when doing small parsing tasks. 

The task is to write code to demonstrate this.

The function (or procedure or method, as appropriate) should
take an input string and an ordered collection of separators.

The order of the separators is significant: 

The delimiter order represents priority in matching, with the first defined delimiter having the highest priority.
In cases where there would be an ambiguity as to
which separator to use at a particular point
(e.g., because one separator is a prefix of another)
the separator with the highest priority should be used.
Delimiters can be reused and the output from the function should be an ordered sequence of substrings.

Test your code using the input string “a!===b=!=c” and the separators “==”, “!=” and “=”.

For these inputs the string should be parsed as ""a"" (!=) """" (==) ""b"" (=) """" (!=) ""c"", where matched delimiters are shown in parentheses, and separated strings are quoted, so our resulting output is ""a"", empty string, ""b"", empty string, ""c"".
Note that the quotation marks are shown for clarity and do not form part of the output.

Extra Credit: provide information that indicates which separator was matched at each separation point and where in the input string that separator was matched.
",Python,"import re
import itertools
 
def multi_split(txt, separators):
    return [m.group(0) for m in re.finditer('|'.join(map(re.escape, separators)), txt)]
 
print('Regex split:')
print(re.split('==|!=|=', 'a!===b=!=c'))
 
print('\nManual split:')
for s in multi_split('a!===b=!=c', ['==', '!=', '=']):
    print('""%s""'% s, end='')",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from queue import Queue
 
q = Queue()
print(""empty?"", q.empty())
 
x = ""black""
print(""push"", x)
q.put(x)
 
print(""empty?"", q.empty())
r = q.get()
if r:
    print(r, ""popped"")
else:
    print(""pop failed"")
 
n = 0
for x in [""blue"", ""red"", ""green""]:
    print(""pushing"", x)
    q.put(x)
    n += 1
 
for i in range(n):
    r = q.get()
    if r:
        print(r, ""popped"")
    else:
        print(""pop failed"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Walk_a_directory/Non-recursively,Walk a directory/Non-recursively,"Task

Walk a given directory and print the names of files matching a given pattern.

(How is ""pattern"" defined? substring match? DOS pattern? BASH pattern? ZSH pattern? Perl regular expression?)


Note: This task is for non-recursive methods.   These tasks should read a single directory, not an entire directory tree.

Note: Please be careful when running any code presented here.



Related task

   Walk Directory Tree   (read entire directory tree). 

",Python,"import glob
for filename in glob.glob('/foo/bar/*.mp3'):
    print(filename)",Human_written,Python_from_C
http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",Python,"import any
import list
 
def flatten(list):
  current = list.begin()
  while current!= list.end():
    if current.type() == any.typeid(list):
      next = current
      next.next()
      list.splice(next, any.cast(list, current))
      current = list.erase(current)
    else:
      current.next()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Trigonometric_functions,Trigonometric functions,"Task

If your language has a library or built-in functions for trigonometry, show examples of:

   sine
   cosine
   tangent
   inverses   (of the above)

using the same angle in radians and degrees.

For the non-inverse functions,   each radian/degree pair should use arguments that evaluate to the same angle   (that is, it's not necessary to use the same angle for all three regular functions as long as the two sine calls use the same angle).

For the inverse functions,   use the same number and convert its answer to radians and degrees.

If your language does not have trigonometric functions available or only has some available,   write functions to calculate the functions based on any   known approximation or identity.



",Python,"import math
import sys
 
pi = 4 * math.atan(1)
#Pi / 4 is 45 degrees. All answers should be the same.
radians = pi / 4
degrees = 45.0
temp = 0
#sine
print ""%f %f"" % (math.sin(radians), math.sin(degrees * pi / 180))
#cosine
print ""%f %f"" % (math.cos(radians), math.cos(degrees * pi / 180))
#tangent
print ""%f %f"" % (math.tan(radians), math.tan(degrees * pi / 180))
#arcsine
temp = math.asin(math.sin(radians))
print ""%f %f"" % (temp, temp * 180 / pi)
#arccosine
temp = math.acos(math.cos(radians))
print ""%f %f"" % (temp, temp * 180 / pi)
#arctangent
temp = math.atan(math.tan(radians))
print ""%f %f"" % (temp, temp * 180 / pi)
 
sys.exit(0)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ''
# or:
s = str()
 
if not s or s == '':
   print(""String is empty"")
 
if len(s) == 0:
    print(""String is empty"")
else:
    print(""String not empty"")
 
 
# boolean test function for python2 and python3
# test for regular (non-unicode) strings
# unicode strings
# None 
def emptystring(s):
   if isinstance(s, (''.__class__ , u''.__class__) ):
      if len(s) == 0: 
         return True
      else 
         return False
 
   elif s is None:
        return True",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Fivenum,Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",Python,"from __future__ import division
import math
import sys
 
def fivenum(array):
    n = len(array)
    if n == 0:
        print(""you entered an empty array."")
        sys.exit()
    x = sorted(array)
 
    n4 = math.floor((n+3.0)/2.0)/2.0
    d = [1, n4, (n+1)/2, n+1-n4, n]
    sum_array = []
 
    for e in range(5):
        floor = int(math.floor(d[e] - 1))
        ceil = int(math.ceil(d[e] - 1))
        sum_array.append(0.5 * (x[floor] + x[ceil]))
 
    return sum_array
 
x = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,
-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,
1.04312009, -0.10305385, 0.75775634, 0.32566578]
 
y = fivenum(x)
print(y)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",Python,"from decimal import Decimal as D
from collections import namedtuple
 
Item = namedtuple('Item', 'price, quant')
 
items = dict( hamburger=Item(D('5.50'), D('4000000000000000')),
              milkshake=Item(D('2.86'), D('2')) )
tax_rate = D('0.0765')
 
fmt = ""%-10s %8s %18s %22s""
print(fmt % tuple('Item Price Quantity Extension'.upper().split()))
 
total_before_tax = 0
for item, (price, quant) in sorted(items.items()):
    ext = price * quant
    print(fmt % (item, price, quant, ext))
    total_before_tax += ext
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'subtotal', total_before_tax))
 
tax = (tax_rate * total_before_tax).quantize(D('0.00'))
print(fmt % ('', '', 'Tax', tax))
 
total = total_before_tax + tax
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'Total', total))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Reduced_row_echelon_form,Reduced row echelon form,"Reduced row echelon form

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Show how to compute the reduced row echelon form
(a.k.a. row canonical form) of a matrix.

The matrix can be stored in any datatype that is convenient
(for most languages, this will probably be a two-dimensional array).

Built-in functions or this pseudocode (from Wikipedia) may be used:

function ToReducedRowEchelonForm(Matrix M) is
    lead := 0
    rowCount := the number of rows in M
    columnCount := the number of columns in M
    for 0 ≤ r < rowCount do
        if columnCount ≤ lead then
            stop
        end if
        i = r
        while M[i, lead] = 0 do
            i = i + 1
            if rowCount = i then
                i = r
                lead = lead + 1
                if columnCount = lead then
                    stop
                end if
            end if
        end while
        Swap rows i and r
        If M[r, lead] is not 0 divide row r by M[r, lead]
        for 0 ≤ i < rowCount do
            if i ≠ r do
                Subtract M[i, lead] multiplied by row r from row i
            end if
        end for
        lead = lead + 1
    end for
end function

For testing purposes, the RREF of this matrix:

 1    2   -1   -4
 2    3   -1   -11
-2    0   -3    22

is:

 1    0    0   -8
 0    1    0    1
 0    0    1   -2


",Python,"# -*- coding: utf-8 -*-
""""""
Created on Sat May 16 15:40:00 2015

@author: rajiv
""""""

from fractions import Fraction

def reduced_row_echelon_form(ary):
    lead = 0
    rows = len(ary)
    cols = len(ary[0])
    rary = convert_to(ary, 'to_r')  # use rational arithmetic
    try:
        for r in range(rows):
            if cols <= lead:
                break
            i = r
            while rary[i][lead] == 0:
                i += 1
                if rows == i:
                    i = r
                    lead += 1
                    if cols == lead:
                        break
            # swap rows i and r 
            rary[i], rary[r] = rary[r], rary[i]
            # normalize row r
            v = rary[r][lead]
            rary[r] = [x / v for x in rary[r]]
            # reduce other rows
            for i in range(rows):
                if i == r:
                    continue
                v = rary[i][lead]
                rary[i] = [x - v * rary[r][j] for j, x in enumerate(rary[i])]
            lead += 1
    except IndexError:
        pass
    return rary

def convert_to(ary, type):
    new = []
    for row in ary:
        new.append([elem.send(type) for elem in row])
    return new

class Rational(Fraction):
    def __str__(self):
        if self.denominator == 1:
            return str(self.numerator)
        else:
            return Fraction.__str__(self)

def print_matrix(m):
    max = [-1] * len(m[0])
    for row in m:
        for i, elem in enumerate(row):
            max[i] = max(max[i], len(str(elem)))
    for row in m:
        for i, elem in enumerate(row):
            print(""%{0}s "".format(max[i]) % elem),
        print

mtx = [
  [ 1, 2, -1, -4],
  [ 2, 3, -1,-11],
  [-2, 0, -3, 22]
]
print_matrix(reduced_row_echelon_form(mtx))
print

mtx = [
  [ 1, 2, 3, 7],
  [-4, 7,-2, 7],
  [ 3, 3, 0, 7]
]
reduced = reduced_row_echelon_form(mtx)
print_matrix(reduced)
print_matrix(convert_to(reduced, 'to_f'))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",Python,"m = """"""    leading spaces

and blank lines""""""",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort,Sorting algorithms/Insertion sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Insertion sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



An O(n2) sorting algorithm which moves elements one at a time into the correct position.
The algorithm consists of inserting one element at a time into the previously sorted part of the array, moving higher ranked elements up as necessary.
To start off, the first (or smallest, or any arbitrary) element of the unsorted array is considered to be the sorted part.

Although insertion sort is an O(n2) algorithm, its simplicity, low overhead, good locality of reference and efficiency make it a good choice in two cases: 


   small   n, 

   as the final finishing-off algorithm for O(n logn) algorithms such as mergesort and quicksort.


The algorithm is as follows (from wikipedia):

function insertionSort(array A)
    for i from 1 to length[A]-1 do
        value := A[i] 
        j := i-1
        while j >= 0 and A[j] > value do
            A[j+1] := A[j]
            j := j-1
        done
        A[j+1] = value
    done

Writing the algorithm for integers will suffice.



",Python,"def insertSort(A):
    for i in range(1, len(A)):
        value = A[i]
        j = i - 1
        while j >= 0 and A[j] > value:
            A[j + 1] = A[j]
            j = j - 1
        A[j + 1] = value",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Exponentiation_with_infix_operators_in_(or_operating_on)_the_base,Exponentiation with infix operators in (or operating on) the base,"(Many programming languages,   especially those with extended─precision integer arithmetic,   usually
support one of  **, ^, ↑  or some such for exponentiation.)



Some languages treat/honor infix operators when performing exponentiation   (raising
numbers to some power by the language's exponentiation operator,   if the computer
programming language has one).



Other programming languages may make use of the   POW   or some other BIF
  (Built─In Ffunction),   or some other library service.

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



This task will deal with the case where there is some form of an   infix operator   operating
in   (or operating on)   the base.



Example

A negative five raised to the 3rd power could be specified as:

   -5  ** 3          or as
  -(5) ** 3          or as
  (-5) ** 3          or as something else


(Not all computer programming languages have an exponential operator and/or support these syntax expression(s).



Task

   compute and display exponentiation with a possible infix operator, whether specified and/or implied/inferred.
   Raise the following numbers   (integer or real):
   -5     and
   +5
   to the following powers:
   2nd     and
   3rd
   using the following expressions   (if applicable in your language):
   -x**p
   -(x)**p
   (-x)**p
   -(x**p)
   Show here (on this page) the four (or more) types of symbolic expressions for each number and power.


Try to present the results in the same format/manner as the other programming entries to make any differences apparent.



The variables may be of any type(s) that is/are applicable in your language.



Related tasks

   Exponentiation order
   Exponentiation operator
   Arbitrary-precision integers (included)
   Parsing/RPN to infix conversion
   Operator precedence


References

 Wikipedia: Order of operations in Programming languages

",Python,"from itertools import product
 
xx = '-5 +5'.split()
pp = '2 3'.split()
texts = '-x**p -(x)**p (-x)**p -(x**p)'.split()
 
print('Integer variable exponentiation')
for x, p in product(xx, pp):
    print(f'  x,p = {x:2},{p}; ', end=' ')
    x, p = int(x), int(p)
    print('; '.join(f""{t} =={eval(t):4}"" for t in texts))
 
print('\nBonus integer literal exponentiation')
X, P = 'xp'
xx.insert(0, ' 5')
texts.insert(0, 'x**p')
for x, p in product(xx, pp):
    texts2 = [t.replace(X, x).replace(P, p) for t in texts]
    print(' ', '; '.join(f""{t2} =={eval(t2):4}"" for t2 in texts2))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"# version 1.1.2
 
class Node(data, prev=None, next=None):
    def __init__(self, data, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next
    def __str__(self):
        sb = str(self.data)
        node = self.next
        while node is not None:
            sb += "" -> "" + str(node.data)
            node = node.next
        return sb
 
if __name__ == ""__main__"":
    n1 = Node(1)
    n2 = Node(2, n1)
    n1.next = n2
    n3 = Node(3, n2)
    n2.next = n3
    print(n1)
    print(n2)
    print(n3)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Count_in_octal,Count in octal,"Task

Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.

Each number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.



Related task

   Integer sequence   is a similar task without the use of octal numbers.

",Python,"i = 0
while i < 10:
    print(oct(i))
    i += 1",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Self-describing_numbers,Self-describing numbers,"Self-describing numbers

You are encouraged to solve this task according to the task description, using any language you may know.
There are several so-called ""self-describing"" or ""self-descriptive"" integers.

An integer is said to be ""self-describing"" if it has the property that, when digit positions are labeled 0 to N-1, the digit in each position is equal to the number of times that that digit appears in the number.

For example,   2020   is a four-digit self describing number:

   position   0   has value   2   and there are two 0s in the number;
   position   1   has value   0   and there are no 1s in the number;
   position   2   has value   2   and there are two 2s;
   position   3   has value   0   and there are zero 3s.


Self-describing numbers < 100.000.000  are:     1210,   2020,   21200,   3211000,   42101000.



Task Description
 Write a function/routine/method/... that will check whether a given positive integer is self-describing.
 As an optional stretch goal - generate and display the set of self-describing numbers.


Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-referential sequence
   Spelling of ordinal numbers

",Python,">>> def isSelfDescribing(n):
	s = str(n)
	return all(s.count(str(i)) == int(ch) for i, ch in enumerate(s))
 
>>> [x for x in range(4000000) if isSelfDescribing(x)]
[1210, 2020, 21200, 3211000]
>>> [(x, isSelfDescribing(x)) for x in (1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000)]
[(1210, True), (2020, True), (21200, True), (3211000, True), (42101000, True), (521001000, True), (6210001000, True)]",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Bitmap,Bitmap,"Show a basic storage type to handle a simple RGB raster graphics image,
and some primitive associated functions.

If possible provide a function to allocate an uninitialised image,
given its width and height, and provide 3 additional functions:

   one to fill an image with a plain RGB color,
   one to set a given pixel with a color,
   one to get the color of a pixel.


(If there are specificities about the storage or the allocation, explain those.)

These functions are used as a base for the articles in the category raster graphics operations, 
and a basic output function to check the results
is available in the article write ppm file.



",Python,"import numpy as np
from PIL import Image
 
# A rectangle from 0,0 to 300,240.
r = (0, 0, 300, 240)
 
# Create an image
im = Image.new('RGBA', (r[2], r[3]))
 
# set some color variables for convience
red = (255, 0, 0, 255)
blue = (0, 0, 255, 255)
 
# Fill with a uniform color
im.paste(red, r)
 
# Set individual pixels
im.putpixel((10, 20), blue)
im.putpixel((20, 30), (0, 0, 0, 255))
im.putpixel((30, 40), (16, 32, 48, 255))
 
# Get the values of specific pixels as color.Color types.
# The color will be in the color.Model of the image (in this
# case color.NRGBA) but color models can convert their values
# to other models.
c1 = im.getpixel((0, 0))
c2 = im.getpixel((10, 20))
 
# or directly as RGB components (scaled values)
redc, greenc, bluec, _ = c1
redc, greenc, bluec, _ = im.getpixel((30, 40))
 
# Images can be read and writen in various formats
im.save('test.png')
 
print(""Image size:"", im.size[0], ""×"", im.size[1])
print(im.size[0] * im.size[1] * 4, ""bytes when encoded as PNG."")
print(""Pixel at %7v is %v"" % ((0, 0), c1))
print(""Pixel at %7v is %#v"" % ((10, 20), c2)) # %#v shows type details
print(""Pixel at %7v has R=%d, G=%d, B=%d"" % ((30, 40), redc, greenc, bluec))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character,Split a character string based on change of character,"

Task

Split a (character) string into comma (plus a blank) delimited
strings based on a change of character   (left to right).

Show the output here   (use the 1st example below).



Blanks should be treated as any other character   (except
they are problematic to display clearly).   The same applies
to commas.



For instance, the string:

 gHHH5YY++///\ 

should be split and show:

 g, HHH, 5, YY, ++, ///, \ 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def split(str):
    print("" input string: {}"".format(str))
    s = ''.join([','.join(list(g)) for _, g in itertools.groupby(str)])
    print(""output string: {}"".format(s))
    return s
 
split(""gHHH5YY++///\\"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Next_highest_int_from_digits,Next highest int from digits,"Given a zero or positive integer, the task is to generate the next largest
integer using only the given digits*1.

   Numbers will not be padded to the left with zeroes.
   Use all given digits, with their given multiplicity. (If a digit appears twice in the input number, it should appear twice in the result).
   If there is no next highest integer return zero.


*1   Alternatively phrased as:   ""Find the smallest integer larger than the (positive or zero) integer   N
 which can be obtained by reordering the (base ten) digits of   N"".


Algorithm 1

   Generate all the permutations of the digits and sort into numeric order.
   Find the number in the list.
   Return the next highest number from the list.


The above could prove slow and memory hungry for numbers with large numbers of
digits, but should be easy to reason about its correctness.



Algorithm 2

   Scan right-to-left through the digits of the number until you find a digit with a larger digit somewhere to the right of it.
   Exchange that digit with the digit on the right that is both more than it, and closest to it.
   Order the digits to the right of this position, after the swap; lowest-to-highest, left-to-right. (I.e. so they form the lowest numerical representation)

E.g.:

    n = 12453
<scan>
    12_4_53
<swap>
    12_5_43
<order-right>
    12_5_34

    return: 12534

This second algorithm is faster and more memory efficient, but implementations
may be harder to test.

One method of testing, (as used in developing the task),   is to compare results from both
algorithms for random numbers generated from a range that the first algorithm can handle.



Task requirements

Calculate the next highest int from the digits of the following numbers:

   0
   9
   12
   21
   12453
   738440
   45072010
   95322020


Optional stretch goal

   9589776899767587796600

",Python,"def closest_more_than(n, lst):
    ""(index of) closest int from lst, to n that is also > n""
    large = max(lst) + 1
    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))
 
def nexthigh(n):
    ""Return nxt highest number from n's digits using scan & re-order""
    assert n == int(abs(n)), ""n >= 0""
    this = list(int(digit) for digit in str(int(n)))[::-1]
    mx = this[0]
    for i, digit in enumerate(this[1:], 1):
        if digit < mx:
            mx_index = closest_more_than(digit, this[:i + 1])
            this[mx_index], this[i] = this[i], this[mx_index]
            this[:i] = sorted(this[:i], reverse=True)
            return int(''.join(str(d) for d in this[::-1]))
        elif digit > mx:
            mx, mx_index = digit, i
    return 0
 
 
if __name__ == '__main__':
    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,
              9589776899767587796600]:
        print(f""{x:>12_d} -> {nexthigh(x):>12_d}"")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Element-wise_operations,Element-wise operations,"This task is similar to:

   Matrix multiplication
   Matrix transposition


Task

Implement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.

Implement:

   addition
   subtraction
   multiplication
   division
   exponentiation


Extend the task if necessary to include additional basic operations, which should not require their own specialised task.



",Python,">>> import random
>>> from operator import add, sub, mul, floordiv
>>> from pprint import pprint as pp
>>> 
>>> def ewise(matrix1, matrix2, op):
	return [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)]
 
>>> m,n = 3,4 	# array dimensions
>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]
>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]
>>> pp(a0); pp(a1)
[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]
[[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]
>>> pp(ewise(a0, a1, add))
[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]
>>> pp(ewise(a0, a1, sub))
[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]
>>> pp(ewise(a0, a1, mul))
[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]
>>> pp(ewise(a0, a1, floordiv))
[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]
>>> pp(ewise(a0, a1, pow))
[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]
>>> pp(ewise(a0, a1, lambda x, y:2*x - y))
[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]
>>> 
>>> def s_ewise(scalar1, matrix1, op):
	return [[op(scalar1, e1) for e1 in row1] for row1 in matrix1]
 
>>> scalar = 10
>>> a0
[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]
>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):
	print(""%10s :"" % op.__name__, s_ewise(scalar, a0, op))
 
 
       add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]
       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]
       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]
  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]
       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]
  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort,Sorting algorithms/Comb sort,"Sorting algorithms/Comb sort

You are encouraged to solve this task according to the task description, using any language you may know.

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a   comb sort.



The Comb Sort is a variant of the Bubble Sort.

Like the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.

Dividing the gap by   



(
1
−

e

−
φ



)

−
1


≈
1.247330950103979


{\displaystyle (1-e^{-\varphi })^{-1}\approx 1.247330950103979}

    works best, but    1.3   may be more practical.



Some implementations use the insertion sort once the gap is less than a certain amount.



Also see

   the Wikipedia article:   Comb sort.


Variants:

 Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.
 Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small).   Comb sort with a low gap isn't much better than the Bubble Sort.


Pseudocode:

function combsort(array input)
    gap := input.size //initialize gap size
    loop until gap = 1 and swaps = 0
        //update the gap value for a next comb. Below is an example
        gap := int(gap / 1.25)
        if gap < 1
          //minimum gap is 1
          gap := 1
        end if
        i := 0
        swaps := 0 //see Bubble Sort for an explanation
        //a single ""comb"" over the input list
        loop until i + gap >= input.size //see Shell sort for similar idea
            if input[i] > input[i+gap]
                swap(input[i], input[i+gap])
                swaps := 1 // Flag a swap has occurred, so the
                           // list is not guaranteed sorted
            end if
            i := i + 1
        end loop
    end loop
end function


",Python,"def Combsort13(a, nElements):
    i = 0
    j = 0
    gap = 0
    swapped = 0
    temp = 0.0
    i = 0
    j = 0
    gap = nElements
    while gap > 1 or swapped == 1:
        gap = gap * 10 / 13
        if gap == 9 or gap == 10:
            gap = 11
        if gap < 1:
            gap = 1
        swapped = 0
        i = 0
        j = gap
        while j < nElements:
            if a[i] > a[j]:
                temp = a[i]
                a[i] = a[j]
                a[j] = temp
                swapped = 1
            i = i + 1
            j = j + 1",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Approximate_equality,Approximate equality,"Sometimes, when testing whether the solution to a task (for example, here on Rosetta Code) is correct, the
difference in floating point calculations between different language implementations becomes significant.

For example, a difference between 32 bit and 64 bit floating point calculations may appear by
about the 8th significant digit in base 10 arithmetic.



Task

Create a function which returns true if two floating point numbers are approximately equal.



The function should allow for differences in the magnitude of numbers, so that, for example,

100000000000000.01   may be approximately equal to   100000000000000.011,

even though   100.01   is not approximately equal to   100.011.

If the language has such a feature in its standard library, this may be used instead of a custom function.

Show the function results with comparisons on the following pairs of values:

     100000000000000.01,   100000000000000.011     (note: should return true)
     100.01,   100.011                                                     (note: should return false)
     10000000000000.001 / 10000.0,   1000000000.0000001000
     0.001,   0.0010000001
     0.000000000000000000000101,   0.0
      sqrt(2) * sqrt(2),    2.0
     -sqrt(2) * sqrt(2),   -2.0
     3.14159265358979323846,   3.14159265358979324


Answers should be true for the first example and false in the second, so that just rounding the numbers to a fixed number of decimals should not be enough. Otherwise answers may vary and still be correct. See the Python code for one type of solution.



",Python,"math.isclose -> bool
    a: double
    b: double
    *
    rel_tol: double = 1e-09
        maximum difference for being considered ""close"", relative to the
        magnitude of the input values
    abs_tol: double = 0.0
        maximum difference for being considered ""close"", regardless of the
        magnitude of the input values
Determine whether two floating point numbers are close in value.
Return True if a is close in value to b, and False otherwise.
For the values to be considered close, the difference between them
must be smaller than at least one of the tolerances.
-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
is, NaN is not close to anything, even itself.  inf and -inf are
only close to themselves.",Human_written,Python_from_Java
http://rosettacode.org/wiki/String_interpolation_(included),String interpolation (included),"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Given a string and defined variables or values, string interpolation is the replacement of defined character sequences in the string by values or variable values.

 For example, given an original string of ""Mary had a X lamb."", a value of ""big"", and if the language replaces X in its interpolation routine, then the result of its interpolation would be the string ""Mary had a big lamb"".
(Languages usually include an infrequently used character or sequence of characters to indicate what is to be replaced such as ""%"", or ""#"" rather than ""X"").


Task

 Use your languages inbuilt string interpolation abilities to interpolate a string missing the text ""little"" which is held in a variable, to produce the output string ""Mary had a little lamb"".
 If possible, give links to further documentation on your languages string interpolation features.

Note: The task is not to create a string interpolation routine, but to show a language's built-in capability.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"extra = ""little""
print(""Mary had a %s lamb."" % extra)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Random_number_generator_(device),Random number generator (device),"Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:

show how to obtain a random 32-bit number from that mechanism.

Related task
 Random_number_generator_(included)

",Python,"import random
rand = random.SystemRandom()
rand.randint(1,10)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",Python,"import msvcrt
 
ch = ''
msvcrt.putch( ""Yes or no?"" )
while ch!= 'Y' and ch!= 'N':
	ch = msvcrt.getch()
	ch = ch.upper()
 
if ch == 'N':
	print ""You said no""
else:
	print ""You said yes""",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import csv
import os
import sys
import traceback
 
def read_sample():
	try:
		f = open(""sample.csv"")
		rows = list(csv.reader(f))
		f.close()
		return rows
	except:
		traceback.print_exc(file=sys.stdout)
		sys.exit()
 
def append_sum(rows):
	rows[0].append(""SUM"")
	for i in range(1, len(rows)):
		rows[i].append(sum(rows[i]))
 
def sum(row):
	try:
		return str(sum(int(x) for x in row))
	except:
		return ""NA""
 
def write_changes(rows):
	try:
		f = open(""output.csv"", ""w"")
		csv.writer(f).writerows(rows)
		f.close()
	except:
		traceback.print_exc(file=sys.stdout)
		sys.exit()
 
def main():
	rows = read_sample()
	append_sum(rows)
	write_changes(rows)
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Send_email,Send email,"Task

Write a function to send an email.

The function should have parameters for setting From, To and Cc addresses; the Subject, and the message text, and optionally fields for the server name and login details.

 If appropriate, explain what notifications of problems/success are given.
 Solutions using libraries or functions from the language are preferred, but failing that, external programs can be used with an explanation.
 Note how portable the solution given is between operating systems when multi-OS languages are used.


(Remember to obfuscate any sensitive data used in examples)



",Python,"import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
 
fromaddr = """"
toaddr = """"
 
msg = MIMEMultipart()
 
msg['From'] = fromaddr
msg['To'] = toaddr
msg['Subject'] = ""Subject of the Mail""
 
body = ""Body_of_the_mail""
msg.attach(MIMEText(body, 'plain'))
 
filename = ""file.txt""
attachment = open(""file.txt"", ""rb"")
 
part = MIMEBase('application', 'octet-stream')
part.set_payload((attachment).read())
encoders.encode_base64(part)
part.add_header('Content-Disposition', ""attachment; filename= %s"" % filename)
 
msg.attach(part)
 
server = smtplib.SMTP('smtp.gmail.com', 587)
server.starttls()
server.login(fromaddr, """")
text = msg.as_string()
server.sendmail(fromaddr, toaddr, text)
server.quit()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Modular_inverse,Modular inverse,"From Wikipedia:

In modular arithmetic,   the modular multiplicative inverse of an integer    a    modulo    m    is an integer    x    such that





a

x
≡
1


(
mod

m
)

.


{\displaystyle a\,x\equiv 1{\pmod {m}}.}


Or in other words, such that:





∃
k
∈

Z

,

a

x
=
1
+
k

m


{\displaystyle \exists k\in \mathbb {Z} ,\qquad a\,x=1+k\,m}


It can be shown that such an inverse exists   if and only if    a    and    m    are coprime,   but we will ignore this for this task.



Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in
your language,   compute the modular inverse of   42 modulo 2017.



",Python,"import sys
 
def mul_inv(a, b):
	b0 = b
	t = 0
	q = 0
	x0 = 0
	x1 = 1
	if (b == 1):
		return 1
	while (a > 1):
		q = a // b
		t = b
		b = a % b
		a = t
		t = x0
		x0 = x1 - q * x0
		x1 = t
	if (x1 < 0):
		x1 += b0
	return x1
 
def main():
	print(mul_inv(42, 2017))
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Fusc_sequence,Fusc sequence,"

Definitions

The   fusc   integer sequence is defined as:

   fusc(0) = 0
   fusc(1) = 1
   for n>1,   the   nth   term is defined as:
   if   n   is even;     fusc(n) = fusc(n/2)
   if   n   is   odd;     fusc(n) = fusc((n-1)/2)   +   fusc((n+1)/2)


Note that MathWorld's definition starts with unity, not zero.   This task will be using the OEIS' version   (above).



An observation

   fusc(A) = fusc(B)
where   A   is some non-negative integer expressed in binary,   and
where   B   is the binary value of   A   reversed.



Fusc numbers are also known as:

   fusc function   (named by Dijkstra, 1982)
   Stern's Diatomic series   (although it starts with unity, not zero)
   Stern-Brocot sequence   (although it starts with unity, not zero)


Task

   show the first   61   fusc numbers (starting at zero) in a horizontal format.
   show the fusc number (and its index) whose length is greater than any previous fusc number length.
   (the length is the number of decimal digits when the fusc number is expressed in base ten.)
   show all numbers with commas   (if appropriate).
   show all output here.


Related task

   RosettaCode Stern-Brocot sequence


Also see

   the MathWorld entry:   Stern's Diatomic Series.
   the OEIS entry:   A2487.

",Python,"import math
import sys
 
def fusc(n):
    if n <= 0:
        return []
    if n == 1:
        return [0]
    res = [0] * n
    res[0] = 0
    res[1] = 1
    for i in range(2, n):
        if i % 2 == 0:
            res[i] = res[i // 2]
        else:
            res[i] = res[(i - 1) // 2] + res[(i + 1) // 2]
    return res
 
def fuscMaxLen(n):
    maxLen = -1
    maxFusc = -1
    f = fusc(n)
    res = []
    for i in range(n):
        if f[i] <= maxFusc:
            continue # avoid expensive str(f[i]) operation where possible
        maxFusc = f[i]
        le = len(str(f[i]))
        if le > maxLen:
            res.append([i, f[i]])
            maxLen = le
    return res
 
def commatize(n):
    s = str(n)
    if n < 0:
        s = s[1:]
    le = len(s)
    for i in range(le - 3, 0, -3):
        s = s[0:i] + "","" + s[i:]
    if n >= 0:
        return s
    return ""-"" + s
 
if __name__ == ""__main__"":
    print(""The first 61 fusc numbers are:"")
    print(fusc(61))
    print(""\nThe fusc numbers whose length > any previous fusc number length are:"")
    res = fuscMaxLen(20000000)  # examine first twenty million numbers say
    for i in range(len(res)):
        print(""%7s (index %10s)"" % (commatize(res[i][1]), commatize(res[i][0])))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Increment_a_numerical_string,Increment a numerical string,"Task

Increment a numerical string.



",Python,next = str(int('123') + 1),Human_written,Python_from_C#
http://rosettacode.org/wiki/Gray_code,Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",Python,"def gray_encode(n):
    return n ^ n >> 1
 
def gray_decode(n):
    m = n >> 1
    while m:
        n ^= m
        m >>= 1
    return n
 
 
if __name__ == '__main__':
    print(""DEC,   BIN =>  GRAY => DEC"")
    for i in range(32):
        gray = gray_encode(i)
        dec = gray_decode(gray)
        print(f"" {i:>2d}, {i:>05b} => {gray:>05b} => {dec:>2d}"")",Human_written,Python_from_C#
http://rosettacode.org/wiki/JSON,JSON,"Load a JSON string into a data structure.
Also, create a new data structure and serialize it into JSON.

Use objects and arrays (as appropriate for your language)
and make sure your JSON is valid (https://jsonformatter.org).
",Python,">>> import json
>>> data = json.loads('{ ""foo"": 1, ""bar"": [10, ""apples""] }')
>>> sample = { ""blue"": [1,2], ""ocean"": ""water"" }
>>> json_string = json.dumps(sample)
>>> json_string
'{""blue"": [1, 2], ""ocean"": ""water""}'
>>> sample
{'blue': [1, 2], 'ocean': 'water'}
>>> data
{'foo': 1, 'bar': [10, 'apples']}",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Poker_hand_analyser,Poker hand analyser,"Task

Create a program to parse a single five card poker hand and rank it according to this list of poker hands.



A poker hand is specified as a space separated list of five playing cards.

Each input card has two characters indicating face and suit.



Example

2d       (two of diamonds).


Faces are:    a, 2, 3, 4, 5, 6, 7, 8, 9, 10, j, q, k

Suits are:    h (hearts),   d (diamonds),   c (clubs),   and   s (spades),   or

alternatively,   the unicode card-suit characters:     ♥ ♦ ♣ ♠ 



Duplicate cards are illegal.

The program should analyze a single hand and produce one of the following outputs:

 straight-flush
 four-of-a-kind
 full-house
 flush
 straight
 three-of-a-kind
 two-pair
 one-pair
 high-card
 invalid



Examples

   2♥ 2♦ 2♣ k♣ q♦:   three-of-a-kind
   2♥ 5♥ 7♦ 8♣ 9♠:   high-card
   a♥ 2♦ 3♣ 4♣ 5♦:   straight
   2♥ 3♥ 2♦ 3♣ 3♦:   full-house
   2♥ 7♥ 2♦ 3♣ 3♦:   two-pair
   2♥ 7♥ 7♦ 7♣ 7♠:   four-of-a-kind 
   10♥ j♥ q♥ k♥ a♥:  straight-flush
   4♥ 4♠ k♠ 5♦ 10♠:  one-pair
   q♣ 10♣ 7♣ 6♣ q♣:  invalid

The programs output for the above examples should be displayed here on this page.



Extra credit

 use the playing card characters introduced with Unicode 6.0 (U+1F0A1 - U+1F0DE).
 allow two jokers
 use the symbol   joker
 duplicates would be allowed (for jokers only)
 five-of-a-kind would then be the highest hand


More extra credit examples

   joker  2♦  2♠  k♠  q♦:     three-of-a-kind
   joker  5♥  7♦  8♠  9♦:     straight
   joker  2♦  3♠  4♠  5♠:     straight
   joker  3♥  2♦  3♠  3♦:     four-of-a-kind
   joker  7♥  2♦  3♠  3♦:     three-of-a-kind
   joker  7♥  7♦  7♠  7♣:     five-of-a-kind
   joker  j♥  q♥  k♥  A♥:     straight-flush
   joker  4♣  k♣  5♦ 10♠:     one-pair
   joker  k♣  7♣  6♣  4♣:     flush
   joker  2♦  joker  4♠  5♠:  straight
   joker  Q♦  joker  A♠ 10♠:  straight
   joker  Q♦  joker  A♦ 10♦:  straight-flush
   joker  2♦  2♠  joker  q♦:  four-of-a-kind



Related tasks

 Playing cards
 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Go Fish

",Python,"# version 1.1.2
 
class Card:
    def __init__(self, face, suit):
        self.face = face
        self.suit = suit
 
FACES = ""23456789tjqka""
SUITS = ""shdc""
 
def is_straight(cards):
    sorted = sorted(cards, key=lambda x: x.face)
    if sorted[0].face + 4 == sorted[4].face:
        return True
    if sorted[4].face == 14 and sorted[0].face == 2 and sorted[3].face == 5:
        return True
    return False
 
def is_flush(cards):
    suit = cards[0].suit
    if all(c.suit == suit for c in cards[1:]):
        return True
    return False
 
def analyze_hand(hand):
    h = hand.lower()
    split = [s for s in h.split(' ') if s!= '']
    if len(split)!= 5:
        return ""invalid""
    cards = []
 
    for s in split:
        if len(s)!= 2:
            return ""invalid""
        f_index = FACES.find(s[0])
        if f_index == -1:
            return ""invalid""
        s_index = SUITS.find(s[1])
        if s_index == -1:
            return ""invalid""
        cards.append(Card(f_index + 2, s[1]))
 
    groups = {}
    for c in cards:
        if c.face in groups:
            groups[c.face].append(c)
        else:
            groups[c.face] = [c]
 
    if len(groups) == 2:
        if any(len(g) == 4 for g in groups.values()):
            return ""four-of-a-kind""
        return ""full-house""
    elif len(groups) == 3:
        if any(len(g) == 3 for g in groups.values()):
            return ""three-of-a-kind""
        return ""two-pair""
    elif len(groups) == 4:
        return ""one-pair""
    else:
        flush = is_flush(cards)
        straight = is_straight(cards)
        if flush and straight:
            return ""straight-flush""
        elif flush:
            return ""flush""
        elif straight:
            return ""straight""
        else:
            return ""high-card""
 
if __name__ == ""__main__"":
    hands = [
        ""2h 2d 2c kc qd"",
        ""2h 5h 7d 8c 9s"",
        ""ah 2d 3c 4c 5d"",
        ""2h 3h 2d 3c 3d"",
        ""2h 7h 2d 3c 3d"",
        ""2h 7h 7d 7c 7s"",
        ""th jh qh kh ah"",
        ""4h 4s ks 5d ts"",
        ""qc tc 7c 6c 4c"",
        ""ah ah 7c 6c 4c""
    ]
    for hand in hands:
        print(f""{hand}: {analyze_hand(hand)}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Knight%27s_tour,Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"import copy
 
boardsize=6
_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) 
 
 
def chess2index(chess, boardsize=boardsize):
    'Convert Algebraic chess notation to internal index format'
    chess = chess.strip().lower()
    x = ord(chess[0]) - ord('a')
    y = boardsize - int(chess[1:])
    return (x, y)
 
def boardstring(board, boardsize=boardsize):
    r = range(boardsize)
    lines = ''
    for y in r:
        lines += '\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '
                                 for x in r)
    return lines
 
def knightmoves(board, P, boardsize=boardsize):
    Px, Py = P
    kmoves = set((Px+x, Py+y) for x,y in _kmoves)
    kmoves = set( (x,y)
                  for x,y in kmoves
                  if 0 <= x < boardsize
                     and 0 <= y < boardsize
                     and not board[(x,y)] )
    return kmoves
 
def accessibility(board, P, boardsize=boardsize):
    access = []
    brd = copy.deepcopy(board)
    for pos in knightmoves(board, P, boardsize=boardsize):
        brd[pos] = -1
        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )
        brd[pos] = 0
    return access
 
def knights_tour(start, boardsize=boardsize, _debug=False):
    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}
    move = 1
    P = chess2index(start, boardsize)
    board[P] = move
    move += 1
    if _debug:
        print(boardstring(board, boardsize=boardsize))
    while move <= len(board):
        P = min(accessibility(board, P, boardsize))[1]
        board[P] = move
        move += 1
        if _debug:
            print(boardstring(board, boardsize=boardsize))
            input('\n%2i next: ' % move)
    return board
 
if __name__ == '__main__':
    while 1:
        boardsize = int(input('\nboardsize: '))
        if boardsize < 5:
            continue
        start = input('Start position: ')
        board = knights_tour(start, boardsize)
        print(boardstring(board, boardsize=boardsize))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Spiral_matrix,Spiral matrix,"Task

Produce a spiral array.



A   spiral array   is a square arrangement of the first    N2   natural numbers,   where the

numbers increase sequentially as you go around the edges of the array spiraling inwards.



For example, given   5,   produce this array:

 0  1  2  3  4
15 16 17 18  5
14 23 24 19  6
13 22 21 20  7
12 11 10  9  8



Related tasks

   Zig-zag matrix 
   Identity_matrix
   Ulam_spiral_(for_primes)

",Python,"VECTORS = [(1, 0), (0, 1), (-1, 0), (0, -1)]
 
def spiral_matrix(size):
    matrix = [[0] * size for _ in range(size)]
    movement = cycle(VECTORS)
    x, y, n = -1, 0, count(1)
 
    for move_x, move_y in chain([size], (i for i in range(1, size) for _ in range(2))):
        x += move_x
        y += move_y
        matrix[y][x] = next(n)
 
    return matrix
 
if __name__ == '__main__':
    for i in spiral_matrix(4):
        print(*('{:>2}'.format(j) for j in i))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Circular_primes,Circular primes,"Definitions
A circular prime is a prime number with the property that the number generated at each intermediate step when cyclically permuting its (base 10) digits will also be prime.

For example:
1193 is a circular prime, since 1931, 9311 and 3119 are all also prime.

Note that a number which is a cyclic permutation of a smaller circular prime is not considered to be itself a circular prime. So 13 is a circular prime, but 31 is not.



A repunit (denoted by R) is a number whose base 10 representation contains only the digit 1.

For example:
R(2) = 11 and R(5) = 11111 are repunits.



Task
 Find the first 19 circular primes.


 If your language has access to arbitrary precision integer arithmetic, given that they are all repunits, find the next 4 circular primes.


 (Stretch) Determine which of the following repunits are probably circular primes: R(5003), R(9887), R(15073), R(25031), R(35317) and R(49081). The larger ones may take a long time to process so just do as many as you reasonably can.


See also
 Wikipedia article - Circular primes.
 Wikipedia article - Repunit.
 OEIS sequence A016114 - Circular primes.

",Python,"import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True
 
    for i in range(8):#number of trials
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True
 
def isPrime(n: int) -> bool:
    '''
        https://www.geeksforgeeks.org/python-program-to-check-whether-a-number-is-prime-or-not/
    '''
    # Corner cases
    if (n <= 1) :
        return False
    if (n <= 3) :
        return True
    # This is checked so that we can skip
    # middle five numbers in below loop
    if (n % 2 == 0 or n % 3 == 0) :
        return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
 
def rotations(n: int)-> set((int,)):
    '''
        >>> {123, 231, 312} == rotations(123)
        True
    '''
    a = str(n)
    return set(int(a[i:] + a[:i]) for i in range(len(a)))
 
def isCircular(n: int) -> bool:
    '''
        >>> [isCircular(n) for n in (11, 31, 47,)]
	[True, True, False]
    '''
    return all(isPrime(int(o)) for o in rotations(n))
 
from itertools import product
 
def main():
    result = [2, 3, 5, 7]
    first = '137'
    latter = '1379'
    for i in range(1, 6):
        s = set(int(''.join(a)) for a in product(first, *((latter,) * i)))
        while s:
            a = s.pop()
            b = rotations(a)
            if isCircular(a):
                result.append(min(b))
            s -= b
    result.sort()
    return result
 
assert [2, 3, 5, 7, 11, 13, 17, 37, 79, 113, 197, 199, 337, 1193, 3779, 11939, 19937, 193939, 199933] == main()
 
 
repunit = lambda n: int('1' * n)
 
def repmain(n: int) -> list:
    '''
        returns the first n repunit primes, probably.
    '''
    result = []
    i = 2
    while len(result) < n:
        if is_Prime(repunit(i)):
            result.append(i)
        i += 1
    return result
 
assert [2, 19, 23, 317, 1031] == repmain(5)
 
# because this Miller-Rabin test is already on rosettacode there's no good reason to test the longer repunits.",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"from pprint import pprint as pp
 
def pascal_upp(n):
    s = [[0] * n for _ in range(n)]
    s[0] = [1] * n
    for i in range(1, n):
        for j in range(i, n):
            s[i][j] = s[i-1][j-1] + s[i][j-1]
    return s
 
def pascal_low(n):
    # transpose of pascal_upp(n)
    return [list(x) for x in zip(*pascal_upp(n))]
 
def pascal_sym(n):
    s = [[1] * n for _ in range(n)]
    for i in range(1, n):
        for j in range(1, n):
            s[i][j] = s[i-1][j] + s[i][j-1]
    return s
 
 
if __name__ == ""__main__"":
    n = 5
    print(""\nUpper:"")
    pp(pascal_upp(n))
    print(""\nLower:"")
    pp(pascal_low(n))
    print(""\nSymmetric:"")
    pp(pascal_sym(n))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Additive_primes,Additive primes,"Definitions
In mathematics, additive primes are prime numbers for which the sum of their decimal digits are also primes.



Task
Write a program to determine (and show here) all additive primes less than 500.

Optionally, show the number of additive primes.



Also see

   the OEIS entry:   A046704 additive primes.
   the prime-numbers entry:   additive primes.
   the geeks for geeks entry: additive prime number.
   the prime-numbers fandom: additive primes.

",Python,"def is_prime(n: int) -> bool:
    if n <= 3:
        return n > 1
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i ** 2 <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True
 
def digit_sum(n: int) -> int:
    sum = 0
    while n > 0:
        sum += n % 10
        n //= 10
    return sum
 
def main() -> None:
    additive_primes = 0
    for i in range(2, 500):
        if is_prime(i) and is_prime(digit_sum(i)):
            additive_primes += 1
            print(i, end="" "")
    print(f""\nFound {additive_primes} additive primes less than 500"")
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Remove_duplicate_elements,Remove duplicate elements,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given an Array, derive a sequence of elements in which all duplicates are removed.

There are basically three approaches seen here:

 Put the elements into a hash table which does not allow duplicates. The complexity is O(n) on average, and O(n2) worst case. This approach requires a hash function for your type (which is compatible with equality), either built-in to your language, or provided by the user.
 Sort the elements and remove consecutive duplicate elements. The complexity of the best sorting algorithms is O(n log n). This approach requires that your type be ""comparable"", i.e., have an ordering. Putting the elements into a self-balancing binary search tree is a special case of sorting.
 Go through the list, and for each element, check the rest of the list to see if it appears again, and discard it if it does. The complexity is O(n2). The up-shot is that this always works on any type (provided that you can test for equality).

",Python,"items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']
unique = list(set(items))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Conjugate_transpose,Conjugate transpose,"Suppose that a matrix 



M


{\displaystyle M}

 contains complex numbers. Then the conjugate transpose of 



M


{\displaystyle M}

 is a matrix 




M

H




{\displaystyle M^{H}}

 containing the complex conjugates of the matrix transposition of 



M


{\displaystyle M}

.

 



(

M

H



)

j
i


=



M

i
j


¯




{\displaystyle (M^{H})_{ji}={\overline {M_{ij}}}}




This means that row 



j


{\displaystyle j}

, column 



i


{\displaystyle i}

 of the conjugate transpose equals the

complex conjugate of row 



i


{\displaystyle i}

, column 



j


{\displaystyle j}

 of the original matrix.



In the next list, 



M


{\displaystyle M}

 must also be a square matrix.

 A Hermitian matrix equals its own conjugate transpose: 




M

H


=
M


{\displaystyle M^{H}=M}

.
 A normal matrix is commutative in multiplication with its conjugate transpose: 




M

H


M
=
M

M

H




{\displaystyle M^{H}M=MM^{H}}

.
 A unitary matrix has its inverse equal to its conjugate transpose: 




M

H


=

M

−
1




{\displaystyle M^{H}=M^{-1}}

. 
 This is true iff 




M

H


M
=

I

n




{\displaystyle M^{H}M=I_{n}}

 and iff 



M

M

H


=

I

n




{\displaystyle MM^{H}=I_{n}}

, where 




I

n




{\displaystyle I_{n}}

 is the identity matrix.


Task

Given some matrix of complex numbers, find its conjugate transpose.

Also determine if the matrix is a:

 Hermitian matrix,
 normal matrix, or 
 unitary matrix.


See also

 MathWorld entry: conjugate transpose
 MathWorld entry: Hermitian matrix
 MathWorld entry: normal matrix
 MathWorld entry: unitary matrix

",Python,"def conjugate_transpose(m):
    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))
 
def mmul( ma, mb):
    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)
 
def mi(size):
    'Complex Identity matrix'
    sz = range(size)
    m = [[0 + 0j for i in sz] for j in sz]
    for i in range(size):
        m[i][i] = 1 + 0j
    return tuple(tuple(row) for row in m)
 
def __allsame(vector):
    first, rest = vector[0], vector[1:]
    return all(i == first for i in rest)
 
def __allnearsame(vector, eps=1e-14):
    first, rest = vector[0], vector[1:]
    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps
               for i in rest)
 
def isequal(matrices, eps=1e-14):
    'Check any number of matrices for equality within eps'
    x = [len(m) for m in matrices]
    if not __allsame(x): return False
    y = [len(m[0]) for m in matrices]
    if not __allsame(y): return False
    for s in range(x[0]):
        for t in range(y[0]):
            if not __allnearsame([m[s][t] for m in matrices], eps): return False
    return True
 
 
def ishermitian(m, ct):
    return isequal([m, ct])
 
def isnormal(m, ct):
    return isequal([mmul(m, ct), mmul(ct, m)])
 
def isunitary(m, ct):
    mct, ctm = mmul(m, ct), mmul(ct, m)
    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])
    ident = mi(mctx)
    return isequal([mct, ctm, ident])
 
def printm(comment, m):
    print(comment)
    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]
    width = max(max(len(f) for f in row) for row in fields)
    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)
    print('\n'.join(lines))
 
if __name__ == '__main__':
    for matrix in [
            ((( 3.000+0.000j), (+2.000+1.000j)), 
            (( 2.000-1.000j), (+1.000+0.000j))),
 
            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), 
            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), 
            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),
 
            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), 
            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), 
            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:
        printm('\nMatrix:', matrix)
        ct = conjugate_transpose(matrix)
        printm('Its conjugate transpose:', ct)
        print('Hermitian? %s.' % ishermitian(matrix, ct))
        print('Normal?    %s.' % isnormal(matrix, ct))
        print('Unitary?   %s.' % isunitary(matrix, ct))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"def pyth(n):
    return (
        (x, y, z)
        for x in range(1, n + 1)
        for y in range(x, n + 1)
        for z in range(y, n + 1)
        if x ** 2 + y ** 2 == z ** 2
    )",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sort_an_integer_array,Sort an integer array,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of integers in ascending numerical order.



Use a sorting facility provided by the language/library if possible.



",Python,"def int_arr(a, b):
    return a - b

numbers = [20, 7, 65, 10, 3, 0, 8, -60]
numbers.sort(int_arr)
print(numbers)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Random_Latin_squares,Random Latin squares,"A Latin square of size n is an arrangement of n symbols in an n-by-n square in such a way that each row and column has each symbol appearing exactly once.

A randomised Latin square generates random configurations of the symbols for any given n.

Example n=4 randomised Latin square

0 2 3 1
2 1 0 3
3 0 1 2
1 3 2 0
Task

 Create a function/routine/procedure/method/... that given n generates a randomised Latin square of size n.
 Use the function to generate and show here, two randomly generated squares of size 5.
Note
 
Strict Uniformity in the random generation is a hard problem and not a requirement of the task.

Reference

 Wikipedia: Latin square
 OEIS: A002860

",Python,"from random import choice, shuffle
from copy import deepcopy
 
def rls(n):
    if n <= 0:
        return []
    else:
        symbols = list(range(n))
        square = _rls(symbols)
        return _shuffle_transpose_shuffle(square)
 
 
def _shuffle_transpose_shuffle(matrix):
    square = deepcopy(matrix)
    shuffle(square)
    trans = list(zip(*square))
    shuffle(trans)
    return trans
 
 
def _rls(symbols):
    n = len(symbols)
    if n == 1:
        return [symbols]
    else:
        sym = choice(symbols)
        symbols.remove(sym)
        square = _rls(symbols)
        square.append(square[0].copy())
        for i in range(n):
            square[i].insert(i, sym)
        return square
 
def _to_text(square):
    if square:
        width = max(len(str(sym)) for row in square for sym in row)
        txt = '\n'.join(' '.join(f""{sym:>{width}}"" for sym in row)
                        for row in square)
    else:
        txt = ''
    return txt
 
def _check(square):
    transpose = list(zip(*square))
    assert _check_rows(square) and _check_rows(transpose), \
        ""Not a Latin square""
 
def _check_rows(square):
    if not square:
        return True
    set_row0 = set(square[0])
    return all(len(row) == len(set(row)) and set(row) == set_row0
               for row in square)
 
 
if __name__ == '__main__':
    for i in [3, 3,  5, 5, 12]:
        square = rls(i)
        print(_to_text(square))
        _check(square)
        print()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Echo_server,Echo server,"Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.

The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.

The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.
",Python,"import socket
import sys
import threading
 
def echo(s, i):
	print ""%d: %s <-> %s"" % (i, s.getsockname(), s.getpeername())
	while True:
		line = s.recv(1024)
		if not line:
			break
		s.send(line)
	print ""%d: closed"" % i
	s.close()
 
def main():
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	s.bind(('', 12321))
	s.listen(5)
	i = 0
	while True:
		try:
			cs, addr = s.accept()
			t = threading.Thread(target=echo, args=(cs, i))
			t.start()
			i += 1
		except KeyboardInterrupt:
			break
 
if __name__ == '__main__':
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Balanced_brackets,Balanced brackets,"Task:

 Generate a string with   N   opening brackets   [   and with   N   closing brackets   ],   in some arbitrary order. 
 Determine whether the generated string is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.


Examples

   (empty)      OK
   []           OK   
   [][]         OK   
   [[][]]       OK 
   ][         NOT OK
   ][][       NOT OK
   []][[]     NOT OK


",Python,"import random
import time
 
def init():
    random.seed(time.time())
 
def generate(n):
    a = ""[]"" * n
    for i in range(len(a) - 1, 0, -1):
        j = random.randint(0, i)
        a[i], a[j] = a[j], a[i]
    return a
 
def testBalanced(s):
    print(s + "": "", end="""")
    open = 0
    for c in s:
        if c == '[':
            open += 1
        elif c == ']':
            if open == 0:
                print(""not ok"")
                return
            open -= 1
        else:
            print(""not ok"")
            return
    if open == 0:
        print(""ok"")
    else:
        print(""not ok"")
 
def main():
    init()
    for i in range(10):
        testBalanced(generate(i))
    testBalanced(""()"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Tau_function,Tau function,"Given a positive integer, count the number of its positive divisors.



Task
Show the result for the first   100   positive integers.



Related task
  Tau number

",Python,"def divisorCount(n):
    total = 1
    # Deal with powers of 2 first
    while (n & 1) == 0:
        n >>= 1
        total += 1
    # Odd prime factors up to the square root
    for p in range(3, int(n**0.5) + 1, 2):
        count = 1
        while n % p == 0:
            n /= p
            count += 1
        total *= count
    # If n > 1 then it's prime
    if n > 1:
        total *= 2
    return total

limit = 100
print(""Count of divisors for the first %d positive integers:"" % limit)
for n in range(1, limit + 1):
    print(""%3d"" % divisorCount(n), end="""")
    if n % 20 == 0:
        print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",Python,"import calendar
calendar.isleap(year)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Polymorphism,Polymorphism,"Task

Create two classes   Point(x,y)   and   Circle(x,y,r)   with a polymorphic function print, accessors for (x,y,r), copy constructor, assignment and destructor and every possible default constructors



",Python,"class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def print(self):
        print(""Point"")


class Circle(Point):
    def __init__(self, x=0, y=0, r=0):
        super().__init__(x, y)
        self.r = r

    def print(self):
        print(""Circle"")


if __name__ == ""__main__"":
    p = Point()
    c = Circle()
    p.print()
    c.print()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Read_a_configuration_file,Read a configuration file,"The task is to read a configuration file in standard configuration file format,
and set variables accordingly.

For this task, we have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines beginning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# This is the fullname parameter
FULLNAME Foo Barber

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# Configuration option names are not case sensitive, but configuration parameter
# data is case sensitive and may be preserved by the application program.

# An optional equals sign can be used to separate configuration parameter data
# from the option name. This is dropped by the parser. 

# A configuration option may take multiple parameters separated by commas.
# Leading and trailing whitespace around parameter names and parameter data fields
# are ignored by the application program.

OTHERFAMILY Rhu Barber, Harry Barber



For the task we need to set four variables according to the configuration entries as follows:

fullname = Foo Barber
favouritefruit = banana
needspeeling = true
seedsremoved = false


We also have an option that contains multiple parameters. These may be stored in an array.

 otherfamily(1) = Rhu Barber
 otherfamily(2) = Harry Barber


Related tasks
 Update a configuration file

",Python,"import os
 
class Config:
    def __init__(self):
        self.full_name = None
        self.favourite_fruit = None
        self.needs_peeling = False
        self.seeds_removed = False
        self.other_family = None
 
def config_from_file(path):
    cfg = Config()
 
    with open(path, 'r') as file:
        for line in file:
            # Remove whitespaces at the beginning and end
            line = line.strip()
 
            # Ignore comments and empty lines
            if line.startswith('#') or line.startswith(';') or not line:
                continue
 
            # Split line into parameter name and rest tokens
            name, *tokens = line.split()
 
            # Remove the equal signs
            tokens = [t for t in tokens if not t.startswith('=')]
            # Remove comment after the parameters
            tokens = [t for t in tokens if not t.startswith('#') and not t.startswith(';')]
 
            # Concat back the parameters into one string to split for separated parameters
            parameters =''.join(tokens)
            # Splits the parameters and trims
            parameters = [p.strip() for p in parameters.split(',')]
 
            # Setting the config parameters
            if name.lower() == 'fullname':
                cfg.full_name = parameters[0]
            elif name.lower() == 'favouritefruit':
                cfg.favourite_fruit = parameters[0]
            elif name.lower() == 'needspeeling':
                cfg.needs_peeling = True
            elif name.lower() =='seedsremoved':
                cfg.seeds_removed = True
            elif name.lower() == 'otherfamily':
                cfg.other_family = parameters
 
    return cfg
 
if __name__ == '__main__':
    path = os.path.join(os.path.dirname(__file__), 'file.conf')
    cfg = config_from_file(path)
    print(cfg.__dict__)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm,Bitmap/Bresenham's line algorithm,"Task

Using the data storage type defined on the Bitmap page for raster graphics images,

draw a line given two points with Bresenham's line algorithm.



",Python,"def line(self, x0, y0, x1, y1):
    ""Bresenham's line algorithm""
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    x, y = x0, y0
    sx = -1 if x0 > x1 else 1
    sy = -1 if y0 > y1 else 1
    if dx > dy:
        err = dx / 2.0
        while x != x1:
            self.set(x, y)
            err -= dy
            if err < 0:
                y += sy
                err += dx
            x += sx
    else:
        err = dy / 2.0
        while y != y1:
            self.set(x, y)
            err -= dx
            if err < 0:
                x += sx
                err += dy
            y += sy        
    self.set(x, y)
Bitmap.line = line
 
bitmap = Bitmap(17,17)
for points in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):
    bitmap.line(*points)
bitmap.chardisplay()
 
'''
The origin, 0,0; is the lower left, with x increasing to the right,
and Y increasing upwards.
 
The chardisplay above produces the following output :
+-----------------+
|        @        |
|       @ @       |
|      @   @      |
|     @     @     |
|    @       @    |
|    @        @   |
|   @          @  |
|  @            @ |
| @              @|
|  @            @ |
|   @          @  |
|    @       @@   |
|     @     @     |
|      @   @      |
|       @ @       |
|        @        |
|                 |
+-----------------+
'''",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Iterated_digits_squaring,Iterated digits squaring,"If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:

15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89
7 -> 49 -> 97 -> 130 -> 10 -> 1
An example in Python:

>>> step = lambda x: sum(int(d) ** 2 for d in str(x))
>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))
>>> [iterate(x) for x in xrange(1, 20)]
[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]


Task

 Count how many number chains for integers 1 <= n < 100_000_000 end with a value 89.
Or, for much less credit - (showing that your algorithm and/or language is slow):

 Count how many number chains for integers 1 <= n < 1_000_000 end with a value 89.
This problem derives from the Project Euler problem 92.

For a quick algorithm for this task see the talk page



Related tasks

 Combinations with repetitions
 Digital root
 Digital root/Multiplicative digital root

",Python,"from math import ceil, log10, factorial
 
def next_step(x):
    result = 0
    while x > 0:
        result += (x % 10) ** 2
        x /= 10
    return result
 
def check(number):
    candidate = 0
    for n in number:
        candidate = candidate * 10 + n
 
    while candidate != 89 and candidate != 1:
        candidate = next_step(candidate)
 
    if candidate == 89:
        digits_count = [0] * 10
        for d in number:
            digits_count[d] += 1
 
        result = factorial(len(number))
        for c in digits_count:
            result /= factorial(c)
        return result
 
    return 0
 
def main():
    limit = 100000000
    cache_size = int(ceil(log10(limit)))
    assert 10 ** cache_size == limit
 
    number = [0] * cache_size
    result = 0
    i = cache_size - 1
 
    while True:
        if i == 0 and number[i] == 9:
            break
        if i == cache_size - 1 and number[i] < 9:
            number[i] += 1
            result += check(number)
        elif number[i] == 9:
            i -= 1
        else:
            number[i] += 1
            for j in xrange(i + 1, cache_size):
                number[j] = number[i]
            i = cache_size - 1
            result += check(number)
 
    print result
 
main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Spiral_matrix,Spiral matrix,"Task

Produce a spiral array.



A   spiral array   is a square arrangement of the first    N2   natural numbers,   where the

numbers increase sequentially as you go around the edges of the array spiraling inwards.



For example, given   5,   produce this array:

 0  1  2  3  4
15 16 17 18  5
14 23 24 19  6
13 22 21 20  7
12 11 10  9  8



Related tasks

   Zig-zag matrix 
   Identity_matrix
   Ulam_spiral_(for_primes)

",Python,"def spiralArray(edge):
    arr = [[] for i in range(edge)]
    x = 0
    y = edge
    total = edge * edge
    dx = 1
    dy = 0
    i = 0
    j = 0
    while y:
        y -= 1
        arr[y] = [0] * edge
    while i < total:
        arr[y][x] = i
        i += 1
        x += dx
        y += dy
        j += 1
        if j == edge:
            if dy < 0:
                x += 1
                y += 1
                edge -= 2
            j = dx
            dx = -dy
            dy = j
            j = 0
    return arr
 
# T E S T:
arr = spiralArray(edge = 5)
for y in range(edge):
    print(arr[y])",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",Python,"import random

switchWins = 0
stayWins = 0

for plays in range(1000000):
    doors = [0,0,0]
    winner = random.randint(0,2)
    doors[winner] = 1

    choice = random.randint(0,2)
    shown = random.randint(0,2)
    while doors[shown] == 1 or shown == choice:
        shown = random.randint(0,2)

    stayWins += doors[choice]
    switchWins += doors[3 - choice - shown]

print(""Staying wins "" + str(stayWins) + "" times."")
print(""Switching wins "" + str(switchWins) + "" times."")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",Python,"# Add this line to the [dependencies] section of your Cargo.toml file:
# num = ""0.2.0""
 
from num import bigint
from num.bigint import ToBigInt
 
# The modular_exponentiation() function takes three identical types
# (which get cast to BigInt), and returns a BigInt:
def modular_exponentiation(n, e, m):
    # Convert n, e, and m to BigInt:
    n = n.to_bigint()
    e = e.to_bigint()
    m = m.to_bigint()
 
    # Sanity check:  Verify that the exponent is not negative:
    assert e >= 0
 
    # As most modular exponentiations do, return 1 if the exponent is 0:
    if e == 0:
        return 1
 
    # Now do the modular exponentiation algorithm:
    result = 1
    base = n % m
    exp = e
 
    # Loop until we can return out result:
    while True:
        if exp % 2 == 1:
            result *= base
            result %= m
 
        if exp == 1:
            return result
 
        exp /= 2
        base *= base
        base %= m",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Generic_swap,Generic swap,"Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.

If your solution language is statically typed please describe the way your language provides genericity.

If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.
That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.

Generic swap is a task which brings together a few separate issues in programming language semantics.

Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.

Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.

Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).

Do your best!



",Python,"a, b = b, a",Human_written,Python_from_Java
http://rosettacode.org/wiki/Jaro_similarity,Jaro similarity,"The Jaro distance is a measure of edit distance between two strings; its inverse, called the Jaro similarity, is a measure of two strings' similarity: the higher the value, the more similar the strings are. The score is normalized such that   0   equates to no similarities and   1   is an exact match.



Definition
The Jaro similarity   




d

j




{\displaystyle d_{j}}

   of two given strings   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   is

 




d

j


=

{




0



if 

m
=
0






1
3



(


m


|


s

1



|




+


m


|


s

2



|




+



m
−
t

m


)




otherwise









{\displaystyle d_{j}=\left\{{\begin{array}{l l}0&{\text{if }}m=0\\{\frac {1}{3}}\left({\frac {m}{|s_{1}|}}+{\frac {m}{|s_{2}|}}+{\frac {m-t}{m}}\right)&{\text{otherwise}}\end{array}}\right.}


Where:

 



m


{\displaystyle m}

   is the number of matching characters;
 



t


{\displaystyle t}

   is half the number of transpositions.


Two characters from   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   respectively, are considered matching only if they are the same and not farther apart than   




⌊



max
(

|


s

1



|

,

|


s

2



|

)

2


⌋

−
1


{\displaystyle \left\lfloor {\frac {\max(|s_{1}|,|s_{2}|)}{2}}\right\rfloor -1}

 characters.

Each character of   




s

1




{\displaystyle s_{1}}

   is compared with all its matching characters in   




s

2




{\displaystyle s_{2}}

. Each difference in position is half a transposition; that is, the number of transpositions is half the number of characters which are common to the two strings but occupy different positions in each one.



Example
Given the strings   




s

1




{\displaystyle s_{1}}

   DWAYNE   and   




s

2




{\displaystyle s_{2}}

   DUANE   we find:

 



m
=
4


{\displaystyle m=4}


 




|


s

1



|

=
6


{\displaystyle |s_{1}|=6}


 




|


s

2



|

=
5


{\displaystyle |s_{2}|=5}


 



t
=
0


{\displaystyle t=0}




We find a Jaro score of:

 




d

j


=


1
3



(


4
6


+


4
5


+



4
−
0

4


)

=
0.822


{\displaystyle d_{j}={\frac {1}{3}}\left({\frac {4}{6}}+{\frac {4}{5}}+{\frac {4-0}{4}}\right)=0.822}




Task
Implement the Jaro algorithm and show the similarity scores for each of the following pairs:

 (""MARTHA"", ""MARHTA"")
 (""DIXON"", ""DICKSONX"")
 (""JELLYFISH"", ""SMELLYFISH"")


 See also
 Jaro–Winkler distance on Wikipedia.

",Python,"'''Jaro distance'''
 
from __future__ import division
 
 
def jaro(s, t):
    '''Jaro distance between two strings.'''
    s_len = len(s)
    t_len = len(t)
 
    if s_len == 0 and t_len == 0:
        return 1
 
    match_distance = (max(s_len, t_len) // 2) - 1
 
    s_matches = [False] * s_len
    t_matches = [False] * t_len
 
    matches = 0
    transpositions = 0
 
    for i in range(s_len):
        start = max(0, i - match_distance)
        end = min(i + match_distance + 1, t_len)
 
        for j in range(start, end):
            if t_matches[j]:
                continue
            if s[i] != t[j]:
                continue
            s_matches[i] = True
            t_matches[j] = True
            matches += 1
            break
 
    if matches == 0:
        return 0
 
    k = 0
    for i in range(s_len):
        if not s_matches[i]:
            continue
        while not t_matches[k]:
            k += 1
        if s[i] != t[k]:
            transpositions += 1
        k += 1
 
    return ((matches / s_len) +
            (matches / t_len) +
            ((matches - transpositions / 2) / matches)) / 3
 
 
def main():
    '''Tests'''
 
    for s, t in [('MARTHA', 'MARHTA'),
                 ('DIXON', 'DICKSONX'),
                 ('JELLYFISH', 'SMELLYFISH')]:
        print(""jaro(%r, %r) = %.10f"" % (s, t, jaro(s, t)))
 
 
if __name__ == '__main__':
    main()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes,Safe primes and unsafe primes,"Definitions

   A   safe prime   is a prime   p   and where   (p-1)/2   is also prime.
   The corresponding prime  (p-1)/2   is known as a   Sophie Germain   prime.
   An   unsafe prime   is a prime   p   and where   (p-1)/2   isn't   a prime.
   An   unsafe prime   is a prime that   isn't   a   safe   prime.


Task

   Find and display (on one line) the first   35   safe primes.
   Find and display the   count   of the safe primes below   1,000,000.
   Find and display the   count   of the safe primes below 10,000,000.
   Find and display (on one line) the first   40   unsafe primes.
   Find and display the   count   of the unsafe primes below   1,000,000.
   Find and display the   count   of the unsafe primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   strong and weak primes.


Also see

   The OEIS article:     safe   primes.
   The OEIS article:   unsafe primes.

",Python,"primes =[]
sp =[]
usp=[]
n = 10000000
if 2<n:
    primes.append(2)
for i in range(3,n+1,2):
    for j in primes:
        if(j>i/2) or (j==primes[-1]):
            primes.append(i)
            if((i-1)/2) in primes:
                sp.append(i)
                break
            else:
                usp.append(i)
                break
        if (i%j==0):
            break
 
print('First 35 safe primes are:\n' , sp[:35])
print('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')
print('There are '+str(len(sp))+' safe primes below 10,000,000')
print('First 40 unsafe primes:\n',usp[:40])
print('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')
print('There are '+str(len(usp))+' safe primes below 10,000,000')",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Penney%27s_game,Penney's game,"Penney's game is a game where two players bet on being the first to see a particular sequence of heads or tails in consecutive tosses of a fair coin.

It is common to agree on a sequence length of three then one player will openly choose a sequence, for example:

 Heads,  Tails,  Heads, or HTH for short.

The other player on seeing the first players choice will choose his sequence. The coin is tossed and the first player to see his sequence in the sequence of coin tosses wins.



Example

One player might choose the sequence HHT and the other THT.

Successive coin tosses of HTTHT gives the win to the second player as the last three coin tosses are his sequence.



Task
Create a program that tosses the coin, keeps score and plays Penney's game against a human opponent.

 Who chooses and shows their sequence of three should be chosen randomly.
 If going first, the computer should randomly choose its sequence of three.
 If going second, the computer should automatically play the optimum sequence.
 Successive coin tosses should be shown.


Show output of a game where the computer chooses first and a game where the user goes first here on this page.



See also
 The Penney Ante Part 1 (Video).
 The Penney Ante Part 2 (Video).

",Python,"from random import randint
from time import sleep
from os import system, name

pause = 500
N = 3

def toss():
    return randint(0, 1)

def as_string(sequence):
    s = """"
    for b in range(0b100, 0, -1):
        s += ""T"" if (sequence & b) > 0 else ""H""
    return s

def user_input():
    while True:
        key = input()
        if key == ""Escape"":
            return -1
        elif key == ""H"":
            return 0
        elif key == ""T"":
            return 1
        else:
            print(""\b"", end="""")

def main():
    your_score = 0
    my_score = 0
    while True:
        print(f""Your score: {your_score}, My score: {my_score}"")
        print(""Determining who goes first..."")
        sleep(pause)
        you_start = toss() == 1
        print(""You go first."" if you_start else ""I go first."")
        your_sequence = 0
        my_sequence = 0
        if you_start:
            print(""Choose your sequence of (H)eads and (T)ails (or press Esc to exit)"")
            for i in range(N):
                user_choice = user_input()
                if user_choice < 0:
                    return
                your_sequence = (your_sequence << 1) + user_choice
            my_sequence = ((~your_sequence << 1) & 0b100) | (your_sequence >> 1)
        else:
            for i in range(N):
                my_sequence = (my_sequence << 1) + toss()
            print(f""I chose {as_string(my_sequence)}"")
            while True:
                print(""Choose your sequence of (H)eads and (T)ails (or press Esc to exit)"")
                your_sequence = 0
                for i in range(N):
                    choice = user_input()
                    if choice < 0:
                        return
                    your_sequence = (your_sequence << 1) + choice
                if your_sequence == my_sequence:
                    print()
                    print(""You cannot choose the same sequence."")
                else:
                    break
        print()
        print(f""Your sequence: {as_string(your_sequence)}, My sequence: {as_string(my_sequence)}"")
        print(""Tossing..."")
        sequence = 0
        for i in range(N):
            sleep(pause)
            toss = toss()
            sequence = (sequence << 1) + toss
            print(""T"" if toss > 0 else ""H"", end="""")
        while True:
            if sequence == your_sequence:
                print()
                print(""You win!"")
                your_score += 1
                break
            elif sequence == my_sequence:
                print()
                print(""I win!"")
                my_score += 1
                break
            sleep(pause)
            toss = toss()
            sequence = ((sequence << 1) + toss) & 0b111
            print(""T"" if toss > 0 else ""H"", end="""")
        print(""Press a key."")
        input()
        system('cls' if name == 'nt' else 'clear')

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Primorial_numbers,Primorial numbers,"Primorial numbers are those formed by multiplying successive prime numbers.



The primorial number series is:

   primorial(0) =         1       (by definition)
   primorial(1) =         2       (2)
   primorial(2) =         6       (2×3)
   primorial(3) =       30       (2×3×5)
   primorial(4) =     210       (2×3×5×7)
   primorial(5) =   2310       (2×3×5×7×11)
   primorial(6) = 30030       (2×3×5×7×11×13)
         ∙ ∙ ∙
To express this mathematically,   primorialn   is  
the product of the first   n   (successive) primes:



   



p
r
i
m
o
r
i
a

l

n


=

∏

k
=
1


n


p
r
i
m

e

k




{\displaystyle primorial_{n}=\prod _{k=1}^{n}prime_{k}}




 ─── where   



p
r
i
m

e

k




{\displaystyle prime_{k}}

   is the   kth   prime number.




In some sense, generating primorial numbers is similar to factorials.

As with factorials, primorial numbers get large quickly.



Task

   Show the first ten primorial numbers   (0 ──► 9,   inclusive).
   Show the length of primorial numbers whose index is:   10   100   1,000   10,000   and   100,000.
   Show the length of the one millionth primorial number   (optional). 
   Use exact integers, not approximations. 


By   length   (above), it is meant the number of decimal digits in the numbers. 




Related tasks

   Sequence of primorial primes
   Factorial
   Fortunate_numbers


See also

   the MathWorld webpage:   primorial
   the Wikipedia   webpage:   primorial.
   the   OEIS   webpage:   A002110.

",Python,"from pyprimes import nprimes
from functools import reduce
 
 
primelist = list(nprimes(1000001))    # [2, 3, 5, ...]
 
def primorial(n):
    return reduce(int.__mul__, primelist[:n], 1)
 
if __name__ == '__main__':
    print('First ten primorals:', [primorial(n) for n in range(10)])
    for e in range(7):
        n = 10**e
        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def palindrome(s):
    return s == s[::-1]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Last_letter-first_letter,Last letter-first letter,"A certain children's game involves starting with a word in a particular category.   Each participant in turn says a word, but that word must begin with the final letter of the previous word.   Once a word has been given, it cannot be repeated.   If an opponent cannot give a word in the category, they fall out of the game.



For example, with   ""animals""   as the category,

Child 1: dog 
Child 2: goldfish
Child 1: hippopotamus
Child 2: snake
...



Task

Take the following selection of 70 English Pokemon names   (extracted from   Wikipedia's list of Pokemon)   and generate the/a sequence with the highest possible number of Pokemon names where the subsequent name starts with the final letter of the preceding name.

No Pokemon name is to be repeated.

audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask



Extra brownie points for dealing with the full list of   646   names.



",Python,"from collections import defaultdict
 
def order_words(words):
    byfirst = defaultdict(set)
    for word in words:
        byfirst[word[0]].add( word )
    #byfirst = dict(byfirst)
    return byfirst
 
def linkfirst(byfirst, sofar):
    '''\
    For all words matching last char of last word in sofar as FIRST char and not in sofar,
    return longest chain as sofar + chain
    '''
 
    assert sofar
    chmatch = sofar[-1][-1]
    options = byfirst[chmatch] - set(sofar)
    #print('  linkfirst options: %r %r' % (chmatch, options))
    if not options:
        return sofar
    else:
        alternatives = ( linkfirst(byfirst, list(sofar) + [word])
                         for word in options )
        mx = max( alternatives, key=len )
        #input('linkfirst: %r' % mx)
        return mx
 
def llfl(words):
 
    byfirst = order_words(words)
    return max( (linkfirst(byfirst, [word]) for word in words), key=len )
 
if __name__ == '__main__':
    pokemon = '''audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask'''
    pokemon = pokemon.strip().lower().split()
    pokemon = sorted(set(pokemon))    
    l = llfl(pokemon)
    for i in range(0, len(l), 8): print(' '.join(l[i:i+8]))
    print(len(l))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Rename_a_file,Rename a file,"Task

Rename:

   a file called     input.txt     into     output.txt     and 
   a directory called     docs     into     mydocs.


This should be done twice:  
once ""here"", i.e. in the current working directory and once in the filesystem root.

It can be assumed that the user has the rights to do so.

(In unix-type systems, only the user root would have
sufficient permissions in the filesystem root.)



",Python,"# version 1.0.6
 
# testing on Windows 10 which needs administrative privileges
# to rename files in the root
 
import os
 
oldPaths = [""input.txt"", ""docs"", ""c:\\input.txt"", ""c:\\docs""]
newPaths = [""output.txt"", ""mydocs"", ""c:\\output.txt"", ""c:\\mydocs""]
for i in range(0, len(oldPaths)):
    oldFile = oldPaths[i]
    newFile = newPaths[i]
    if os.rename(oldFile, newFile):
        print(oldPaths[i] + "" successfully renamed to "" + newPaths[i])
    else:
        print(oldPaths[i] + "" could not be renamed"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Number_names,Number names,"Task

Show how to spell out a number in English.

You can use a preexisting implementation or roll your own, but you should support inputs up to at least one million (or the maximum value of your language's default bounded integer type, if that's less).

Support for inputs other than positive integers (like zero, negative integers, and floating-point numbers) is optional.



Related task

   Spelling of ordinal numbers.

",Python,"TENS = [None, None, ""twenty"", ""thirty"", ""forty"",
        ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
SMALL = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"",
         ""six"", ""seven"", ""eight"", ""nine"", ""ten"", ""eleven"",
         ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
         ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""]
HUGE = [None, None] + [h + ""illion"" 
                       for h in (""m"", ""b"", ""tr"", ""quadr"", ""quint"", ""sext"", 
                                  ""sept"", ""oct"", ""non"", ""dec"")]
 
def nonzero(c, n, connect=''):
    return """" if n == 0 else connect + c + spell_integer(n)
 
def last_and(num):
    if ',' in num:
        pre, last = num.rsplit(',', 1)
        if ' and ' not in last:
            last = ' and' + last
        num = ''.join([pre, ',', last])
    return num
 
def big(e, n):
    if e == 0:
        return spell_integer(n)
    elif e == 1:
        return spell_integer(n) + "" thousand""
    else:
        return spell_integer(n) + "" "" + HUGE[e]
 
def base1000_rev(n):
    # generates the value of the digits of n in base 1000
    # (i.e. 3-digit chunks), in reverse.
    while n != 0:
        n, r = divmod(n, 1000)
        yield r
 
def spell_integer(n):
    if n < 0:
        return ""minus "" + spell_integer(-n)
    elif n < 20:
        return SMALL[n]
    elif n < 100:
        a, b = divmod(n, 10)
        return TENS[a] + nonzero(""-"", b)
    elif n < 1000:
        a, b = divmod(n, 100)
        return SMALL[a] + "" hundred"" + nonzero("" "", b, ' and')
    else:
        num = "", "".join([big(e, x) for e, x in
                         enumerate(base1000_rev(n)) if x][::-1])
        return last_and(num)
 
if __name__ == '__main__':
    # examples
    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):
        print('%+4i -> %s' % (n, spell_integer(n)))
    print('')  
 
    n = 201021002001
    while n:
        print('%-12i -> %s' % (n, spell_integer(n)))
        n //= -10
    print('%-12i -> %s' % (n, spell_integer(n)))
    print('')",Human_written,Python_from_C++
http://rosettacode.org/wiki/Non-continuous_subsequences,Non-continuous subsequences,"Consider some sequence of elements. (It differs from a mere set of elements by having an ordering among members.)

A subsequence contains some subset of the elements of this sequence, in the same order.

A continuous subsequence is one in which no elements are missing between the first and last elements of the subsequence.

Note: Subsequences are defined structurally, not by their contents.
So a sequence a,b,c,d will always have the same subsequences and continuous subsequences, no matter which values are substituted; it may even be the same value.


Task: Find all non-continuous subsequences for a given sequence.



Example

For the sequence   1,2,3,4,   there are five non-continuous subsequences, namely:

   1,3
   1,4
   2,4
   1,3,4
   1,2,4


Goal

There are different ways to calculate those subsequences.

Demonstrate algorithm(s) that are natural for the language.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def ncsub(seq, s=0):
    if seq:
        x = seq[:1]
        xs = seq[1:]
        p2 = s % 2
        p1 = not p2
        return [x + ys for ys in ncsub(xs, s + p1)] + ncsub(xs, s + p2)
    else:
        return [[]] if s >= 3 else []",Human_written,Python_from_Go
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class Node(object):
     def __init__(self, data = None, prev = None, next = None):
         self.prev = prev
         self.next = next
         self.data = data
     def __str__(self):
         return str(self.data)
     def __repr__(self):
         return repr(self.data)
     def iter_forward(self):
         c = self
         while c != None:
             yield c
             c = c.next
     def iter_backward(self):
         c = self
         while c != None:
             yield c
             c = c.prev",Human_written,Python_from_C#
http://rosettacode.org/wiki/Deconvolution/1D,Deconvolution/1D,"The convolution of two functions 





F




{\displaystyle {\mathit {F}}}

 and 





H




{\displaystyle {\mathit {H}}}

 of
an integer variable is defined as the function 





G




{\displaystyle {\mathit {G}}}


satisfying





G
(
n
)
=

∑

m
=
−
∞


∞


F
(
m
)
H
(
n
−
m
)


{\displaystyle G(n)=\sum _{m=-\infty }^{\infty }F(m)H(n-m)}


for all integers 





n




{\displaystyle {\mathit {n}}}

. Assume 



F
(
n
)


{\displaystyle F(n)}

 can be non-zero only for 



0


{\displaystyle 0}

 ≤ 





n




{\displaystyle {\mathit {n}}}

 ≤ 




|



F



|



{\displaystyle |{\mathit {F}}|}

, where 




|



F



|



{\displaystyle |{\mathit {F}}|}

 is the ""length"" of 





F




{\displaystyle {\mathit {F}}}

, and similarly for 





G




{\displaystyle {\mathit {G}}}

 and 





H




{\displaystyle {\mathit {H}}}

, so that the functions can be modeled as finite sequences by identifying 




f

0


,

f

1


,

f

2


,
…


{\displaystyle f_{0},f_{1},f_{2},\dots }

 with 



F
(
0
)
,
F
(
1
)
,
F
(
2
)
,
…


{\displaystyle F(0),F(1),F(2),\dots }

, etc.
Then for example, values of 




|



F



|

=
6


{\displaystyle |{\mathit {F}}|=6}

 and 




|



H



|

=
5


{\displaystyle |{\mathit {H}}|=5}

 would determine the following value of 





g




{\displaystyle {\mathit {g}}}

 by definition.










g

0




=



f

0



h

0







g

1




=



f

1



h

0




+



f

0



h

1







g

2




=



f

2



h

0




+



f

1



h

1




+



f

0



h

2







g

3




=



f

3



h

0




+



f

2



h

1




+



f

1



h

2




+



f

0



h

3







g

4




=



f

4



h

0




+



f

3



h

1




+



f

2



h

2




+



f

1



h

3




+



f

0



h

4







g

5




=



f

5



h

0




+



f

4



h

1




+



f

3



h

2




+



f

2



h

3




+



f

1



h

4







g

6




=





f

5



h

1




+



f

4



h

2




+



f

3



h

3




+



f

2



h

4







g

7




=







f

5



h

2




+



f

4



h

3




+



f

3



h

4







g

8




=









f

5



h

3




+



f

4



h

4







g

9




=











f

5



h

4








{\displaystyle {\begin{array}{lllllllllll}g_{0}&=&f_{0}h_{0}\\g_{1}&=&f_{1}h_{0}&+&f_{0}h_{1}\\g_{2}&=&f_{2}h_{0}&+&f_{1}h_{1}&+&f_{0}h_{2}\\g_{3}&=&f_{3}h_{0}&+&f_{2}h_{1}&+&f_{1}h_{2}&+&f_{0}h_{3}\\g_{4}&=&f_{4}h_{0}&+&f_{3}h_{1}&+&f_{2}h_{2}&+&f_{1}h_{3}&+&f_{0}h_{4}\\g_{5}&=&f_{5}h_{0}&+&f_{4}h_{1}&+&f_{3}h_{2}&+&f_{2}h_{3}&+&f_{1}h_{4}\\g_{6}&=&&&f_{5}h_{1}&+&f_{4}h_{2}&+&f_{3}h_{3}&+&f_{2}h_{4}\\g_{7}&=&&&&&f_{5}h_{2}&+&f_{4}h_{3}&+&f_{3}h_{4}\\g_{8}&=&&&&&&&f_{5}h_{3}&+&f_{4}h_{4}\\g_{9}&=&&&&&&&&&f_{5}h_{4}\end{array}}}


We can write this in matrix form as:






(





g

0







g

1







g

2







g

3







g

4







g

5







g

6







g

7







g

8







g

9






)

=

(





f

0







f

1





f

0







f

2





f

1





f

0







f

3





f

2





f

1





f

0







f

4





f

3





f

2





f

1





f

0







f

5





f

4





f

3





f

2





f

1








f

5





f

4





f

3





f

2









f

5





f

4





f

3










f

5





f

4











f

5






)



(





h

0







h

1







h

2







h

3







h

4






)



{\displaystyle \left({\begin{array}{l}g_{0}\\g_{1}\\g_{2}\\g_{3}\\g_{4}\\g_{5}\\g_{6}\\g_{7}\\g_{8}\\g_{9}\\\end{array}}\right)=\left({\begin{array}{lllll}f_{0}\\f_{1}&f_{0}\\f_{2}&f_{1}&f_{0}\\f_{3}&f_{2}&f_{1}&f_{0}\\f_{4}&f_{3}&f_{2}&f_{1}&f_{0}\\f_{5}&f_{4}&f_{3}&f_{2}&f_{1}\\&f_{5}&f_{4}&f_{3}&f_{2}\\&&f_{5}&f_{4}&f_{3}\\&&&f_{5}&f_{4}\\&&&&f_{5}\end{array}}\right)\;\left({\begin{array}{l}h_{0}\\h_{1}\\h_{2}\\h_{3}\\h_{4}\\\end{array}}\right)}


or





g
=
A

h


{\displaystyle g=A\;h}


For this task, implement a function (or method, procedure, subroutine, etc.) deconv to perform deconvolution (i.e., the inverse of convolution) by constructing and solving such a system of equations represented by the above matrix 



A


{\displaystyle A}

 for 





h




{\displaystyle {\mathit {h}}}

 given 





f




{\displaystyle {\mathit {f}}}

 and 





g




{\displaystyle {\mathit {g}}}

.

 The function should work for 





G




{\displaystyle {\mathit {G}}}

 of arbitrary length (i.e., not hard coded or constant) and 





F




{\displaystyle {\mathit {F}}}

 of any length up to that of 





G




{\displaystyle {\mathit {G}}}

. Note that 




|



H



|



{\displaystyle |{\mathit {H}}|}

 will be given by 




|



G



|

−

|



F



|

+
1


{\displaystyle |{\mathit {G}}|-|{\mathit {F}}|+1}

.
 There may be more equations than unknowns. If convenient, use a function from a library that finds the best fitting solution to an overdetermined system of linear equations (as in the Multiple regression task). Otherwise, prune the set of equations as needed and solve as in the Reduced row echelon form task.
 Test your solution on the following data. Be sure to verify both that deconv



(
g
,
f
)
=
h


{\displaystyle (g,f)=h}

 and deconv



(
g
,
h
)
=
f


{\displaystyle (g,h)=f}

 and display the results in a human readable form.

h = [-8,-9,-3,-1,-6,7]

f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]

g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]

",Python,"def ToReducedRowEchelonForm( M ):
    if not M: return
    lead = 0
    rowCount = len(M)
    columnCount = len(M[0])
    for r in range(rowCount):
        if lead >= columnCount:
            return
        i = r
        while M[i][lead] == 0:
            i += 1
            if i == rowCount:
                i = r
                lead += 1
                if columnCount == lead:
                    return
        M[i],M[r] = M[r],M[i]
        lv = M[r][lead]
        M[r] = [ mrx / lv for mrx in M[r]]
        for i in range(rowCount):
            if i != r:
                lv = M[i][lead]
                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]
        lead += 1
    return M
 
def pmtx(mtx):
    print ('\n'.join(''.join(' %4s' % col for col in row) for row in mtx))
 
def convolve(f, h):
    g = [0] * (len(f) + len(h) - 1)
    for hindex, hval in enumerate(h):
        for findex, fval in enumerate(f):
            g[hindex + findex] += fval * hval
    return g
 
def deconvolve(g, f):
    lenh = len(g) - len(f) + 1
    mtx = [[0 for x in range(lenh+1)] for y in g]
    for hindex in range(lenh):
        for findex, fval in enumerate(f):
            gindex = hindex + findex
            mtx[gindex][hindex] = fval
    for gindex, gval in enumerate(g):        
        mtx[gindex][lenh] = gval
    ToReducedRowEchelonForm( mtx )
    return [mtx[i][lenh] for i in range(lenh)]  # h
 
if __name__ == '__main__':
    h = [-8,-9,-3,-1,-6,7]
    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]
    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]
    assert convolve(f,h) == g
    assert deconvolve(g, f) == h",Human_written,Python_from_Java
http://rosettacode.org/wiki/Floyd-Warshall_algorithm,Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",Python,"from math import inf
from itertools import product
 
def floyd_warshall(n, edge):
    rn = range(n)
    dist = [[inf] * n for i in rn]
    nxt  = [[0]   * n for i in rn]
    for i in rn:
        dist[i][i] = 0
    for u, v, w in edge:
        dist[u-1][v-1] = w
        nxt[u-1][v-1] = v-1
    for k, i, j in product(rn, repeat=3):
        sum_ik_kj = dist[i][k] + dist[k][j]
        if dist[i][j] > sum_ik_kj:
            dist[i][j] = sum_ik_kj
            nxt[i][j]  = nxt[i][k]
    print(""pair     dist    path"")
    for i, j in product(rn, repeat=2):
        if i != j:
            path = [i]
            while path[-1] != j:
                path.append(nxt[path[-1]][j])
            print(""%d → %d  %4d       %s"" 
                  % (i + 1, j + 1, dist[i][j], 
                     ' → '.join(str(p + 1) for p in path)))
 
if __name__ == '__main__':
    floyd_warshall(4, [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]])",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",Python,"import math

math.e # e - not standard but offered by most implementations
math.pi # pi - not standard but offered by most implementations
math.sqrt(x) # square root--cube root also available in C99 (cbrt)
math.log(x) # natural logarithm--log base 10 also available (log10)
math.exp(x) # exponential
abs(x) # absolute value (for integers)
math.fabs(x) # absolute value (for doubles)
math.floor(x) # floor
math.ceil(x) # ceiling
math.pow(x,y) # power",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",Python,"def isqrt(x):
    q, r = 1, 0
    while (q <= x): q <<= 2
    while (q > 1):
        q >>= 2; t = x-r-q; r >>= 1
        if (t >= 0): x, r = t, r+q
    return r
 
print("" "".join(str(isqrt(n)) for n in range(66)))
 
for n in range(1, 74, 2):
    print(""%d:\t%s"" % (n, isqrt(7**n)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/RPG_attributes_generator,RPG attributes generator,"RPG   =   Role Playing Game.



You're running a tabletop RPG, and your players are creating characters.

Each character has six core attributes: strength, dexterity, constitution, intelligence, wisdom, and charisma.

One way of generating values for these attributes is to roll four, 6-sided dice (d6) and sum the three highest rolls, discarding the lowest roll.

Some players like to assign values to their attributes in the order they're rolled.

To ensure generated characters don't put players at a disadvantage, the following requirements must be satisfied:

 The total of all character attributes must be at least 75.
 At least two of the attributes must be at least 15.

However, this can require a lot of manual dice rolling. A programatic solution would be much faster.



Task

Write a program that:

 Generates 4 random, whole values between 1 and 6.
 Saves the sum of the 3 largest values.
 Generates a total of 6 values this way.
 Displays the total, and all 6 values once finished.

 The order in which each value was generated must be preserved.
 The total of all 6 values must be at least 75.
 At least 2 of the values must be 15 or more.
",Python,"import random
from operator import itemgetter
 
attributes_total = 0
count = 0
attributes = [0, 0, 0, 0, 0, 0]
rolls = [0, 0, 0, 0]
 
while attributes_total < 75 or count < 2:
    attributes_total = 0
    count = 0
 
    for attrib in range(0, 6):
        for roll in range(0, 4):
            rolls[roll] = 1 + (random.randint(1, 6))
 
        rolls.sort()
        roll_total = rolls[1] + rolls[2] + rolls[3]
 
        attributes[attrib] = roll_total
        attributes_total += roll_total
 
        if roll_total >= 15:
            count += 1
 
print(""Attributes generated : ["", end="""")
print(attributes[0], end="", "")
print(attributes[1], end="", "")
print(attributes[2], end="", "")
print(attributes[3], end="", "")
print(attributes[4], end="", "")
print(attributes[5], end=""]"")
 
print(""\nTotal: "", attributes_total)
print(""Values above 15 : "", count)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Linear_congruential_generator,Linear congruential generator,"The linear congruential generator is a very simple example of a random number generator.

All linear congruential generators use this formula:

 




r

n
+
1


=
a
×

r

n


+
c


(
mod

m
)



{\displaystyle r_{n+1}=a\times r_{n}+c{\pmod {m}}}




Where:

 




r

0




{\displaystyle r_{0}}

 is a seed.
 




r

1




{\displaystyle r_{1}}

, 




r

2




{\displaystyle r_{2}}

, 




r

3




{\displaystyle r_{3}}

, ..., are the random numbers.
 



a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.


If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

.

LCG numbers have poor quality. 




r

n




{\displaystyle r_{n}}

 and 




r

n
+
1




{\displaystyle r_{n+1}}

 are not independent, as true random numbers would be. Anyone who knows 




r

n




{\displaystyle r_{n}}

 can predict 




r

n
+
1




{\displaystyle r_{n+1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r

0




{\displaystyle r_{0}}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes 



s
t
a
t

e

0




{\displaystyle state_{0}}

. The random sequence is 



r
a
n

d

1




{\displaystyle rand_{1}}

, 



r
a
n

d

2




{\displaystyle rand_{2}}

 and so on.



BSD formula

 



s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e

n


+
12345


(
mod


2

31


)



{\displaystyle state_{n+1}=1103515245\times state_{n}+12345{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n




{\displaystyle rand_{n}=state_{n}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 2147483647.


Microsoft formula

 



s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}=214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.


The BSD formula was so awful that FreeBSD switched to a different formula.

More info is at Random number generator (included)#C.



",Python,"from itertools import islice
 
def randBSD(seed):
    a = 1103515245
    c = 12345
    m = 2**31 - 1
    return islice(map(lambda x: (a * x + c) % m, iterate(seed)), 1, None)
 
def randMS(seed):
    a = 214013
    c = 2531011
    m = 2**31 - 1
    return islice(map(lambda x: (a * x + c) % m, iterate(seed)), 1, None)
 
if __name__ == '__main__':
    print('BSD:')
    print(list(map(str, islice(randBSD(0), 10))))
    print('\nMS:')
    print(list(map(str, islice(randMS(0), 10))))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Element-wise_operations,Element-wise operations,"This task is similar to:

   Matrix multiplication
   Matrix transposition


Task

Implement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.

Implement:

   addition
   subtraction
   multiplication
   division
   exponentiation


Extend the task if necessary to include additional basic operations, which should not require their own specialised task.



",Python,">>> import random
>>> from operator import add, sub, mul, floordiv
>>> from pprint import pprint as pp
>>> 
>>> def ewise(matrix1, matrix2, op):
	return [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)]
 
>>> m,n = 3,4 	# array dimensions
>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]
>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]
>>> pp(a0); pp(a1)
[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]
[[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]
>>> pp(ewise(a0, a1, add))
[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]
>>> pp(ewise(a0, a1, sub))
[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]
>>> pp(ewise(a0, a1, mul))
[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]
>>> pp(ewise(a0, a1, floordiv))
[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]
>>> pp(ewise(a0, a1, pow))
[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]
>>> pp(ewise(a0, a1, lambda x, y:2*x - y))
[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]
>>> 
>>> def s_ewise(scalar1, matrix1, op):
	return [[op(scalar1, e1) for e1 in row1] for row1 in matrix1]
 
>>> scalar = 10
>>> a0
[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]
>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):
	print(""%10s :"" % op.__name__, s_ewise(scalar, a0, op))
 
 
       add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]
       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]
       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]
  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]
       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]
  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Semiprime,Semiprime,"Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.


Semiprimes   are also known as:

   semi-primes
   biprimes
   bi-primes
    2-almost    primes
   or simply:    P2  


Example
 
   1679  =  23 × 73  

(This particular number was chosen as the length of the Arecibo message).



Task

Write a function determining whether a given number is semiprime.



See also

 The Wikipedia article:  semiprime.
 The Wikipedia article:  almost prime.
 The OEIS sequence:  A001358: semiprimes  which has a shorter definition: the product of two primes.

",Python,"from prime_decomposition import decompose
 
def semiprime(n):
    d = decompose(n)
    try:
        return next(d) * next(d) == n
    except StopIteration:
        return False",Human_written,Python_from_C
http://rosettacode.org/wiki/SEDOLs,SEDOLs,"Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.



That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.



Related tasks

   Luhn test
   ISIN

",Python,"import java.util.Scanner;

public class SEDOL:
    def main(self, args):
        sc = Scanner(System.in)
        while sc.hasNext():
            sedol = sc.next()
            print(sedol + self.getSedolCheckDigit(sedol))

    mult = [1, 3, 1, 7, 3, 9]

    def getSedolCheckDigit(self, str):
        if not self.validateSedol(str):
            System.err.println(""SEDOL strings must contain six characters with no vowels."")
            return -1
        str = str.toUpperCase()
        total = 0
        for i in range(6):
            s = str.charAt(i)
            total += Character.digit(s, 36) * self.mult[i]
        return (10 - (total % 10)) % 10

    def validateSedol(self, str):
        return (str.length() == 6) and not str.toUpperCase().matches("".*?[AEIOU].*?"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Unicode_variable_names,Unicode variable names,"Task

 Describe, and give a pointer to documentation on your languages use of characters beyond those of the ASCII character set in the naming of variables.
 Show how to:
 Set a variable with a name including the 'Δ', (delta character), to 1 
 Increment it
 Print its value.


Related task
 
 Case-sensitivity of identifiers

",Python,"# Works for Python 3.6+
Δ = 1
Δ += 1
print(Δ)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Distributed_programming,Distributed programming,"Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.

The protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.

This task is intended to demonstrate high-level communication facilities beyond just creating sockets.
",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
import SimpleXMLRPCServer
 
class MyHandlerInstance:
    def echo(self, data):
        '''Method for returning data got from client'''
        return 'Server responded: %s' % data
 
    def div(self, num1, num2):
        '''Method for divide 2 numbers'''
        return num1/num2
 
def foo_function():
    '''A function (not an instance method)'''
    return True
 
HOST = ""localhost""
PORT = 8000
 
server = SimpleXMLRPCServer.SimpleXMLRPCServer((HOST, PORT))
 
# register built-in system.* functions.
server.register_introspection_functions()
 
# register our instance
server.register_instance(MyHandlerInstance())
 
# register our function as well
server.register_function(foo_function)
 
try:
    # serve forever
    server.serve_forever()
except KeyboardInterrupt:
    print 'Exiting...'
    server.server_close()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Random_number_generator_(device),Random number generator (device),"Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:

show how to obtain a random 32-bit number from that mechanism.

Related task
 Random_number_generator_(included)

",Python,"import random
rand = random.SystemRandom()
rand.randint(1,10)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Padovan_sequence,Padovan sequence,"

The Padovan sequence is similar to the Fibonacci sequence in several ways.
Some are given in the table below, and the referenced video shows some of the geometric
similarities.



 Comment 
 Padovan 
 Fibonacci


 
 



 Named after. 
 Richard Padovan 
 Leonardo of Pisa: Fibonacci


 
 



 Recurrence initial values. 
 P(0)=P(1)=P(2)=1 
 F(0)=0, F(1)=1


 Recurrence relation. 
 P(n)=P(n-2)+P(n-3) 
 F(n)=F(n-1)+F(n-2)


 
 



 First 10 terms. 
 1,1,1,2,2,3,4,5,7,9 
 0,1,1,2,3,5,8,13,21,34


 
 



 Ratio of successive terms... 
 Plastic ratio, p 
 Golden ratio, g


 
 1.324717957244746025960908854… 
 1.6180339887498948482...


 Exact formula of ratios p and q. 
 ((9+69**.5)/18)**(1/3) + ((9-69**.5)/18)**(1/3) 
 (1+5**0.5)/2


 Ratio is real root of polynomial. 
 p: x**3-x-1 
 g: x**2-x-1


 
 



 Spirally tiling the plane using. 
 Equilateral triangles 
 Squares


 
 



 Constants for ... 
 s= 1.0453567932525329623 
 a=5**0.5


 ... Computing by truncation. 
 P(n)=floor(p**(n-1) / s + .5) 
 F(n)=floor(g**n / a + .5)


 
 



 L-System Variables. 
 A,B,C 
 A,B


 L-System Start/Axiom. 
 A 
 A


 L-System Rules. 
 A->B,B->C,C->AB 
 A->B,B->AB

Task

 Write a function/method/subroutine to compute successive members of the Padovan series using the recurrence relation.
 Write a function/method/subroutine to compute successive members of the Padovan series using the floor function.
 Show the first twenty terms of the sequence.
 Confirm that the recurrence and floor based functions give the same results for 64 terms,
 Write a function/method/... using the L-system to generate successive strings.
 Show the first 10 strings produced from the L-system
 Confirm that the length of the first 32 strings produced is the Padovan sequence.
Show output here, on this page.

Ref

 The Plastic Ratio - Numberphile video.

",Python,"from math import floor
from collections import deque
from typing import Dict, Generator
 
 
def padovan_r() -> Generator[int, None, None]:
    last = deque([1, 1, 1], 4)
    while True:
        last.append(last[-2] + last[-3])
        yield last.popleft()
 
_p, _s = 1.324717957244746025960908854, 1.0453567932525329623
 
def padovan_f(n: int) -> int:
    return floor(_p**(n-1) / _s + .5)
 
def padovan_l(start: str='A',
             rules: Dict[str, str]=dict(A='B', B='C', C='AB')
             ) -> Generator[str, None, None]:
    axiom = start
    while True:
        yield axiom
        axiom = ''.join(rules[ch] for ch in axiom)
 
 
if __name__ == ""__main__"":
    from itertools import islice
 
    print(""The first twenty terms of the sequence."")
    print(str([padovan_f(n) for n in range(20)])[1:-1])
 
    r_generator = padovan_r()
    if all(next(r_generator) == padovan_f(n) for n in range(64)):
        print(""\nThe recurrence and floor based algorithms match to n=63 ."")
    else:
        print(""\nThe recurrence and floor based algorithms DIFFER!"")
 
    print(""\nThe first 10 L-system string-lengths and strings"")
    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))
    print('\n'.join(f""  {len(string):3} {repr(string)}""
                    for string in islice(l_generator, 10)))
 
    r_generator = padovan_r()
    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))
    if all(len(next(l_generator)) == padovan_f(n) == next(r_generator)
           for n in range(32)):
        print(""\nThe L-system, recurrence and floor based algorithms match to n=31 ."")
    else:
        print(""\nThe L-system, recurrence and floor based algorithms DIFFER!"")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Text_processing/1,Text processing/1,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.
Often data is produced by one program, in the wrong format for later use by another program or person. In these situations another program can be written to parse and transform the original data into a format useful to the other. The term ""Data Munging"" is often used in programming circles for this task.

A request on the comp.lang.awk newsgroup led to a typical data munging task:

I have to analyse data files that have the following format:
Each row corresponds to 1 day and the field logic is: $1 is the date,
followed by 24 value/flag pairs, representing measurements at 01:00,
02:00 ... 24:00 of the respective day. In short:

<date> <val1> <flag1> <val2> <flag2> ...  <val24> <flag24>

Some test data is available at: 
... (nolonger available at original location)

I have to sum up the values (per day and only valid data, i.e. with
flag>0) in order to calculate the mean. That's not too difficult.
However, I also need to know what the ""maximum data gap"" is, i.e. the
longest period with successive invalid measurements (i.e values with
flag<=0)
The data is free to download and use and is of this format:

Data is no longer available at that link. Zipped mirror available here (offsite mirror).

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Only a sample of the data showing its format is given above. The full example file may be downloaded here.

Structure your program to show statistics for each line of the file, (similar to the original Python, Perl, and AWK examples below), followed by summary statistics for the file. When showing example output just show a few line statistics and the full end summary.
",Python,"import fileinput
import sys
 
nodata = 0;             # Current run of consecutive flags<0 in lines of file
nodata_max=-1;          # Max consecutive flags<0 in lines of file
nodata_maxline=[];      # ... and line number(s) where it occurs
 
tot_file = 0            # Sum of file data
num_file = 0            # Number of file data items with flag>0
 
infiles = sys.argv[1:]
 
for line in fileinput.input():
  tot_line=0;             # sum of line data
  num_line=0;             # number of line data items with flag>0
 
  # extract field info
  field = line.split()
  date  = field[0]
  data  = [float(f) for f in field[1::2]]
  flags = [int(f)   for f in field[2::2]]
 
  for datum, flag in zip(data, flags):
    if flag<1:
      nodata += 1
    else:
      # check run of data-absent fields
      if nodata_max==nodata and nodata>0:
        nodata_maxline.append(date)
      if nodata_max<nodata and nodata>0:
        nodata_max=nodata
        nodata_maxline=[date]
      # re-initialise run of nodata counter
      nodata=0; 
      # gather values for averaging
      tot_line += datum
      num_line += 1
 
  # totals for the file so far
  tot_file += tot_line
  num_file += num_line
 
  print ""Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f"" % (
        date, 
        len(data) -num_line, 
        num_line, tot_line, 
        tot_line/num_line if (num_line>0) else 0)
 
print """"
print ""File(s)  = %s"" % ("", "".join(infiles),)
print ""Total    = %10.3f"" % (tot_file,)
print ""Readings = %6i"" % (num_file,)
print ""Average  = %10.3f"" % (tot_file / num_file,)
 
print ""\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s"" % (
    nodata_max, "", "".join(nodata_maxline))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Hailstone_sequence,Hailstone sequence,"The Hailstone sequence of numbers can be generated from a starting positive integer,   n   by:

   If   n   is     1     then the sequence ends.
   If   n   is   even then the next   n   of the sequence    = n/2 
   If   n   is   odd   then the next   n   of the sequence    = (3 * n) + 1 


The (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.



This sequence was named by Lothar Collatz in 1937   (or possibly in 1939),   and is also known as (the):

   hailstone sequence,   hailstone numbers
   3x + 2 mapping,   3n + 1 problem
   Collatz sequence
   Hasse's algorithm
   Kakutani's problem
   Syracuse algorithm,   Syracuse problem
   Thwaites conjecture 
   Ulam's problem


The hailstone sequence is also known as   hailstone numbers   (because the values are usually subject to multiple descents and ascents like hailstones in a cloud).



Task

 Create a routine to generate the hailstone sequence for a number.
 Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
   (But don't show the actual sequence!)


See also

   xkcd (humourous).
   The Notorious Collatz conjecture Terence Tao, UCLA (Presentation, pdf).
   The Simplest Math Problem No One Can Solve Veritasium (video, sponsored).

",Python,"def hs(n,seq):
    sequence = seq
    sequence.append(n)
    if n == 1:
        return sequence
    else:
        newn = (n % 2 == 0) and n / 2 or (3 * n) + 1
        return hs(newn, sequence)
 
n = 27
sequence = hs(n,[])
print(len(sequence), ""Elements"")
start = sequence[0:4]
end = sequence[-4:]
print(""Starting with : "" + "","".join(str(x) for x in start) + "" and ending with : "" + "","".join(str(x) for x in end))
number = 0
longest = 0
for i in range(1,100000):
    count = len(hs(i,[]))
    if count > longest:
        longest = count
        number = i
print(""Number < 100000 with longest Hailstone seq.: "" + str(number) + "" with length of "" + str(longest))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Palindromic_gapful_numbers,Palindromic gapful numbers,"Palindromic gapful numbers

You are encouraged to solve this task according to the task description, using any language you may know.
Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

1037   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    1037. 



A palindromic number is   (for this task, a positive integer expressed in base ten),   when the number is
reversed,   is the same as the original number.



Task

   Show   (nine sets)   the first   20   palindromic gapful numbers that   end   with:
   the digit   1
   the digit   2
   the digit   3
   the digit   4
   the digit   5
   the digit   6
   the digit   7
   the digit   8
   the digit   9
   Show   (nine sets, like above)   of palindromic gapful numbers:
   the last   15   palindromic gapful numbers   (out of      100)
   the last   10   palindromic gapful numbers   (out of   1,000)       {optional}


For other ways of expressing the (above) requirements, see the   discussion   page.



Note

All palindromic gapful numbers are divisible by eleven.



Related tasks

   palindrome detection.
   gapful numbers.


Also see

   The OEIS entry:   A108343 gapful numbers.

",Python,"from itertools import count
from pprint import pformat
import re
import heapq
 
 
def pal_part_gen(odd=True):
    for i in count(1):
        fwd = str(i)
        rev = fwd[::-1][1:] if odd else fwd[::-1]
        yield int(fwd + rev)
 
def pal_ordered_gen():
    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))
 
def is_gapful(x):
    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)
 
if __name__ == '__main__':
    start = 100
    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:
        print(f""\nLast {last} of the first {mx} binned-by-last digit "" 
              f""gapful numbers >= {start}"")
        bin = {i: [] for i in range(1, 10)}
        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))
        while any(len(val) < mx for val in bin.values()):
            g = next(gen)
            val = bin[g % 10]
            if len(val) < mx:
                val.append(g)
        b = {k:v[-last:] for k, v in bin.items()}
        txt = pformat(b, width=220)
        print('', re.sub(r""[{},\[\]]"", '', txt))",Human_written,Python_from_C++
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"# version 1.1.2
 
games = [""12"", ""13"", ""14"", ""23"", ""24"", ""34""]
results = ""000000""
 
def nextResult():
    global results
    if results == ""222222"": return False
    res = int(results, 3) + 1
    results = str(res).zfill(6)
    return True
 
def main():
    points = [[0] * 10 for _ in range(4)]
    while nextResult():
        records = [0] * 4
        for i in range(6):
            if results[i] == '2': records[int(games[i][0]) - 1] += 3
            elif results[i] == '1':
                records[int(games[i][0]) - 1] += 1
                records[int(games[i][1]) - 1] += 1
            elif results[i] == '0': records[int(games[i][1]) - 1] += 3
        records.sort()
        for i in range(4): points[i][records[i]] += 1
    print(""POINTS       0    1    2    3    4    5    6    7    8    9"")
    print(""-------------------------------------------------------------"") 
    places = [""1st"", ""2nd"", ""3rd"", ""4th""]
    for i in range(4):
        print(f""{places[i]} place    "", end="""")
        for j in range(10): print(f""{points[3 - i][j]:5d}"", end="""")
        print()
 
if __name__ == ""__main__"": main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",Python,"import os

print(os.path.getsize('input.txt'))
print(os.path.getsize('c:/input.txt'))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/String_matching,String matching,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings, demonstrate the following three types of string matching:

   Determining if the first string starts with second string
   Determining if the first string contains the second string at any location
   Determining if the first string ends with the second string


Optional requirements:

   Print the location of the match for part 2
   Handle multiple occurrences of a string for part 2.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"""abcd"".startswith(""ab"") #returns True
""abcd"".endswith(""zn"") #returns False
""bb"" in ""abab"" #returns False
""ab"" in ""abab"" #returns True
loc = ""abab"".find(""bb"") #returns -1
loc = ""abab"".find(""ab"") #returns 0
loc = ""abab"".find(""ab"",loc+1) #returns 2",Human_written,Python_from_Go
http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",Python,"array = []
 
array.append(1)
array.append(3)
 
array[0] = 2
 
print array[0]",Human_written,Python_from_C#
http://rosettacode.org/wiki/Twin_primes,Twin primes,"Twin primes are pairs of natural numbers   (P1  and  P2)   that satisfy the following:

     P1   and   P2   are primes
     P1  +  2   =   P2


Task

Write a program that displays the number of pairs of twin primes that can be found under a user-specified number

(P1 < user-specified number & P2 < user-specified number).



Extension

 Find all twin prime pairs under 100000, 10000000 and 1000000000.
 What is the time complexity of the program? Are there ways to reduce computation time?


Examples

> Search Size: 100
> 8 twin prime pairs.

> Search Size: 1000
> 35 twin prime pairs.



Also see

   The OEIS entry: A001097: Twin primes. 
   The OEIS entry: A167874: The number of distinct primes < 10^n which are members of twin-prime pairs. 
   The OEIS entry: A077800: List of twin primes {p, p+2}, with repetition. 
   The OEIS entry: A007508: Number of twin prime pairs below 10^n. 

",Python,"import math
import sys
 
def main():
    max = int(input(""Search Size: ""))
    counter = 0
    x = 3
    while x <= max:
        sqrtNum = int(math.sqrt(x)) + 1
        if x + 2 <= max:
            counter += 1 if findPrime(x + 2, int(math.sqrt(x + 2)) + 1) and findPrime(x, sqrtNum) else 0
        x += 1
    print(f""{counter} twin prime pairs."")
 
def findPrime(x, sqrtNum):
    divisor = 2
    while divisor <= sqrtNum:
        if x % divisor == 0:
            return False
        divisor += 1
    return True
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Solve_a_Numbrix_puzzle,Solve a Numbrix puzzle,"Numbrix puzzles are similar to Hidato.
The most important difference is that it is only possible to move 1 node left, right, up, or down (sometimes referred to as the Von Neumann neighborhood).
Published puzzles also tend not to have holes in the grid and may not always indicate the end node.
Two examples follow:

Example 1
Problem.

 0  0  0  0  0  0  0  0  0
 0  0 46 45  0 55 74  0  0
 0 38  0  0 43  0  0 78  0
 0 35  0  0  0  0  0 71  0
 0  0 33  0  0  0 59  0  0
 0 17  0  0  0  0  0 67  0
 0 18  0  0 11  0  0 64  0
 0  0 24 21  0  1  2  0  0
 0  0  0  0  0  0  0  0  0

Solution.

 49 50 51 52 53 54 75 76 81
 48 47 46 45 44 55 74 77 80
 37 38 39 40 43 56 73 78 79
 36 35 34 41 42 57 72 71 70
 31 32 33 14 13 58 59 68 69
 30 17 16 15 12 61 60 67 66
 29 18 19 20 11 62 63 64 65
 28 25 24 21 10  1  2  3  4
 27 26 23 22  9  8  7  6  5

Example 2
Problem.

 0  0  0  0  0  0  0  0  0
 0 11 12 15 18 21 62 61  0
 0  6  0  0  0  0  0 60  0
 0 33  0  0  0  0  0 57  0
 0 32  0  0  0  0  0 56  0
 0 37  0  1  0  0  0 73  0
 0 38  0  0  0  0  0 72  0
 0 43 44 47 48 51 76 77  0
 0  0  0  0  0  0  0  0  0

Solution.

  9 10 13 14 19 20 63 64 65
  8 11 12 15 18 21 62 61 66
  7  6  5 16 17 22 59 60 67
 34 33  4  3 24 23 58 57 68
 35 32 31  2 25 54 55 56 69
 36 37 30  1 26 53 74 73 70
 39 38 29 28 27 52 75 72 71
 40 43 44 47 48 51 76 77 78
 41 42 45 46 49 50 81 80 79

Task
Write a program to solve puzzles of this ilk,
demonstrating your program by solving the above examples.
Extra credit for other interesting examples.



Related tasks

 A* search algorithm
 Solve a Holy Knight's tour
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve the no connection puzzle

",Python,"ADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]
 
class HLPsolver:
    def __init__(self, board):
        self.board = board
        self.size = len(board)
        self.solution = [[0 for i in range(self.size)] for j in range(self.size)]
        self.solve()
 
    def solve(self):
        self.solve_rec(0, 0)
        print(self.solution)
 
    def solve_rec(self, x, y):
        if x == self.size:
            return True
        if y == self.size:
            return self.solve_rec(x + 1, 0)
        if self.board[x][y]!= 0:
            return self.solve_rec(x, y + 1)
        for i in range(1, self.size * self.size + 1):
            if self.is_valid(x, y, i):
                self.solution[x][y] = i
                if self.solve_rec(x, y + 1):
                    return True
        self.solution[x][y] = 0
        return False
 
    def is_valid(self, x, y, i):
        for dx, dy in ADJACENT:
            if 0 <= x + dx < self.size and 0 <= y + dy < self.size:
                if self.board[x + dx][y + dy] == i:
                    return False
        return True
 
board1 = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 46, 45, 0, 55, 74, 0, 0],
          [0, 38, 0, 0, 43, 0, 0, 78, 0],
          [0, 35, 0, 0, 0, 0, 0, 71, 0],
          [0, 0, 33, 0, 0, 0, 59, 0, 0],
          [0, 17, 0, 0, 0, 0, 0, 67, 0],
          [0, 18, 0, 0, 11, 0, 0, 64, 0],
          [0, 0, 24, 21, 0, 1, 2, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0]]
HLPsolver(board1)
 
board2 = [[0, 0, 0, 0, 0, 0, 0, 0, 0],
          [0, 11, 12, 15, 18, 21, 62, 61, 0],
          [0, 6, 0, 0, 0, 0, 0, 60, 0],
          [0, 33, 0, 0, 0, 0, 0, 57, 0],
          [0, 32, 0, 0, 0, 0, 0, 56, 0],
          [0, 37, 0, 1, 0, 0, 0, 73, 0],
          [0, 38, 0, 0, 0, 0, 0, 72, 0],
          [0, 43, 44, 47, 48, 51, 76, 77, 0],
          [0, 0, 0, 0, 0, 0, 0, 0, 0]]
HLPsolver(board2)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Window_creation/X11,Window creation/X11,"Task

Create a simple X11 application,   using an X11 protocol library such as Xlib or XCB,   that draws a box and   ""Hello World""   in a window.

Implementations of this task should   avoid using a toolkit   as much as possible.



",Python,"# Python 3.6
 
from ctypes import *
 
Xlib = cdll.LoadLibrary(""libX11.so"")
 
class XEvent(Structure):
    _fields_ = [(""type"", c_int)]
 
def main():
    msg = ""Hello, World!""
    d = Xlib.XOpenDisplay(None)
    if d == None:
        print(""Cannot open display"")
        return
 
    s = Xlib.XDefaultScreen(d)
    w = Xlib.XCreateSimpleWindow(d, Xlib.XRootWindow(d, s), 10, 10, 160, 160, 1,
                                 Xlib.XBlackPixel(d, s), Xlib.XWhitePixel(d, s))
    Xlib.XSelectInput(d, w, 0x00000001L | 0x00000002L)
    Xlib.XMapWindow(d, w)
    e = XEvent()
 
    while True:
        Xlib.XNextEvent(d, byref(e))
        if e.type == 12:
            Xlib.XFillRectangle(d, w, Xlib.XDefaultGC(d, s), 55, 40, 50, 50)
            Xlib.XDrawString(d, w, Xlib.XDefaultGC(d, s), 45, 120, msg, len(msg))
        elif e.type == 2:
            break
 
    Xlib.XCloseDisplay(d)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Stern-Brocot_sequence,Stern-Brocot sequence,"For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the Fibonacci sequence.

 The first and second members of the sequence are both 1:
     1, 1
 Start by considering the second member of the sequence
 Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the sequence:
     1, 1, 2
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1
 Consider the next member of the series, (the third member i.e. 2)
 GOTO 3
 
         ─── Expanding another loop we get: ───

 Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the sequence:
     1, 1, 2, 1, 3
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1, 3, 2
 Consider the next member of the series, (the fourth member i.e. 1)


The task is to

 Create a function/method/subroutine/procedure/... to generate the Stern-Brocot sequence of integers using the method outlined above.
 Show the first fifteen members of the sequence. (This should be: 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4)
 Show the (1-based) index of where the numbers 1-to-10 first appears in the sequence.
 Show the (1-based) index of where the number 100 first appears in the sequence.
 Check that the greatest common divisor of all the two consecutive members of the series up to the 1000th member, is always one.

Show your output on this page.



Related tasks

   Fusc sequence.
   Continued fraction/Arithmetic


Ref

 Infinite Fractions - Numberphile (Video).
 Trees, Teeth, and Time: The mathematics of clock making. 
 A002487 The On-Line Encyclopedia of Integer Sequences.

",Python,"def stern_brocot(predicate=lambda series: len(series) < 20):
    """"""\
    Generates members of the stern-brocot series, in order, returning them when the predicate becomes false
 
    >>> print('The first 10 values:',
              stern_brocot(lambda series: len(series) < 10)[:10])
    The first 10 values: [1, 1, 2, 1, 3, 2, 3, 1, 4, 3]
    >>>
    """"""
 
    sb, i = [1, 1], 0
    while predicate(sb):
        sb += [sum(sb[i:i + 2]), sb[i + 1]]
        i += 1
    return sb
 
 
if __name__ == '__main__':
    from fractions import gcd
 
    n_first = 15
    print('The first %i values:\n  ' % n_first,
          stern_brocot(lambda series: len(series) < n_first)[:n_first])
    print()
    n_max = 10
    for n_occur in list(range(1, n_max + 1)) + [100]:
        print('1-based index of the first occurrence of %3i in the series:' % n_occur,
              stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)
              # The following would be much faster. Note that new values always occur at odd indices
              # len(stern_brocot(lambda series: n_occur != series[-2])) - 1)
 
    print()
    n_gcd = 1000
    s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]
    assert all(gcd(prev, this) == 1
               for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'",Human_written,Python_from_C#
http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",Python,"# International class; name and street
class 国際(object):
    def __init__(self, なまえ, Straße):
        self.なまえ = なまえ
        self.Straße = Straße

    # Say who am I!
    def 言え(self):
        print(""I am {0} from {1}"".format(self.なまえ, self.Straße))

# all the people of the world!
民族 = [
    国際(""高田　Friederich"", ""台湾""),
    国際(""Smith Σωκράτης"", ""Cantù""),
    国際(""Stanisław Lec"", ""południow""),
]

for garçon in 民族:
    garçon.言え()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Write_entire_file,Write entire file,"Task

(Over)write a file so that it contains a string.



The reverse of Read entire file—for when you want to update or create a file which you would read in its entirety all at once.



",Python,"with open(filename, 'w') as f:
    f.write(data)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"#!/usr/bin/env python
a = input('Enter value of a: ')
b = input('Enter value of b: ')
 
if a < b:
    print 'a is less than b'
elif a > b:
    print 'a is greater than b'
elif a == b:
    print 'a is equal to b'",Human_written,Python_from_C++
http://rosettacode.org/wiki/Metronome,Metronome,"
The task is to implement a   metronome.

The metronome should be capable of producing high and low audio beats, accompanied by a visual beat indicator, and the beat pattern and tempo should be configurable.

For the purpose of this task, it is acceptable to play sound files for production of the beat notes, and an external player may be used.

However, the playing of the sounds should not interfere with the timing of the metronome.

The visual indicator can simply be a blinking red or green area of the screen (depending on whether a high or low beat is being produced), and the metronome can be implemented using a terminal display, or optionally, a graphical display, depending on the language capabilities.

If the language has no facility to output sound, then it is permissible for this to implemented using just the visual indicator.



",Python,"#!/usr/bin/python

import sys
import time

bpm = 60
msr = 4
i = 0

if len(sys.argv) > 1:
    bpm = int(sys.argv[1])

if len(sys.argv) > 2:
    msr = int(sys.argv[2])

while True:
    for j in range(msr-1):
        print(""\a"")
        time.sleep(60.0/bpm)
    print(""\aAND %d"" % i)
    i += 1
    time.sleep(60.0/bpm)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Man_or_boy_test,Man or boy test,"Man or boy test

You are encouraged to solve this task according to the task description, using any language you may know.

Background: The man or boy test was proposed by computer scientist Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The aim of the test was to distinguish compilers that correctly implemented ""recursion and non-local references"" from those that did not.


I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers'
 — Donald Knuth
Task: Imitate Knuth's example in Algol 60 in another language, as far as possible.

Details: Local variables of routines are often kept in activation records (also call frames). In many languages, these records are kept on a call stack. In Algol (and e.g. in Smalltalk), they are allocated on a heap instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the Funarg Problem.

In Knuth's example, each call to A allocates an activation record for the variable A. When B is called from A, any access to k now refers to this activation record. Now B in turn calls A, but passes itself as an argument. This argument remains bound to the activation record. This call to A also ""shifts"" the variables xi by one place, so eventually the argument B (still bound to its particular
activation record) will appear as x4 or x5 in a call to A. If this happens when the expression x4 + x5 is evaluated, then this will again call B, which in turn will update k in the activation record it was originally bound to. As this activation record is shared with other instances of calls to A and B, it will influence the whole computation.

So all the example does is to set up a convoluted calling structure, where updates to k can influence the behavior
in completely different parts of the call tree.

Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be −67.

Performance and Memory: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error. Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.

The table below shows the result, call depths, and total calls for a range of k:



 k

 0

 1

 2

 3

 4

 5

 6

 7

 8

 9

 10

 11

 12

 13

 14

 15

 16

 17

 18

 19

 20

 21

 22

 23

 24

 25

 26

 27

 28

 29

 30


 A

 1

 0

 -2

 0

 1

 0

 1

 -1

 -10

 -30

 -67

 -138

 -291

 -642

 -1,446

 -3,250

 -7,244

 -16,065

 -35,601

 -78,985

 -175,416

 -389,695

 -865,609

 -1,922,362

 -4,268,854

 -9,479,595

 -21,051,458

 -46,750,171

 -103,821,058

 -230,560,902

 -512,016,658


 A called

 1

 2

 3

 4

 8

 18

 38

 80

 167

 347

 722

 1,509

 3,168

 6,673

 14,091

 29,825

 63,287

 134,652

 287,264

 614,442

 1,317,533

 2,831,900

 6,100,852

 13,172,239

 28,499,827

 61,786,266

 134,202,509

 292,011,464

 

 

 


 A depth

 1

 2

 3

 4

 8

 16

 32

 64

 128

 256

 512

 1,024

 2,048

 4,096

 8,192

 16,384

 32,768

 65,536

 131,072

 262,144

 524,288

 1,048,576

 2,097,152

 4,194,304

 8,388,608

 

 

 

 

 

 


 B called

 0

 1

 2

 3

 7

 17

 37

 79

 166

 346

 721

 1,508

 3,167

 6,672

 14,090

 29,824

 63,286

 134,651

 287,263

 614,441

 1,317,532

 2,831,899

 6,100,851

 13,172,238

 28,499,826

 

 

 

 

 

 


 B depth

 0

 1

 2

 3

 7

 15

 31

 63

 127

 255

 511

 1,023

 2,047

 4,095

 8,191

 16,383

 32,767

 65,535

 131,071

 262,143

 524,287

 1,048,575

 2,097,151

 4,194,303

 8,388,607

 

 

 

 

 

 



Related tasks

   Jensen's Device

",Python,"from __future__ import annotations
from dataclasses import dataclass
from typing import Any
 
class Arg:
    def run(self) -> int:
        raise NotImplementedError
 
@dataclass
class B(Arg):
    k: int
    x1: Arg
    x2: Arg
    x3: Arg
    x4: Arg
 
    def run(self) -> int:
        self.k -= 1
        return a(self.k, self, self.x1, self.x2, self.x3, self.x4)
 
def a(k: int, x1: Arg, x2: Arg, x3: Arg, x4: Arg, x5: Arg) -> int:
    if k <= 0:
        return x4.run() + x5.run()
    else:
        return B(k, x1, x2, x3, x4).run()
 
if __name__ == ""__main__"":
    print(a(10, 1, -1, -1, 1, 0))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sort_numbers_lexicographically,Sort numbers lexicographically,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Given an integer   n,   return   1──►n   (inclusive)   in lexicographical order.



Show all output here on this page.



Example

Given   13,

return:   [1,10,11,12,13,2,3,4,5,6,7,8,9].
",Python,"from itertools import permutations
 
def lex_order(n):
    if n < 1:
        return []
    return sorted(map(int, map(''.join, permutations(str(n)))))
 
if __name__ == '__main__':
    print(""In lexicographical order:\n"")
    for n in [0, 5, 13, 21, -22]:
        print(f""{n:3}: {lex_order(n)}"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Hello_world/Newline_omission,Hello world/Newline omission,"Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.



Task

Display the string   Goodbye, World!   without a trailing newline.



Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Standard error
   Hello world/Text

",Python,"def main():
    print(""Goodbye, World!"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sum_multiples_of_3_and_5,Sum multiples of 3 and 5,"Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

This is is the same as Project Euler problem 1.

Extra credit: do this efficiently for n = 1e20 or higher.



",Python,"def sum35a(n):
    'Direct count'
    # note: ranges go to n-1
    return sum(x for x in range(n) if x%3==0 or x%5==0)
 
def sum35b(n): 
    ""Count all the 3's; all the 5's; minus double-counted 3*5's""
    # note: ranges go to n-1
    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))
 
def sum35c(n):
    'Sum the arithmetic progressions: sum3 + sum5 - sum15'
    consts = (3, 5, 15)
    # Note: stop at n-1
    divs = [(n-1) // c for c in consts]
    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]
    return sums[0] + sums[1] - sums[2]
 
#test
for n in range(1001):
    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)
    assert sa == sb == sc  # python tests aren't like those of c.
 
print('For n = %7i -> %i\n' % (n, sc))
 
# Pretty patterns
for p in range(7):
    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))
 
# Scalability 
p = 20
print('\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"import sys
def Recur(i):
    print(i)
    Recur(i + 1)

Recur(0)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Digital_root,Digital root,"The digital root, 



X


{\displaystyle X}

, of a number, 



n


{\displaystyle n}

, is calculated:

 find 



X


{\displaystyle X}

 as the sum of the digits of 



n


{\displaystyle n}


 find a new 



X


{\displaystyle X}

 by summing the digits of 



X


{\displaystyle X}

, repeating until 



X


{\displaystyle X}

 has only one digit.
The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:





627615


{\displaystyle 627615}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;




39390


{\displaystyle 39390}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



6


{\displaystyle 6}

;




588225


{\displaystyle 588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



3


{\displaystyle 3}

;




393900588225


{\displaystyle 393900588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;
The digital root may be calculated in bases other than 10.



See

 Casting out nines for this wiki's use of this procedure.
 Digital root/Multiplicative digital root
 Sum digits of an integer
 Digital root sequence on OEIS
 Additive persistence sequence on OEIS
 Iterated digits squaring

",Python,"def digital_root (n):
    ap = 0
    n = abs(int(n))
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
        ap += 1
    return ap, n
 
if __name__ == '__main__':
    for n in [627615, 39390, 588225, 393900588225, 55]:
        persistance, root = digital_root(n)
        print(""%12i has additive persistance %2i and digital root %i."" 
              % (n, persistance, root))",Human_written,Python_from_C
http://rosettacode.org/wiki/Monads/Maybe_monad,Monads/Maybe monad,"Demonstrate in your programming language the following:

Construct a Maybe Monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that Monad (or just use what the language already has implemented)
Make two functions, each which take a number and return a monadic number, e.g. Int -> Maybe Int and Int -> Maybe String
Compose the two functions with bind


A Monad is a single type which encapsulates several other types, eliminating boilerplate code. In practice it acts like a dynamically typed computational sequence, though in many cases the type issues can be resolved at compile time.

A Maybe Monad is a monad which specifically encapsulates the type of an undefined value.
",Python,"from enum import Enum
from typing import Union, Optional
 
class Type(Enum):
    INT = 1
    STRING = 2
 
class Maybe:
    def __init__(self, i: int, s: str, t: Type, is_something: bool):
        self.i = i
        self.s = s
        self.t = t
        self.is_something = is_something
 
def print_Maybe(m: Maybe):
    if m.t == Type.INT:
        print(f""Just {m.i} : INT"")
 
    elif m.t == Type.STRING:
        print(f""Just \""{m.s}\"" : STRING"")
 
    else:
        print(""Nothing"")
 
def return_maybe(data: Union[int, str], t: Type) -> Maybe:
    if t == Type.INT:
        return Maybe(data, None, Type.INT, True)
 
    elif t == Type.STRING:
        return Maybe(0, data, Type.STRING, True)
 
    else:
        return Maybe(0, None, None, False)
 
def bind_maybe(m: Maybe, f: Callable[[int], Maybe]) -> Maybe:
    if f(m.i).is_something:
        return f(m.i)
 
    else:
        return Maybe(0, None, None, False)
 
def f_1(v: int) -> Maybe:
    return Maybe(v * v, None, Type.INT, True)
 
def f_2(v: int) -> Maybe:
    return Maybe(0, ""x"" * v, Type.STRING, True)
 
if __name__ == ""__main__"":
    i = 7
    s = ""lorem ipsum dolor sit amet""
 
    m_1 = return_maybe(i, Type.INT)
    m_2 = return_maybe(s, Type.STRING)
 
    print_Maybe(m_1) # print value of m_1: Just 49
    print_Maybe(m_2) # print value of m_2 : Just ""lorem ipsum dolor sit amet""
 
    print_Maybe(bind_maybe(m_1, f_1)) # m_1 `bind` f_1 :: Maybe Int
    print_Maybe(bind_maybe(m_1, f_2)) # m_1 `bind` f_2 :: Maybe String
 
    print_Maybe(bind_maybe(bind_maybe(m_1, f_1), f_2)) # (m_1 `bind` f_1) `bind` f_2 :: Maybe String -- it prints 49 'x' characters in a row",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Chat_server,Chat server,"Task

Write a server for a minimal text based chat.

People should be able to connect via ‘telnet’, sign on with a nickname, and type messages which will then be seen by all other connected users. Arrivals and departures of chat members should generate appropriate notification messages.



",Python,"#!/usr/bin/env python
 
import socket
import thread
import time
 
HOST = """"
PORT = 4004
 
def accept(conn):
    """"""
    Call the inner func in a thread so as not to block. Wait for a 
    name to be entered from the given connection. Once a name is 
    entered, set the connection to non-blocking and add the user to 
    the users dict.
    """"""
    def threaded():
        while True:
            conn.send(""Please enter your name: "")
            try:
                name = conn.recv(1024).strip()
            except socket.error:
                continue
            if name in users:
                conn.send(""Name entered is already in use.\n"")
            elif name:
                conn.setblocking(False)
                users[name] = conn
                broadcast(name, ""+++ %s arrived +++"" % name)
                break
    thread.start_new_thread(threaded, ())
 
def broadcast(name, message):
    """"""
    Send a message to all users from the given name.
    """"""
    print message
    for to_name, conn in users.items():
        if to_name != name:
            try:
                conn.send(message + ""\n"")
            except socket.error:
                pass
 
# Set up the server socket.
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.setblocking(False)
server.bind((HOST, PORT))
server.listen(1)
print ""Listening on %s"" % (""%s:%s"" % server.getsockname())
 
# Main event loop.
users = {}
while True:
    try:
        # Accept new connections.
        while True:
            try:
                conn, addr = server.accept()
            except socket.error:
                break
            accept(conn)
        # Read from connections.
        for name, conn in users.items():
            try:
                message = conn.recv(1024)
            except socket.error:
                continue
            if not message:
                # Empty string is given on disconnect.
                del users[name]
                broadcast(name, ""--- %s leaves ---"" % name)
            else:
                broadcast(name, ""%s> %s"" % (name, message.strip()))
        time.sleep(.1)
    except (SystemExit, KeyboardInterrupt):
        break",Human_written,Python_from_Java
http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",Python,"from __future__ import division, print_function
from math import gcd, sqrt
 
 
def hero(a, b, c):
    s = (a + b + c) / 2
    a2 = s * (s - a) * (s - b) * (s - c)
    return sqrt(a2) if a2 > 0 else 0
 
 
def is_heronian(a, b, c):
    a = hero(a, b, c)
    return a > 0 and a.is_integer()
 
 
def gcd3(x, y, z):
    return gcd(gcd(x, y), z)
 
 
if __name__ == '__main__':
    MAXSIDE = 200
 
    N = 1 + MAXSIDE
    h = [(x, y, z)
         for x in range(1, N)
         for y in range(x, N)
         for z in range(y, N) if (x + y > z) and
         1 == gcd3(x, y, z) and
         is_heronian(x, y, z)]
 
    # By increasing area, perimeter, then sides
    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))
 
    print(
        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)
    )
    print('\nFirst ten when ordered by increasing area, then perimeter,',
          'then maximum sides:')
    print('\n'.join('  %14r perim: %3i area: %i'
                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))
    print('\nAll with area 210 subject to the previous ordering:')
    print('\n'.join('  %14r perim: %3i area: %i'
                    % (sides, sum(sides), hero(*sides)) for sides in h
                    if hero(*sides) == 210))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"# Julia Operators in Order of Preference
#--------------------------------------------
#Syntax 				. followed by ::
#Exponentiation			^
#Fractions			//
#Multiplication			* / % & \
#Bitshifts			<< >> >>>
#Addition			+ - | ⊻
#Syntax				:.. followed by |>
#Comparisons			> < >= <= == === != !== <:
#Control flow			&& followed by || followed by ?
#Assignments			= += -= *= /= //= \= ^= ÷= %= |= &= ⊻= <<= >>= >>>=

#Operator precedence can be checked within Julia with the Base.operator_precedence function:

#julia> Base.operator_precedence(:>=), Base.operator_precedence(:&&), Base.operator_precedence(:(=))
#(6, 4, 1)

#Julia Associativity of Operators
#---------------------------------------------
#Assignment (=, etc.), conditional (a ? b : c), -> arrows, lazy OR/AND (&& ||), 
#power operators, and unary operators are right associative. All others are 
#left associative.",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Object_serialization,Object serialization,"Create a set of data types based upon inheritance. Each data type or class should have a print command that displays the contents of an instance of that class to standard output. Create instances of each class in your inheritance hierarchy and display them to standard output. Write each of the objects to a file named objects.dat in binary form using serialization or marshalling. Read the file objects.dat and print the contents of each serialized object.
",Python,"# Object Serialization in Python
# serialization in python is accomplished via the Pickle module.
# Alternatively, one can use the cPickle module if speed is the key,
# everything else in this example remains the same.
 
import pickle
 
class Entity:
	def __init__(self):
		self.name = ""Entity""
	def printName(self):
		print self.name
 
class Person(Entity): #OldMan inherits from Entity
	def __init__(self): #override constructor
		self.name = ""Cletus"" 
 
instance1 = Person()
instance1.printName()
 
instance2 = Entity()
instance2.printName()
 
target = file(""objects.dat"", ""w"") # open file
 
#  Serialize
pickle.dump((instance1, instance2), target) # serialize `instance1` and `instance2`to `target`
target.close() # flush file stream
print ""Serialized...""
 
# Unserialize
target = file(""objects.dat"") # load again
i1, i2 = pickle.load(target)
print ""Unserialized...""
 
i1.printName()
i2.printName()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation,Permutations/Rank of a permutation,"A particular ranking of a permutation associates an integer with a particular ordering of all the permutations of a set of distinct items.
For our purposes the ranking will assign integers 



0..
(
n
!
−
1
)


{\displaystyle 0..(n!-1)}

 to an ordering of all the permutations of the integers 



0..
(
n
−
1
)


{\displaystyle 0..(n-1)}

.

For example, the permutations of the digits zero to 3 arranged lexicographically have the following rank:

  PERMUTATION      RANK
  (0, 1, 2, 3) ->  0
  (0, 1, 3, 2) ->  1
  (0, 2, 1, 3) ->  2
  (0, 2, 3, 1) ->  3
  (0, 3, 1, 2) ->  4
  (0, 3, 2, 1) ->  5
  (1, 0, 2, 3) ->  6
  (1, 0, 3, 2) ->  7
  (1, 2, 0, 3) ->  8
  (1, 2, 3, 0) ->  9
  (1, 3, 0, 2) -> 10
  (1, 3, 2, 0) -> 11
  (2, 0, 1, 3) -> 12
  (2, 0, 3, 1) -> 13
  (2, 1, 0, 3) -> 14
  (2, 1, 3, 0) -> 15
  (2, 3, 0, 1) -> 16
  (2, 3, 1, 0) -> 17
  (3, 0, 1, 2) -> 18
  (3, 0, 2, 1) -> 19
  (3, 1, 0, 2) -> 20
  (3, 1, 2, 0) -> 21
  (3, 2, 0, 1) -> 22
  (3, 2, 1, 0) -> 23
Algorithms exist that can generate a rank from a permutation for some particular ordering of permutations, and that can generate the same rank from the given individual permutation (i.e. given a rank of 17 produce (2, 3, 1, 0) in the example above).

One use of such algorithms could be in generating a small, random, sample of permutations of 



n


{\displaystyle n}

 items without duplicates when the total number of permutations is large. Remember that the total number of permutations of 



n


{\displaystyle n}

 items is given by 



n
!


{\displaystyle n!}

 which grows large very quickly: A 32 bit integer can only hold 



12
!


{\displaystyle 12!}

, a 64 bit integer only 



20
!


{\displaystyle 20!}

. It becomes difficult to take the straight-forward approach of generating all permutations then taking a random sample of them.

A question on the Stack Overflow site asked how to generate one million random and indivudual permutations of 144 items.



Task

 Create a function to generate a permutation from a rank.
 Create the inverse function that given the permutation generates its rank.
 Show that for 



n
=
3


{\displaystyle n=3}

 the two functions are indeed inverses of each other.
 Compute and show here 4 random, individual, samples of permutations of 12 objects.


Stretch goal

 State how reasonable it would be to use your program to address the limits of the Stack Overflow question.


References

 Ranking and Unranking Permutations in Linear Time by Myrvold & Ruskey. (Also available via Google here).
 Ranks on the DevData site.
 Another answer on Stack Overflow to a different question that explains its algorithm in detail.


Related tasks

Factorial_base_numbers_indexing_permutations_of_a_collection

",Python,"from math import factorial as fact
from random import randrange
from textwrap import wrap
 
def identity_perm(n): 
    return list(range(n))
 
def unranker1(n, r, pi):
    while n > 0:
        n1, (rdivn, rmodn) = n-1, divmod(r, n)
        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]
        n = n1
        r = rdivn
    return pi
 
def init_pi1(n, pi): 
    pi1 = [-1] * n
    for i in range(n): 
        pi1[pi[i]] = i
    return pi1
 
def ranker1(n, pi, pi1):
    if n == 1: 
        return 0
    n1 = n-1
    s = pi[n1]
    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]
    pi1[s], pi1[n1] = pi1[n1], pi1[s]
    return s + n * ranker1(n1, pi, pi1)
 
def unranker2(n, r, pi):
    while n > 0:
        n1 = n-1
        s, rmodf = divmod(r, fact(n1))
        pi[n1], pi[s] = pi[s], pi[n1]
        n = n1
        r = rmodf
    return pi
 
def ranker2(n, pi, pi1):
    if n == 1: 
        return 0
    n1 = n-1
    s = pi[n1]
    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]
    pi1[s], pi1[n1] = pi1[n1], pi1[s]
    return s * fact(n1) + ranker2(n1, pi, pi1)
 
def get_random_ranks(permsize, samplesize):    
    perms = fact(permsize)
    ranks = set()
    while len(ranks) < samplesize:
        ranks |= set( randrange(perms) 
                      for r in range(samplesize - len(ranks)) )
    return ranks    
 
def test1(comment, unranker, ranker):    
    n, samplesize, n2 = 3, 4, 12
    print(comment)
    perms = []
    for r in range(fact(n)):
        pi = identity_perm(n)
        perm = unranker(n, r, pi)
        perms.append((r, perm))
    for r, pi in perms:
        pi1 = init_pi1(n, pi)
        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))
    print('\n  %i random individual samples of %i items:' % (samplesize, n2))
    for r in get_random_ranks(n2, samplesize):
        pi = identity_perm(n2)
        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))
    print('')
 
def test2(comment, unranker):    
    samplesize, n2 = 4, 144
    print(comment)
    print('  %i random individual samples of %i items:' % (samplesize, n2))
    for r in get_random_ranks(n2, samplesize):
        pi = identity_perm(n2)
        print('    ' + '\n      '.join(wrap(repr(unranker(n2, r, pi)))))
    print('')
 
if __name__ == '__main__':
    test1('First ordering:', unranker1, ranker1)
    test1('Second ordering:', unranker2, ranker2)
    test2('First ordering, large number of perms:', unranker1)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",Python,"import random

def main():
    switchWins = 0
    stayWins = 0
    gen = random.Random()
    for plays in range(32768):
        doors = [0, 0, 0]
        doors[gen.randint(0, 2)] = 1
        choice = gen.randint(0, 2)
        shown = 0
        while doors[shown] == 1 or shown == choice:
            shown = gen.randint(0, 2)
        stayWins += doors[choice]
        switchWins += doors[3 - choice - shown]
    print(""Switching wins "" + str(switchWins) + "" times."")
    print(""Staying wins "" + str(stayWins) + "" times."")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Equilibrium_index,Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",Python,"# version 1.2
 
def equilibriumIndices(a):
    ei = []
    if not a: return ei # empty list
    sumAll = sum(a)
    sumLeft = 0
    sumRight = 0
    for i in range(len(a)):
        sumRight = sumAll - sumLeft - a[i]
        if sumLeft == sumRight: ei.append(i)
        sumLeft += a[i]
    return ei
 
a = [-7, 1, 5, 2, -4, 3, 0]
ei = equilibriumIndices(a)
if not ei:
    print(""There are no equilibrium indices"")
elif len(ei) == 1:
    print(""The only equilibrium index is : {}"".format(ei[0]))
else:
    print(""The equilibrium indices are : {}"".format("", "".join(map(str, ei))))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Cramer%27s_rule,Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",Python,"import numpy as np
 
def cramers_rule(matrix, b):
    denominator = np.linalg.det(matrix)
    result = []
    for i in range(len(b)):
        result.append(np.linalg.det(np.column_stack((b, matrix[:, 0:i], matrix[:, i+1:len(b)]))) / denominator)
    return result
 
matrix = np.array([[2, -1, 5, 1], [3, 2, 2, -6], [1, 3, 3, -1], [5, -2, -3, 3]])
b = np.array([-3, -32, -47, 49])
print(""Solution = "" + str(cramers_rule(matrix, b)))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Parameterized_SQL_statement,Parameterized SQL statement,"SQL injection
Using a SQL update statement like this one (spacing is optional):

UPDATE players
   SET name = 'Smith, Steve', score = 42, active = TRUE
   WHERE jerseyNum = 99
Non-parameterized SQL is the GoTo statement of database programming. Don't do it, and make sure your coworkers don't either.",Python,"import sys
from PyQt5.QtSql import *
 
# Command line arguments: data-source user password
# Obviously in a real application the password would be obtained in a secure manner.
 
if len(sys.argv)!= 4:
    print(""Usage: %s data-source user password"" % sys.argv[0])
    sys.exit(1)
db = QSqlDatabase.addDatabase(""QODBC"")
db.setDatabaseName(sys.argv[1])
if not db.open(sys.argv[2], sys.argv[3]):
    error = db.lastError()
    print(""Cannot connect to data source: %s"" % error.text())
    sys.exit(1)
print(""Connected to data source."")
query = QSqlQuery(db)
query.prepare(""UPDATE players SET name = ?, score = ?, active = ? WHERE jerseyNum = ?"")
query.bindValue(0, """")
query.bindValue(1, 42)
query.bindValue(2, True)
query.bindValue(3, 99)
if not query.exec_():
    error = db.lastError()
    print(""Cannot update database: %s"" % error.text())
    sys.exit(1)
print(""Update succeeded."")
sys.exit(0)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/SHA-1,SHA-1,"SHA-1 or SHA1 is a one-way hash function;
it computes a 160-bit message digest.
SHA-1 often appears in security protocols; for example,
many HTTPS websites use RSA with SHA-1 to secure their connections.
BitTorrent uses SHA-1 to verify downloads.
Git and Mercurial use SHA-1 digests to identify commits.

A US government standard, FIPS 180-1, defines SHA-1.

Find the SHA-1 message digest for a string of octets. You may either call a SHA-1 library, or implement SHA-1 in your language. Both approaches interest Rosetta Code.



 Warning: SHA-1 has known weaknesses. Theoretical attacks may find a collision after 252 operations, or perhaps fewer.
This is much faster than a brute force attack of 280 operations. USgovernment deprecated SHA-1.
For production-grade cryptography, users may consider a stronger alternative, such as SHA-256 (from the SHA-2 family) or the upcoming SHA-3.

",Python,"import hashlib
h = hashlib.sha1()
h.update(bytes(""Ars longa, vita brevis"", encoding=""ASCII""))
h.hexdigest()
# ""e640d285242886eb96ab80cbf858389b3df52f43""",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Monads/Maybe_monad,Monads/Maybe monad,"Demonstrate in your programming language the following:

Construct a Maybe Monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that Monad (or just use what the language already has implemented)
Make two functions, each which take a number and return a monadic number, e.g. Int -> Maybe Int and Int -> Maybe String
Compose the two functions with bind


A Monad is a single type which encapsulates several other types, eliminating boilerplate code. In practice it acts like a dynamically typed computational sequence, though in many cases the type issues can be resolved at compile time.

A Maybe Monad is a monad which specifically encapsulates the type of an undefined value.
",Python,"from typing import Union
 
class Maybe:
    def __init__(self, value):
        self.value = value
 
class Some(Maybe):
    def __init__(self, value):
        super().__init__(value)
 
class None(Maybe):
    def __init__(self):
        super().__init__(None)
 
def monadic_square_root(x):
    if x >= 0:
        return Some(x ** 0.5)
    else:
        return None()
 
for x in [4.0, 8.0, -15.0, 16.23, -42]:
    maybe = monadic_square_root(x)
    if isinstance(maybe, Some):
        print(f""The square root of {x} is {maybe.value}"")
    else:
        print(f""Square root of {x} is undefined."")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Python,"width = int(raw_input(""Width of myarray: ""))
height = int(raw_input(""Height of Array: ""))
myarray = [[0] * width for i in range(height)]
myarray[0][0] = 3.5
print (myarray[0][0])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Write_float_arrays_to_a_text_file,Write float arrays to a text file,"Task

Write two equal-sized numerical arrays 'x' and 'y' to
a two-column text file named 'filename'.

The first column of the file contains values from an 'x'-array with a
given 'xprecision', the second -- values from 'y'-array with 'yprecision'.

For example, considering:

   x = {1, 2, 3, 1e11};
   y = {1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791}; 
                                                          /* sqrt(x) */
   xprecision = 3;
   yprecision = 5;

The file should look like:

   1    1
   2    1.4142
   3    1.7321
   1e+011   3.1623e+005

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",Python,"# prepare test data
x = [1, 2, 3, 1e11]
y = [math.sqrt(xx) for xx in x]
xprecision = 3
yprecision = 5
 
# write the arrays
with open('sqrt.dat', 'w') as f:
  for xx, yy in zip(x, y):
    f.write(""%.*g\t%.*g\n"" % (xprecision, xx, yprecision, yy))
 
# print the result file
with open('sqrt.dat', 'r') as f:
  print(f.read())",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Kolakoski_sequence,Kolakoski sequence,"The Kolakoski sequence is an infinite sequence of natural numbers, (excluding zero); with the property that:

 if you form a new sequence from the counts of runs of the same number in the first sequence, this new sequence is the same as the first sequence.
Example

This is not a Kolakoski sequence:

1,1,2,2,2,1,2,2,1,2,...
Its sequence of run counts, (sometimes called a run length encoding, (RLE); but a true RLE also gives the character that each run encodes), is calculated like this:

 Starting from the leftmost number of the sequence we have 2 ones, followed by 3 twos, then 1 ones, 2 twos, 1 one, ...
The above gives the RLE of:

2, 3, 1, 2, 1, ...
The original sequence is different from its RLE in this case. It would be the same for a true Kolakoski sequence.

Creating a Kolakoski sequence

Lets start with the two numbers (1, 2) that we will cycle through; i.e. they will be used in this order:
 1,2,1,2,1,2,....

 We start the sequence s with the first item from the cycle c:
 1
 An index, k, into the, (expanding), sequence will step, or index through each item of the sequence s from the first, at its own rate.
 
We will arrange that the k'th item of s states how many times the last item of sshould appear at the end of s.

We started s with 1 and therefore s[k] states that it should appear only the 1 time.



Increment k
Get the next item from c and append it to the end of sequence s. s will then become:
 1, 2
k was moved to the second item in the list and s[k] states that it should appear two times, so append another of the last item to the sequence s:
 1, 2,2
Increment k
Append the next item from the cycle to the list:
 1, 2,2, 1
k is now at the third item in the list that states that the last item should appear twice so add another copy of the last item to the sequence s:
 1, 2,2, 1,1
increment k
...

Note that the RLE of 1, 2, 2, 1, 1, ... begins 1, 2, 2 which is the beginning of the original sequence. The generation algorithm ensures that this will always be the case.

Task

 Create a routine/proceedure/function/... that given an initial ordered list/array/tuple etc of the natural numbers (1, 2), returns the next number from the list when accessed in a cycle.
 Create another routine that when given the initial ordered list (1, 2) and the minimum length of the sequence to generate; uses the first routine and the algorithm above, to generate at least the requested first members of the kolakoski sequence.
 Create a routine that when given a sequence, creates the run length encoding of that sequence (as defined above) and returns the result of checking if sequence starts with the exact members of its RLE. (But note, due to sampling, do not compare the last member of the RLE).
 Show, on this page, (compactly), the first 20 members of the sequence generated from (1, 2)
 Check the sequence againt its RLE.
 Show, on this page, the first 20 members of the sequence generated from (2, 1)
 Check the sequence againt its RLE.
 Show, on this page, the first 30 members of the Kolakoski sequence generated from (1, 3, 1, 2)
 Check the sequence againt its RLE.
 Show, on this page, the first 30 members of the Kolakoski sequence generated from (1, 3, 2, 1)
 Check the sequence againt its RLE.
(There are rules on generating Kolakoski sequences from this method that are broken by the last example)
",Python,"from __future__ import print_function
 
TRUE = 1
FALSE = 0
 
def next_in_cycle(c, len, index):
    return c[index % len]
 
def kolakoski(c, s, clen, slen):
    i = 0
    j = 0
    k = 0
    while True:
        s[i] = next_in_cycle(c, clen, k)
        if s[k] > 1:
            for j in range(1, s[k]):
                if i == slen:
                    return
                s[i] = s[i - 1]
                i += 1
        if i == slen:
            return
        k += 1
 
def possible_kolakoski(s, len):
    i = 0
    j = 0
    prev = s[0]
    count = 1
    rle = [0] * len
    result = TRUE
    for i in range(1, len):
        if s[i] == prev:
            count += 1
        else:
            rle[j] = count
            count = 1
            prev = s[i]
            j += 1
    for i in range(j):
        if rle[i]!= s[i]:
            result = FALSE
            break
    return result
 
def print_array(a, len):
    print(""["", end="""")
    for i in range(len):
        print(a[i], end="""")
        if i < len - 1:
            print("", "", end="""")
    print(""]"")
 
if __name__ == ""__main__"":
    i = 0
    clen = 0
    slen = 0
    s = []
    c0 = [1, 2]
    c1 = [2, 1]
    c2 = [1, 3, 1, 2]
    c3 = [1, 3, 2, 1]
    cs = [c0, c1, c2, c3]
    p = 0
    clens = [2, 2, 4, 4]
    slens = [20, 20, 30, 30]
    for i in range(4):
        clen = clens[i]
        slen = slens[i]
        s = [0] * slen
        kolakoski(cs[i], s, clen, slen)
        print(""First %d members of the sequence generated by "" % slen, end="""")
        print_array(cs[i], clen)
        print("":"")
        print_array(s, slen)
        print("""")
        p = possible_kolakoski(s, slen)
        print(""Possible Kolakoski sequence? %s"" % (""True"" if p else ""False""))
        print("""")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Periodic_table,Periodic table,"Task

Display the row and column in the periodic table of the given atomic number.

The periodic table

Let us consider the following periodic table representation.

     __________________________________________________________________________ 
    |   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18 |
    |                                                                          |
    |1  H                                                                   He |
    |                                                                          |
    |2  Li  Be                                          B   C   N   O   F   Ne |
    |                                                                          |
    |3  Na  Mg                                          Al  Si  P   S   Cl  Ar |
    |                                                                          |
    |4  K   Ca  Sc  Ti  V   Cr  Mn  Fe  Co  Ni  Cu  Zn  Ga  Ge  As  Se  Br  Kr |
    |                                                                          |
    |5  Rb  Sr  Y   Zr  Nb  Mo  Tc  Ru  Rh  Pd  Ag  Cd  In  Sn  Sb  Te  I   Xe |
    |                                                                          |
    |6  Cs  Ba  *   Hf  Ta  W   Re  Os  Ir  Pt  Au  Hg  Tl  Pb  Bi  Po  At  Rn |
    |                                                                          |
    |7  Fr  Ra  °   Rf  Db  Sg  Bh  Hs  Mt  Ds  Rg  Cn  Nh  Fl  Mc  Lv  Ts  Og |
    |__________________________________________________________________________|
    |                                                                          |
    |                                                                          |
    |8  Lantanoidi* La  Ce  Pr  Nd  Pm  Sm  Eu  Gd  Tb  Dy  Ho  Er  Tm  Yb  Lu |
    |                                                                          |
    |9   Aktinoidi° Ak  Th  Pa  U   Np  Pu  Am  Cm  Bk  Cf  Es  Fm  Md  No  Lr |
    |__________________________________________________________________________|

Example test cases;
   1 -> 1 1
   2 -> 1 18
   29 -> 4 11
   42 -> 5 6
   57 -> 8 4
   58 -> 8 5
   72 -> 6 4
   89 -> 9 4
Details;
The representation of the periodic table may be represented in various way. The one presented in this challenge does have the following property : Lantanides and Aktinoides are all in a dedicated row, hence there is no element that is placed at 6, 3 nor 7, 3.

You may take a look at the atomic number repartitions here.

The atomic number is at least 1, at most 118.



See also
 
   the periodic table
   This task was an idea from CompSciFact
   The periodic table in ascii that was used as template

",Python,"def perta(atomic) -> (int, int):
 
    NOBLES = 2, 10, 18, 36, 54, 86, 118
    INTERTWINED = 0, 0, 0, 0, 0, 57, 89
    INTERTWINING_SIZE = 14
    LINE_WIDTH = 18
 
    prev_noble = 0
    for row, noble in enumerate(NOBLES):
        if atomic <= noble:  # we are at the good row. We now need to determine the column
            nb_elem = noble - prev_noble  # number of elements on that row
            rank =  atomic - prev_noble  # rank of the input element among elements
            if INTERTWINED[row] and INTERTWINED[row] <= atomic <= INTERTWINED[row] + INTERTWINING_SIZE:  # lantanides or actinides
                row += 2
                col = rank + 1
            else:  # not a lantanide nor actinide
                # handle empty spaces between 1-2, 4-5 and 12-13.
                nb_empty = LINE_WIDTH - nb_elem  # spaces count as columns
                inside_left_element_rank = 2 if noble > 2 else 1
                col = rank + (nb_empty if rank > inside_left_element_rank else 0)
            break
        prev_noble = noble
    return row+1, col
 
 
 
# small test suite
 
TESTS = {
    1: (1, 1),
    2: (1, 18),
    29: (4,11),
    42: (5, 6),
    58: (8, 5),
    59: (8, 6),
    57: (8, 4),
    71: (8, 18),
    72: (6, 4),
    89: (9, 4),
    90: (9, 5),
    103: (9, 18),
}
 
for input, out in TESTS.items():
    found = perta(input)
    print('TEST:{:3d} -> '.format(input) + str(found) + (f' ; ERROR: expected {out}' if found != out else ''))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.0.12
 
import re
 
class String(object):
    def __init__(self, s):
        self.s = s
 
    def remove(self, r):
        return re.sub(r'[' + r + ']', '', self.s)
 
if __name__ == '__main__':
    print(String(""She was a soul stripper. She took my heart!"").remove(""aei""))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously,Loop over multiple arrays simultaneously,"Task

Loop over multiple arrays   (or lists or tuples or whatever they're called in
your language)   and display the    i th    element of each.

Use your language's   ""for each""   loop if it has one, otherwise iterate
through the collection in order with some other loop.



For this example, loop over the arrays:

    (a,b,c)
    (A,B,C) 
    (1,2,3) 

to produce the output:

    aA1
    bB2
    cC3



If possible, also describe what happens when the arrays are of different lengths.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"list1 = [[""a"",""b"",""c""], [""A"", ""B"", ""C""], [""1"", ""2"", ""3""]]
for i in range(len(list1)):
    for lista in list1:
        print(lista[i], end="""")
    print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Maximum_triangle_path_sum,Maximum triangle path sum,"Starting from the top of a pyramid of numbers like this, you can walk down going one step on the right or on the left, until you reach the bottom row:

                          55
                        94 48
                       95 30 96
                     77 71 26 67

One of such walks is 55 - 94 - 30 - 26.
You can compute the total of the numbers you have seen in such walk,
in this case it's 205.

Your problem is to find the maximum total among all possible paths from the top to the bottom row of the triangle. In the little example above it's 321.



Task

Find the maximum total in the triangle below:

                          55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93

Such numbers can be included in the solution code, or read from a ""triangle.txt"" file.

This task is derived from the Euler Problem #18.



",Python,"def solve(tri):
    while len(tri) > 1:
        t0 = tri.pop()
        t1 = tri.pop()
        tri.append([max(t0[i], t0[i+1]) + t for i,t in enumerate(t1)])
    return tri[0][0]
 
 
data = """"""                55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93""""""
 
print solve([map(int, row.split()) for row in data.splitlines()])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"import queue
import assert

def main():
    q = queue.Queue()
    assert( q.empty() )        # initially the queue is empty

    q.put(1)                  # add an element
    assert( not q.empty() )       # now the queue isn't empty any more
    assert( q.get() == 1 )   # the first element is, of course, 1

    q.put(2)                  # add another element
    assert( not q.empty() )       # it's of course not empty again
    assert( q.get() == 1 )   # the first element didn't change

    q.put(3)                  # add yet an other element
    assert( not q.empty() )       # the queue is still not empty
    assert( q.get() == 1 )   # and the first element is still 1

    q.get()                    # remove the first element
    assert( not q.empty() )       # the queue is not yet empty
    assert( q.get() == 2)    # the first element is now 2 (the 1 is gone)

    q.get()
    assert( not q.empty() )
    assert( q.get() == 3)

    q.put(4)
    assert( not q.empty() )
    assert( q.get() == 3)

    q.get()
    assert( not q.empty() )
    assert( q.get() == 4)

    q.get()
    assert( q.empty() )

    q.put(5)
    assert( not q.empty() )
    assert( q.get() == 5)

    q.get()
    assert( q.empty() )

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Set,Set,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A   set  is a collection of elements, without duplicates and without order.



Task

Show each of these set operations:

 Set creation
 Test m ∈ S -- ""m is an element in set S""
 A ∪ B -- union; a set of all elements either in set A or in set B.
 A ∩ B -- intersection; a set of all elements in both set A and set B.
 A ∖ B -- difference; a set of all elements in set A, except those in set B.
 A ⊆ B -- subset; true if every element in set A is also in set B.
 A = B -- equality; true if every element of set A is in set B and vice versa.


As an option, show some other set operations.

(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.)

As another option, show how to modify a mutable set.



One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,">>> from sets import Set
>>> s1, s2 = Set([1, 2, 3, 4]), Set([3, 4, 5, 6]) # different ways of creating a set
>>> s1 | s2 # Union
set([1, 2, 3, 4, 5, 6])
>>> s1 & s2 # Intersection
set([3, 4])
>>> s1 - s2 # Difference
set([1, 2])
>>> s1.issubset(s1) # Proper subset
True
>>> Set([3, 1]).issubset(s1) # Proper subset
True
>>> s1.issubset(s1) # Subset
True
>>> Set([3, 1]).issubset(s1) # Subset
True
>>> Set([3, 2, 4, 1]) == s1 # Equality
True
>>> s1 == s2 # Equality
False
>>> 2 in s1 # Membership
True
>>> Set([1, 2, 3, 4, 5]).issuperset(s1) # Proper superset
True
>>> Set([1, 2, 3, 4]).issuperset(s1) # Proper superset
False
>>> Set([1, 2, 3, 4]).issuperset(s1) # Superset
True
>>> s1 ^ s2 # Symmetric difference
set([1, 2, 5, 6])
>>> len(s1) # Cardinality
4
>>> s1.add(99) # Mutability (or s1.add(99) )
>>> s1.remove(99) # Mutability
>>> s1.update(s2) # Mutability
>>> s1.difference_update(s2) # Mutability
>>>",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Count_in_factors,Count in factors,"Task

Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.

For the purpose of this task,   1   (unity)   may be shown as itself.



Example

      2   is prime,   so it would be shown as itself.

      6   is not prime;   it would be shown as   



2
×
3


{\displaystyle 2\times 3}

.
2144   is not prime;   it would be shown as   



2
×
2
×
2
×
2
×
2
×
67


{\displaystyle 2\times 2\times 2\times 2\times 2\times 67}

.



Related tasks

   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Python,"from functools import lru_cache
 
primes = [2, 3, 5, 7, 11, 13, 17]    # Will be extended
 
@lru_cache(maxsize=2000)
def pfactor(n):
    if n == 1:
        return [1]
    n2 = n // 2 + 1
    for p in primes:
        if p <= n2:
            d, m = divmod(n, p)
            if m == 0:
                if d > 1:
                    return [p] + pfactor(d)
                else:
                    return [p]
        else:
            if n > primes[-1]:
                primes.append(n)
            return [n]
 
if __name__ == '__main__':
    mx = 5000
    for n in range(1, mx + 1):
        factors = pfactor(n)
        if n <= 10 or n >= mx - 20:
            print( '%4i %5s %s' % (n,
                                   '' if factors != [n] or n == 1 else 'prime',
                                   'x'.join(str(i) for i in factors)) )
        if n == 11:
            print('...')
 
    print('\nNumber of primes gathered up to', n, 'is', len(primes))
    print(pfactor.cache_info())",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Law_of_cosines_-_triples,Law of cosines - triples,"The Law of cosines states that for an angle γ, (gamma) of any triangle, if the sides adjacent to the angle are A and B and the side opposite is C; then the lengths of the sides are related by this formula:

           A2 + B2 - 2ABcos(γ) = C2 

Specific angles

For an angle of of   90º   this becomes the more familiar ""Pythagoras equation"":

           A2 + B2  =  C2           

For an angle of   60º   this becomes the less familiar equation:

           A2 + B2 - AB  =  C2       

And finally for an angle of   120º   this becomes the equation:

           A2 + B2 + AB  =  C2      



Task

   Find all integer solutions (in order) to the three specific cases, distinguishing between each angle being considered.
   Restrain all sides to the integers   1..13   inclusive.
   Show how many results there are for each of the three angles mentioned above.
   Display results on this page.


Note: Triangles with the same length sides but different order are to be treated as the same.

Optional Extra credit

 How many 60° integer triples are there for sides in the range 1..10_000 where the sides are not all of the same length.


Related Task
 Pythagorean triples


See also

 Visualising Pythagoras: ultimate proofs and crazy contortions Mathlogger Video

",Python,"import math
from itertools import product
 
def law_of_cosines_triples(degrees, max_side_length, not_all_the_same_length=False, print_triples=True):
    print(f""{degrees} degree triangles in range 1..{max_side_length}"")
    if not_all_the_same_length:
        print(""where not all sides are the same"")
    count = 0
    triples = find_triples(degrees, max_side_length)
    if not_all_the_same_length:
        triples = [triple for triple in triples if not_all_the_same_length(triple)]
    for triple in triples:
        count += 1
        if print_triples:
            print(triple)
    print(f""{count} solutions"")
 
def find_triples(degrees, max_side_length):
    radians = degrees * math.pi / 180
    coefficient = round(math.cos(radians) * -2)
    max_side_length_squared = max_side_length * max_side_length
    return [
        (a, b, c)
        for a in range(1, max_side_length + 1)
        for b in range(1, a + 1)
        for c in range(1, b + 1)
        if a * a + b * b + a * b * coefficient <= max_side_length_squared
        and c * c == a * a + b * b + a * b * coefficient
    ]
 
def not_all_the_same_length(triple):
    return triple[0]!= triple[1] or triple[0]!= triple[2]
 
if __name__ == ""__main__"":
    law_of_cosines_triples(60, 13)
    law_of_cosines_triples(90, 13)
    law_of_cosines_triples(120, 13)
    law_of_cosines_triples(60, 10_000, True, False)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Van_Eck_sequence,Van Eck sequence,"The sequence is generated by following this pseudo-code:

A:  The first term is zero.
    Repeatedly apply:
        If the last term is *new* to the sequence so far then:
B:          The next term is zero.
        Otherwise:
C:          The next term is how far back this last term occured previously.



Example

Using A:

0
Using B:

0 0
Using C:

0 0 1
Using B:

0 0 1 0
Using C: (zero last occurred two steps back - before the one)

0 0 1 0 2
Using B:

0 0 1 0 2 0
Using C: (two last occurred two steps back - before the zero)

0 0 1 0 2 0 2 2
Using C: (two last occurred one step back)

0 0 1 0 2 0 2 2 1
Using C: (one last appeared six steps back)

0 0 1 0 2 0 2 2 1 6
...



Task

 Create a function/procedure/method/subroutine/... to generate the Van Eck sequence of numbers.
 Use it to display here, on this page:
 The first ten terms of the sequence.
 Terms 991 - to - 1000 of the sequence.


References

 Don't Know (the Van Eck Sequence) - Numberphile video.
 Wikipedia Article: Van Eck's Sequence.
  OEIS sequence: A181391.

",Python,"def van_eck():
    ar = [0]
    while True:
        term = ar[-1]
        yield term
        ar.append(ar.count(term) - 1 if ar.count(term) == 1 else len(ar) - 1 - ar[::-1].index(term))
 
ve = list(van_eck())
print(ve[:10], ve[-10:])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Statistics/Basic,Statistics/Basic,"Statistics is all about large groups of numbers.
When talking about a set of sampled data, most frequently used is their mean value and standard deviation (stddev).
If you have set of data 




x

i




{\displaystyle x_{i}}

 where 



i
=
1
,
2
,
…
,
n




{\displaystyle i=1,2,\ldots ,n\,\!}

, the mean is 






x
¯



≡


1
n



∑

i



x

i




{\displaystyle {\bar {x}}\equiv {1 \over n}\sum _{i}x_{i}}

, while the stddev is 



σ
≡




1
n



∑

i




(

x

i


−



x
¯



)


2






{\displaystyle \sigma \equiv {\sqrt {{1 \over n}\sum _{i}\left(x_{i}-{\bar {x}}\right)^{2}}}}

.

When examining a large quantity of data, one often uses a histogram, which shows the counts of data samples falling into a prechosen set of intervals (or bins).
When plotted, often as bar graphs, it visually indicates how often each data value occurs.

Task Using your language's random number routine, generate real numbers in the range of [0, 1]. It doesn't matter if you chose to use open or closed range.
Create 100 of such numbers (i.e. sample size 100) and calculate their mean and stddev.
Do so for sample size of 1,000 and 10,000, maybe even higher if you feel like.
Show a histogram of any of these sets.
Do you notice some patterns about the standard deviation?

Extra Sometimes so much data need to be processed that it's impossible to keep all of them at once. Can you calculate the mean, stddev and histogram of a trillion numbers? (You don't really need to do a trillion numbers, just show how it can be done.)

Hint

For a finite population with equal probabilities at all points, one can derive:








(
x
−


x
¯



)

2



¯


=



x

2


¯


−



x
¯



2




{\displaystyle {\overline {(x-{\overline {x}})^{2}}}={\overline {x^{2}}}-{\overline {x}}^{2}}


Or, more verbosely:







1
N



∑

i
=
1


N


(

x

i


−


x
¯



)

2


=


1
N



(

∑

i
=
1


N



x

i


2


)

−



x
¯



2


.


{\displaystyle {\frac {1}{N}}\sum _{i=1}^{N}(x_{i}-{\overline {x}})^{2}={\frac {1}{N}}\left(\sum _{i=1}^{N}x_{i}^{2}\right)-{\overline {x}}^{2}.}


See also
 Statistics/Normal distribution
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"def sd1(numbers):
    if numbers:
        mean = sum(numbers) / len(numbers)
        sd = (sum((n - mean)**2 for n in numbers) / len(numbers))**0.5
        return sd, mean
    else:
        return 0, 0
 
def sd2(numbers):
    if numbers:
        sx = sxx = n = 0
        for x in numbers:
            sx += x
            sxx += x*x
            n += 1
        sd = (n * sxx - sx*sx)**0.5 / n
        return sd, sx / n
    else:
        return 0, 0
 
def histogram(numbers):
    h = [0] * 10
    maxwidth = 50 # characters
    for n in numbers:
        h[int(n*10)] += 1
    mx = max(h)
    print()
    for n, i in enumerate(h):
        print('%3.1f: %s' % (n / 10, '+' * int(i / mx * maxwidth)))
    print()
 
if __name__ == '__main__':
    import random
    for i in range(1, 6):
        n = [random.random() for j in range(10**i)]
        print(""\n##\n## %i numbers\n##"" % 10**i)
        print('  Naive  method: sd: %8.6f, mean: %8.6f' % sd1(n))
        print('  Second method: sd: %8.6f, mean: %8.6f' % sd2(n))
        histogram(n)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",Python,"from __future__ import division
from __future__ import print_function
from builtins import range
from past.utils import old_div
from builtins import object
import sys
 
class Pi(object):
    def __init__(self):
        self.TWO = 2
        self.THREE = 3
        self.FOUR = 4
        self.SEVEN = 7
        self.q = 1
        self.r = 0
        self.t = 1
        self.k = 1
        self.n = 3
        self.l = 3
 
    def calcPiDigits(self):
        first = True
        while True:
            if (self.FOUR * self.q + self.r - self.t) < (self.n * self.t):
                sys.stdout.write(str(self.n))
                if first:
                    sys.stdout.write(""."")
                    first = False
                self.r = 10 * (self.r - self.n * self.t)
                self.n = 10 * (self.THREE * self.q + self.r) // self.t - 10 * self.n
                self.q = 10 * self.q
                sys.stdout.flush()
            else:
                self.r = 2 * self.q + self.r
                self.n = (2 * self.q + self.r) * self.l // self.t - self.n
                self.q = self.q * self.k
                self.t = self.t * self.l
                self.l = self.l + 2
                self.k = self.k + 1
 
if __name__ == ""__main__"":
    p = Pi()
    p.calcPiDigits()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Successive_prime_differences,Successive prime differences,"The series of increasing prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

The task applies a filter to the series returning groups of successive primes, (s'primes), that differ from the next by a given value or values.

Example 1: Specifying that the difference between s'primes be 2 leads to the groups:

(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), ...

(Known as Twin primes or Prime pairs)

Example 2: Specifying more than one difference between s'primes leads to groups of size one greater than the number of differences. Differences of 2, 4 leads to the groups:

(5, 7, 11), (11, 13, 17), (17, 19, 23), (41, 43, 47), .... 

In the first group 7 is two more than 5 and 11 is four more than 7; as well as 5, 7, and 11 being successive primes.
Differences are checked in the order of the values given, (differences of 4, 2 would give different groups entirely).

Task

 In each case use a list of primes less than 1_000_000
 For the following Differences show the first and last group, as well as the number of groups found:
 Differences of 2.
 Differences of 1.
 Differences of 2, 2.
 Differences of 2, 4.
 Differences of 4, 2.
 Differences of 6, 4, 2.
 Show output here.

Note: Generation of a list of primes is a secondary aspect of the task. Use of a built in function, well known library, or importing/use of prime generators from other Rosetta Code tasks is encouraged.

references
https://pdfs.semanticscholar.org/78a1/7349819304863ae061df88dbcb26b4908f03.pdf
https://www.primepuzzles.net/puzzles/puzz_011.htm
https://matheplanet.de/matheplanet/nuke/html/viewtopic.php?topic=232720&start=0",Python,"import math
 
def sieve(limit):
    primes = [2]
    c = [False] * (limit + 1)
    p = 3
    while True:
        p2 = p * p
        if p2 > limit:
            break
        for i in range(p2, limit + 1, 2 * p):
            c[i] = True
        while True:
            p += 2
            if not c[p]:
                break
    for i in range(3, limit + 1, 2):
        if not c[i]:
            primes.append(i)
    return primes
 
def successive_primes(primes, diffs):
    results = []
    dl = len(diffs)
    for i in range(len(primes) - dl):
        group = [primes[i]]
        for j in range(i, i + dl):
            if primes[j + 1] - primes[j]!= diffs[j - i]:
                continue
            group.append(primes[j + 1])
        results.append(group)
    return results
 
if __name__ == '__main__':
    primes = sieve(999999)
    diffs_list = [[2], [1], [2, 2], [2, 4], [4, 2], [6, 4, 2]]
    print(""For primes less than 1,000,000:-\n"")
    for diffs in diffs_list:
        print(""  For differences of %s ->\n"" % diffs)
        sp = successive_primes(primes, diffs)
        if not sp:
            print(""    No groups found"")
            continue
        print(""    First group   = %s"" % sp[0])
        print(""    Last group    = %s"" % sp[-1])
        print(""    Number found  = %d"" % len(sp))
        print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Doubly-linked_list/Definition,Doubly-linked list/Definition,"Define the data structure for a complete Doubly Linked List.

 The structure should support adding elements to the head, tail and middle of the list. 
 The structure should not allow circular loops


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import deque
 
some_list = deque([""a"", ""b"", ""c""])
print(some_list)
 
some_list.appendleft(""Z"")
print(some_list)
 
for value in reversed(some_list):
    print(value)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",Python,"import numpy as np
 
def minor(a, x, y):
    length = len(a) - 1
    result = np.empty((length, length))
    for i in range(length):
        for j in range(length):
            if i < x and j < y:
                result[i][j] = a[i][j]
            elif i >= x and j < y:
                result[i][j] = a[i + 1][j]
            elif i < x and j >= y:
                result[i][j] = a[i][j + 1]
            else:
                result[i][j] = a[i + 1][j + 1]
    return result
 
def det(a):
    if len(a) == 1:
        return a[0][0]
 
    sign = 1
    sum = 0
    for i in range(len(a)):
        sum += sign * a[0][i] * det(minor(a, 0, i))
        sign *= -1
    return sum
 
def perm(a):
    if len(a) == 1:
        return a[0][0]
 
    sum = 0
    for i in range(len(a)):
        sum += a[0][i] * perm(minor(a, 0, i))
    return sum
 
def test(m):
    p = perm(m)
    d = det(m)
 
    print(m)
    print(""Permanent: {}, determinant: {}"".format(p, d))
    print()
 
test([[1, 2], [3, 4]])
test([[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]])
test([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]])",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Loops/Continue,Loops/Continue,"Task

Show the following output using one loop.

1, 2, 3, 4, 5
6, 7, 8, 9, 10



Try to achieve the result by forcing the next iteration within the loop
upon a specific condition, if your language allows it.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"for i in range(1, 11):
    print(i, end='')
    if i % 5 == 0:
        print()
        continue
    print(', ', end='')",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Elementary_cellular_automaton/Random_Number_Generator,Elementary cellular automaton/Random Number Generator,"Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.

Steven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.

The purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.

You can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.

For extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.

Reference

 Cellular automata: Is Rule 30 random? (PDF).

",Python,"class WolfGen:
    def __init__(self):
        self.ca = ElementaryCA(30)
    def next(self):
        out = 0
        for i in range(8):
            out |= ((1 & self.ca.next())<<i)
        return out

gen = WolfGen()
for _ in range(10):
    print(gen.next(), end=' ')",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion,Parsing/RPN to infix conversion,"Parsing/RPN to infix conversion

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a program that takes an RPN representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in infix notation.

 Assume an input of a correct, space separated, string of tokens
 Generate a space separated output string representing the same expression in infix notation
 Show how the major datastructure of your algorithm changes with each new token parsed.
 Test with the following input RPN strings then print and display the output here.


 RPN input 
 sample output


 3 4 2 * 1 5 - 2 3 ^ ^ / +
 3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3


 1 2 + 3 4 + ^ 5 6 + ^
 ( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )

 Operator precedence and operator associativity is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



See also

   Parsing/Shunting-yard algorithm   for a method of generating an RPN from an infix expression.
   Parsing/RPN calculator algorithm   for a method of calculating a final value from this output RPN expression.
   Postfix to infix   from the RubyQuiz site.

",Python,"import re
import sys
 
class Entry:
	def __init__(self, expr, op):
		self.expr = expr
		self.op = op
 
def PrecedenceLess(lhs, rhs, assoc):
	KNOWN = { ""+"": 1, ""-"": 1, ""*"": 2, ""/"": 2, ""^"": 3 }
	ASSOCIATIVE = { ""+"", ""*"" }
	return (KNOWN.get(lhs, 0) < KNOWN.get(rhs, 0) + (assoc and rhs not in ASSOCIATIVE))
 
def Parenthesize(old, token, assoc):
	if old.op and PrecedenceLess(old.op, token, assoc):
		old.expr = '(' + old.expr + ')'
 
def AddToken(stack, token):
	if re.search(r'\d', token):
		stack.append(Entry(token, ''))	# it's a number, no operator
	else:	# it's an operator
		if len(stack) < 2:
			print(""Stack underflow"")
			sys.exit(1)
		rhs = stack.pop()
		Parenthesize(rhs, token, False)
		lhs = stack.pop()
		Parenthesize(lhs, token, True)
		stack.append(Entry(lhs.expr +'' + token +'' + rhs.expr, token))
 
def ToInfix(src):
	stack = []
	for token in src.split():
		AddToken(stack, token)
	if len(stack)!= 1:
		print(""Incomplete expression"")
		sys.exit(1)
	return stack.pop().expr
 
if __name__ == '__main__':
	print(ToInfix(""3 4 2 * 1 5 - 2 3 ^ ^ / +""))
	print(ToInfix(""1 2 + 3 4 + ^ 5 6 + ^""))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",Python,"from __future__ import division, print_function
from math import gcd, sqrt
 
 
def hero(a, b, c):
    s = (a + b + c) / 2
    a2 = s * (s - a) * (s - b) * (s - c)
    return sqrt(a2) if a2 > 0 else 0
 
 
def is_heronian(a, b, c):
    a = hero(a, b, c)
    return a > 0 and a.is_integer()
 
 
def gcd3(x, y, z):
    return gcd(gcd(x, y), z)
 
 
if __name__ == '__main__':
    MAXSIDE = 200
 
    N = 1 + MAXSIDE
    h = [(x, y, z)
         for x in range(1, N)
         for y in range(x, N)
         for z in range(y, N) if (x + y > z) and
         1 == gcd3(x, y, z) and
         is_heronian(x, y, z)]
 
    # By increasing area, perimeter, then sides
    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))
 
    print(
        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)
    )
    print('\nFirst ten when ordered by increasing area, then perimeter,',
          'then maximum sides:')
    print('\n'.join('  %14r perim: %3i area: %i'
                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))
    print('\nAll with area 210 subject to the previous ordering:')
    print('\n'.join('  %14r perim: %3i area: %i'
                    % (sides, sum(sides), hero(*sides)) for sides in h
                    if hero(*sides) == 210))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Terminal_control/Display_an_extended_character,Terminal control/Display an extended character,"Task

Display an extended (non ASCII) character onto the terminal.

Specifically, display a    £    (GBP currency sign).



",Python,print u'\u00a3',Human_written,Python_from_Go
http://rosettacode.org/wiki/Multi-dimensional_array,Multi-dimensional array,"For the purposes of this task, the actual memory layout or access method of this data structure is not mandated.

It is enough to:

 State the number and extent of each index to the array.
 Provide specific, ordered, integer indices for all dimensions of the array together with a new value to update the indexed value.
 Provide specific, ordered, numeric indices for all dimensions of the array to obtain the arrays value at that indexed position.


Task

 State if the language supports multi-dimensional arrays in its syntax and usual implementation.
 State whether the language uses row-major or column major order for multi-dimensional array storage, or any other relevant kind of storage.
 Show how to create a four dimensional array in your language and set, access, set to another value; and access the new value of an integer-indexed item of the array.
 The idiomatic method for the language is preferred.
 The array should allow a range of five, four, three and two (or two three four five if convenient), in each of the indices, in order. (For example, if indexing starts at zero for the first index then a range of 0..4 inclusive would suffice).
 State if memory allocation is optimised for the array - especially if contiguous memory is likely to be allocated.
 If the language has exceptional native multi-dimensional array support such as optional bounds checking, reshaping, or being able to state both the lower and upper bounds of index ranges, then this is the task to mention them.


Show all output here, (but you may judiciously use ellipses to shorten repetitive output text).



",Python,"#Single dimensional array of integers
a = [0]*10
 
#2-dimensional array, also called matrix of floating point numbers.
#This matrix has 3 rows and 2 columns.
b = [[0.0]*2]*3
 
#3-dimensional array ( Cube ? Cuboid ? Lattice ?) of characters
c = [[['']*6]*5]*4
 
#4-dimensional array (Hypercube ?) of doubles
d = [[[[0.0]*9]*8]*7]*6
 
#Note that the right most number in the [] is required, all the others may be omitted.
#Thus this is ok :
e = [[0]*3]*5
 
#But this is not
#float f[5][4][];
 
#But why bother with all those numbers ? You can also write :
g = [0]*10
 
#And for a matrix
h = [[0.0]*2]*3
 
#or if you want to show off
i = [[[0.0]*9]*8]*7
 
#you get the idea
j = [[['']*6]*5]*4",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class DListNode(ListNode):
    def __init__(self, value, prev=None, succ=None):
        self.value = value
        self.prev = prev
        if prev:
            prev.succ = self
        self.succ = succ
        if succ:
            succ.prev = self
 
    @classmethod
    def from_values(cls, *ary):
        f = ary.pop()
        for i in ary:
            f = cls(i, succ=f)
        return f
 
list = DListNode.from_values(1,2,3,4)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Additive_primes,Additive primes,"Definitions
In mathematics, additive primes are prime numbers for which the sum of their decimal digits are also primes.



Task
Write a program to determine (and show here) all additive primes less than 500.

Optionally, show the number of additive primes.



Also see

   the OEIS entry:   A046704 additive primes.
   the prime-numbers entry:   additive primes.
   the geeks for geeks entry: additive prime number.
   the prime-numbers fandom: additive primes.

",Python,"import math
 
def memoizeIsPrime(N):
    is_prime = [False] * N
    is_prime[2] = True
    is_prime[3] = True
    prime = [3]
    end = 1
    for n in range(5, N, 2):
        n_is_prime = True
        for i in range(end):
            PRIME = prime[i]
            if n % PRIME == 0:
                n_is_prime = False
                break
            if PRIME * PRIME > n:
                break
        if n_is_prime:
            prime[end] = n
            end += 1
            is_prime[n] = True
    return is_prime
 
def sumOfDecimalDigits(n):
    sum = 0
    while n > 0:
        sum += n % 10
        n //= 10
    return sum
 
N = 500
print(""Rosetta Code: additive primes less than"", N, "":"")
is_prime = memoizeIsPrime(N)
print(""   2"", end="""")
count = 1
for i in range(3, N, 2):
    if is_prime[i] and is_prime[sumOfDecimalDigits(i)]:
        print(""%4d"" % i, end="""")
        count += 1
        if count % 10 == 0:
            print()
print(""\nThose were"", count, ""additive primes."")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Make_directory_path,Make directory path,"Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect.
If the directory already exists, return successfully.
Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.



",Python,"from errno import EEXIST
from os import mkdir, curdir
from os.path import split, exists
 
def mkdirp(path, mode=0777):
    head, tail = split(path)
    if not tail:
        head, tail = split(head)
    if head and tail and not exists(head):
        try:
            mkdirp(head, mode)
        except OSError as e:
            # be happy if someone already created the path
            if e.errno != EEXIST:
                raise
        if tail == curdir:  # xxx/newdir/. exists if xxx/newdir exists
            return
    try:
        mkdir(path, mode)
    except OSError as e:
        # be happy if someone already created the path
        if e.errno != EEXIST:
            raise",Human_written,Python_from_C
http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping,Sutherland-Hodgman polygon clipping,"The   Sutherland-Hodgman clipping algorithm   finds the polygon that is the intersection between an arbitrary polygon (the “subject polygon”) and a convex polygon (the “clip polygon”).

It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.



Task

Take the closed polygon defined by the points:

 



[
(
50
,
150
)
,
(
200
,
50
)
,
(
350
,
150
)
,
(
350
,
300
)
,
(
250
,
300
)
,
(
200
,
250
)
,
(
150
,
350
)
,
(
100
,
250
)
,
(
100
,
200
)
]


{\displaystyle [(50,150),(200,50),(350,150),(350,300),(250,300),(200,250),(150,350),(100,250),(100,200)]}


and clip it by the rectangle defined by the points:

 



[
(
100
,
100
)
,
(
300
,
100
)
,
(
300
,
300
)
,
(
100
,
300
)
]


{\displaystyle [(100,100),(300,100),(300,300),(100,300)]}


Print the sequence of points that define the resulting clipped polygon.



Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon.

(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)



",Python,"class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
class Polygon:
    def __init__(self, points):
        self.points = points
 
def is_inside(p, cp1, cp2):
    return (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)
 
def compute_intersection(cp1, cp2, s, e):
    dc = Point(cp1.x - cp2.x, cp1.y - cp2.y)
    dp = Point(s.x - e.x, s.y - e.y)
    n1 = cp1.x * cp2.y - cp1.y * cp2.x
    n2 = s.x * e.y - s.y * e.x
    n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x)
    return Point((n1 * dp.x - n2 * dc.x) * n3, (n1 * dp.y - n2 * dc.y) * n3)
 
def sutherland_hodgman_clip(subject_polygon, clip_polygon):
    result_ring = subject_polygon.points[:]
    cp1 = clip_polygon.points[-1]
    for cp2 in clip_polygon.points:
        input = result_ring
        s = input[-1]
        result_ring = []
        for e in input:
            if is_inside(e, cp1, cp2):
                if not is_inside(s, cp1, cp2):
                    result_ring.append(compute_intersection(cp1, cp2, s, e))
                result_ring.append(e)
            elif is_inside(s, cp1, cp2):
                result_ring.append(compute_intersection(cp1, cp2, s, e))
            s = e
        cp1 = cp2
    return Polygon(result_ring)
 
def main():
    subject_polygon = Polygon([
        Point(50.0, 150.0), Point(200.0, 50.0), Point(350.0, 150.0), Point(350.0, 300.0),
        Point(250.0, 300.0), Point(200.0, 250.0), Point(150.0, 350.0), Point(100.0, 250.0),
        Point(100.0, 200.0),
    ])
    clip_polygon = Polygon([
        Point(100.0, 100.0), Point(300.0, 100.0), Point(300.0, 300.0), Point(100.0, 300.0),
    ])
    result = sutherland_hodgman_clip(subject_polygon, clip_polygon)
    print(result.points)
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/XML/XPath,XML/XPath,"Perform the following three XPath queries on the XML Document below:

 //item[1]: Retrieve the first ""item"" element 
 //price/text(): Perform an action on each ""price"" element (print it out)
 //name: Get an array of all the ""name"" elements
XML Document:

<inventory title=""OmniCorp Store #45x10^3"">
  <section name=""health"">
    <item upc=""123456789"" stock=""12"">
      <name>Invisibility Cream</name>
      <price>14.50</price>
      <description>Makes you invisible</description>
    </item>
    <item upc=""445322344"" stock=""18"">
      <name>Levitation Salve</name>
      <price>23.99</price>
      <description>Levitate yourself for up to 3 hours per application</description>
    </item>
  </section>
  <section name=""food"">
    <item upc=""485672034"" stock=""653"">
      <name>Blork and Freen Instameal</name>
      <price>4.95</price>
      <description>A tasty meal in a tablet; just add water</description>
    </item>
    <item upc=""132957764"" stock=""44"">
      <name>Grob winglets</name>
      <price>3.56</price>
      <description>Tender winglets of Grob. Just add water</description>
    </item>
  </section>
</inventory>
",Python,"import sys
from lxml import etree
 
def main(argv):
	if len(argv) <= 2:
		print ""Usage: %s <XML Document Name> <XPath expression>"" % argv[0]
		return 0
 
	docname = argv[1]
	xpath = argv[2]
	doc = etree.parse(docname)
	result = doc.xpath(xpath)
	for i, node in enumerate(result):
		print ""Value %d: %s"" % (i+1, node.text)
 
if __name__ == ""__main__"":
	main(sys.argv)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Catamorphism,Catamorphism,"Reduce is a function or method that is used to take the values in an array or a list and apply a function to successive members of the list to produce (or reduce them to), a single value.



Task

Show how reduce (or foldl or foldr etc), work (or would be implemented) in your language.



See also

 Wikipedia article:   Fold
 Wikipedia article:   Catamorphism

",Python,">>> # Python 2.X
>>> from operator import add
>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]
>>> help(reduce)
Help on built-in function reduce in module __builtin__:
 
reduce(...)
    reduce(function, sequence[, initial]) -> value
 
    Apply a function of two arguments cumulatively to the items of a sequence,
    from left to right, so as to reduce the sequence to a single value.
    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
    of the sequence in the calculation, and serves as a default when the
    sequence is empty.
 
>>> reduce(add, listoflists, [])
['the', 'cat', 'sat', 'on', 'the', 'mat']
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Tokenize_a_string,Tokenize a string,"Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word.

Display the words to the 'user', in the simplest manner possible, separated by a period.

To simplify, you may display a trailing period.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ""Hello,How,Are,You,Today""
print('.'.join(s.split(',')))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",Python,"$ python -c 'print ""Hello""'
Hello",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Percolation/Bond_percolation,Percolation/Bond percolation,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Given an 



M
×
N


{\displaystyle M\times N}

 rectangular array of cells numbered 




c
e
l
l

[
0..
M
−
1
,
0..
N
−
1
]


{\displaystyle \mathrm {cell} [0..M-1,0..N-1]}

, assume 



M


{\displaystyle M}

 is horizontal and 



N


{\displaystyle N}

 is downwards. Each 




c
e
l
l

[
m
,
n
]


{\displaystyle \mathrm {cell} [m,n]}

 is bounded by (horizontal) walls 




h
w
a
l
l

[
m
,
n
]


{\displaystyle \mathrm {hwall} [m,n]}

 and 




h
w
a
l
l

[
m
+
1
,
n
]


{\displaystyle \mathrm {hwall} [m+1,n]}

; (vertical) walls 




v
w
a
l
l

[
m
,
n
]


{\displaystyle \mathrm {vwall} [m,n]}

 and 




v
w
a
l
l

[
m
,
n
+
1
]


{\displaystyle \mathrm {vwall} [m,n+1]}



Assume that the probability of any wall being present is a constant 



p


{\displaystyle p}

 where

 



0.0
≤
p
≤
1.0


{\displaystyle 0.0\leq p\leq 1.0}


Except for the outer horizontal walls at 



m
=
0


{\displaystyle m=0}

 and 



m
=
M


{\displaystyle m=M}

 which are always present.

The task

Simulate pouring a fluid onto the top surface (



n
=
0


{\displaystyle n=0}

) where the fluid will enter any empty cell it is adjacent to if there is no wall between where it currently is and the cell on the other side of the (missing) wall.

The fluid does not move beyond the horizontal constraints of the grid.

The fluid may move “up” within the confines of the grid of cells. If the fluid reaches a bottom cell that has a missing bottom wall then the fluid can be said to 'drip' out the bottom at that point.

Given 



p


{\displaystyle p}

 repeat the percolation 



t


{\displaystyle t}

 times to estimate the proportion of times that the fluid can percolate to the bottom for any given 



p


{\displaystyle p}

.

Show how the probability of percolating through the random grid changes with 



p


{\displaystyle p}

 going from 



0.0


{\displaystyle 0.0}

 to 



1.0


{\displaystyle 1.0}

 in 



0.1


{\displaystyle 0.1}

 increments and with the number of repetitions to estimate the fraction at any given 



p


{\displaystyle p}

 as 



t
=
100


{\displaystyle t=100}

.

Use an 



M
=
10
,
N
=
10


{\displaystyle M=10,N=10}

 grid of cells for all cases.

Optionally depict fluid successfully percolating through a grid graphically.

Show all output on this page.



",Python,"import random
import sys
 
class Grid:
    def __init__(self, p, x, y):
        self.m = x
        self.n = y
        thresh = int(random.random.RAND_MAX * p)
 
        # Allocate two addition rows to avoid checking bounds.
        # Bottom row is also required by drippage
        self.start = [RBWALL] * self.m
        self.cells = self.start + [0] * (self.m * self.n)
        self.end = self.cells + [0] * self.m
        for i in range(self.m):
            self.start[i] = RBWALL
        for i in range(self.n):
            for j in range(self.m):
                self.end[i * self.m + j] = (random.random() < thresh and BWALL or 0) | (random.random() < thresh and RWALL or 0)
            self.end[i * self.m + self.m - 1] |= RWALL | (random.random() < thresh and BWALL or 0)
        self.end[self.m * self.n] = 0
 
    def percolate(self):
        i = 0
        while i < self.m and not self.fill(self.cells + i):
            i += 1
        return i < self.m
 
    def show(self):
        for j in range(self.m):
            print ""+-"",
        print ""+""
 
        for i in range(self.n + 1):
            print (i == self.n and "" "" or ""|""),
            for j in range(self.m):
                print ((self.cells[i * self.m + j] & FILL) and ""#"" or "" ""),
                print ((self.cells[i * self.m + j] & RWALL) and ""|"" or "" ""),
            print
 
            if i == self.n:
                return
 
            for j in range(self.m):
                print ((self.cells[i * self.m + j] & BWALL) and ""+-"" or ""+ ""),
            print ""+""
 
    def fill(self, p):
        if (p[0] & FILL):
            return False
        p[0] |= FILL
        if p >= self.end:
            return True # success: reached bottom row
 
        return ((not (p[0] & BWALL) and self.fill(p + self.m)) or
                (not (p[0] & RWALL) and self.fill(p + 1)) or
                (not (p[-1] & RWALL) and self.fill(p - 1)) or
                (not (p[-self.m] & BWALL) and self.fill(p - self.m)))
 
FILL   = 1 << 0
RWALL  = 1 << 1       # right wall
BWALL  = 1 << 2       # bottom wall
RBWALL = RWALL | BWALL # right/bottom wall
 
if __name__ == ""__main__"":
    M = 10
    N = 10
    grid = Grid(.5, M, N)
    grid.percolate()
    grid.show()
 
    C = 10000
    print ""\nrunning %dx%d grids %d times for each p:"" % (M, N, C)
    for p in range(1, M):
        cnt = 0
        for i in range(C):
            cnt += Grid(p / float(M), M, N).percolate()
        print ""p = %f: %f"" % (p / float(M), cnt / float(i))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Singleton,Singleton,"A Global Singleton is a class of which only one instance exists within a program.

Any attempt to use non-static members of the class involves performing operations on this one instance.



",Python,">>> class Borg(object):
	__state = {}
	def __init__(self):
		self.__dict__ = self.__state
	# Any other class names/methods
 
 
>>> b1 = Borg()
>>> b2 = Borg()
>>> b1 is b2
False
>>> b1.datum = range(5)
>>> b1.datum
[0, 1, 2, 3, 4]
>>> b2.datum
[0, 1, 2, 3, 4]
>>> b1.datum is b2.datum
True
>>> # For any datum!",Human_written,Python_from_Go
http://rosettacode.org/wiki/Pierpont_primes,Pierpont primes,"A Pierpont prime is a prime number of the form: 2u3v + 1 for some non-negative integers  u  and  v .



A Pierpont prime of the second kind is a prime number of the form: 2u3v - 1 for some non-negative integers  u  and  v .


The term ""Pierpont primes"" is generally understood to mean the first definition, but will be called ""Pierpont primes of the first kind"" on this page to distinguish them.



Task

 Write a routine (function, procedure, whatever) to find Pierpont primes of the first & second kinds.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the first kind.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the second kind
 If your language supports large integers, find and display here, on this page, the 250th Pierpont prime of the first kind and the 250th Pierpont prime of the second kind.


See also

 Wikipedia - Pierpont primes
 OEIS:A005109 - Class 1 -, or Pierpont primes
 OEIS:A005105 - Class 1 +, or Pierpont primes of the second kind

",Python,"import math
import sys
 
def pierpont_primes(n, first):
    primes = []
    if first:
        primes.append(2)
        n -= 1
 
    two_test = 2
    three_test = 3
    two_index = 0
    three_index = 0
    two_smooth = []
 
    one = 1
    m_one = -1
    count = 0
    while count < n:
        min_val = min(two_test, three_test)
        two_smooth.append(min_val)
        if min_val == two_test:
            two_test = 2 * two_smooth[two_index]
            two_index += 1
        if min_val == three_test:
            three_test = 3 * two_smooth[three_index]
            three_index += 1
        test = min_val + (one if first else m_one)
        if is_prime(test):
            primes.append(test)
            count += 1
 
    return primes
 
def is_prime(n):
    if n == 2 or n == 3:
        return True
    if n < 2 or n % 2 == 0:
        return False
    if n < 9:
        return True
    if n % 3 == 0:
        return False
    r = int(math.sqrt(n))
    f = 5
    while f <= r:
        if n % f == 0:
            return False
        if n % (f + 2) == 0:
            return False
        f += 6
    return True
 
def display(message, primes):
    print(message)
    for i in range(1, len(primes) + 1):
        print(f""{primes[i - 1]:10d}  "", end="""")
        if i % 10 == 0:
            print()
 
if __name__ == ""__main__"":
    display(""First 50 Pierpont primes of the first kind:"", pierpont_primes(50, True))
    display(""First 50 Pierpont primes of the second kind:"", pierpont_primes(50, False))
    print(f""250th Pierpont prime of the first kind:     {pierpont_primes(250, True)[249]:,}"")
    print(f""250th Pierpont prime of the second kind:    {pierpont_primes(250, False)[249]:,}"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Primality_by_Wilson%27s_theorem,Primality by Wilson's theorem,"Task

Write a boolean function that tells whether a given integer is prime using Wilson's theorem.

By Wilson's theorem, a number p is prime if and only if p divides (p - 1)! + 1.

Remember that 1 and all non-positive integers are not prime.



See also

 Cut-the-knot: Wilson's theorem.
 Wikipedia: Wilson's theorem

",Python,"def factorial(n):
    product = 1
    if n < 2:
        return 1
    for i in range(n, 0, -1):
        prev = product
        product *= i
        if product < prev:
            print(""Overflowed"")
            return product
    return product
 
def isPrime(n):
    large = factorial(n - 1) + 1
    return (large % n) == 0
 
for n in range(2, 22):
    print(""Is %d prime: %d"" % (n, isPrime(n)))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Non-decimal_radices/Output,Non-decimal radices/Output,"Programming languages often have built-in routines to convert a non-negative integer for printing in different number bases. Such common number bases might include binary, Octal and Hexadecimal.



Task

Print a small range of integers in some different bases, as supported by standard routines of your programming language.



Note

This is distinct from Number base conversion as a user-defined conversion function is not asked for.)

The reverse operation is Common number base parsing.



",Python,"for n in range(34):
  print "" %3o %2d %2X"" % (n, n, n)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Minimum_positive_multiple_in_base_10_using_only_0_and_1,Minimum positive multiple in base 10 using only 0 and 1,"Every positive integer has infinitely many base-10 multiples that only use the digits 0 and 1. The goal of this task is to find and display the minimum multiple that has this property.

This is simple to do, but can be challenging to do efficiently.

To avoid repeating long, unwieldy phrases, the operation ""minimum positive multiple of a positive integer n in base 10 that only uses the digits 0 and 1"" will hereafter be referred to as ""B10"".

Task

Write a routine to find the B10 of a given integer.

E.G.

      n                  B10      n  × multiplier
      1                    1    ( 1  × 1         )
      2                   10    ( 2  × 5         )
      7                 1001    ( 7  x 143       )
      9            111111111    ( 9  x 12345679  )
     10                   10    ( 10 x 1         )

and so on.

Use the routine to find and display here, on this page, the B10 value for:

   1 through 10, 95 through 105, 297, 576, 594, 891, 909, 999

Optionally find B10 for:

   1998, 2079, 2251, 2277

Stretch goal; find B10 for:

   2439, 2997, 4878

There are many opportunities for optimizations, but avoid using magic numbers as much as possible. If you do use magic numbers, explain briefly why and what they do for your implementation.



See also

 OEIS:A004290 Least positive multiple of n that when written in base 10 uses only 0's and 1's.
 How to find Minimum Positive Multiple in base 10 using only 0 and 1",Python,"def getA004290(n):
    if n < 2:
        return 1
    arr = [[0 for _ in range(n)] for _ in range(n)]
    arr[0][0] = 1
    arr[0][1] = 1
    m = 0
    while True:
        m += 1
        if arr[m - 1][-10 ** m % n] == 1:
            break
        arr[m][0] = 1
        for k in range(1, n):
            arr[m][k] = max([arr[m - 1][k], arr[m - 1][k - 10 ** m % n]])
    r = 10 ** m
    k = -r % n
    for j in range((m - 1), 0, -1):
        if arr[j - 1][k] == 0:
            r = r + 10 ** j
            k = (k - 10 ** j) % n   
    if k == 1:
        r += 1
    return r
 
for n in [i for i in range(1, 11)] + \
          [i for i in range(95, 106)] + \
          [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]:
    result = getA004290(n)
    print(f""A004290({n}) = {result} = {n} * {result // n})"")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Create_a_file,Create a file,"In this task, the job is to create a new empty file called ""output.txt"" of size 0 bytes
and an empty directory called ""docs"". This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.
",Python,"import os
for directory in ['/', './']:
  open(directory + 'output.txt', 'w').close()  # create /output.txt, then ./output.txt
  os.mkdir(directory + 'docs')                 # create directory /docs, then ./docs",Human_written,Python_from_C
http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape,Create a file on magnetic tape,"The task is to create a new file called ""TAPE.FILE"" of any size on Magnetic Tape.
",Python,"# version 1.1.0 (Linux)
 
import sys
 
lp0 = open(""/dev/tape"", ""w"")
lp0.write(""Hello, world!"")
lp0.close()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Doubly-linked_list/Traversal,Doubly-linked list/Traversal,"Traverse from the beginning of a doubly-linked list to the end, and from the end to the beginning.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class List:
    def __init__(self, data, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev
 
    def append(self, data):
        if self.next == None:
            self.next = List(data, None, self)
            return self.next
        else:
            return self.next.append(data)
 
# Build the list
tail = head = List(10)
for i in [ 20, 30, 40 ]:
    tail = tail.append(i)
 
# Traverse forwards
node = head
while node != None:
    print(node.data)
    node = node.next
 
# Traverse Backwards
node = tail
while node != None:
    print(node.data)
    node = node.prev",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Associative_array/Creation,Associative array/Creation,"Task

The goal is to create an associative array (also known as a dictionary, map, or hash).



Related tasks:

 Associative arrays/Iteration
 Hash from two arrays


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"hash = dict()  # 'dict' is the dictionary type.
hash = dict(red=""FF0000"", green=""00FF00"", blue=""0000FF"")
hash = { 'key1':1, 'key2':2, }
value = hash[key]",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ""Hello""
if s is not None and len(s) == 5:
    print(""s is 5 characters long"")
else:
    print(""s is not 5 characters long"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Pseudo-random_numbers/Combined_recursive_generator_MRG32k3a,Pseudo-random numbers/Combined recursive generator MRG32k3a,"MRG32k3a Combined recursive generator (pseudo-code)

   /* Constants */
   /* First generator */
   a1 = [0, 1403580, -810728]
   m1 = 2**32 - 209
   /* Second Generator */
   a2 = [527612, 0, -1370589]
   m2 = 2**32 - 22853
    
   d = m1 + 1
   
   class MRG32k3a
       x1 = [0, 0, 0]  /* list of three last values of gen #1 */
       x2 = [0, 0, 0]  /* list of three last values of gen #2 */
       
       method seed(u64 seed_state)
           assert seed_state in range >0 and < d 
           x1 = [seed_state, 0, 0]
           x2 = [seed_state, 0, 0]
       end method
           
       method next_int()
           x1i = (a1[0]*x1[0] + a1[1]*x1[1] + a1[2]*x1[2]) mod m1
           x2i = (a2[0]*x2[0] + a2[1]*x2[1] + a2[2]*x2[2]) mod m2
           x1 = [x1i, x1[0], x1[1]]    /* Keep last three */
           x2 = [x2i, x2[0], x2[1]]    /* Keep last three */
           z = (x1i - x2i) % m1
           answer = (z + 1)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / d
       end method
       
   end class


MRG32k3a Use:
   random_gen = instance MRG32k3a
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 1459213977 */
   print(random_gen.next_int())   /* 2827710106 */
   print(random_gen.next_int())   /* 4245671317 */
   print(random_gen.next_int())   /* 3877608661 */
   print(random_gen.next_int())   /* 2595287583 */
   
       

Task
 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers generated with the seed `1234567`
are as shown above

 Show that for an initial seed of '987654321' the counts of 100_000
repetitions of

   floor(random_gen.next_float() * 5)

Is as follows:

   0: 20002, 1: 20060, 2: 19948, 3: 20059, 4: 19931

 Show your output here, on this page.

",Python,"import math
 
def mod(x, y):
    m = x % y
    if m < 0:
        if y < 0:
            return m - y
        else:
            return m + y
    return m
 
class RNG:
    # first generator
    a1 = [0, 1403580, -810728]
    m1 = (1 << 32) - 209
    x1 = []
    # second generator
    a2 = [527612, 0, -1370589]
    m2 = (1 << 32) - 22853
    x2 = []
    # other
    d = m1 + 1
 
    def seed(self, state):
        self.x1 = [state, 0, 0]
        self.x2 = [state, 0, 0]
 
    def next_int(self):
        x1i = mod(self.a1[0] * self.x1[0] + self.a1[1] * self.x1[1] + self.a1[2] * self.x1[2], self.m1)
        x2i = mod(self.a2[0] * self.x2[0] + self.a2[1] * self.x2[1] + self.a2[2] * self.x2[2], self.m2)
        z = mod(x1i - x2i, self.m1)
 
        # keep the last three values of the first generator
        self.x1 = [x1i, self.x1[0], self.x1[1]]
        # keep the last three values of the second generator
        self.x2 = [x2i, self.x2[0], self.x2[1]]
 
        return z + 1
 
    def next_float(self):
        return 1.0 * self.next_int() / self.d
 
if __name__ == '__main__':
    rng = RNG()
 
    rng.seed(1234567)
    print(rng.next_int())
    print(rng.next_int())
    print(rng.next_int())
    print(rng.next_int())
    print(rng.next_int())
    print()
 
    counts = [0, 0, 0, 0, 0]
    rng.seed(987654321)
    for i in range(100_000):
        value = math.floor(rng.next_float() * 5.0)
        counts[value] += 1
    for i in range(len(counts)):
        print(f'{i}: {counts[i]}')",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sorting_algorithms/Heapsort,Sorting algorithms/Heapsort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Heapsort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Heapsort is an in-place sorting algorithm with worst case and average complexity of   O(n logn).

The basic idea is to turn the array into a binary heap structure, which has the property that it allows efficient retrieval and removal of the maximal element.

We repeatedly ""remove"" the maximal element from the heap, thus building the sorted list from back to front.

A heap sort requires random access, so can only be used on an array-like data structure.

Pseudocode:

function heapSort(a, count) is
   input: an unordered array a of length count
 
   (first place a in max-heap order)
   heapify(a, count)
 
   end := count - 1
   while end > 0 do
      (swap the root(maximum value) of the heap with the
       last element of the heap)
      swap(a[end], a[0])
      (decrement the size of the heap so that the previous
       max value will stay in its proper place)
      end := end - 1
      (put the heap back in max-heap order)
      siftDown(a, 0, end)



function heapify(a,count) is
   (start is assigned the index in a of the last parent node)
   start := (count - 2) / 2
   
   while start ≥ 0 do
      (sift down the node at index start to the proper place
       such that all nodes below the start index are in heap
       order)
      siftDown(a, start, count-1)
      start := start - 1
   (after sifting down the root all nodes/elements are in heap order)
 
function siftDown(a, start, end) is
   (end represents the limit of how far down the heap to sift)
   root := start

   while root * 2 + 1 ≤ end do       (While the root has at least one child)
      child := root * 2 + 1           (root*2+1 points to the left child)
      (If the child has a sibling and the child's value is less than its sibling's...)
      if child + 1 ≤ end and a[child] < a[child + 1] then
         child := child + 1           (... then point to the right child instead)
      if a[root] < a[child] then     (out of max-heap order)
         swap(a[root], a[child])
         root := child                (repeat to continue sifting down the child now)
      else
         return



Write a function to sort a collection of integers using heapsort.



",Python,"def heapSort(a):
	count = len(a)
 
	#first place a in max-heap order
	heapify(a, count)
 
	end = count - 1
	while end > 0:
		#swap the root(maximum value) of the heap with the
		#last element of the heap
		tmp = a[end]
		a[end] = a[0]
		a[0] = tmp
		#put the heap back in max-heap order
		siftDown(a, 0, end - 1)
		#decrement the size of the heap so that the previous
		#max value will stay in its proper place
		end -= 1
 
def heapify(a, count):
	#start is assigned the index in a of the last parent node
	start = (count - 2) / 2 #binary heap
 
	while start >= 0:
		#sift down the node at index start to the proper place
		#such that all nodes below the start index are in heap
		#order
		siftDown(a, start, count - 1)
		start -= 1
	#after sifting down the root all nodes/elements are in heap order
 
def siftDown(a, start, end):
	#end represents the limit of how far down the heap to sift
	root = start
 
	while (root * 2 + 1) <= end:      #While the root has at least one child
		child = root * 2 + 1           #root*2+1 points to the left child
		#if the child has a sibling and the child's value is less than its sibling's...
		if child + 1 <= end and a[child] < a[child + 1]:
			child = child + 1           #... then point to the right child instead
		if a[root] < a[child]:     #out of max-heap order
			tmp = a[root]
			a[root] = a[child]
			a[child] = tmp
			root = child                #repeat to continue sifting down the child now
		else:
			return",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",Python,"import sys
from bitarray import bitarray
 
class SierpinskiTriangle:
    def __init__(self, n):
        if n < 1:
            raise ValueError(""Order must be greater than zero"")
        self.len = 1 << (n+1)
        self.b = bitarray(self.len+1)
        self.b.setall(False)
        self.b[self.len>>1] = True
 
    def display(self):
        for j in range(self.len / 2):
            for i in range(self.b.length()):
                sys.stdout.write(""*"" if self.b[i] else "" "")
            sys.stdout.write(""\n"")
            self.nextGen()
 
    def nextGen(self):
        next = bitarray(self.b.length())
        next.setall(False)
        for i in range(self.b.length()):
            if self.b[i]:
                next[i - 1] = next[i - 1] ^ True
                next[i + 1] = next[i + 1] ^ True
        self.b = next
 
if __name__ == ""__main__"":
    s = SierpinskiTriangle(int(sys.argv[1]))
    s.display()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test,Miller–Rabin primality test,"

 This page uses content from Wikipedia. The original article was at Miller–Rabin primality test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime or not.

The algorithm, as modified by Michael O. Rabin to avoid the generalized Riemann hypothesis, is a probabilistic algorithm.

The pseudocode, from Wikipedia is:

Input: n > 2, an odd integer to be tested for primality;
       k, a parameter that determines the accuracy of the test
Output: composite if n is composite, otherwise probably prime
write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1
LOOP: repeat k times:
   pick a randomly in the range [2, n − 1]
   x ← ad mod n
   if x = 1 or x = n − 1 then do next LOOP
   repeat s − 1 times:
      x ← x2 mod n
      if x = 1 then return composite
      if x = n − 1 then do next LOOP
   return composite
return probably prime

 The nature of the test involves big numbers, so the use of ""big numbers"" libraries (or similar features of the language of your choice) are suggested, but not mandatory.
 Deterministic variants of the test exist and can be implemented as extra (not mandatory to complete the task)

",Python,"import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True  
 
    for i in range(8):#number of trials 
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Kronecker_product,Kronecker product,"Kronecker product

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Implement the   Kronecker product   of two matrices (arbitrary sized) resulting in a block matrix. 




Test cases

Show results for each of the following two samples:




Sample 1 (from Wikipedia):



          ┌   ┐     ┌   ┐     ┌           ┐
          │1 2│     │0 5│     │ 0  5  0 10│
          │3 4│  x  │6 7│  =  │ 6  7 12 14│
	  └   ┘     └   ┘     │ 0 15  0 20│
	                      │18 21 24 28│
                              └           ┘ 

Sample 2:

          ┌     ┐     ┌       ┐     ┌                       ┐       
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
          │1 1 1│  x  │1 0 0 1│  =  │0 0 0 0 1 0 0 1 0 0 0 0│
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
	  └     ┘     └       ┘     │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │1 0 0 1 1 0 0 1 1 0 0 1│
                                    │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    │0 0 0 0 1 0 0 1 0 0 0 0│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    └                       ┘



See implementations and results below in JavaScript and PARI/GP languages.



Related task

  Kronecker product based fractals. 

",Python,"#!/usr/bin/env python3
 
# Sample 1
a1 = [[1, 2], [3, 4]]
b1 = [[0, 5], [6, 7]]
 
# Sample 2
a2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
b2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]
 
def kronecker(matrix1, matrix2):
    final_list = []
    sub_list = []
 
    count = len(matrix2)
 
    for elem1 in matrix1:
        counter = 0
        check = 0
        while check < count:
            for num1 in elem1:
                for num2 in matrix2[counter]:
                    sub_list.append(num1 * num2)
            counter += 1
            final_list.append(sub_list)
            sub_list = []
            check +=1
 
    return final_list
 
# Result 1
result1 = kronecker(a1, b1)
for elem in result1:
    print(elem)
 
print("""")
 
# Result 2
result2 = kronecker(a2, b2)
for elem in result2:
    print(elem)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Set,Set,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A   set  is a collection of elements, without duplicates and without order.



Task

Show each of these set operations:

 Set creation
 Test m ∈ S -- ""m is an element in set S""
 A ∪ B -- union; a set of all elements either in set A or in set B.
 A ∩ B -- intersection; a set of all elements in both set A and set B.
 A ∖ B -- difference; a set of all elements in set A, except those in set B.
 A ⊆ B -- subset; true if every element in set A is also in set B.
 A = B -- equality; true if every element of set A is in set B and vice versa.


As an option, show some other set operations.

(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.)

As another option, show how to modify a mutable set.



One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,">>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}
>>> s1 | s2 # Union
{1, 2, 3, 4, 5, 6}
>>> s1 & s2 # Intersection
{3, 4}
>>> s1 - s2 # Difference
{1, 2}
>>> s1 < s1 # True subset
False
>>> {3, 1} < s1 # True subset
True
>>> s1 <= s1 # Subset
True
>>> {3, 1} <= s1 # Subset
True
>>> {3, 2, 4, 1} == s1 # Equality
True
>>> s1 == s2 # Equality
False
>>> 2 in s1 # Membership
True
>>> 10 not in s1 # Non-membership
True
>>> {1, 2, 3, 4, 5} > s1 # True superset
True
>>> {1, 2, 3, 4} > s1 # True superset
False
>>> {1, 2, 3, 4} >= s1 # Superset
True
>>> s1 ^ s2 # Symmetric difference
{1, 2, 5, 6}
>>> len(s1) # Cardinality
4
>>> s1.add(99) # Mutability
>>> s1
{99, 1, 2, 3, 4}
>>> s1.discard(99) # Mutability
>>> s1
{1, 2, 3, 4}
>>> s1 |= s2 # Mutability
>>> s1
{1, 2, 3, 4, 5, 6}
>>> s1 -= s2 # Mutability
>>> s1
{1, 2}
>>> s1 ^= s2 # Mutability
>>> s1
{1, 2, 3, 4, 5, 6}
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Four_is_magic,Four is magic,"Task

Write a subroutine, function, whatever it may be called in your language, that takes an integer number and returns an English text sequence starting with the English cardinal representation of that integer, the word 'is' and then the English cardinal representation of the count of characters that made up the first word, followed by a comma.

Continue the sequence by using the previous count word as the first word of the next phrase, append 'is' and the cardinal count of the letters in that word.

Continue until you reach four. Since four has four characters, finish by adding the words 'four is magic' and a period. All integers will eventually wind up at four.

For instance, suppose your are given the integer 3. Convert 3 to Three, add  is , then the cardinal character count of three, or five, with a comma to separate if from the next phrase. Continue the sequence five is four, (five has four letters), and finally, four is magic.

     Three is five, five is four, four is magic.

For reference, here are outputs for 0 through 9.

     Zero is four, four is magic.
     One is three, three is five, five is four, four is magic.
     Two is three, three is five, five is four, four is magic.
     Three is five, five is four, four is magic.
     Four is magic.
     Five is four, four is magic.
     Six is three, three is five, five is four, four is magic.
     Seven is five, five is four, four is magic.
     Eight is five, five is four, four is magic.
     Nine is four, four is magic.



Some task guidelines

 You may assume the input will only contain integer numbers.
 Cardinal numbers between 20 and 100 may use either hyphens or spaces as word separators but they must use a word separator. (23 is twenty three or twenty-three not twentythree.)
 Cardinal number conversions should follow the  English short scale. (billion is 1e9, trillion is 1e12, etc.)
 Cardinal numbers should not include commas. (20140 is twenty thousand one hundred forty not twenty thousand, one hundred forty.)
 When converted to a string, 100 should be one hundred, not a hundred or hundred, 1000 should be one thousand, not a thousand or thousand.
 When converted to a string, there should be no and in the cardinal string. 130 should be one hundred thirty not one hundred and thirty.
 When counting characters, count all of the characters in the cardinal number including spaces and hyphens. One hundred fifty-one should be 21 not 18.
 The output should follow the format ""N is K, K is M, M is ... four is magic."" (unless the input is 4, in which case the output should simply be ""four is magic."")
 The output can either be the return value from the function, or be displayed from within the function.
 You are encouraged, though not mandated to use proper sentence capitalization.
 You may optionally support negative numbers. -7 is negative seven.
 Show the output here for a small representative sample of values, at least 5 but no more than 25. You are free to choose which which numbers to use for output demonstration.


You can choose to use a library, (module, external routine, whatever) to do the cardinal conversions as long as the code is easily and freely available to the public.

If you roll your own, make the routine accept at minimum any integer from 0 up to 999999. If you use a pre-made library, support at least up to unsigned 64 bit integers. (or the largest integer supported in your language if it is less.)

Four is magic is a popular code-golf task. This is not code golf. Write legible, idiomatic and well formatted code.




Related tasks

   Four is the number of_letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Summarize and say sequence
   Spelling of ordinal numbers
   De Bruijn sequences

",Python,"import math
 
small = [
    ""zero"", ""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight"",
    ""nine"", ""ten"", ""eleven"", ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
    ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""
]
 
tens = [
    ""twenty"", ""thirty"", ""forty"", ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""
]
 
named_numbers = [
    { ""name"": ""hundred"", ""number"": 100 },
    { ""name"": ""thousand"", ""number"": 1000 },
    { ""name"": ""million"", ""number"": 1000000 },
    { ""name"": ""billion"", ""number"": 1000000000 },
    { ""name"": ""trillion"", ""number"": 1000000000000 },
    { ""name"": ""quadrillion"", ""number"": 1000000000000000 },
    { ""name"": ""quintillion"", ""number"": 1000000000000000000 }
]
 
def get_named_number(n):
    for i in range(len(named_numbers) - 1):
        if n < named_numbers[i + 1][""number""]:
            return named_numbers[i]
    return named_numbers[-1]
 
def cardinal(n):
    if n < 20:
        return small[n]
    elif n < 100:
        result = tens[n//10 - 2]
        if n % 10!= 0:
            result += ""-"" + small[n % 10]
        return result
    else:
        num = get_named_number(n)
        p = num[""number""]
        result = cardinal(n//p)
        result += "" "" + num[""name""]
        if n % p!= 0:
            result += "" "" + cardinal(n % p)
        return result
 
def magic(n):
    result = """"
    for i in range(100):
        text = cardinal(n)
        if i == 0:
            text = text[0].upper() + text[1:]
        result += text
        if n == 4:
            result += "" is magic.""
            break
        text_len = len(text)
        result += "" is ""
        result += cardinal(text_len)
        result += "", ""
        n = text_len
    return result
 
def test_magic(n):
    print(magic(n))
 
test_magic(5)
test_magic(13)
test_magic(78)
test_magic(797)
test_magic(2739)
test_magic(4000)
test_magic(7893)
test_magic(93497412)
test_magic(2673497412)
test_magic(10344658531277200972)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Euler%27s_identity,Euler's identity,"

 This page uses content from Wikipedia. The original article was at Euler's_identity. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, Euler's identity is the equality:

               ei
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 + 1 = 0

where

   e is Euler's number, the base of natural logarithms,
   i is the imaginary unit, which satisfies i2 = −1, and
   
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 is pi, the ratio of the circumference of a circle to its diameter.

Euler's identity is often cited as an example of deep mathematical beauty. Three of the basic arithmetic operations occur exactly once each: addition, multiplication, and exponentiation. The identity also links five fundamental mathematical constants:

   The number 0.
   The number 1.
   The number 
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 (
  
    
      
        π
      
    
    {\displaystyle \pi }
  
 = 3.14159+),
   The number e (e = 2.71828+), which occurs widely in mathematical analysis.
   The number i, the imaginary unit of the complex numbers.

Task
Show in your language that Euler's identity is true. As much as possible and practical, mimic the Euler's identity equation.

Most languages are limited to IEEE 754 floating point calculations so will have some error in the calculation.

If that is the case, or there is some other limitation, show
that ei



π


{\displaystyle \pi }

 + 1 is approximately equal to zero and
show the amount of error in the calculation.

If your language is capable of symbolic calculations, show
that ei



π


{\displaystyle \pi }

 + 1 is exactly equal to zero for bonus kudos points.



",Python,">>> import math
>>> math.e ** (math.pi * 1j) + 1
1.2246467991473532e-16j",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",Python,"# Version 1.2.40
 
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
def d2pt(n, d):
    x = 0
    y = 0
    t = d
    s = 1
    while s < n:
        rx = 1 & (t / 2)
        ry = 1 & (t ^ rx)
        p = Point(x, y)
        rot(s, p, rx, ry)
        x = p.x + s * rx
        y = p.y + s * ry
        t /= 4
        s *= 2
    return Point(x, y)
 
def rot(n, p, rx, ry):
    if ry == 0:
        if rx == 1:
            p.x = n - 1 - p.x
            p.y = n - 1 - p.y
        t  = p.x
        p.x = p.y
        p.y = t
 
def main():
    n = 32
    k = 3
    pts = [['' for i in range(n * k)] for j in range(n * k)]
    prev = Point(0, 0)
    pts[0][0] = '.'
    for d in range(1, n * n):
        curr = d2pt(n, d)
        cx = curr.x * k
        cy = curr.y * k
        px = prev.x * k
        py = prev.y * k
        pts[cx][cy] = '.'
        if cx == px :
            if py < cy:
                for y in range(py + 1, cy): pts[cx][y] = '|'
            else:
                for y in range(cy + 1, py): pts[cx][y] = '|'
        else:
            if px < cx:
                for x in range(px + 1, cx): pts[x][cy] = '_'
            else:
                for x in range(cx + 1, px): pts[x][cy] = '_'
        prev = curr
    for i in range(n * k):
        for j in range(n * k): print(pts[j][i], end='')
        print()
 
main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/String_comparison,String comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Demonstrate how to compare two strings from within the language and how to achieve a lexical comparison.



The task should demonstrate:

 Comparing two strings for exact equality
 Comparing two strings for inequality (i.e., the inverse of exact equality)
 Comparing two strings to see if one is lexically ordered before than the other
 Comparing two strings to see if one is lexically ordered after than the other
 How to achieve both case sensitive comparisons and case insensitive comparisons within the language
 How the language handles comparison of numeric strings if these are not treated lexically
 Demonstrate any other kinds of string comparisons that the language provides, particularly as it relates to your type system. 


For example, you might demonstrate the difference between generic/polymorphic comparison and coercive/allomorphic comparison if your language supports such a distinction.



Here ""generic/polymorphic"" comparison means that the function or operator you're using doesn't always do string comparison, but bends the actual semantics of the comparison depending on the types one or both arguments; with such an operator, you achieve string comparison only if the arguments are sufficiently string-like in type or appearance.

In contrast, a ""coercive/allomorphic"" comparison function or operator has fixed string-comparison semantics regardless of the argument type;   instead of the operator bending, it's the arguments that are forced to bend instead and behave like strings if they can,   and the operator simply fails if the arguments cannot be viewed somehow as strings.   A language may have one or both of these kinds of operators;   see the Raku entry for an example of a language with both kinds of operators.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def compare(a, b):
    print(""\n%r is of type %r and %r is of type %r""
          % (a, type(a), b, type(b)))
    if a <  b:      print('%r is strictly less than  %r' % (a, b))
    if a <= b:      print('%r is less than or equal to %r' % (a, b))
    if a >  b:      print('%r is strictly greater than  %r' % (a, b))
    if a >= b:      print('%r is greater than or equal to %r' % (a, b))
    if a == b:      print('%r is equal to %r' % (a, b))
    if a != b:      print('%r is not equal to %r' % (a, b))
    if a is b:      print('%r has object identity with %r' % (a, b))
    if a is not b:  print('%r has negated object identity with %r' % (a, b))
 
compare('YUP', 'YUP')
compare('BALL', 'BELL')
compare('24', '123')
compare(24, 123)
compare(5.0, 5)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Smarandache_prime-digital_sequence,Smarandache prime-digital sequence,"The Smarandache prime-digital sequence (SPDS for brevity) is the sequence of primes whose digits are themselves prime.

For example 257 is an element of this sequence because it is prime itself and its digits: 2, 5 and 7 are also prime.

Task
 Show the first 25 SPDS primes.
 Show the hundredth SPDS prime.


See also

 OEIS A019546: Primes whose digits are primes.
 https://www.scribd.com/document/214851583/On-the-Smarandache-prime-digital-subsequence-sequences

",Python,"def divisors(n):
    divs = [1]
    for ii in range(2, int(n ** 0.5) + 3):
        if n % ii == 0:
            divs.append(ii)
            divs.append(int(n / ii))
    divs.append(n)
    return list(set(divs))
 
 
def is_prime(n):
    return len(divisors(n)) == 2
 
 
def digit_check(n):
    if len(str(n))<2:
        return True
    else:
        for digit in str(n):
            if not is_prime(int(digit)):
                return False
        return True
 
 
def sequence(max_n=None):
    ii = 0
    n = 0
    while True:
        ii += 1
        if is_prime(ii):
            if max_n is not None:
                if n>max_n:
                    break
            if digit_check(ii):
                n += 1
                yield ii
 
 
if __name__ == '__main__':
    generator = sequence(100)
    for index, item in zip(range(1, 16), generator):
        print(index, item)
    for index, item in zip(range(16, 100), generator):
        pass
    print(100, generator.__next__())",Human_written,Python_from_C++
"http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications","Abundant, deficient and perfect number classifications","These define three classifications of positive integers based on their   proper divisors.

Let   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.

   if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
   if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
   if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).



Example

6   has proper divisors of   1,   2,   and   3.

1 + 2 + 3 = 6,   so   6   is classed as a perfect number.



Task

Calculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.

Show the results here.



Related tasks

   Aliquot sequence classifications.   (The whole series from which this task is a subset.)
   Proper divisors
   Amicable pairs

",Python,"from collections import Counter

def proper_divisors(n):
    return [i for i in range(1, n//2+1) if n % i == 0]

res = Counter(1 < sum(proper_divisors(n)) < n for n in range(1, 20001))
print(""Deficient: {}   Perfect: {}   Abundant: {}"".format(*res.values()))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Call_an_object_method,Call an object method,"In object-oriented programming a method is a function associated with a particular class or object. In most forms of object oriented implementations methods can be static, associated with the class itself; or instance, associated with an instance of a class.

Show how to call a static or class method, and an instance method of a class.
",Python,"class MyClass(object):
	@classmethod
	def myClassMethod(self, x):
		pass
	@staticmethod
	def myStaticMethod(x):
		pass
	def myMethod(self, x):
		return 42 + x
 
myInstance = MyClass()
 
# Instance method
myInstance.myMethod(someParameter)
# A method can also be retrieved as an attribute from the class, and then explicitly called on an instance:
MyClass.myMethod(myInstance, someParameter)
 
 
# Class or static methods
MyClass.myClassMethod(someParameter)
MyClass.myStaticMethod(someParameter)
# You can also call class or static methods on an instance, which will simply call it on the instance's class
myInstance.myClassMethod(someParameter)
myInstance.myStaticMethod(someParameter)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sorting_algorithms/Patience_sort,Sorting algorithms/Patience sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of numbers (of any convenient size) into ascending order using   Patience sorting.



Related task

   Longest increasing subsequence

",Python,"from functools import total_ordering
from bisect import bisect_left
from heapq import merge
 
@total_ordering
class Pile(list):
    def __lt__(self, other): return self[-1] < other[-1]
    def __eq__(self, other): return self[-1] == other[-1]
 
def patience_sort(n):
    piles = []
    # sort into piles
    for x in n:
        new_pile = Pile([x])
        i = bisect_left(piles, new_pile)
        if i != len(piles):
            piles[i].append(x)
        else:
            piles.append(new_pile)
 
    # use a heap-based merge to merge piles efficiently
    n[:] = merge(*[reversed(pile) for pile in piles])
 
if __name__ == ""__main__"":
    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]
    patience_sort(a)
    print a",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Concurrent_computing,Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",Python,"import asyncio
 
 
async def print_(string: str) -> None:
    print(string)
 
 
async def main():
    strings = ['Enjoy', 'Rosetta', 'Code']
    coroutines = map(print_, strings)
    await asyncio.gather(*coroutines)
 
 
if __name__ == '__main__':
    asyncio.run(main())",Human_written,Python_from_C#
http://rosettacode.org/wiki/Arithmetic/Complex,Arithmetic/Complex,"A   complex number   is a number which can be written as:




a
+
b
×
i


{\displaystyle a+b\times i}


(sometimes shown as:




b
+
a
×
i


{\displaystyle b+a\times i}


where   



a


{\displaystyle a}

   and   



b


{\displaystyle b}

  are real numbers,   and   



i


{\displaystyle i}

   is   √ -1 



Typically, complex numbers are represented as a pair of real numbers called the ""imaginary part"" and ""real part"",   where the imaginary part is the number to be multiplied by 



i


{\displaystyle i}

.



Task

 Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) 
 Print the results for each operation tested.
 Optional: Show complex conjugation.


By definition, the   complex conjugate   of




a
+
b
i


{\displaystyle a+bi}


is




a
−
b
i


{\displaystyle a-bi}





Some languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.



",Python,">>> z1 = 1.5 + 3j
>>> z2 = 1.5 + 1.5j
>>> z1 + z2
(3+4.5j)
>>> z1 - z2
1.5j
>>> z1 * z2
(-2.25+6.75j)
>>> z1 / z2
(1.5+0.5j)
>>> - z1
(-1.5-3j)
>>> z1.conjugate()
(1.5-3j)
>>> abs(z1)
3.3541019662496847
>>> z1 ** z2
(-1.1024829553277784-0.38306415117199333j)
>>> z1.real
1.5
>>> z1.imag
3.0
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/History_variables,History variables,"Storing the history of objects in a program is a common task. 
Maintaining the history of an object in a program has traditionally required programmers either to write specific code for handling the historical data, or to use a library which supports history logging.

History variables are variables in a programming language which store not only their current value, but also the values they have contained in the past. Some existing languages do provide support for history variables. However these languages typically have many limits and restrictions on use of history variables.
 

[http://www.bod.com/index.php?id=3435&objk_id=148050 ""History Variables:
The Semantics, Formal Correctness, and Implementation of History Variables
in an Imperative Programming Language"" by Mallon and Takaoka]

Concept also discussed on LtU and Patents.com.

Task
 
Demonstrate History variable support:

 enable history variable support (if needed) 
 define a history variable
 assign three values
 non-destructively display the history
 recall the three values. 

For extra points, if the language of choice does not support history variables,
demonstrate how this might be implemented.



",Python,"# version 1.1.4
 
class HistoryVariable(initialValue):
    def __init__(self, initialValue):
        self.history = []
        self.currentValue = initialValue
 
    @property
    def currentValue(self):
        return self.history[-1]
 
    @currentValue.setter
    def currentValue(self, value):
        self.history.append(value)
 
    def showHistory(self):
        print(""The variable's history, oldest values first, is:"")
        for item in self.history:
            print(item)
 
if __name__ == ""__main__"":
    v = HistoryVariable(1)
    v.currentValue = 2
    v.currentValue = 3
    v.showHistory()
    print(""\nCurrentvalue is {}"".format(v.currentValue))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Cuban_primes,Cuban primes,"The name   cuban   has nothing to do with   Cuba  (the country),   but has to do with the
fact that cubes   (3rd powers)   play a role in its definition.



Some definitions of cuban primes

   primes which are the difference of two consecutive cubes.
   primes of the form:   (n+1)3 - n3.
   primes of the form:   n3 - (n-1)3.
   primes   p   such that   n2(p+n)   is a cube for some   n>0.
   primes   p   such that   4p = 1 + 3n2.


Cuban primes were named in 1923 by Allan Joseph Champneys Cunningham.



Task requirements

   show the first   200   cuban primes   (in a multi─line horizontal format).
   show the   100,000th   cuban prime.
   show all cuban primes with commas   (if appropriate).
   show all output here.


Note that   cuban prime   isn't capitalized   (as it doesn't refer to the nation of Cuba).



Also see

   Wikipedia entry:     cuban prime.
   MathWorld entry:   cuban prime.
   The OEIS entry:     A002407.     The   100,000th   cuban prime can be verified in the   2nd   example   on this OEIS web page.

",Python,"import datetime
import math
 
primes = [ 3, 5 ]
 
cutOff = 200
 
bigUn =  100_000
chunks = 50
little = bigUn / chunks
 
tn = "" cuban prime""
print (""The first {:,}{}s:"".format(cutOff, tn))
 
c = 0
showEach = True
u = 0
v = 1
st = datetime.datetime.now()
 
for i in range(1, int(math.pow(2,20))):
	found = False
	u += 6
	v += u
	mx = int(math.sqrt(v))
 
	for item in primes:
		if (item > mx):
			break
		if (v % item == 0):
			found = True
			break
 
	if (found == 0):
		c += 1
		if (showEach):
			z = primes[-1]
			while (z <= v - 2):
				z += 2
 
				fnd = False
				for item in primes:
					if (item > mx):
						break
					if (z % item == 0):
						fnd = True
						break
 
				if (not fnd):
					primes.append(z)
 
			primes.append(v)
			print(""{:>11,}"".format(v), end='')
 
			if (c % 10 == 0):
				print("""");
			if (c == cutOff):
				showEach = False
				print (""Progress to the {:,}th {}:"".format(bigUn, tn), end='')
		if (c % little == 0):
			print('.', end='')
		if (c == bigUn):
			break
 
print("""");
print (""The {:,}th{} is {:,}"".format(c, tn, v))
print(""Computation time was {} seconds"".format((datetime.datetime.now() - st).seconds))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player),Guess the number/With feedback (player),"Task

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.
The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.



Related tasks

   Guess the number/With Feedback
   Bulls and cows/Player

",Python,"inclusive_range = mn, mx = (1, 10)
 
print('''\
Think of a number between %i and %i and wait for me to guess it.
On every guess of mine you should state whether the guess was
too high, too low, or equal to your number by typing h, l, or =
''' % inclusive_range)
 
i = 0
while True:
    i += 1
    guess = (mn+mx)//2
    txt = input(""Guess %2i is: %2i. The score for which is (h,l,=): ""
                % (i, guess)).strip().lower()[0]
    if txt not in 'hl=':
        print(""  I don't understand your input of '%s' ?"" % txt)
        continue
    if txt == 'h':
        mx = guess-1
    if txt == 'l':
        mn = guess+1
    if txt == '=':
        print(""  Ye-Haw!!"")
        break
    if (mn > mx) or (mn < inclusive_range[0]) or (mx > inclusive_range[1]):
        print(""Please check your scoring as I cannot find the value"")
        break
 
print(""\nThanks for keeping score."")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/RIPEMD-160,RIPEMD-160,"RIPEMD-160 is another hash function; it computes a 160-bit message digest.

There is a RIPEMD-160 home page, with test vectors and pseudocode for RIPEMD-160.
For padding the message, RIPEMD-160 acts like MD4 (RFC 1320).

Find the RIPEMD-160 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code”.
You may either call an RIPEMD-160 library, or implement RIPEMD-160 in your language.
",Python,"Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> import hashlib
>>> h = hashlib.new('ripemd160')
>>> h.update(b""Rosetta Code"")
>>> h.hexdigest()
'b3be159860842cebaa7174c8fff0aa9e50a5199f'
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Repeat,Repeat,"Task

Write a procedure which accepts as arguments another procedure and a positive integer.

The latter procedure is executed a number of times equal to the accepted integer.



",Python,"#!/usr/bin/python
def repeat(f,n):
  for i in range(n):
    f();
 
def procedure():
  print(""Example"");
 
repeat(procedure,3); #prints ""Example"" (without quotes) three times, separated by newlines.",Human_written,Python_from_C
http://rosettacode.org/wiki/Sexy_primes,Sexy primes,"

 This page uses content from Wikipedia. The original article was at Sexy_prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, sexy primes are prime numbers that differ from each other by six.

For example, the numbers 5 and 11 are both sexy primes, because 11 minus 6 is 5.

The term ""sexy prime"" is a pun stemming from the Latin word for six: sex.



Sexy prime pairs: Sexy prime pairs are groups of two primes that differ by 6. e.g. (5 11), (7 13), (11 17)

See sequences: OEIS:A023201 and OEIS:A046117

Sexy prime triplets: Sexy prime triplets are groups of three primes where each differs from the next by 6. e.g. (5 11 17), (7 13 19), (17 23 29)

See sequences: OEIS:A046118, OEIS:A046119 and OEIS:A046120

Sexy prime quadruplets: Sexy prime quadruplets are groups of four primes where each differs from the next by 6. e.g. (5 11 17 23), (11 17 23 29)

See sequences: OEIS:A023271, OEIS:A046122, OEIS:A046123 and OEIS:A046124

Sexy prime quintuplets: Sexy prime quintuplets are groups of five primes with a common difference of 6. One of the terms must be divisible by 5, because 5 and 6 are relatively prime. Thus, the only possible sexy prime quintuplet is (5 11 17 23 29)

Task

For each of pairs, triplets, quadruplets and quintuplets, Find and display the count of each group type of sexy primes less than one million thirty-five (1,000,035).
Display at most the last 5, less than one million thirty-five, of each sexy prime group type.
Find and display the count of the unsexy primes less than one million thirty-five.
Find and display the last 10 unsexy primes less than one million thirty-five.
Note that 1000033 SHOULD NOT be counted in the pair count. It is sexy, but not in a pair within the limit. However, it also SHOULD NOT be listed in the unsexy primes since it is sexy. 

",Python,"from array import array
from collections import deque
from prime_sieve import prime_sieve

def main():
    max = 1000035
    max_group_size = 5
    diff = 6
    array_size = max + diff
    max_groups = 5
    max_unsexy = 10

    # Use Sieve of Eratosthenes to find prime numbers up to max
    sieve = prime_sieve(array_size)

    group_count = [0] * max_group_size
    groups = [deque(maxlen=max_groups) for _ in range(max_group_size)]
    unsexy_count = 0
    unsexy_primes = deque(maxlen=max_unsexy)
    group = []

    for p in range(2, max):
        if not sieve.is_prime(p):
            continue
        if not sieve.is_prime(p + diff) and (p - diff < 2 or not sieve.is_prime(p - diff)):
            # if p + diff and p - diff aren't prime then p can't be sexy
            unsexy_count += 1
            unsexy_primes.append(p)
        else:
            # find the groups of sexy primes that begin with p
            group.clear()
            group.append(p)
            for group_size in range(1, max_group_size):
                next_p = p + group_size * diff
                if next_p >= max or not sieve.is_prime(next_p):
                    break
                group.append(next_p)
                group_count[group_size] += 1
                groups[group_size].append(group[:])

    for size in range(1, max_group_size):
        print(""number of groups of size {} is {}"".format(size + 1, group_count[size]))
        print(""last {} groups of size {}:"".format(len(groups[size]), size + 1), end="""")
        for group in groups[size]:
            print("" ("", end="""")
            for i in range(len(group)):
                if i > 0:
                    print("" "", end="""")
                print(group[i], end="""")
            print("")"", end="""")
        print(""\n"")

    print(""number of unsexy primes is {}"".format(unsexy_count))
    print(""last {} unsexy primes:"".format(len(unsexy_primes)), end="""")
    for prime in unsexy_primes:
        print("" {}"".format(prime), end="""")
    print()

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Last_Friday_of_each_month,Last Friday of each month,"Task

Write a program or a script that returns the date of the last Fridays of each month of a given year.

The year may be given through any simple input method in your language (command line, std in, etc).



Example of an expected output:

./last_fridays 2012
2012-01-27
2012-02-24
2012-03-30
2012-04-27
2012-05-25
2012-06-29
2012-07-27
2012-08-31
2012-09-28
2012-10-26
2012-11-30
2012-12-28



Related tasks
 Five weekends
 Day of the week
 Find the last Sunday of each month

",Python,"def last_friday_of_month(year, month):
    i = 0
    while True:
        last_day = datetime.date(year, month, i)
        if last_day.weekday() == 4:
            return last_day.strftime(""%A, %B %d, %Y"")
        i -= 1

def print_last_fridays_of_month(year):
    for month in range(1, 13):
        print(last_friday_of_month(year, month))

if __name__ == ""__main__"":
    year = int(sys.argv[1])
    print_last_fridays_of_month(year)",Ai_generated,Python_from_JavaScript
"http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem","Sailors, coconuts and a monkey problem","Five sailors are shipwrecked on an island and collect a large pile of coconuts during the day.

That night the first sailor wakes up and decides to take his first share early so tries to divide the pile of coconuts equally into five piles but finds that there is one coconut left over, so he tosses it to a monkey and then hides ""his"" one of the five equally sized piles of coconuts and pushes the other four piles together to form a single visible pile of coconuts again and goes to bed.

To cut a long story short, each of the sailors in turn gets up once during the night and performs the same actions of dividing the coconut pile into five, finding that one coconut is left over and giving that single remainder coconut to the monkey.

In the morning (after the surreptitious and separate action of each of the five sailors during the night), the remaining coconuts are divided into five equal piles for each of the sailors, whereupon it is found that the pile of coconuts divides equally amongst the sailors with no remainder. (Nothing for the monkey in the morning.)



The task

 Calculate the minimum possible size of the initial pile of coconuts collected during the first day.
 Use a method that assumes an answer is possible, and then applies the constraints of the tale to see if it is correct. (I.e. no applying some formula that generates the correct answer without integer divisions and remainders and tests on remainders; but constraint solvers are allowed.)
 Calculate the size of the initial pile of coconuts if six sailors were marooned and went through a similar process (but split into six piles instead of five of course).
 Show your answers here.


Extra credit (optional)

 Give some indication of the number of coconuts each sailor hides during the night.


Note

 Of course the tale is told in a world where the collection of any amount of coconuts in a day and multiple divisions of the pile, etc can occur in time fitting the story line, so as not to affect the mathematics.
 The tale is also told in a version where the monkey also gets a coconut in the morning. This is not that tale!


C.f

 Monkeys and Coconuts - Numberphile (Video) Analytical solution.
 A002021: Pile of coconuts problem The On-Line Encyclopedia of Integer Sequences. (Although some of its references may use the alternate form of the tale).

",Python,"coconuts = 11
for ns in range(2, 10):
    hidden = [0] * ns
    coconuts = (coconuts // ns) * ns + 1
    while True:
        nc = coconuts
        for s in range(1, ns + 1):
            if nc % ns == 1:
                hidden[s - 1] = nc // ns
                nc -= hidden[s - 1] + 1
                if s == ns and nc % ns == 0:
                    print(ns, ""sailors require a minimum of"", coconuts, ""coconuts"")
                    for t in range(1, ns + 1):
                        print(""\tSailor"", t, ""hides"", hidden[t - 1])
                    print(""\tThe monkey gets"", ns)
                    print(""\tFinally, each sailor takes"", nc // ns, ""\b\n"")
                    break
            else:
                break
        coconuts += ns",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Set,Set,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A   set  is a collection of elements, without duplicates and without order.



Task

Show each of these set operations:

 Set creation
 Test m ∈ S -- ""m is an element in set S""
 A ∪ B -- union; a set of all elements either in set A or in set B.
 A ∩ B -- intersection; a set of all elements in both set A and set B.
 A ∖ B -- difference; a set of all elements in set A, except those in set B.
 A ⊆ B -- subset; true if every element in set A is also in set B.
 A = B -- equality; true if every element of set A is in set B and vice versa.


As an option, show some other set operations.

(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.)

As another option, show how to modify a mutable set.



One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,">>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}
>>> s1 | s2 # Union
{1, 2, 3, 4, 5, 6}
>>> s1 & s2 # Intersection
{3, 4}
>>> s1 - s2 # Difference
{1, 2}
>>> s1 < s1 # True subset
False
>>> {3, 1} < s1 # True subset
True
>>> s1 <= s1 # Subset
True
>>> {3, 1} <= s1 # Subset
True
>>> {3, 2, 4, 1} == s1 # Equality
True
>>> s1 == s2 # Equality
False
>>> 2 in s1 # Membership
True
>>> 10 not in s1 # Non-membership
True
>>> {1, 2, 3, 4, 5} > s1 # True superset
True
>>> {1, 2, 3, 4} > s1 # True superset
False
>>> {1, 2, 3, 4} >= s1 # Superset
True
>>> s1 ^ s2 # Symmetric difference
{1, 2, 5, 6}
>>> len(s1) # Cardinality
4
>>> s1.add(99) # Mutability
>>> s1
{99, 1, 2, 3, 4}
>>> s1.discard(99) # Mutability
>>> s1
{1, 2, 3, 4}
>>> s1 |= s2 # Mutability
>>> s1
{1, 2, 3, 4, 5, 6}
>>> s1 -= s2 # Mutability
>>> s1
{1, 2}
>>> s1 ^= s2 # Mutability
>>> s1
{1, 2, 3, 4, 5, 6}
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sort_an_integer_array,Sort an integer array,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of integers in ascending numerical order.



Use a sorting facility provided by the language/library if possible.



",Python,"nums = [2,4,3,1,2]
nums.sort()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Compare_a_list_of_strings,Compare a list of strings,"Task

Given a   list   of arbitrarily many strings, show how to:

   test if they are all lexically equal
   test if every string is lexically less than the one after it (i.e. whether the list is in strict ascending order)


Each of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.

If the input list has less than two elements, the tests should always return true.

There is no need to provide a complete program and output.

Assume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.

Try to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.

If you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Raku for a solution that gets away with simply using a built-in language feature. 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"all(a == nexta for a, nexta in zip(strings, strings[1:])) # All equal
all(a < nexta for a, nexta in zip(strings, strings[1:])) # Strictly ascending
 
len(set(strings)) == 1  # Concise all equal
sorted(strings, reverse=True) == strings  # Concise (but not particularly efficient) ascending",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Euler_method,Euler method,"Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.   It is an explicit method for solving initial value problems (IVPs), as described in the wikipedia page.

The ODE has to be provided in the following form:

 






d
y
(
t
)


d
t



=
f
(
t
,
y
(
t
)
)


{\displaystyle {\frac {dy(t)}{dt}}=f(t,y(t))}


with an initial value

 



y
(

t

0


)
=

y

0




{\displaystyle y(t_{0})=y_{0}}


To get a numeric solution, we replace the derivative on the   LHS   with a finite difference approximation:

 






d
y
(
t
)


d
t



≈



y
(
t
+
h
)
−
y
(
t
)

h




{\displaystyle {\frac {dy(t)}{dt}}\approx {\frac {y(t+h)-y(t)}{h}}}


then solve for 



y
(
t
+
h
)


{\displaystyle y(t+h)}

:

 



y
(
t
+
h
)
≈
y
(
t
)
+
h




d
y
(
t
)


d
t





{\displaystyle y(t+h)\approx y(t)+h\,{\frac {dy(t)}{dt}}}


which is the same as

 



y
(
t
+
h
)
≈
y
(
t
)
+
h

f
(
t
,
y
(
t
)
)


{\displaystyle y(t+h)\approx y(t)+h\,f(t,y(t))}


The iterative solution rule is then:

 




y

n
+
1


=

y

n


+
h

f
(

t

n


,

y

n


)


{\displaystyle y_{n+1}=y_{n}+h\,f(t_{n},y_{n})}


where   



h


{\displaystyle h}

   is the step size, the most relevant parameter for accuracy of the solution.   A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.


Example: Newton's Cooling Law

Newton's cooling law describes how an object of initial temperature   



T
(

t

0


)
=

T

0




{\displaystyle T(t_{0})=T_{0}}

   cools down in an environment of temperature   




T

R




{\displaystyle T_{R}}

:

 






d
T
(
t
)


d
t



=
−
k

Δ
T


{\displaystyle {\frac {dT(t)}{dt}}=-k\,\Delta T}


or

 






d
T
(
t
)


d
t



=
−
k

(
T
(
t
)
−

T

R


)


{\displaystyle {\frac {dT(t)}{dt}}=-k\,(T(t)-T_{R})}




It says that the cooling rate   






d
T
(
t
)


d
t





{\displaystyle {\frac {dT(t)}{dt}}}

   of the object is proportional to the current temperature difference   



Δ
T
=
(
T
(
t
)
−

T

R


)


{\displaystyle \Delta T=(T(t)-T_{R})}

   to the surrounding environment.

The analytical solution, which we will compare to the numerical approximation, is

 



T
(
t
)
=

T

R


+
(

T

0


−

T

R


)


e

−
k
t




{\displaystyle T(t)=T_{R}+(T_{0}-T_{R})\;e^{-kt}}




Task

Implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:

   2 s
   5 s       and 
   10 s 
and to compare with the analytical solution.



Initial values

   initial temperature   




T

0




{\displaystyle T_{0}}

   shall be   100 °C
   room temperature   




T

R




{\displaystyle T_{R}}

   shall be   20 °C
   cooling constant     



k


{\displaystyle k}

     shall be   0.07 
   time interval to calculate shall be from   0 s   ──►   100 s


A reference solution (Common Lisp) can be seen below.   We see that bigger step sizes lead to reduced approximation accuracy.

",Python,"# Function that takes differential-equation, initial condition,
# ending x, and step size as parameters
def eulersMethod(f, x1, y1, x2, h):
	# Header
	print(""\tX\t|\tY\t"")
	print(""------------------------------------"")
 
	# Initial Variables
	x=x1
	y=y1
 
	# While we're not done yet
	# Both sides of the OR let you do Euler's Method backwards
	while ((x<x2 and x1<x2) or (x>x2 and x1>x2)):
		# Print what we have
		print(""\t"" + str(x) + ""\t|\t"" + str(y))
 
		# Calculate the next values
		y += h*f(x, y)
		x += h
 
	return y
 
def cooling(x, y):
	return -0.07 * (y-20)
 
eulersMethod(cooling, 0, 100, 100, 10)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",Python,"import os
 
for file in sorted(os.listdir()):
	print(file)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation,Horner's rule for polynomial evaluation,"A fast scheme for evaluating a polynomial such as:

 



−
19
+
7
x
−
4

x

2


+
6

x

3





{\displaystyle -19+7x-4x^{2}+6x^{3}\,}


when

 



x
=
3



{\displaystyle x=3\;}

.
is to arrange the computation as follows:

 



(
(
(
(
0
)
x
+
6
)
x
+
(
−
4
)
)
x
+
7
)
x
+
(
−
19
)



{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\;}


And compute the result from the innermost brackets outwards as in this pseudocode:

coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.
Cf. Formal power series
",Python,">>> def horner(coeffs, x):
	acc = 0
	for c in reversed(coeffs):
		acc = acc * x + c
	return acc
 
>>> horner( (-19, 7, -4, 6), 3)
128",Human_written,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"class BogoSort:
	def __init__(self):
		self.arr=[4,5,6,0,7,8,9,1,2,3]
		self.shuffle=1
		self.bogo()
	def bogo(self):
		while not self.isSorted():
			self.shuffle+=1
			self.shuffleArr()
		print(""This took ""+str(self.shuffle)+"" shuffles."")
	def shuffleArr(self):
		i=len(self.arr)-1
		while i>0:
			self.swap(i,int(random.random()*i))
			i-=1
	def swap(self,i,j):
		temp=self.arr[i]
		self.arr[i]=self.arr[j]
		self.arr[j]=temp
	def isSorted(self):
		for i in range(1,len(self.arr)):
			if self.arr[i]<self.arr[i-1]:
				return False
		return True
	def display1D(self):
		for i in range(len(self.arr)):
			print(self.arr[i],end="" "")
		print()
 
if __name__==""__main__"":
	now=BogoSort()
	print(""Unsorted: "",end="""")
	now.display1D()
	print(""Sorted: "",end="""")
	now.display1D()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Variable-length_quantity,Variable-length quantity,"Implement some operations on variable-length quantities, at least including conversions from a normal number in the language to the binary representation of the variable-length quantity for that number, and vice versa. Any variants are acceptable.



Task

With above operations,

convert these two numbers 0x200000 (2097152 in decimal) and 0x1fffff (2097151 in decimal) into sequences of octets (an eight-bit byte); 
display these sequences of octets;
convert these sequences of octets back to numbers, and check that they are equal to original numbers.

",Python,"import struct
 
buf = struct.pack('<d', 3.141592653589793)
print(buf.hex())",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Set,Set,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A   set  is a collection of elements, without duplicates and without order.



Task

Show each of these set operations:

 Set creation
 Test m ∈ S -- ""m is an element in set S""
 A ∪ B -- union; a set of all elements either in set A or in set B.
 A ∩ B -- intersection; a set of all elements in both set A and set B.
 A ∖ B -- difference; a set of all elements in set A, except those in set B.
 A ⊆ B -- subset; true if every element in set A is also in set B.
 A = B -- equality; true if every element of set A is in set B and vice versa.


As an option, show some other set operations.

(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.)

As another option, show how to modify a mutable set.



One might implement a set using an associative array (with set elements as array keys and some dummy value as the values).

One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators).

The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,">>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}
>>> s1 | s2 # Union
{1, 2, 3, 4, 5, 6}
>>> s1 & s2 # Intersection
{3, 4}
>>> s1 - s2 # Difference
{1, 2}
>>> s1 < s1 # True subset
False
>>> {3, 1} < s1 # True subset
True
>>> s1 <= s1 # Subset
True
>>> {3, 1} <= s1 # Subset
True
>>> {3, 2, 4, 1} == s1 # Equality
True
>>> s1 == s2 # Equality
False
>>> 2 in s1 # Membership
True
>>> 10 not in s1 # Non-membership
True
>>> {1, 2, 3, 4, 5} > s1 # True superset
True
>>> {1, 2, 3, 4} > s1 # True superset
False
>>> {1, 2, 3, 4} >= s1 # Superset
True
>>> s1 ^ s2 # Symmetric difference
{1, 2, 5, 6}
>>> len(s1) # Cardinality
4
>>> s1.add(99) # Mutability
>>> s1
{99, 1, 2, 3, 4}
>>> s1.discard(99) # Mutability
>>> s1
{1, 2, 3, 4}
>>> s1 |= s2 # Mutability
>>> s1
{1, 2, 3, 4, 5, 6}
>>> s1 -= s2 # Mutability
>>> s1
{1, 2}
>>> s1 ^= s2 # Mutability
>>> s1
{1, 2, 3, 4, 5, 6}
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Levenshtein_distance/Alignment,Levenshtein distance/Alignment,"The Levenshtein distance algorithm returns the number of atomic operations (insertion, deletion or edition) that must be performed on a string in order to obtain an other one, but it does not say anything about the actual operations used or their order.

An alignment is a notation used to describe the operations used to turn a string into an other. At some point in the strings, the minus character ('-') is placed in order to signify that a character must be added at this very place. For instance, an alignment between the words 'place' and 'palace' is:

P-LACE
PALACE



Task

Write a function that shows the alignment of two strings for the corresponding levenshtein distance.

As an example, use the words ""rosettacode"" and ""raisethysword"".

You can either implement an algorithm, or use a dedicated library (thus showing us how it is named in your language).



",Python,import edit_distance,Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",Python,">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]
>>> def stoogesort(L, i=0, j=None):
	if j is None:
		j = len(L) - 1
	if L[j] < L[i]:
		L[i], L[j] = L[j], L[i]
	if j - i > 1:
		t = (j - i + 1) // 3
		stoogesort(L, i  , j-t)
		stoogesort(L, i+t, j  )
		stoogesort(L, i  , j-t)
	return L
 
>>> stoogesort(data)
[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Date_format,Date format,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Task

Display the   current date   in the formats of:

   2007-11-23     and 
   Friday, November 23, 2007

",Python,"import datetime
today = datetime.date.today()
# The first requested format is a method of datetime objects:
today.isoformat()
# For full flexibility, use the strftime formatting codes from the link above:
today.strftime(""%A, %B %d, %Y"")
# This mechanism is integrated into the general string formatting system.
# You can do this with positional arguments referenced by number
""The date is {0:%A, %B %d, %Y}"".format(d)
# Or keyword arguments referenced by name
""The date is {date:%A, %B %d, %Y}"".format(date=d)
# Since Python 3.6, f-strings allow the value to be inserted inline
f""The date is {d:%A, %B %d, %Y}""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Inheritance/Multiple,Inheritance/Multiple,"Multiple inheritance allows to specify that one  class is a subclass of several other classes.

Some languages allow multiple inheritance for arbitrary classes,   others restrict it to interfaces,   some don't allow it at all.



Task

Write two classes (or interfaces) Camera and MobilePhone,   then write a class CameraPhone which is both a Camera and a MobilePhone.

There is no need to implement any functions for those classes.



",Python,"# Example of composition of anonymous structs
from typing import NamedTuple
 
# Two ordinary structs
class camera(NamedTuple):
    optics: str
    sensor: str
 
class mobilePhone(NamedTuple):
    sim: str
    firmware: str
 
# Fields are anonymous because only the type is listed.
# Also called an embedded field.
class cameraPhone(NamedTuple):
    camera: camera
    mobilePhone: mobilePhone
 
def main():
    # Struct literals must still reflect the nested structure
    htc = cameraPhone(camera(optics=""zoom""), mobilePhone(firmware=""3.14""))
 
    # But fields of anonymous structs can be referenced without qualification.
    # This provides some effect of the two parent structs being merged, as
    # with multiple inheritance in some other programming languages.
    htc.sim = ""XYZ""
    print(htc)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",Python,"#!/usr/bin/env python
# canonicalize a CIDR block specification:
# make sure none of the host bits are set
 
import sys
from socket import inet_aton, inet_ntoa
from struct import pack, unpack
 
args = sys.argv[1:]
if len(args) == 0:
    args = sys.stdin.readlines()
 
for cidr in args:
   # IP in dotted-decimal / bits in network part
   dotted, size_str = cidr.split('/')
   size = int(size_str)
 
   numeric = unpack('!I', inet_aton(dotted))[0]  # IP as an integer
   binary = f'{numeric:#034b}'                   # then as a padded binary string
   prefix = binary[:size + 2]                    # just the network part
                                                 #   (34 and +2 are to account
                                                 #    for leading '0b')
 
   canon_binary = prefix + '0' * (32 - size)     # replace host part with all zeroes
   canon_numeric = int(canon_binary, 2)          # convert back to integer
   canon_dotted = inet_ntoa(pack('!I',
                            (canon_numeric)))    # and then to dotted-decimal
   print(f'{canon_dotted}/{size}')               # output result",Human_written,Python_from_Go
http://rosettacode.org/wiki/Rock-paper-scissors,Rock-paper-scissors,"Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive   AI   (artificial intelligence)   player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

   Rock beats scissors
   Scissors beat paper
   Paper beats rock


If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.



Extra credit

Support additional choices   additional weapons.



",Python,"from random import choice
 
rules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}
previous = ['rock', 'paper', 'scissors']
 
while True:
    human = input('\nchoose your weapon: ')
    computer = rules[choice(previous)]  # choose the weapon which beats a randomly chosen weapon from ""previous""
 
    if human in ('quit', 'exit'): break
 
    elif human in rules:
        previous.append(human)
        print('the computer played', computer, end='; ')
 
        if rules[computer] == human:  # if what beats the computer's choice is the human's choice...
            print('yay you win!')
        elif rules[human] == computer:  # if what beats the human's choice is the computer's choice...
            print('the computer beat you... :(')
        else: print(""it's a tie!"")
 
    else: print(""that's not a valid choice"")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Rename_a_file,Rename a file,"Task

Rename:

   a file called     input.txt     into     output.txt     and 
   a directory called     docs     into     mydocs.


This should be done twice:  
once ""here"", i.e. in the current working directory and once in the filesystem root.

It can be assumed that the user has the rights to do so.

(In unix-type systems, only the user root would have
sufficient permissions in the filesystem root.)



",Python,"import os
 
err = ""File move error""
os.rename(""input.txt"", ""output.txt"")
os.rename(""docs"", ""mydocs"")
os.rename(""/input.txt"", ""/output.txt"")
os.rename(""/docs"", ""/mydocs"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Multiplication_tables,Multiplication tables,"Task

Produce a formatted   12×12   multiplication table of the kind memorized by rote when in primary (or elementary) school.



Only print the top half triangle of products.



",Python,">>> size = 12
>>> width = len(str(size**2))
>>> for row in range(-1,size+1):
	if row==0:
		print(""─""*width + ""┼""+""─""*((width+1)*size-1))
	else:
		print("""".join(""%*s%1s"" % ((width,) + ((""x"",""│"")      if row==-1 and col==0
					              else (row,""│"") if row>0   and col==0
					              else (col,"""")  if row==-1
					              else ("""","""")   if row>col
					              else (row*col,"""")))
			       for col in range(size+1)))
 
 
  x│  1   2   3   4   5   6   7   8   9  10  11  12 
───┼───────────────────────────────────────────────
  1│  1   2   3   4   5   6   7   8   9  10  11  12 
  2│      4   6   8  10  12  14  16  18  20  22  24 
  3│          9  12  15  18  21  24  27  30  33  36 
  4│             16  20  24  28  32  36  40  44  48 
  5│                 25  30  35  40  45  50  55  60 
  6│                     36  42  48  54  60  66  72 
  7│                         49  56  63  70  77  84 
  8│                             64  72  80  88  96 
  9│                                 81  90  99 108 
 10│                                    100 110 120 
 11│                                        121 132 
 12│                                            144 
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Python,"class Animal:
    def __init__(self):
        #functions go here...",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Substitution_cipher,Substitution cipher,"Substitution Cipher Implementation - File Encryption/Decryption



Task

Encrypt a input/source file by replacing every upper/lower case alphabets of the source file with another predetermined upper/lower case alphabets or symbols and save it into another output/encrypted file and then again convert that output/encrypted file into original/decrypted file.

This type of Encryption/Decryption scheme is often called a Substitution Cipher.



Related tasks

 Caesar cipher
 Rot-13
 Vigenère Cipher/Cryptanalysis


See also

 Wikipedia: Substitution cipher

",Python,"from string import printable
import random
 
EXAMPLE_KEY = ''.join(sorted(printable, key=lambda _:random.random()))
 
def encode(plaintext, key):
    return ''.join(key[printable.index(char)] for char in plaintext)
 
def decode(plaintext, key):
    return ''.join(printable[key.index(char)] for char in plaintext)
 
original = ""A simple example.""
encoded = encode(original, EXAMPLE_KEY)
decoded = decode(encoded, EXAMPLE_KEY)
print(""""""The original is: {}
Encoding it with the key: {}
Gives: {}
Decoding it by the same key gives: {}"""""".format(
    original, EXAMPLE_KEY, encoded, decoded))",Human_written,Python_from_C
http://rosettacode.org/wiki/Ordered_partitions,Ordered partitions,"In this task we want to find the ordered partitions into fixed-size blocks.

This task is related to Combinations in that it has to do with discrete mathematics and moreover a helper function to compute combinations is (probably) needed to solve this task.





p
a
r
t
i
t
i
o
n
s
(



a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n


)


{\displaystyle partitions({\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n})}

 should generate all distributions of the elements in 



{
1
,
.
.
.
,

Σ

i
=
1


n





a
r
g



i


}


{\displaystyle \{1,...,\Sigma _{i=1}^{n}{\mathit {arg}}_{i}\}}

 into 



n


{\displaystyle n}

 blocks of respective size 






a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

.

Example 1: 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

 would create:

{({1, 2}, {}, {3, 4}), 
 ({1, 3}, {}, {2, 4}), 
 ({1, 4}, {}, {2, 3}), 
 ({2, 3}, {}, {1, 4}), 
 ({2, 4}, {}, {1, 3}), 
 ({3, 4}, {}, {1, 2})}

Example 2: 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 would create:

{({1}, {2}, {3}), 
 ({1}, {3}, {2}), 
 ({2}, {1}, {3}), 
 ({2}, {3}, {1}), 
 ({3}, {1}, {2}), 
 ({3}, {2}, {1})}

Note that the number of elements in the list is








(






a
r
g



1


+



a
r
g



2


+
.
.
.
+



a
r
g



n






a
r
g



1




)



⋅



(






a
r
g



2


+



a
r
g



3


+
.
.
.
+



a
r
g



n






a
r
g



2




)



⋅
…
⋅



(





a
r
g



n





a
r
g



n




)





{\displaystyle {{\mathit {arg}}_{1}+{\mathit {arg}}_{2}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{1}}\cdot {{\mathit {arg}}_{2}+{\mathit {arg}}_{3}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{2}}\cdot \ldots \cdot {{\mathit {arg}}_{n} \choose {\mathit {arg}}_{n}}}


(see the definition of the binomial coefficient if you are not familiar with this notation) and the number of elements remains the same regardless of how the argument is permuted
(i.e. the multinomial coefficient).

Also, 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 creates the permutations of 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 and thus there would be 



3
!
=
6


{\displaystyle 3!=6}

 elements in the list.

Note: Do not use functions that are not in the standard library of the programming language you use. Your file should be written so that it can be executed on the command line and by default outputs the result of 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

. If the programming language does not support polyvariadic functions pass a list as an argument.

Notation

Here are some explanatory remarks on the notation used in the task description:





{
1
,
…
,
n
}


{\displaystyle \{1,\ldots ,n\}}

 denotes the set of consecutive numbers from 



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

, e.g. 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 if 



n
=
3


{\displaystyle n=3}

.





Σ


{\displaystyle \Sigma }

 is the mathematical notation for summation, e.g. 




Σ

i
=
1


3


i
=
6


{\displaystyle \Sigma _{i=1}^{3}i=6}

 (see also [1]).








a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

 are the arguments — natural numbers — that the sought function receives.



",Python,"from itertools import combinations
 
def partitions(*args):
    def p(s, *args):
        if not args: return [[]]
        res = []
        for c in combinations(s, args[0]):
            s0 = [x for x in s if x not in c]
            for r in p(s0, *args[1:]):
                res.append([c] + r)
        return res
    s = range(sum(args))
    return p(s, *args)
 
print partitions(2, 0, 2)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",Python,"def r2cf(n1,n2):
  while n2:
    n1, (t1, n2) = n2, divmod(n1, n2)
    yield t1
 
print(list(r2cf(1,2)))    # => [0, 2]
print(list(r2cf(3,1)))    # => [3]
print(list(r2cf(23,8)))    # => [2, 1, 7]
print(list(r2cf(13,11)))    # => [1, 5, 2]
print(list(r2cf(22,7)))    # => [3, 7]
print(list(r2cf(14142,10000)))    # => [1, 2, 2, 2, 2, 2, 1, 1, 29]
print(list(r2cf(141421,100000)))    # => [1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]
print(list(r2cf(1414214,1000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]
print(list(r2cf(14142136,10000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Catalan_numbers,Catalan numbers,"Catalan numbers

You are encouraged to solve this task according to the task description, using any language you may know.


Catalan numbers are a sequence of numbers which can be defined directly:






C

n


=


1

n
+
1






(



2
n

n


)



=



(
2
n
)
!


(
n
+
1
)
!

n
!





 for 

n
≥
0.


{\displaystyle C_{n}={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\,n!}}\qquad {\mbox{ for }}n\geq 0.}


Or recursively:






C

0


=
1


and



C

n
+
1


=

∑

i
=
0


n



C

i




C

n
−
i




for 

n
≥
0
;


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0;}


Or alternatively (also recursive):






C

0


=
1


and



C

n


=



2
(
2
n
−
1
)


n
+
1




C

n
−
1


,


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n}={\frac {2(2n-1)}{n+1}}C_{n-1},}




Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization   is not required, but may be worth the effort when using the second method above.



Related tasks

Catalan numbers/Pascal's triangle
Evaluate binomial coefficients

",Python,"from functools import lru_cache
 
class Catalan:
    def __init__(self):
        self.m = {0: 1.0}
 
    def __call__(self, n):
        if n not in self.m:
            self.m[n] = self.compute(n)
        return self.m[n]
 
    def compute(self, n):
        raise NotImplementedError
 
class CatalanI(Catalan):
    def compute(self, n):
        return round(self.fact(2 * n) / (self.fact(n + 1) * self.fact(n)))
 
    @lru_cache(maxsize=None)
    def fact(self, n):
        if n in self.facts:
            return self.facts[n]
        f = n * self.fact(n - 1)
        self.facts[n] = f
        return f
 
    facts = {0: 1.0, 1: 1.0, 2: 2.0}
 
class CatalanR1(Catalan):
    def compute(self, n):
        sum = 0.0
        for i in range(n):
            sum += self(i) * self(n - 1 - i)
        return round(sum)
 
class CatalanR2(Catalan):
    def compute(self, n):
        return round(2.0 * (2 * (n - 1) + 1) / (n + 1) * self(n - 1))
 
if __name__ == '__main__':
    c = [CatalanI(), CatalanR1(), CatalanR2()]
    for i in range(16):
        print(' '.join(f'{c[j](i):9d}' for j in range(3)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Python,"try:
    cmp     # Python 2 OK or NameError in Python 3
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              cmp=lambda x,y:cmp(y+x, x+y)))
except NameError:
    # Python 3
    from functools import cmp_to_key
    def cmp(x, y):
        return -1 if x<y else ( 0 if x==y else 1)
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y))))
 
for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:
    print('Numbers: %r\n  Largest integer: %15s' % (numbers, maxnum(numbers)))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Factorions,Factorions,"

Definition

A factorion is a natural number that equals the sum of the factorials of its digits.



Example
 
145   is a factorion in base 10 because:


          1! + 4! + 5!   =   1 + 24 + 120   =   145 





It can be shown (see talk page) that no factorion in base 10 can exceed   1,499,999.



Task

Write a program in your language to demonstrate, by calculating and printing out the factorions, that:

   There are   3   factorions in base   9
   There are   4   factorions in base 10
   There are   5   factorions in base 11 
   There are   2   factorions in base 12     (up to the same upper bound as for base 10)


See also

 Wikipedia article
 OEIS:A014080 - Factorions in base 10
 OEIS:A193163 - Factorions in base n

",Python,"fact = [1] # cache factorials from 0 to 11
for n in range(1, 12):
    fact.append(fact[n-1] * n)
 
for b in range(9, 12+1):
    print(f""The factorions for base {b} are:"")
    for i in range(1, 1500000):
        fact_sum = 0
        j = i
        while j > 0:
            d = j % b
            fact_sum += fact[d]
            j = j//b
        if fact_sum == i:
            print(i, end="" "")
    print(""\n"")",Human_written,Python_from_C
http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",Python,">>> import time
>>> time.asctime(time.gmtime(0))
'Thu Jan  1 00:00:00 1970'
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Square_but_not_cube,Square but not cube,"Task

Show the first   30   positive integers which are squares but not cubes of such integers.

Optionally, show also the first   3   positive integers which are both squares and cubes,   and mark them as such.



",Python,"# nonCubeSquares :: Int -> [(Int, Bool)]
def nonCubeSquares(n):
    upto = enumFromTo(1)
    ns = upto(n)
    setCubes = set(x ** 3 for x in ns)
    ms = upto(n + len(set(x * x for x in ns).intersection(
        setCubes
    )))
    return list(tuple([x * x, x in setCubes]) for x in ms)
 
 
# squareListing :: [(Int, Bool)] -> [String]
def squareListing(xs):
    justifyIdx = justifyRight(len(str(1 + len(xs))))(' ')
    justifySqr = justifyRight(1 + len(str(xs[-1][0])))(' ')
    return list(
        '(' + str(1 + idx) + '^2 = ' + str(n) +
        ' = ' + str(round(n ** (1 / 3))) + '^3)' if bln else (
            justifyIdx(1 + idx) + ' ->' +
            justifySqr(n)
        )
        for idx, (n, bln) in enumerate(xs)
    )
 
 
def main():
    print(
        unlines(
            squareListing(
                nonCubeSquares(30)
            )
        )
    )
 
 
# GENERIC ------------------------------------------------------------------
 
# enumFromTo :: Int -> Int -> [Int]
def enumFromTo(m):
    return lambda n: list(range(m, 1 + n))
 
 
# justifyRight :: Int -> Char -> String -> String
def justifyRight(n):
    return lambda cFiller: lambda a: (
        ((n * cFiller) + str(a))[-n:]
    )
 
 
# unlines :: [String] -> String
def unlines(xs):
    return '\n'.join(xs)
 
 
main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",Python,">>> from operator import mul
>>> def matrixMul(m1, m2):
  return map(
    lambda row:
      map(
        lambda *column:
          sum(map(mul, row, column)),
        *m2),
    m1)
 
>>> def identity(size):
	size = range(size)
	return [[(i==j)*1 for i in size] for j in size]
 
>>> def matrixExp(m, pow):
	assert pow>=0 and int(pow)==pow, ""Only non-negative, integer powers allowed""
	accumulator = identity(len(m))
	for i in range(pow):
		accumulator = matrixMul(accumulator, m)
	return accumulator
 
>>> def printtable(data):
	for row in data:
		print ' '.join('%-5s' % ('%s' % cell) for cell in row)
 
 
>>> m = [[3,2], [2,1]]
>>> for i in range(5):
	print '\n%i:' % i
	printtable( matrixExp(m, i) )
 
 
 
0:
1     0    
0     1    
 
1:
3     2    
2     1    
 
2:
13    8    
8     5    
 
3:
55    34   
34    21   
 
4:
233   144  
144   89   
>>> printtable( matrixExp(m, 10) )
1346269 832040
832040 514229
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Ascending_primes,Ascending primes,"Generate and show all primes with strictly ascending decimal digits.

Aside: Try solving without peeking at existing solutions. I had a weird idea for generating
a prime sieve faster, which needless to say didn't pan out. The solution may be p(r)etty trivial
but generating them quickly is at least mildly interesting.
Tip: filtering all 7,027,260 primes below 123,456,789 probably won't kill you, but there is
at least one significantly better and much faster way, needing a mere 511 odd/prime tests.



See also
 OEIS:A052015 - Primes with distinct digits in ascending order


Related

Primes with digits in nondecreasing order (infinite series allowing duplicate digits, whereas this isn't and doesn't)
Pandigital prime (whereas this is the smallest, with gaps in the used digits being permitted)

",Python,"from sympy import isprime
 
def ascending(x=0):
    for y in range(x*10 + (x%10) + 1, x*10 + 10):
        yield from ascending(y)
        yield(y)
 
print(sorted(x for x in ascending() if isprime(x)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Lucas-Lehmer_test,Lucas-Lehmer test,"Lucas-Lehmer Test:

for 



p


{\displaystyle p}

 an odd prime, the Mersenne number 




2

p


−
1


{\displaystyle 2^{p}-1}

 is prime if and only if 




2

p


−
1


{\displaystyle 2^{p}-1}

 divides 



S
(
p
−
1
)


{\displaystyle S(p-1)}

 where 



S
(
n
+
1
)
=
(
S
(
n
)

)

2


−
2


{\displaystyle S(n+1)=(S(n))^{2}-2}

, and 



S
(
1
)
=
4


{\displaystyle S(1)=4}

.



Task

Calculate all Mersenne primes up to the implementation's
maximum precision, or the 47th Mersenne prime   (whichever comes first).



",Python,"# version 1.0.6
 
import math
 
MAX = 19
 
def isPrime(n):
    if n < 2: return False 
    if n % 2 == 0: return n == 2
    if n % 3 == 0: return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0: return False
        d += 2
        if n % d == 0: return False
        d += 4
    return True
 
def main():
    count = 0
    p = 3   # first odd prime
    s = 4
    m = 2 ** (p - 1) - 1
    while True:
        for i in range(1, p - 1):
            s = (s * s - 2) % m 
        if s == 0:
            count +=1
            print(""M%d "" % p, end="""")
            if count == MAX:
                print()
                return
        # obtain next odd prime
        while True:
            p += 2         
            if isPrime(p): break
 
main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Machine_code,Machine code,"The task requires poking machine code directly into memory and executing it. The machine code is the architecture-specific opcodes which have the simple task of adding two unsigned bytes together and making the result available to the high-level language.

For example, the following assembly language program is given for x86 (32 bit) architectures:

mov EAX, [ESP+4]
add EAX, [ESP+8]
ret
This would translate into the following opcode bytes:

139 68 36 4 3 68 36 8 195
Or in hexadecimal:

8B 44 24 04 03 44 24 08 C3
Task

If different than 32-bit x86, specify the target architecture of the machine code for your example. It may be helpful to also include an assembly version of the machine code for others to reference and understand what is being executed. Then, implement the following in your favorite programming language:

 Poke the necessary opcodes into a memory location.
 Provide a means to pass two values to the machine code.
 Execute the machine code with the following arguments: unsigned-byte argument of value 7; unsigned-byte argument of value 12; The result would be 19.
 Perform any clean up actions that are appropriate for your chosen language (free the pointer or memory allocations, etc.)

",Python,"import ctypes
import os
from ctypes import c_ubyte, c_int
 
code = bytes([0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3])
 
code_size = len(code)
# copy code into an executable buffer
if (os.name == 'posix'):
    import mmap
    executable_map = mmap.mmap(-1, code_size, mmap.MAP_PRIVATE | mmap.MAP_ANON, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)
    # we must keep a reference to executable_map until the call, to avoid freeing the mapped memory
    executable_map.write(code)
    # the mmap object won't tell us the actual address of the mapping, but we can fish it out by allocating
    # some ctypes object over its buffer, then asking the address of that
    func_address = ctypes.addressof(c_ubyte.from_buffer(executable_map))
elif (os.name == 'nt'):
    # the mmap module doesn't support protection flags on Windows, so execute VirtualAlloc instead
    code_buffer = ctypes.create_string_buffer(code)
    PAGE_EXECUTE_READWRITE = 0x40  # Windows constants that would usually come from header files
    MEM_COMMIT = 0x1000
    executable_buffer_address = ctypes.windll.kernel32.VirtualAlloc(0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)
    if (executable_buffer_address == 0):
        print('Warning: Failed to enable code execution, call will likely cause a protection fault.')
        func_address = ctypes.addressof(code_buffer)
    else:
        ctypes.memmove(executable_buffer_address, code_buffer, code_size)
        func_address = executable_buffer_address
else:
    # for other platforms, we just hope DEP isn't enabled
    code_buffer = ctypes.create_string_buffer(code)
    func_address = ctypes.addressof(code_buffer)
 
prototype = ctypes.CFUNCTYPE(c_int, c_ubyte, c_ubyte) # build a function prototype from return type and argument types
func = prototype(func_address)                        # build an actual function from the prototype by specifying the address
res = func(7,12)
print(res)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Happy_numbers,Happy numbers,"From Wikipedia, the free encyclopedia:

 A happy number is defined by the following process:
 Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals   1   (where it will stay),   or it loops endlessly in a cycle which does not include   1.   


 Those numbers for which this process end in   1   are       happy   numbers,   
 while   those numbers   that   do   not   end in   1   are   unhappy   numbers. 


Task

Find and print the first   8   happy numbers.

Display an example of your output here on this page.



See also

   The OEIS entry:   The     happy numbers:   A007770
   The OEIS entry:   The unhappy numbers;   A031177

",Python,"def ishappy(n):
    cache = []
    sum = 0
    while n!= 1:
        if n in cache:
            return False
        cache.append(n)
        while n!= 0:
            digit = n % 10
            sum += digit * digit
            n = n // 10
        n = sum
        sum = 0
    return True
 
num = 1
happynums = []
 
while len(happynums) < 8:
    if ishappy(num):
        happynums.append(num)
    num += 1
print(""First 8 happy numbers : "" + "","".join(str(happynums)))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Poker_hand_analyser,Poker hand analyser,"Task

Create a program to parse a single five card poker hand and rank it according to this list of poker hands.



A poker hand is specified as a space separated list of five playing cards.

Each input card has two characters indicating face and suit.



Example

2d       (two of diamonds).


Faces are:    a, 2, 3, 4, 5, 6, 7, 8, 9, 10, j, q, k

Suits are:    h (hearts),   d (diamonds),   c (clubs),   and   s (spades),   or

alternatively,   the unicode card-suit characters:     ♥ ♦ ♣ ♠ 



Duplicate cards are illegal.

The program should analyze a single hand and produce one of the following outputs:

 straight-flush
 four-of-a-kind
 full-house
 flush
 straight
 three-of-a-kind
 two-pair
 one-pair
 high-card
 invalid



Examples

   2♥ 2♦ 2♣ k♣ q♦:   three-of-a-kind
   2♥ 5♥ 7♦ 8♣ 9♠:   high-card
   a♥ 2♦ 3♣ 4♣ 5♦:   straight
   2♥ 3♥ 2♦ 3♣ 3♦:   full-house
   2♥ 7♥ 2♦ 3♣ 3♦:   two-pair
   2♥ 7♥ 7♦ 7♣ 7♠:   four-of-a-kind 
   10♥ j♥ q♥ k♥ a♥:  straight-flush
   4♥ 4♠ k♠ 5♦ 10♠:  one-pair
   q♣ 10♣ 7♣ 6♣ q♣:  invalid

The programs output for the above examples should be displayed here on this page.



Extra credit

 use the playing card characters introduced with Unicode 6.0 (U+1F0A1 - U+1F0DE).
 allow two jokers
 use the symbol   joker
 duplicates would be allowed (for jokers only)
 five-of-a-kind would then be the highest hand


More extra credit examples

   joker  2♦  2♠  k♠  q♦:     three-of-a-kind
   joker  5♥  7♦  8♠  9♦:     straight
   joker  2♦  3♠  4♠  5♠:     straight
   joker  3♥  2♦  3♠  3♦:     four-of-a-kind
   joker  7♥  2♦  3♠  3♦:     three-of-a-kind
   joker  7♥  7♦  7♠  7♣:     five-of-a-kind
   joker  j♥  q♥  k♥  A♥:     straight-flush
   joker  4♣  k♣  5♦ 10♠:     one-pair
   joker  k♣  7♣  6♣  4♣:     flush
   joker  2♦  joker  4♠  5♠:  straight
   joker  Q♦  joker  A♠ 10♠:  straight
   joker  Q♦  joker  A♦ 10♦:  straight-flush
   joker  2♦  2♠  joker  q♦:  four-of-a-kind



Related tasks

 Playing cards
 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Go Fish

",Python,"from collections import namedtuple
 
class Card(namedtuple('Card', 'face, suit')):
    def __repr__(self):
        return ''.join(self)
 
 
suit = '♥ ♦ ♣ ♠'.split()
# ordered strings of faces
faces   = '2 3 4 5 6 7 8 9 10 j q k a'
lowaces = 'a 2 3 4 5 6 7 8 9 10 j q k'
# faces as lists
face   = faces.split()
lowace = lowaces.split()
 
 
def straightflush(hand):
    f,fs = ( (lowace, lowaces) if any(card.face == '2' for card in hand)
             else (face, faces) )
    ordered = sorted(hand, key=lambda card: (f.index(card.face), card.suit))
    first, rest = ordered[0], ordered[1:]
    if ( all(card.suit == first.suit for card in rest) and
         ' '.join(card.face for card in ordered) in fs ):
        return 'straight-flush', ordered[-1].face
    return False
 
def fourofakind(hand):
    allfaces = [f for f,s in hand]
    allftypes = set(allfaces)
    if len(allftypes) != 2:
        return False
    for f in allftypes:
        if allfaces.count(f) == 4:
            allftypes.remove(f)
            return 'four-of-a-kind', [f, allftypes.pop()]
    else:
        return False
 
def fullhouse(hand):
    allfaces = [f for f,s in hand]
    allftypes = set(allfaces)
    if len(allftypes) != 2:
        return False
    for f in allftypes:
        if allfaces.count(f) == 3:
            allftypes.remove(f)
            return 'full-house', [f, allftypes.pop()]
    else:
        return False
 
def flush(hand):
    allstypes = {s for f, s in hand}
    if len(allstypes) == 1:
        allfaces = [f for f,s in hand]
        return 'flush', sorted(allfaces,
                               key=lambda f: face.index(f),
                               reverse=True)
    return False
 
def straight(hand):
    f,fs = ( (lowace, lowaces) if any(card.face == '2' for card in hand)
             else (face, faces) )
    ordered = sorted(hand, key=lambda card: (f.index(card.face), card.suit))
    first, rest = ordered[0], ordered[1:]
    if ' '.join(card.face for card in ordered) in fs:
        return 'straight', ordered[-1].face
    return False
 
def threeofakind(hand):
    allfaces = [f for f,s in hand]
    allftypes = set(allfaces)
    if len(allftypes) <= 2:
        return False
    for f in allftypes:
        if allfaces.count(f) == 3:
            allftypes.remove(f)
            return ('three-of-a-kind', [f] +
                     sorted(allftypes,
                            key=lambda f: face.index(f),
                            reverse=True))
    else:
        return False
 
def twopair(hand):
    allfaces = [f for f,s in hand]
    allftypes = set(allfaces)
    pairs = [f for f in allftypes if allfaces.count(f) == 2]
    if len(pairs) != 2:
        return False
    p0, p1 = pairs
    other = [(allftypes - set(pairs)).pop()]
    return 'two-pair', pairs + other if face.index(p0) > face.index(p1) else pairs[::-1] + other
 
def onepair(hand):
    allfaces = [f for f,s in hand]
    allftypes = set(allfaces)
    pairs = [f for f in allftypes if allfaces.count(f) == 2]
    if len(pairs) != 1:
        return False
    allftypes.remove(pairs[0])
    return 'one-pair', pairs + sorted(allftypes,
                                      key=lambda f: face.index(f),
                                      reverse=True)
 
def highcard(hand):
    allfaces = [f for f,s in hand]
    return 'high-card', sorted(allfaces,
                               key=lambda f: face.index(f),
                               reverse=True)
 
handrankorder =  (straightflush, fourofakind, fullhouse,
                  flush, straight, threeofakind,
                  twopair, onepair, highcard)
 
def rank(cards):
    hand = handy(cards)
    for ranker in handrankorder:
        rank = ranker(hand)
        if rank:
            break
    assert rank, ""Invalid: Failed to rank cards: %r"" % cards
    return rank
 
def handy(cards='2♥ 2♦ 2♣ k♣ q♦'):
    hand = []
    for card in cards.split():
        f, s = card[:-1], card[-1]
        assert f in face, ""Invalid: Don't understand card face %r"" % f
        assert s in suit, ""Invalid: Don't understand card suit %r"" % s
        hand.append(Card(f, s))
    assert len(hand) == 5, ""Invalid: Must be 5 cards in a hand, not %i"" % len(hand)
    assert len(set(hand)) == 5, ""Invalid: All cards in the hand must be unique %r"" % cards
    return hand
 
 
if __name__ == '__main__':
    hands = [""2♥ 2♦ 2♣ k♣ q♦"",
     ""2♥ 5♥ 7♦ 8♣ 9♠"",
     ""a♥ 2♦ 3♣ 4♣ 5♦"",
     ""2♥ 3♥ 2♦ 3♣ 3♦"",
     ""2♥ 7♥ 2♦ 3♣ 3♦"",
     ""2♥ 7♥ 7♦ 7♣ 7♠"",
     ""10♥ j♥ q♥ k♥ a♥""] + [
     ""4♥ 4♠ k♠ 5♦ 10♠"",
     ""q♣ 10♣ 7♣ 6♣ 4♣"",
     ]
    print(""%-18s %-15s %s"" % (""HAND"", ""CATEGORY"", ""TIE-BREAKER""))
    for cards in hands:
        r = rank(cards)
        print(""%-18r %-15s %r"" % (cards, r[0], r[1]))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Permutations/Derangements,Permutations/Derangements,"A derangement is a permutation of the order of distinct items in which no item appears in its original place.

For example, the only two derangements of the three items (0, 1, 2) are (1, 2, 0), and (2, 0, 1).

The number of derangements of n distinct items is known as the subfactorial of n, sometimes written as !n.
There are various ways to calculate !n.



Task

 Create a named function/method/subroutine/... to generate derangements of the integers 0..n-1, (or 1..n if you prefer). 
 Generate and show all the derangements of 4 integers using the above routine.
 Create a function that calculates the subfactorial of n, !n.
 Print and show a table of the counted number of derangements of n vs. the calculated !n for n from 0..9 inclusive.


Optional stretch goal

   Calculate    !20 


Related tasks

   Anagrams/Deranged anagrams
   Best shuffle
   Left_factorials



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import permutations
from math import factorial
from sys import argv
 
def deranged(depth, len, d, show):
    count = 0
    for i in range(len - 1, depth - 1, -1):
        if i == d[depth]:
            continue
        d[i], d[depth] = d[depth], d[i]
        count += deranged(depth + 1, len, d, show)
        d[i], d[depth] = d[depth], d[i]
    return count
 
def gen_n(n, show):
    a = list(range(n))
    return deranged(0, n, a, show)
 
def sub_fact(n):
    if n < 2:
        return 1 - n
    return (sub_fact(n - 1) + sub_fact(n - 2)) * (n - 1)
 
if __name__ == '__main__':
    print(""Deranged Four:"")
    gen_n(4, 1)
    print(""\nCompare list vs calc:"")
    for i in range(10):
        print(""%d:\t%d\t%d"" % (i, gen_n(i, 0), sub_fact(i)))
    print(""\nfurther calc:"")
    for i in range(10, 21):
        print(""%d: %d"" % (i, sub_fact(i)))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Text_processing/Max_licenses_in_use,Text processing/Max licenses in use,"A company currently pays a fixed sum for the use of a particular licensed software package.   In determining if it has a good deal it decides to calculate its maximum use of the software from its license management log file.

Assume the software's licensing daemon faithfully records a checkout event when a copy of the software starts and a checkin event when the software finishes to its log file.

An example of checkout and checkin events are:

 License OUT @ 2008/10/03_23:51:05 for job 4974
 ...
 License IN  @ 2008/10/04_00:18:22 for job 4974



Task

Save the 10,000 line log file from    here   into a local file, then write a program to scan the file extracting both the maximum licenses that were out at any time, and the time(s) at which this occurs.

Mirror of log file available as a zip here (offsite mirror).



",Python,"out, max_out, max_times = 0, -1, []
for job in open('mlijobs.txt'):
    out += 1 if ""OUT"" in job else -1
    if out > max_out:
        max_out, max_times = out, []
    if out == max_out:
        max_times.append(job.split()[3])
 
print(""Maximum simultaneous license use is %i at the following times:"" % max_out)
print('  ' + '\n  '.join(max_times))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Loops/Do-while,Loops/Do-while,"Start with a value at 0. Loop while value mod 6 is not equal to 0.
Each time through the loop, add 1 to the value then print it.
The loop must execute at least once.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges


Reference

 Do while loop Wikipedia.

",Python,"val = 0
while True:
   val +=1
   print val
   if val % 6 == 0: break",Human_written,Python_from_C#
http://rosettacode.org/wiki/Commatizing_numbers,Commatizing numbers,"Commatizing   numbers (as used here, is a handy expedient made-up word) is the act of adding commas to a number (or string), or to the numeric part of a larger string.



Task

Write a function that takes a string as an argument with optional arguments or parameters (the format of parameters/options is left to the programmer) that in general, adds commas (or some
other characters, including blanks or tabs) to the first numeric part of a string (if it's suitable for commatizing as per the rules below), and returns that newly commatized string.

Some of the commatizing rules (specified below) are arbitrary, but they'll be a part of this task requirements, if only to make the results consistent amongst national preferences and other disciplines.

The number may be part of a larger (non-numeric) string such as:

   «US$1744 millions»       ──or──
   ±25000 motes.


The string may possibly not have a number suitable for commatizing, so it should be untouched and no error generated.

If any argument (option) is invalid, nothing is changed and no error need be generated (quiet execution, no fail execution).   Error message generation is optional.

The exponent part of a number is never commatized.   The following string isn't suitable for commatizing:   9.7e+12000

Leading zeroes are never commatized.   The string   0000000005714.882   after commatization is:   0000000005,714.882

Any   period   (.)   in a number is assumed to be a   decimal point.

The original string is never changed   except   by the addition of commas   [or whatever character(s) is/are used for insertion], if at all.

To wit, the following should be preserved:

   leading signs (+, -)       ── even superfluous signs
   leading/trailing/embedded blanks, tabs, and other whitespace 
   the case (upper/lower) of the exponent indicator, e.g.:   4.8903d-002


Any exponent character(s) should be supported:

   1247e12
   57256.1D-4
   4444^60
   7500∙10**35
   8500x10**35
   9500↑35
   +55000↑3
   1000**100
   2048²
   409632
   10000pow(pi)

Numbers may be terminated with any non-digit character, including subscripts and/or superscript:   41421356243   or   7320509076(base 24).

The character(s) to be used for the comma can be specified, and may contain blanks, tabs, and other whitespace characters, as well as multiple characters.   The default is the comma (,) character.

The   period length   can be specified   (sometimes referred to as ""thousands"" or ""thousands separators"").   The   period length   can be defined as the length (or number) of the decimal digits between commas.   The default period length is   3.

 E.G.:   in this example, the   period length   is five:   56789,12340,14148
The location of where to start the scanning for the target field (the numeric part) should be able to be specified.   The default is   1.

The character strings below may be placed in a file (and read) or stored as simple strings within the program.



Strings to be used as a minimum

The value of   pi   (expressed in base 10)   should be separated with blanks every   5   places past the decimal point,

the Zimbabwe dollar amount should use a decimal point for the ""comma"" separator:

   pi=3.14159265358979323846264338327950288419716939937510582097494459231
   The author has two Z$100000000000000 Zimbabwe notes (100 trillion).
   ""-in Aus$+1411.8millions""
   ===US$0017440 millions=== (in 2000 dollars)
   123.e8000 is pretty big.
   The land area of the earth is 57268900(29% of the surface) square miles.
   Ain't no numbers in this here words, nohow, no way, Jose.
   James was never known as 0000000007
   Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.
   ␢␢␢$-140000±100 millions.
   6/9/1946 was a good year for some.

where the penultimate string has three leading blanks   (real blanks are to be used).



Also see

 The Wiki entry:   (sir) Arthur Eddington's number of protons in the universe. 

",Python,"import re
 
def commatize(s, start=0, step=3, ins=','):
    if start < 0 or start > len(s) or step < 1 or step > len(s):
        return
 
    m = re.search(r'([1-9][0-9]*)', s[start:])
    result = s[:start]
 
    if m:
        sb = m.group(1)[::-1]
        for i in range(step, len(sb), step):
            sb = sb[:i] + ins + sb[i:]
        m.expand(sb[::-1], result)
 
    print(m.appendTail(result))
 
if __name__ == '__main__':
    commatize(""pi=3.14159265358979323846264338327950288419716939937510582""
                + ""097494459231"", 6, 5, "" "")
 
    commatize(""The author has two Z$100000000000000 Zimbabwe notes (100 ""
                + ""trillion)."", 0, 3, ""."")
 
    with open('input.txt') as f:
        for line in f:
            commatize(line)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Hickerson_series_of_almost_integers,Hickerson series of almost integers,"The following function,   due to D. Hickerson,   is said to generate ""Almost integers"" by the

""Almost Integer"" page of Wolfram MathWorld,   (December 31 2013).   (See formula numbered   51.)



The function is:           



h
(
n
)
=



n
!


2
(
ln
⁡

2


)

n
+
1







{\displaystyle h(n)={\operatorname {n} ! \over 2(\ln {2})^{n+1}}}





It is said to produce ""almost integers"" for   n   between   1   and   17.
The purpose of the task is to verify this assertion.

Assume that an ""almost integer"" has either a nine or a zero as its first digit after the decimal point of its decimal string representation



Task

Calculate all values of the function checking and stating which are ""almost integers"".

Note: Use extended/arbitrary precision numbers in your calculation if necessary to ensure you have adequate precision of results as for example:

               h(18) = 3385534663256845326.39...


",Python,"from decimal import Decimal
from math import factorial
 
def hickerson(n):
    return Decimal(factorial(n)) / (Decimal(2) * (Decimal(2).ln() ** Decimal(n + 1)))
 
for i in range(1, 18):
    h = hickerson(i)
    dec_part = str(h).split('.')[1]
    if dec_part.startswith('0') or dec_part.startswith('9'):
        print(f'{h} is an almost integer.')
    else:
        print(f'{h} is not an almost integer.')",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Bitmap/PPM_conversion_through_a_pipe,Bitmap/PPM conversion through a pipe,"Using the data storage type defined on this page for raster images, delegate writing a JPEG file through a pipe using the output_ppm function defined on this other page.

There are various utilities that can be used for this task, for example: cjpeg (package ""jpeg-progs"" on Linux), ppmtojpeg (package ""netpbm"" on Linux), convert (from ImageMagick, multi-platform).
",Python,"""""""
Adapted from https://stackoverflow.com/questions/26937143/ppm-to-jpeg-jpg-conversion-for-python-3-4-1
Requires pillow-5.3.0 with Python 3.7.1 32-bit on Windows.
Sample ppm graphics files from http://www.cs.cornell.edu/courses/cs664/2003fa/images/
""""""
 
from PIL import Image
 
im = Image.open(""boxes_1.ppm"")
im.save(""boxes_1.jpg"")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",Python,"import inspect
 
# Sample classes for inspection
class Super(object):
  def __init__(self, name):
    self.name = name
 
  def __str__(self):
    return ""Super(%s)"" % (self.name,)
 
  def doSup(self):
    return 'did super stuff'
 
  @classmethod
  def cls(cls):
    return 'cls method (in sup)'
 
  @classmethod
  def supCls(cls):
    return 'Super method'
 
  @staticmethod
  def supStatic():
    return 'static method'
 
class Other(object):
  def otherMethod(self):
    return 'other method'
 
class Sub(Other, Super):
  def __init__(self, name, *args):
    super(Sub, self).__init__(name);
    self.rest = args;
    self.methods = {}
 
  def __dir__(self):
    return list(set( \
        sum([dir(base) for base in type(self).__bases__], []) \
        + type(self).__dict__.keys() \
        + self.__dict__.keys() \
        + self.methods.keys() \
      ))
 
  def __getattr__(self, name):
    if name in self.methods:
      if callable(self.methods[name]) and self.methods[name].__code__.co_argcount > 0:
        if self.methods[name].__code__.co_varnames[0] == 'self':
          return self.methods[name].__get__(self, type(self))
        if self.methods[name].__code__.co_varnames[0] == 'cls':
          return self.methods[name].__get__(type(self), type)
      return self.methods[name]
    raise AttributeError(""'%s' object has no attribute '%s'"" % (type(self).__name__, name))
 
  def __str__(self):
    return ""Sub(%s)"" % self.name
 
  def doSub():
    return 'did sub stuff'
 
  @classmethod
  def cls(cls):
    return 'cls method (in Sub)'
 
  @classmethod
  def subCls(cls):
    return 'Sub method'
 
  @staticmethod
  def subStatic():
    return 'Sub method'
 
sup = Super('sup')
sub = Sub('sub', 0, 'I', 'two')
sub.methods['incr'] = lambda x: x+1
sub.methods['strs'] = lambda self, x: str(self) * x
 
# names
[method for method in dir(sub) if callable(getattr(sub, method))]
# instance methods
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == sub]
#['__dir__', '__getattr__', '__init__', '__str__', 'doSub', 'doSup', 'otherMethod', 'strs']
# class methods 
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == type(sub)]
#['__subclasshook__', 'cls', 'subCls', 'supCls']
# static & free dynamic methods
[method for method in dir(sub) if callable(getattr(sub, method)) and type(getattr(sub, method)) == type(lambda:nil)]
#['incr', 'subStatic', 'supStatic']
 
# names & values; doesn't include wrapped, C-native methods
inspect.getmembers(sub, predicate=inspect.ismethod)
# names using inspect
map(lambda t: t[0], inspect.getmembers(sub, predicate=inspect.ismethod))
#['__dir__', '__getattr__', '__init__', '__str__', 'cls', 'doSub', 'doSup', 'otherMethod', 'strs', 'subCls', 'supCls']",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort,Sorting algorithms/Comb sort,"Sorting algorithms/Comb sort

You are encouraged to solve this task according to the task description, using any language you may know.

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a   comb sort.



The Comb Sort is a variant of the Bubble Sort.

Like the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.

Dividing the gap by   



(
1
−

e

−
φ



)

−
1


≈
1.247330950103979


{\displaystyle (1-e^{-\varphi })^{-1}\approx 1.247330950103979}

    works best, but    1.3   may be more practical.



Some implementations use the insertion sort once the gap is less than a certain amount.



Also see

   the Wikipedia article:   Comb sort.


Variants:

 Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.
 Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small).   Comb sort with a low gap isn't much better than the Bubble Sort.


Pseudocode:

function combsort(array input)
    gap := input.size //initialize gap size
    loop until gap = 1 and swaps = 0
        //update the gap value for a next comb. Below is an example
        gap := int(gap / 1.25)
        if gap < 1
          //minimum gap is 1
          gap := 1
        end if
        i := 0
        swaps := 0 //see Bubble Sort for an explanation
        //a single ""comb"" over the input list
        loop until i + gap >= input.size //see Shell sort for similar idea
            if input[i] > input[i+gap]
                swap(input[i], input[i+gap])
                swaps := 1 // Flag a swap has occurred, so the
                           // list is not guaranteed sorted
            end if
            i := i + 1
        end loop
    end loop
end function


",Python,"import math
def combSort(input):
    gap = len(input)
    swaps = True
    while gap > 1 or swaps:
        gap /= 1.247330950103979
        if gap < 1:
            gap = 1
        i = 0
        swaps = False
        while i + gap < len(input):
            igap = i + int(gap)
            if input[i] > input[igap]:
                swap = input[i]
                input[i] = input[igap]
                input[igap] = swap
                swaps = True
            i += 1
    return input
unsorted = [3, 5, 1, 9, 7, 6, 8, 2, 4]
print(combSort(unsorted))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",Python,"import math
 
def isqrt(x):
    if x < 0:
        raise ValueError(""Argument cannot be negative"")
    q = 1
    while q <= x:
        q <<= 2
    z = x
    r = 0
    while q > 1:
        q >>= 2
        t = z - r - q
        r >>= 1
        if t >= 0:
            z = t
            r += q
    return r
 
if __name__ == ""__main__"":
    print(""The integer square root of integers from 0 to 65 are:"")
    for i in range(66):
        print(isqrt(i), end="" "")
    print()
 
    print(""The integer square roots of powers of 7 from 7^1 up to 7^73 are:"")
    print(""power                                    7 ^ power                                                 integer square root"")
    print(""----- --------------------------------------------------------------------------------- -----------------------------------------"")
    pow7 = 7
    bi49 = 49
    for i in range(1, 74, 2):
        print(f""{i:2d} %{84d} %{41d}"")
        pow7 *= bi49",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Pierpont_primes,Pierpont primes,"A Pierpont prime is a prime number of the form: 2u3v + 1 for some non-negative integers  u  and  v .



A Pierpont prime of the second kind is a prime number of the form: 2u3v - 1 for some non-negative integers  u  and  v .


The term ""Pierpont primes"" is generally understood to mean the first definition, but will be called ""Pierpont primes of the first kind"" on this page to distinguish them.



Task

 Write a routine (function, procedure, whatever) to find Pierpont primes of the first & second kinds.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the first kind.
 Use the routine to find and display here, on this page, the first 50 Pierpont primes of the second kind
 If your language supports large integers, find and display here, on this page, the 250th Pierpont prime of the first kind and the 250th Pierpont prime of the second kind.


See also

 Wikipedia - Pierpont primes
 OEIS:A005109 - Class 1 -, or Pierpont primes
 OEIS:A005105 - Class 1 +, or Pierpont primes of the second kind

",Python,"from math import gcd
from sympy import isprime
 
def pierpont(n):
    p = [[0] * n for _ in range(2)]
    p[0][0] = 2
    count = 0
    count1 = 1
    count2 = 0
    s = [1]
    i2 = 0
    i3 = 0
    k = 1
    while count < n:
        n2 = s[i2] * 2
        n3 = s[i3] * 3
        if n2 < n3:
            t = n2
            i2 += 1
        else:
            t = n3
            i3 += 1
        if t > s[k - 1]:
            s.append(t)
            k += 1
            t += 1
            if count1 < n and isprime(t):
                p[0][count1] = t
                count1 += 1
            t -= 2
            if count2 < n and isprime(t):
                p[1][count2] = t
                count2 += 1
            count = min(count1, count2)
    return p
 
if __name__ == ""__main__"":
    p = pierpont(2000)
 
    print(""First 50 Pierpont primes of the first kind:"")
    for i in range(50):
        print(f""{p[0][i]:8d}"", end="" "")
        if (i - 9) % 10 == 0:
            print()
 
    print(""\nFirst 50 Pierpont primes of the second kind:"")
    for i in range(50):
        print(f""{p[1][i]:8d}"", end="" "")
        if (i - 9) % 10 == 0:
            print()
 
    print(f""\n250th Pierpont prime of the first kind: {p[0][249]}"")
    print(f""\n250th Pierpont prime of the first kind: {p[1][249]}"")
 
    print(f""\n1000th Pierpont prime of the first kind: {p[0][999]}"")
    print(f""\n1000th Pierpont prime of the first kind: {p[1][999]}"")
 
    print(f""\n2000th Pierpont prime of the first kind: {p[0][1999]}"")
    print(f""\n2000th Pierpont prime of the first kind: {p[1][1999]}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Evaluate_binomial_coefficients,Evaluate binomial coefficients,"This programming task, is to calculate ANY binomial coefficient.

However, it has to be able to output   






(


5
3


)





{\displaystyle {\binom {5}{3}}}

,   which is   10.

This formula is recommended:


 






(


n
k


)



=



n
!


(
n
−
k
)
!
k
!



=



n
(
n
−
1
)
(
n
−
2
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
(
k
−
2
)
…
1





{\displaystyle {\binom {n}{k}}={\frac {n!}{(n-k)!k!}}={\frac {n(n-1)(n-2)\ldots (n-k+1)}{k(k-1)(k-2)\ldots 1}}}





See Also:

 Combinations and permutations
 Pascal's triangle

 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"def binomialCoeff(n, k):
    result = 1
    for i in range(1, k+1):
        result = result * (n-i+1) / i
    return result
 
if __name__ == ""__main__"":
    print(binomialCoeff(5, 3))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Rock-paper-scissors,Rock-paper-scissors,"Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive   AI   (artificial intelligence)   player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

   Rock beats scissors
   Scissors beat paper
   Paper beats rock


If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.



Extra credit

Support additional choices   additional weapons.



",Python,"from random import choice
 
rules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}
previous = ['rock', 'paper', 'scissors']
 
while True:
    human = input('\nchoose your weapon: ')
    computer = rules[choice(previous)]  # choose the weapon which beats a randomly chosen weapon from ""previous""
 
    if human in ('quit', 'exit'): break
 
    elif human in rules:
        previous.append(human)
        print('the computer played', computer, end='; ')
 
        if rules[computer] == human:  # if what beats the computer's choice is the human's choice...
            print('yay you win!')
        elif rules[human] == computer:  # if what beats the human's choice is the computer's choice...
            print('the computer beat you... :(')
        else: print(""it's a tie!"")
 
    else: print(""that's not a valid choice"")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Pointers_and_references,Pointers and references,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


In this task, the goal is to demonstrate common operations on pointers and references. These examples show pointer operations on the stack, which can be dangerous and is rarely done. Pointers and references are commonly used along with Memory allocation on the heap.
",Python,pointer17 = pointer16,Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane,Find the intersection of a line with a plane,"Finding the intersection of an infinite ray with a plane in 3D is an important topic in collision detection.



Task

Find the point of intersection for the infinite ray with direction   (0, -1, -1)   passing through position   (0, 0, 10)   with the infinite plane with a normal vector of   (0, 0, 1)   and which passes through [0, 0, 5].



",Python,"import sys
 
class Vector:
	def __init__(self,x,y,z):
		self.x = x
		self.y = y
		self.z = z
 
def addVectors(a,b):
	return Vector(a.x+b.x,a.y+b.y,a.z+b.z)
 
def subVectors(a,b):
	return Vector(a.x-b.x,a.y-b.y,a.z-b.z)
 
def dotProduct(a,b):
	return a.x*b.x + a.y*b.y + a.z*b.z
 
def scaleVector(l,a):
	return Vector(l*a.x,l*a.y,l*a.z)
 
def intersectionPoint(lineVector, linePoint, planeNormal, planePoint):
	diff = subVectors(linePoint,planePoint)
 
	return addVectors(addVectors(diff,planePoint),scaleVector(-dotProduct(diff,planeNormal)/dotProduct(lineVector,planeNormal),lineVector))
 
if __name__ == ""__main__"":
	if len(sys.argv)!=5:
		print ""Usage : %s <line direction, point on line, normal to plane and point on plane given as (x,y,z) tuples separated by space>"" % sys.argv[0]
	else:
		lV = Vector(*[float(x) for x in sys.argv[1][1:-1].split(',')])
		lP = Vector(*[float(x) for x in sys.argv[2][1:-1].split(',')])
		pN = Vector(*[float(x) for x in sys.argv[3][1:-1].split(',')])
		pP = Vector(*[float(x) for x in sys.argv[4][1:-1].split(',')])
 
		if dotProduct(lV,pN)==0:
			print ""Line and Plane do not intersect, either parallel or line is on the plane""
		else:
			iP = intersectionPoint(lV,lP,pN,pP)
 
			print ""Intersection point is (%lf,%lf,%lf)"" % (iP.x,iP.y,iP.z)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"import os

lprFile = open( ""/dev/lp0"", ""w"" )
lprFile.write( ""Hello World!\n"" )
lprFile.close()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Image_convolution,Image convolution,"One class of image digital filters is described by a rectangular matrix of real coefficients called kernel convoluted in a sliding window of image pixels. Usually the kernel is square 




K

k
l




{\displaystyle K_{kl}}

, where k, l are in the range -R,-R+1,..,R-1,R. W=2R+1 is the kernel width. The filter determines the new value of a monochromatic image pixel Pij as a convolution of the image pixels in the window centered in i, j and the kernel values:







P

i
j


=


∑

k
=
−
R


R



∑

l
=
−
R


R



P

i
+
k
 
j
+
l



K

k
l





{\displaystyle P_{ij}=\displaystyle \sum _{k=-R}^{R}\sum _{l=-R}^{R}P_{i+k\ j+l}K_{kl}}




Color images are usually split into the channels which are filtered independently. A color model can be changed as well, i.e. filtration is performed not necessarily in RGB. Common kernels sizes are 3x3 and 5x5. The complexity of filtrating grows quadratically (O(n2)) with the kernel width.

Task: Write a generic convolution 3x3 kernel filter. Optionally show some end user filters that use this generic one.

(You can use, to test the functions below, these input and output solutions.)
",Python,"#!/bin/python
from PIL import Image, ImageFilter
 
if __name__==""__main__"":
	im = Image.open(""test.jpg"")
 
	kernelValues = [-2,-1,0,-1,1,1,0,1,2] #emboss
	kernel = ImageFilter.Kernel((3,3), kernelValues)
 
	im2 = im.filter(kernel)
 
	im2.show()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Plot_coordinate_pairs,Plot coordinate pairs,"Task

Plot a function represented as     x,  y     numerical arrays.

Post the resulting image for the following input arrays (taken from Python's Example section on Time a function):

      x = {0,   1,    2,    3,    4,    5,     6,     7,     8,     9};
      y = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0};

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",Python,"# Version 1.2.31
import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0, 100, 0.1)
y = np.sin(x)

plt.plot(x, y, label=""sin(x)"")
plt.title(""Plot a function with a legend"")
plt.xlabel(""X"")
plt.ylabel(""Y"")
plt.legend()
plt.show()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Bioinformatics/base_count,Bioinformatics/base count,"Given this string representing ordered DNA bases:

CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT



Task

   ""Pretty print"" the sequence followed by a summary of the counts of each of the bases:   (A, C, G, and T)   in the sequence 
   print the total count of each base in the string.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from collections import Counter
 
def basecount(dna):
    return sorted(Counter(dna).items())
 
def seq_split(dna, n=50):
    return [dna[i: i+n] for i in range(0, len(dna), n)]
 
def seq_pp(dna, n=50):
    for i, part in enumerate(seq_split(dna, n)):
        print(f""{i*n:>5}: {part}"")
    print(""\n  BASECOUNT:"")
    tot = 0
    for base, count in basecount(dna):
        print(f""    {base:>3}: {count}"")
        tot += count
    base, count = 'TOT', tot
    print(f""    {base:>3}= {count}"")
 
if __name__ == '__main__':
    print(""SEQUENCE:"")
    sequence = '''\
CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT'''
    seq_pp(sequence)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",Python,"import string, sys
if sys.version_info[0] < 3:
    input = raw_input
 
def ispangram(sentence, alphabet=string.ascii_lowercase):
    alphaset = set(alphabet)
    return alphaset <= set(sentence.lower())
 
print ( ispangram(input('Sentence: ')) )",Human_written,Python_from_C++
http://rosettacode.org/wiki/Cramer%27s_rule,Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",Python,"def det(m,n):
 if n==1: return m[0][0]
 z=0
 for r in range(n):
  k=m[:]
  del k[r]
  z+=m[r][0]*(-1)**r*det([p[1:]for p in k],n-1)
 return z
w=len(t)
d=det(h,w)
if d==0:r=[]
else:r=[det([r[0:i]+[s]+r[i+1:]for r,s in zip(h,t)],w)/d for i in range(w)]
print(r)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Combinations_and_permutations,Combinations and permutations,"

 This page uses content from Wikipedia. The original article was at Combination. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



 This page uses content from Wikipedia. The original article was at Permutation. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the combination    (nCk)    and permutation    (nPk)    operators in the target language:

 






n



C

k


=



(


n
k


)



=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle ^{n}\operatorname {C} _{k}={\binom {n}{k}}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}


 






n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




See the Wikipedia articles for a more detailed description.

To test, generate and print examples of:

   A sample of permutations from 1 to 12 and Combinations from 10 to 60 using exact Integer arithmetic.
   A sample of permutations from 5 to 15000 and Combinations from 100 to 1000 using approximate Floating point arithmetic.
 This 'floating point' code could be implemented using an approximation, e.g., by calling the Gamma function.


Related task

   Evaluate binomial coefficients



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"from __future__ import print_function
 
from scipy.misc import factorial as fact
from scipy.misc import comb
 
def perm(N, k, exact=0):
    return comb(N, k, exact) * fact(k, exact)
 
exact=True
print('Sample Perms 1..12')
for N in range(1, 13):
    k = max(N-2, 1)
    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\n')
 
print('\n\nSample Combs 10..60')
for N in range(10, 61, 10):
    k = N-2
    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\n')
 
exact=False
print('\n\nSample Perms 5..1500 Using FP approximations')
for N in [5, 15, 150, 1500, 15000]:
    k = N-2
    print('%iP%i =' % (N, k), perm(N, k, exact))
 
print('\nSample Combs 100..1000 Using FP approximations')
for N in range(100, 1001, 100):
    k = N-2
    print('%iC%i =' % (N, k), comb(N, k, exact))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Almost_prime,Almost prime,"A   k-Almost-prime   is a natural number   



n


{\displaystyle n}

   that is the product of   



k


{\displaystyle k}

   (possibly identical) primes.



Example

1-almost-primes,   where   



k
=
1


{\displaystyle k=1}

,   are the prime numbers themselves.

2-almost-primes,   where   



k
=
2


{\displaystyle k=2}

,   are the   semiprimes.



Task

Write a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   



1
<=
K
<=
5


{\displaystyle 1<=K<=5}

.



Related tasks

   Semiprime
   Category:Prime Numbers

",Python,"def kPrime(n, k):
    nf = 0
    for i in range(2, n+1):
        while n % i == 0:
            if nf == k:
                return False
            nf += 1
            n //= i
    return nf == k
 
def gen(k, n):
    r = [0] * n
    n = 2
    for i in range(n):
        while not kPrime(n, k):
            n += 1
        r[i] = n
        n += 1
    return r
 
for k in range(1, 6):
    print(k, gen(k, 10))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def remove_comments(line, sep):
    for s in sep:
        i = line.find(s)
        if i >= 0:
            line = line[:i]
    return line.strip()
 
# test
print remove_comments('apples ; pears # and bananas', ';#')
print remove_comments('apples ; pears # and bananas', '!')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Unicode_variable_names,Unicode variable names,"Task

 Describe, and give a pointer to documentation on your languages use of characters beyond those of the ASCII character set in the naming of variables.
 Show how to:
 Set a variable with a name including the 'Δ', (delta character), to 1 
 Increment it
 Print its value.


Related task
 
 Case-sensitivity of identifiers

",Python,">>> Δx = 1
>>> Δx += 1
>>> print(Δx)
2
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class dlNode:
    def __init__(self, string, next, prev):
        self.string = string
        self.next = next
        self.prev = prev",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Arithmetic_numbers,Arithmetic numbers,"Definition
A positive integer n is an arithmetic number if the average of its positive divisors is also an integer.

Clearly all odd primes p must be arithmetic numbers because their only divisors are 1 and p whose sum is even and hence their average must be an integer. However, the prime number 2 is not an arithmetic number because the average of its divisors is 1.5.

Example
30 is an arithmetic number because its 7 divisors are: [1, 2, 3, 5, 6, 10, 15, 30], their sum is 72 and average 9 which is an integer.

Task
Calculate and show here:

1. The first 100 arithmetic numbers.

2. The xth arithmetic number where x = 1,000 and x = 10,000.

3. How many of the first x arithmetic numbers are composite.

Note that, technically, the arithmetic number 1 is neither prime nor composite.

Stretch
Carry out the same exercise in 2. and 3. above for x = 100,000 and x = 1,000,000.

References
 Wikipedia: Arithmetic number
 OEIS:A003601 - Numbers n such that the average of the divisors of n is an integer



",Python,"def factors(n: int):
    f = set([1, n])
    i = 2
    while True:
        j = n // i
        if j < i:
            break
        if i * j == n:
            f.add(i)
            f.add(j)
        i += 1
    return f
 
arithmetic_count = 0
composite_count = 0
n = 1
while arithmetic_count <= 1000000:
    f = factors(n)
    if (sum(f)/len(f)).is_integer():
        arithmetic_count += 1
        if len(f) > 2:
            composite_count += 1
        if arithmetic_count <= 100:
            print(f'{n:3d} ', end='')
            if arithmetic_count % 10 == 0:
                print()
        if arithmetic_count in (1000, 10000, 100000, 1000000):
            print(f'\n{arithmetic_count}th arithmetic number is {n}')
            print(f'Number of composite arithmetic numbers <= {n}: {composite_count}')
    n += 1",Human_written,Python_from_C
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"# version 1.0.6
# tested on Windows 10
 
import os
 
def main():
   print(os.getenv(""SystemRoot""))
 
if __name__ == ""__main__"":
   main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Perfect_shuffle,Perfect shuffle,"A perfect shuffle (or faro/weave shuffle) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:



 7♠ 8♠ 9♠ J♠ Q♠ K♠→7♠  8♠  9♠
  J♠  Q♠  K♠→7♠ J♠ 8♠ Q♠ 9♠ K♠


When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:





 original: 

1
2
3
4
5
6
7
8



 after 1st shuffle: 

1
5
2
6
3
7
4
8



 after 2nd shuffle: 

1
3
5
7
2
4
6
8



 after 3rd shuffle: 

1
2
3
4
5
6
7
8




The Task
 Write a function that can perform a perfect shuffle on an even-sized list of values.
 Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under ""Test Cases"" below.
 You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all ""cards"" are unique within each deck.
 Print out the resulting shuffle counts, to demonstrate that your program passes the test-cases.
Test Cases


 input (deck size) 
 output (number of shuffles required)


 8 
 3


 24 
 11


 52 
 8


 100 
 30


 1020 
 1018


 1024 
 10


 10000 
 300


",Python,"# ===> INCLUDES <============================================================
import sys
import random
 
# ===> CONSTANTS <===========================================================
N_DECKS = 7
kDecks = [ 8, 24, 52, 100, 1020, 1024, 10000 ]
 
# ===> FUNCTION PROTOTYPES <=================================================
def CreateDeck( nCards ):
    deck = [0] * nCards
    return deck
 
def InitDeck( deck, nCards ):
    for i in range(nCards):
        deck[i] = i
 
def DuplicateDeck( orig, nCards ):
    dest = CreateDeck( nCards )
    for i in range(nCards):
        dest[i] = orig[i]
    return dest
 
def InitedDeck( deck, nCards ):
    for i in range(nCards):
        if deck[i]!= i:
            return False
    return True
 
def ShuffleDeck( deck, nCards ):
    copy = DuplicateDeck( deck, nCards )
    for i in range(nCards/2):
        deck[2*i] = copy[i]
        deck[2*i+1] = copy[i+nCards/2]
 
# ===> FUNCTION DEFINITIONS <================================================
 
if __name__ == ""__main__"":
    for i in range(N_DECKS):
        nCards = kDecks[i]
 
        deck = CreateDeck( nCards )
        InitDeck( deck, nCards )
        nShuffles = 0
 
        while not InitedDeck(deck,nCards):
            ShuffleDeck( deck, nCards )
            nShuffles += 1
 
        print ""Cards count: %d, shuffles required: %d."" % (nCards, nShuffles)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort,Sorting algorithms/Permutation sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a permutation sort, which proceeds by generating the possible permutations
of the input array/list until discovering the sorted one.

Pseudocode:

while not InOrder(list) do
    nextPermutation(list)
done


",Python,"from itertools import permutations
 
in_order = lambda s: all(x <= s[i+1] for i,x in enumerate(s[:-1]))
perm_sort = lambda s: (p for p in permutations(s) if in_order(p)).next()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/DNS_query,DNS query,"DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.

Use DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.



",Python,"import socket
import sys
 
def main():
  rc = 0
  try:
    entries = socket.getaddrinfo(""www.kame.net"", None)
    for entry in entries:
      print(entry[4][0])
  except Exception as e:
    print(e)
    rc = 1
  return rc
 
if __name__ == ""__main__"":
  sys.exit(main())",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",Python,"import string
 
def move_to_front(str,c):
    p=str
    q=str.find(c)
    str=str[q]+str[0:q]+str[q+1:]
    return str
 
def decode(pass,size,sym):
    table=""abcdefghijklmnopqrstuvwxyz""
    for i in range(size):
        c=table[pass[i]]
        index=move_to_front(table,c)
        if pass[i]!=index:
            print ""there is an error""
        sym[i]=c
    sym[size]='\0'
 
def encode(sym,size,pass):
    table=""abcdefghijklmnopqrstuvwxyz""
    for i in range(size):
        c=sym[i]
        pass[i]=move_to_front(table,c)
 
def check(sym,size,pass):
    pass2=[0]*size
    sym2=[0]*size
    val=1
 
    encode(sym,size,pass2)
    i=0
    while i<size and pass[i]==pass2[i]:
        i+=1
    if i!=size:
        val=0
 
    decode(pass,size,sym2)
    if sym!=sym2:
        val=0
 
    return val
 
sym=[""broood"",""bananaaa"",""hiphophiphop""]
pass=[0]*MAX_SIZE
for i in range(3):
    len=len(sym[i])
    encode(sym[i],len,pass)
    print sym[i],"": ["",
    for j in range(len):
        print pass[j],
    print ""]""
    if check(sym[i],len,pass):
        print ""Correct :)""
    else:
        print ""Incorrect :(\n""",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Square_but_not_cube,Square but not cube,"Task

Show the first   30   positive integers which are squares but not cubes of such integers.

Optionally, show also the first   3   positive integers which are both squares and cubes,   and mark them as such.



",Python,"# nonCubeSquares :: Int -> [(Int, Bool)]
def nonCubeSquares(n):
    upto = enumFromTo(1)
    ns = upto(n)
    setCubes = set(x ** 3 for x in ns)
    ms = upto(n + len(set(x * x for x in ns).intersection(
        setCubes
    )))
    return list(tuple([x * x, x in setCubes]) for x in ms)
 
 
# squareListing :: [(Int, Bool)] -> [String]
def squareListing(xs):
    justifyIdx = justifyRight(len(str(1 + len(xs))))(' ')
    justifySqr = justifyRight(1 + len(str(xs[-1][0])))(' ')
    return list(
        '(' + str(1 + idx) + '^2 = ' + str(n) +
        ' = ' + str(round(n ** (1 / 3))) + '^3)' if bln else (
            justifyIdx(1 + idx) + ' ->' +
            justifySqr(n)
        )
        for idx, (n, bln) in enumerate(xs)
    )
 
 
def main():
    print(
        unlines(
            squareListing(
                nonCubeSquares(30)
            )
        )
    )
 
 
# GENERIC ------------------------------------------------------------------
 
# enumFromTo :: Int -> Int -> [Int]
def enumFromTo(m):
    return lambda n: list(range(m, 1 + n))
 
 
# justifyRight :: Int -> Char -> String -> String
def justifyRight(n):
    return lambda cFiller: lambda a: (
        ((n * cFiller) + str(a))[-n:]
    )
 
 
# unlines :: [String] -> String
def unlines(xs):
    return '\n'.join(xs)
 
 
main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Simple_database,Simple database,"Task

Write a simple tool to track a small set of data.

The tool should have a command-line interface to enter at least two different values.

The entered data should be stored in a structured format and saved to disk.

It does not matter what kind of data is being tracked.   It could be a collection (CDs, coins, baseball cards, books), a diary, an electronic organizer (birthdays/anniversaries/phone numbers/addresses), etc.



You should track the following details:

 A description of the item. (e.g., title, name)
 A category or tag (genre, topic, relationship such as “friend” or “family”)
 A date (either the date when the entry was made or some other date that is meaningful, like the birthday); the date may be generated or entered manually
 Other optional fields


The command should support the following Command-line arguments to run:

 Add a new entry
 Print the latest entry
 Print the latest entry for each category
 Print all entries sorted by a date


The category may be realized as a tag or as structure (by making all entries in that category subitems)

The file format on disk should be human readable, but it need not be standardized.   A natively available format that doesn't need an external library is preferred.   Avoid developing your own format if you can use an already existing one.   If there is no existing format available, pick one of:

   JSON
   S-Expressions
   YAML
   others


Related task

   Take notes on the command line 

",Python,"#!/usr/bin/python3
 
'''\
Simple database for: http://rosettacode.org/wiki/Simple_database
 
'''
 
import argparse
from argparse import Namespace
import datetime
import shlex
 
 
def parse_args():
    'Set up, parse, and return arguments'
 
    parser = argparse.ArgumentParser(epilog=globals()['__doc__'])
 
    parser.add_argument('command', choices='add pl plc pa'.split(),
                        help='''\
add: Add a new entry
pl:  Print the latest entry
plc: Print the latest entry for each category/tag
pa:  Print all entries sorted by a date''')
    parser.add_argument('-d', '--description',
                        help='A description of the item. (e.g., title, name)')
    parser.add_argument('-t', '--tag',
                        help=('''A category or tag (genre, topic, relationship '''
                              '''such as “friend” or “family”)'''))
    parser.add_argument('-f', '--field', nargs=2, action='append', 
                        help='Other optional fields with value (can be repeated)')
 
    return parser
 
def do_add(args, dbname):
    'Add a new entry'
    if args.description is None:
        args.description = ''
    if args.tag is None:
        args.tag = ''
    del args.command
    print('Writing record to %s' % dbname)
    with open(dbname, 'a') as db:
        db.write('%r\n' % args)
 
def do_pl(args, dbname):
    'Print the latest entry'
    print('Getting last record from %s' % dbname)
    with open(dbname, 'r') as db:
        for line in db: pass
    record = eval(line)
    del record._date
    print(str(record))
 
def do_plc(args, dbname):
    'Print the latest entry for each category/tag'
    print('Getting latest record for each tag from %s' % dbname)
    with open(dbname, 'r') as db:
        records = [eval(line) for line in db]
    tags = set(record.tag for record in records)
    records.reverse()
    for record in records:
        if record.tag in tags:
            del record._date
            print(str(record))
            tags.discard(record.tag)
            if not tags: break
 
def do_pa(args, dbname):
    'Print all entries sorted by a date'
    print('Getting all records by date from %s' % dbname)
    with open(dbname, 'r') as db:
        records = [eval(line) for line in db]
    for record in records:
        del record._date
        print(str(record))
 
def test():
    import time
    parser = parse_args()
    for cmdline in [
                    """"""-d Book -f title 'Windy places' -f type hardback --tag DISCOUNT add"""""",
                    """"""-d Book -f title 'RC spammers'  -f type paperback -t   DISCOUNT add"""""",
                    """"""-d Book -f title 'Splat it' -f type hardback -f special 'first edition' -t PREMIUM add"""""",
                    """"""pl"""""",
                    """"""plc"""""",
                    ]:
        args = parser.parse_args(shlex.split(cmdline))
        now = datetime.datetime.utcnow()
        args._date = now.isoformat()
        do_command[args.command](args, dbname)
        time.sleep(0.5)
 
 
 
do_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)
dbname = '_simple_db_db.py'
 
 
if __name__ == '__main__':
    if 0:
        test()
    else:
        parser = parse_args()
        args = parser.parse_args()
        now = datetime.datetime.utcnow()
        args._date = now.isoformat()
        do_command[args.command](args, dbname)",Human_written,Python_from_C
http://rosettacode.org/wiki/Look-and-say_sequence,Look-and-say sequence,"The   Look and say sequence   is a recursively defined sequence of numbers studied most notably by   John Conway.



The   look-and-say sequence   is also known as the   Morris Number Sequence,   after cryptographer Robert Morris,   and the puzzle   What is the next number in the sequence 1,   11,   21,   1211,   111221?   is sometimes referred to as the Cuckoo's Egg,   from a description of Morris in Clifford Stoll's book   The Cuckoo's Egg.


Sequence Definition

 Take a decimal number
 Look at the number, visually grouping consecutive runs of the same digit.
 Say the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.
 This becomes the next number of the sequence.

An example:

 Starting with the number 1,   you have one 1 which produces 11
 Starting with 11,   you have two 1's.   I.E.:   21
 Starting with 21,   you have one 2, then one 1.   I.E.:   (12)(11) which becomes 1211
 Starting with 1211,   you have one 1, one 2, then two 1's.   I.E.:   (11)(12)(21) which becomes 111221


Task

Write a program to generate successive members of the look-and-say sequence.



Related tasks

   Fours is the number of letters in the ...
   Number names
   Self-describing numbers
   Self-referential sequence
   Spelling of ordinal numbers


See also

   Look-and-Say Numbers (feat John Conway), A Numberphile Video.
   This task is related to, and an application of, the Run-length encoding task.
   Sequence A005150 on The On-Line Encyclopedia of Integer Sequences.

",Python,"def lookandsay(str):
    return ''.join([str(len(group)) + digit for group, digit in re.findall(r'((.)\2*)', str)])

num = ""1""
for i in range(10):
    print(num)
    num = lookandsay(num)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"from itertools import product
 
def newSeq(start, end):
    if end < start:
        end = start
    return range(start, end+1)
 
def newSofs():
    return [[]]
 
def listComp(s, in_, expr, pred):
    s2 = []
    for t in expr(s, in_):
        if pred(t):
            s2.append(t)
    return s2
 
def build(s, t):
    u = []
    for ss in s:
        for tt in t:
            uu = ss[:]
            uu.append(tt)
            u.append(uu)
    return u
 
if __name__ == '__main__':
    pt = newSofs()
    in_ = newSeq(1, 20)
    expr = lambda s, t: build(build(build(s, t), t), t)
    pred = lambda t: len(t) == 3 and t[0]*t[0]+t[1]*t[1] == t[2]*t[2] and t[0] < t[1] < t[2]
    pt = listComp(pt, in_, expr, pred)
    print(pt)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/SEDOLs,SEDOLs,"Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.



That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.



Related tasks

   Luhn test
   ISIN

",Python,"def char2value(c):
  assert c not in 'AEIOU', ""No vowels""
  return int(c, 36)
 
sedolweight = [1,3,1,7,3,9]
 
def checksum(sedol):
    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,
                  sedol, sedolweight)
               )
    return str((10 - (tmp % 10)) % 10)
 
for sedol in '''
    710889
    B0YBKJ
    406566
    B0YBLH
    228276
    B0YBKL
    557910
    B0YBKR
    585284
    B0YBKT
    '''.split():
    print sedol + checksum(sedol)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Primorial_numbers,Primorial numbers,"Primorial numbers are those formed by multiplying successive prime numbers.



The primorial number series is:

   primorial(0) =         1       (by definition)
   primorial(1) =         2       (2)
   primorial(2) =         6       (2×3)
   primorial(3) =       30       (2×3×5)
   primorial(4) =     210       (2×3×5×7)
   primorial(5) =   2310       (2×3×5×7×11)
   primorial(6) = 30030       (2×3×5×7×11×13)
         ∙ ∙ ∙
To express this mathematically,   primorialn   is  
the product of the first   n   (successive) primes:



   



p
r
i
m
o
r
i
a

l

n


=

∏

k
=
1


n


p
r
i
m

e

k




{\displaystyle primorial_{n}=\prod _{k=1}^{n}prime_{k}}




 ─── where   



p
r
i
m

e

k




{\displaystyle prime_{k}}

   is the   kth   prime number.




In some sense, generating primorial numbers is similar to factorials.

As with factorials, primorial numbers get large quickly.



Task

   Show the first ten primorial numbers   (0 ──► 9,   inclusive).
   Show the length of primorial numbers whose index is:   10   100   1,000   10,000   and   100,000.
   Show the length of the one millionth primorial number   (optional). 
   Use exact integers, not approximations. 


By   length   (above), it is meant the number of decimal digits in the numbers. 




Related tasks

   Sequence of primorial primes
   Factorial
   Fortunate_numbers


See also

   the MathWorld webpage:   primorial
   the Wikipedia   webpage:   primorial.
   the   OEIS   webpage:   A002110.

",Python,"from pyprimes import nprimes
from functools import reduce
 
 
primelist = list(nprimes(1000001))    # [2, 3, 5, ...]
 
def primorial(n):
    return reduce(int.__mul__, primelist[:n], 1)
 
if __name__ == '__main__':
    print('First ten primorals:', [primorial(n) for n in range(10)])
    for e in range(7):
        n = 10**e
        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))",Human_written,Python_from_C
http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",Python,"'''
I could understand the explanation of the Monty Hall problem
but needed some more evidence
 
References:
  http://www.bbc.co.uk/dna/h2g2/A1054306
  http://en.wikipedia.org/wiki/Monty_Hall_problem especially:
  http://en.wikipedia.org/wiki/Monty_Hall_problem#Increasing_the_number_of_doors
'''
from random import randrange
 
doors, iterations = 3,100000  # could try 100,1000
 
def monty_hall(choice, switch=False, doorCount=doors):
  # Set up doors
  door = [False]*doorCount
  # One door with prize
  door[randrange(doorCount)] = True
 
  chosen = door[choice]
 
  unpicked = door
  del unpicked[choice]
 
  # Out of those unpicked, the alternative is either:
  #   the prize door, or
  #   an empty door if the initial choice is actually the prize.
  alternative = True in unpicked
 
  if switch:
    return alternative
  else:
    return chosen
 
print ""\nMonty Hall problem simulation:""
print doors, ""doors,"", iterations, ""iterations.\n""
 
print ""Not switching allows you to win"",
print sum(monty_hall(randrange(3), switch=False)
          for x in range(iterations)),
print ""out of"", iterations, ""times.""
print ""Switching allows you to win"",
print sum(monty_hall(randrange(3), switch=True)
          for x in range(iterations)),
print ""out of"", iterations, ""times.\n""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Parallel_calculations,Parallel calculations,"Many programming languages allow you to specify computations to be run in parallel.
While Concurrent computing is focused on concurrency,
the purpose of this task is to distribute time-consuming calculations
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one
with the largest minimal prime factor
(that is, the one that contains relatively large factors).
To speed up the search, the factorization should be done
in parallel using separate threads or processes,
to take advantage of multi-core CPUs.

Show how this can be formulated in your language.
Parallelize the factorization of those numbers,
then search the returned list of numbers and factors
for the largest minimal factor,
and return that number and its prime factors.

For the prime number decomposition
you may use the solution of the Prime decomposition task.
",Python,"import rayon
import prime_decomposition
 
def largest_min_factor(numbers):
    return max(rayon.par_iter(prime_decomposition.factor(n)[0] for n in numbers))
 
if __name__ == ""__main__"":
    numbers = [1122725, 1125827, 1122725, 1152800, 1157978, 1099726]
    max = largest_min_factor(numbers)
    print(""The largest minimal factor is {}"".format(max))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Mertens_function,Mertens function,"The Mertens function M(x) is the count of square-free integers up to x that have an even number of prime factors, minus the count of those that have an odd number.

It is an extension of the Möbius function. Given the Möbius function μ(n), the Mertens function M(x) is the sum of the Möbius numbers from n == 1 through n == x.



Task

 Write a routine (function, procedure, whatever) to find the Mertens number for any positive integer x.
 Use that routine to find and display here, on this page, at least the first 99 terms in a grid layout. (Not just one long line or column of numbers.)
 Use that routine to find and display here, on this page, the number of times the Mertens function sequence is equal to zero in the range M(1) through M(1000).
 Use that routine to find and display here, on this page, the number of times the Mertens function sequence crosses zero in the range M(1) through M(1000). (Crossing defined as this term equal to zero but preceding term not.)


See also

 Wikipedia: Mertens function
 Wikipedia: Möbius function
 OEIS: A002321 - Mertens's function
 OEIS: A028442 - Numbers n such that Mertens's function M(n) is zero
 Numberphile - Mertens Conjecture
 Stackexchange: compute the mertens function

This is not code golf.   The stackexchange link is provided as an algorithm reference, not as a guide.



Related tasks

 Möbius function

",Python,"def mertens(count):
    """"""Generate Mertens numbers""""""
    m = [None, 1]
    for n in range(2, count+1):
        m.append(1)
        for k in range(2, n+1):
            m[n] -= m[n//k]
    return m
 
 
ms = mertens(1000)
 
print(""The first 99 Mertens numbers are:"")
print(""  "", end=' ')
col = 1
for n in ms[1:100]:
    print(""{:2d}"".format(n), end=' ')
    col += 1
    if col == 10:
        print()
        col = 0
 
zeroes = sum(x==0 for x in ms)
crosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))
print(""M(N) equals zero {} times."".format(zeroes))
print(""M(N) crosses zero {} times."".format(crosses))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Non-continuous_subsequences,Non-continuous subsequences,"Consider some sequence of elements. (It differs from a mere set of elements by having an ordering among members.)

A subsequence contains some subset of the elements of this sequence, in the same order.

A continuous subsequence is one in which no elements are missing between the first and last elements of the subsequence.

Note: Subsequences are defined structurally, not by their contents.
So a sequence a,b,c,d will always have the same subsequences and continuous subsequences, no matter which values are substituted; it may even be the same value.


Task: Find all non-continuous subsequences for a given sequence.



Example

For the sequence   1,2,3,4,   there are five non-continuous subsequences, namely:

   1,3
   1,4
   2,4
   1,3,4
   1,2,4


Goal

There are different ways to calculate those subsequences.

Demonstrate algorithm(s) that are natural for the language.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"#, July 19th., 2017 - Yes well is this any better?
class N:
    def __init__(self, n):
        self.n = n-1
        self.i = 0
        self.g = 0
        self.e = 1
        self.l = n-1
    def hasNext(self):
        self.g = (1<<self.n)+self.e
        for self.i in range(self.l, self.n):
            self.g += 1<<self.i
        if self.l == 2:
            self.l = self.n-1
            self.e = 1
            return True
        if self.e < ((1<<(self.l-1))-1):
            self.e += 1
            return True
        self.e = 1
        self.l -= 1
        return self.l > 0
    def next(self):
        return self.g",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Python,"def genfizzbuzz(factorwords, numbers):
    # sort entries by factor
    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])
    lines = []
    for num in numbers:
        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)
        lines.append(words if words else str(num))
    return '\n'.join(lines)
 
if __name__ == '__main__':
    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))",Human_written,Python_from_C
http://rosettacode.org/wiki/Optional_parameters,Optional parameters,"Task

Define a function/method/subroutine which sorts a sequence (""table"") of sequences (""rows"") of strings (""cells""), by one of the strings. Besides the input to be sorted, it shall have the following optional parameters:





 ordering
 A function specifying the ordering of strings; lexicographic by default.
 column
 An integer specifying which string of each row to compare; the first by default.
 reverse
 Reverses the ordering.


This task should be considered to include both positional and named optional parameters, as well as overloading on argument count as in Java or selector name as in Smalltalk, or, in the extreme, using different function names. Provide these variations of sorting in whatever way is most natural to your language. If the language supports both methods naturally, you are encouraged to describe both.

Do not implement a sorting algorithm; this task is about the interface. If you can't use a built-in sort routine, just omit the implementation (with a comment).

See also:

 Named Arguments

",Python,">>> def printtable(data):
    for row in data:
        print ' '.join('%-5s' % ('""%s""' % cell) for cell in row)
 
 
>>> import operator
>>> def sorttable(table, ordering=None, column=0, reverse=False):
    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)
 
>>> data = [[""a"", ""b"", ""c""], ["""", ""q"", ""z""], [""zap"", ""zip"", ""Zot""]]
>>> printtable(data)
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
""zap"" ""zip"" ""Zot""
>>> printtable( sorttable(data) )
""""    ""q""   ""z""  
""a""   ""b""   ""c""  
""zap"" ""zip"" ""Zot""
>>> printtable( sorttable(data, column=2) )
""zap"" ""zip"" ""Zot""
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
>>> printtable( sorttable(data, column=1) )
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
""zap"" ""zip"" ""Zot""
>>> printtable( sorttable(data, column=1, reverse=True) )
""zap"" ""zip"" ""Zot""
""""    ""q""   ""z""  
""a""   ""b""   ""c""  
>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )
""zap"" ""zip"" ""Zot""
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Execute_SNUSP,Execute SNUSP,"Execute SNUSP is an implementation of SNUSP.
Other implementations of SNUSP.
RCSNUSP
SNUSP
An implementation need only properly implement the Core SNUSP instructions ('$', '\', '/', '+', '-', '<', '>', ',', '.', '!', and '?'). Modular SNUSP ('#', '@') and Bloated SNUSP (':', ';', '%', and '&') are also allowed, but not required. Any extra characters that you implement should be noted in the description of your implementation. Any cell size is allowed, EOF support is optional, as is whether you have bounded or unbounded memory.
",Python,"#!/usr/bin/env python3
 
HW = r'''
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/'''
 
def snusp(store, code):
    ds = bytearray(store)  # data store
    dp = 0                 # data pointer
    cs = code.splitlines() # 2 dimensional code store
    ipr, ipc = 0, 0        # instruction pointers in row and column
    for r, row in enumerate(cs):
        try:
            ipc = row.index('$')
            ipr = r
            break
        except ValueError:
            pass
    rt, dn, lt, up = range(4)
    id = rt  # instruction direction.  starting direction is always rt
    def step():
        nonlocal ipr, ipc
        if id&1:
            ipr += 1 - (id&2)
        else:
            ipc += 1 - (id&2)
    while ipr >= 0 and ipr < len(cs) and ipc >= 0 and ipc < len(cs[ipr]):
        op = cs[ipr][ipc]
        if op == '>':
            dp += 1
        elif op == '<':
            dp -= 1
        elif op == '+':
            ds[dp] += 1
        elif op == '-':
            ds[dp] -= 1
        elif op == '.':
            print(chr(ds[dp]), end='')
        elif op == ',':
            ds[dp] = input()
        elif op == '/':
            id = ~id
        elif op == '\\':
            id ^= 1
        elif op == '!':
            step()
        elif op == '?':
            if not ds[dp]:
                step()
        step()
 
if __name__ == '__main__':
    snusp(5, HW)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Terminal_control/Cursor_positioning,Terminal control/Cursor positioning,"

Task

Move the cursor to column   3,   row   6,   and display the word   ""Hello""   (without the quotes),   so that the letter   H   is in column   3   on row   6.



",Python,"print(""\033[6;3HHello"")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",Python,"#!/usr/bin/env python
# -*- coding: latin-1 -*-
 
u = 'abcdé'
print(ord(u[-1]))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,">>> def fiblike(start):
	addnum = len(start)
	memo = start[:]
	def fibber(n):
		try:
			return memo[n]
		except IndexError:
			ans = sum(fibber(i) for i in range(n-addnum, n))
			memo.append(ans)
			return ans
	return fibber
 
>>> fibo = fiblike([1,1])
>>> [fibo(i) for i in range(10)]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> lucas = fiblike([2,1])
>>> [lucas(i) for i in range(10)]
[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]
>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :
	fibber = fiblike([1] + [2**i for i in range(n-1)])
	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))
 
 
n= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...
n= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...
n= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...
n= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...
n= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...
n= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...
n= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...
n= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...
n=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Get_system_command_output,Get system command output,"Task
Execute a system command and get its output into the program. The output may be stored in any kind of collection (array, list, etc.).




Related task
  Execute a system command

",Python,">>> import subprocess
>>> returned_text = subprocess.check_output(""dir"", shell=True, universal_newlines=True)
>>> type(returned_text)
<class 'str'>
>>> print(returned_text)
 Volume in drive C is Windows
 Volume Serial Number is 44X7-73CE
 
 Directory of C:\Python33
 
04/07/2013  06:40    <DIR>          .
04/07/2013  06:40    <DIR>          ..
27/05/2013  07:10    <DIR>          DLLs
27/05/2013  07:10    <DIR>          Doc
27/05/2013  07:10    <DIR>          include
27/05/2013  07:10    <DIR>          Lib
27/05/2013  07:10    <DIR>          libs
16/05/2013  00:15            33,326 LICENSE.txt
15/05/2013  22:49           214,554 NEWS.txt
16/05/2013  00:03            26,624 python.exe
16/05/2013  00:03            27,136 pythonw.exe
15/05/2013  22:49             6,701 README.txt
27/05/2013  07:10    <DIR>          tcl
27/05/2013  07:10    <DIR>          Tools
16/05/2013  00:02            43,008 w9xpopen.exe
               6 File(s)        351,349 bytes
               9 Dir(s)  46,326,947,840 bytes free
 
>>> # Ref: https://docs.python.org/3/library/subprocess.html",Human_written,Python_from_Java
http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",Python,"# Version 1.2.41
 
import csv
 
class Record:
    def __init__(self, account, password, uid, gid, gecos, directory, shell):
        self.account = account
        self.password = 
        self.uid = uid
        self.gid = gid
        self.gecos = gecos
        self.directory = directory
        self.shell = shell
    def __str__(self):
        return f""{self.account}:{self.password}:{self.uid}:{self.gid}:{','.join(self.gecos)}:{self.directory}:{self.shell}""
 
def parseRecord(line):
    fields = line.split(':')
    return Record(
        fields[0],
        fields[1],
        fields[2],
        fields[3],
        fields[4].split(','),
        fields[5],
        fields[6]
    )
 
def main():
    startData = [
        ""jsmith:x:1001:1000:,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash"",
        ""jdoe:x:1002:1000:,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash""
    ]
    records = [parseRecord(line) for line in startData]
    with open(""passwd.csv"", ""w"") as f:
        writer = csv.writer(f)
        for record in records:
            writer.writerow(record)
    print(""Initial records:\n"")
    with open(""passwd.csv"", ""r"") as f:
        reader = csv.reader(f)
        for record in reader:
            print(parseRecord(record))
 
    newData = ""xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash""
    record = parseRecord(newData)
    with open(""passwd.csv"", ""a"") as f:
        writer = csv.writer(f)
        writer.writerow(record)
    print(""\nRecords after another one is appended:\n"")
    with open(""passwd.csv"", ""r"") as f:
        reader = csv.reader(f)
        for record in reader:
            print(parseRecord(record))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_palindrome(s):
  return s == s[::-1]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Python,"import random
import time
 
def s_of_n_creator(n):
    s = []
    m = n
    def s_of_n(item):
        nonlocal s, m
        if len(s) < n:
            s.append(item)
        else:
            m += 1
            if random.randint(0, m) < n:
                s[random.randint(0, n - 1)] = item
        return s
    return s_of_n
 
if __name__ == '__main__':
    random.seed(time.time())
    freq = [0] * 10
    for r in range(100000):
        s_of_n = s_of_n_creator(3)
        for d in range(ord('0'), ord('9')):
            s_of_n(d)
        for d in s_of_n(ord('9')):
            freq[d - ord('0')] += 1
    print(freq)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Python,"def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = _matrix[row][int(digit)] 
    return row == 0
 
_matrix = (
    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),
    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),
    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),
    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),
    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),
    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),
    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),
    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),
    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),
    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)
)
 
if __name__ == '__main__':
    for test in [5724, 5727, 112946]:
        print(f'{test}\t Validates as: {damm(test)}')",Human_written,Python_from_C
http://rosettacode.org/wiki/N%27th,N'th,"Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix.



Example

Returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th



Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs:
0..25, 250..265, 1000..1025


Note: apostrophes are now optional to allow correct apostrophe-less English.



",Python,"class Nth:
	def ordinalAbbrev(n):
		ans = ""th"" #most of the time it should be ""th""
		if(n % 100 / 10 == 1): return ans #teens are all ""th""
		if(n % 10 == 1): ans = ""st""
		elif(n % 10 == 2): ans = ""nd""
		elif(n % 10 == 3): ans = ""rd""
		return ans
 
	def main():
		for i in range(0, 26):
			print(i + ordinalAbbrev(i) + "" "")
		print()
		for i in range(250, 266):
			print(i + ordinalAbbrev(i) + "" "")
		print()
		for i in range(1000, 1026):
			print(i + ordinalAbbrev(i) + "" "")
 
if __name__ == '__main__':
	main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/N-queens_problem,N-queens problem,"

Solve the eight queens puzzle.



You can extend the problem to solve the puzzle with a board of size   NxN.

For the number of solutions for small values of   N,   see   OEIS: A000170.



Related tasks

 A* search algorithm
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Knight's tour
 Peaceful chess queen armies
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"from itertools import permutations
 
n = 8
cols = range(n)
for vec in permutations(cols):
    if n == len(set(vec[i]+i for i in cols)) \
         == len(set(vec[i]-i for i in cols)):
        print ( vec )",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Time_a_function,Time a function,"Task

Write a program which uses a timer (with the least granularity available
on your system) to time how long a function takes to execute.

Whenever possible, use methods which measure only the processing time used
by the current process; instead of the difference in system time
between start and finish, which could include time used by
other processes on the computer.

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",Python,"import timeit

def nothing():
    pass

def sum():
    sum = 0
    for x in range(1, 1000000):
        sum += x
    return sum

print(timeit.timeit(""nothing()"", setup=""from __main__ import nothing"", number=1000000))
print(timeit.timeit(""sum()"", setup=""from __main__ import sum"", number=1000000))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Ulam_spiral_(for_primes),Ulam spiral (for primes),"An Ulam spiral (of primes) is a method of visualizing primes when expressed in a (normally counter-clockwise) outward spiral (usually starting at 1),   constructed on a square grid, starting at the ""center"".

An Ulam spiral is also known as a   prime spiral.

The first grid (green) is shown with sequential integers,   starting at   1.

In an Ulam spiral of primes, only the primes are shown (usually indicated by some glyph such as a dot or asterisk),   and all non-primes as shown as a blank   (or some other whitespace).

Of course, the grid and border are not to be displayed (but they are displayed here when using these Wiki HTML tables).

Normally, the spiral starts in the ""center"",   and the   2nd   number is to the viewer's right and the number spiral starts from there in a counter-clockwise direction.

There are other geometric shapes that are used as well, including clock-wise spirals.

Also, some spirals (for the   2nd   number)   is viewed upwards from the   1st   number instead of to the right, but that is just a matter of orientation.

Sometimes, the starting number can be specified to show more visual striking patterns (of prime densities).

[A larger than necessary grid (numbers wise) is shown here to illustrate the pattern of numbers on the diagonals   (which may be used by the method to orientate the direction of spiral-construction algorithm within the example computer programs)].

Then, in the next phase in the transformation of the Ulam prime spiral,   the non-primes are translated to blanks.

In the orange grid below,   the primes are left intact,   and all non-primes are changed to blanks.

Then, in the final transformation of the Ulam spiral (the yellow grid),   translate the primes to a glyph such as a    •    or some other suitable glyph.





 65 
 64 
 63 
 62 
 61 
 60 
 59 
 58 
 57


 66 
 37 
 36 
 35 
 34 
 33 
 32 
 31 
 56


 67 
 38 
 17 
 16 
 15 
 14 
 13 
 30 
 55


 68 
 39 
 18 
  5 
  4 
  3 
 12 
 29 
 54


 69 
 40 
 19 
  6 
  1 
  2 
 11 
 28 
 53


 70 
 41 
 20 
  7 
  8 
  9 
 10 
 27 
 52


 71 
 42 
 21 
 22 
 23 
 24 
 25 
 26 
 51


 72 
 43 
 44 
 45 
 46 
 47 
 48 
 49 
 50


 73 
 74 
 75 
 76 
 77 
 78 
 79 
 80 
 81



   
   
   
   
 61 
   
 59 
   
  


   
 37 
   
   
   
   
   
 31 
  


 67 
   
 17 
   
   
   
 13 
   
  


   
   
   
  5 
   
  3 
   
 29 
  


   
   
 19 
   
   
  2 
 11 
   
 53


   
 41 
   
  7 
   
   
   
   
  


 71 
   
   
   
 23 
   
   
   
  


   
 43 
   
   
   
 47 
   
   
  


 73 
   
   
   
   
   
 79 
   
  



   
   
   
   
  • 
   
  • 
   
  


   
  • 
   
   
   
   
   
  • 
  


  • 
   
  • 
   
   
   
  • 
   
  


   
   
   
  • 
   
  • 
   
  • 
  


   
   
  • 
   
   
  • 
  • 
   
  •


   
  • 
   
  • 
   
   
   
   
  


  • 
   
   
   
  • 
   
   
   
  


   
  • 
   
   
   
  • 
   
   
  


  • 
   
   
   
   
   
  • 
   
  



The Ulam spiral becomes more visually obvious as the grid increases in size.



Task
For any sized   N × N   grid,   construct and show an Ulam spiral (counter-clockwise) of primes starting at some specified initial number   (the default would be 1),   with some suitably   dotty   (glyph) representation to indicate primes,   and the absence of dots to indicate non-primes.

You should demonstrate the generator by showing at Ulam prime spiral large enough to (almost) fill your terminal screen.



Related tasks

   Spiral matrix
   Zig-zag matrix
   Identity matrix 
   Sequence of primes by Trial Division


See also
 Wikipedia entry:   Ulam spiral 
 MathWorld™ entry:   Prime Spiral

",Python,"import math
 
def is_prime(a):
    if a == 2:
        return True
    if a <= 1 or a % 2 == 0:
        return False
    max = int(math.sqrt(a))
    x = 3
    while x <= max:
        if a % x == 0:
            return False
        x += 2
    return True
 
class Ulam:
    def __init__(self, n, s, c):
        self.u = [["""" for x in range(n)] for y in range(n)]
        dir = 0
        y = int(n / 2)
        x = y - 1 if n % 2 == 0 else y
        for j in range(s, n * n + s):
            self.u[y][x] = ""{}"".format(j) if is_prime(j) else "" ---""
 
            if dir == 0:
                if x < n - 1 and self.u[y - 1][x] == """" and j > s:
                    dir = 1
            elif dir == 1:
                if self.u[y][x - 1] == """":
                    dir = 2
            elif dir == 2:
                if x == 0 or self.u[y + 1][x] == """":
                    dir = 3
            elif dir == 3:
                if self.u[y][x + 1] == """":
                    dir = 0
 
            if dir == 0:
                x += 1
            elif dir == 1:
                y -= 1
            elif dir == 2:
                x -= 1
            elif dir == 3:
                y += 1
 
    def __str__(self):
        return ""\n"".join(map(str, self.u))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Check_output_device_is_a_terminal,Check output device is a terminal,"Task

Demonstrate how to check whether the output device is a terminal or not.



Related task

   Check input device is a terminal

",Python,"import sys
 
if sys.stdout.isatty():
    print(""stdout is a tty"")
else:
    print(""stdout is not a tty"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Playfair_cipher,Playfair cipher,"Playfair cipher

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Implement a  Playfair cipher for encryption and decryption.



The user must be able to choose   J  =  I     or   no   Q   in the alphabet.

The output of the encrypted and decrypted message must be in capitalized digraphs, separated by spaces.



Output example

                HI DE TH EG OL DI NT HE TR EX ES TU MP


",Python,"from string import ascii_uppercase
from itertools import product
from re import findall
 
def uniq(seq):
    seen = {}
    return [seen.setdefault(x, x) for x in seq if x not in seen]
 
def partition(seq, n):
    return [seq[i : i + n] for i in xrange(0, len(seq), n)]
 
 
""""""Instantiate a specific encoder/decoder.""""""
def playfair(key, from_ = 'J', to = None):
    if to is None:
        to = 'I' if from_ == 'J' else ''
 
    def canonicalize(s):
        return filter(str.isupper, s.upper()).replace(from_, to)
 
    # Build 5x5 matrix.
    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)
 
    # Pregenerate all forward translations.
    enc = {}
 
    # Map pairs in same row.
    for row in m:
        for i, j in product(xrange(5), repeat=2):
            if i != j:
                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]
 
    # Map pairs in same column.
    for c in zip(*m):
        for i, j in product(xrange(5), repeat=2):
            if i != j:
                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]
 
    # Map pairs with cross-connections.
    for i1, j1, i2, j2 in product(xrange(5), repeat=4):
        if i1 != i2 and j1 != j2:
            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]
 
    # Generate reverse translations.
    dec = dict((v, k) for k, v in enc.iteritems())
 
    def sub_enc(txt):
        lst = findall(r""(.)(?:(?!\1)(.))?"", canonicalize(txt))
        return "" "".join(enc[a + (b if b else 'X')] for a, b in lst)
 
    def sub_dec(encoded):
        return "" "".join(dec[p] for p in partition(canonicalize(encoded), 2))
 
    return sub_enc, sub_dec
 
 
(encode, decode) = playfair(""Playfair example"")
orig = ""Hide the gold in...the TREESTUMP!!!""
print ""Original:"", orig
enc = encode(orig)
print ""Encoded:"", enc
print ""Decoded:"", decode(enc)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Morse_code,Morse code,"Morse code
It has been in use for more than 175 years — longer than any other electronic encoding system.



Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).



As the standard Morse code does not contain all possible characters,
you may either ignore unknown characters in the file,
or indicate them somehow   (e.g. with a different pitch).



",Python,"import time, winsound #, sys
 
char2morse = {          
          ""!"": ""---."",      ""\"""": "".-..-."",     ""$"": ""...-..-"",    ""'"": "".----."",  
          ""("": ""-.--."",      "")"": ""-.--.-"",     ""+"": "".-.-."",      "","": ""--..--"", 
          ""-"": ""-....-"",     ""."": "".-.-.-"",     ""/"": ""-..-."", 
          ""0"": ""-----"",      ""1"": "".----"",      ""2"": ""..---"",      ""3"": ""...--"", 
          ""4"": ""....-"",      ""5"": ""....."",      ""6"": ""-...."",      ""7"": ""--..."", 
          ""8"": ""---.."",      ""9"": ""----."", 
          "":"": ""---..."",     "";"": ""-.-.-."",     ""="": ""-...-"",      ""?"": ""..--.."", 
          ""@"": "".--.-."", 
          ""A"": "".-"",         ""B"": ""-..."",       ""C"": ""-.-."",       ""D"": ""-.."", 
          ""E"": ""."",          ""F"": ""..-."",       ""G"": ""--."",        ""H"": ""...."", 
          ""I"": "".."",         ""J"": "".---"",       ""K"": ""-.-"",        ""L"": "".-.."", 
          ""M"": ""--"",         ""N"": ""-."",         ""O"": ""---"",        ""P"": "".--."", 
          ""Q"": ""--.-"",       ""R"": "".-."",        ""S"": ""..."",        ""T"": ""-"", 
          ""U"": ""..-"",        ""V"": ""...-"",       ""W"": "".--"",        ""X"": ""-..-"", 
          ""Y"": ""-.--"",       ""Z"": ""--.."", 
          ""["": ""-.--."",      ""]"": ""-.--.-"",     ""_"": ""..--.-"",
 }
 
e = 50      # Element time in ms. one dit is on for e then off for e
f = 1280    # Tone freq. in hertz
chargap = 1 # Time between characters of a word, in units of e
wordgap = 7 # Time between words, in units of e
 
def gap(n=1):
    time.sleep(n * e / 1000)
off = gap
 
def on(n=1):
    winsound.Beep(f, n * e)
 
def dit():
    on(); off()
 
def dah():
    on(3); off()
 
def bloop(n=3):
    winsound.Beep(f//2, n * e)
 
def windowsmorse(text):
    for word in text.strip().upper().split():
        for char in word:
            for element in char2morse.get(char, '?'):
                if element == '-':
                    dah()
                elif element == '.':
                    dit()
                else:
                    bloop()
            gap(chargap)
        gap(wordgap)
 
# Outputs its own source file as Morse. An audible quine!
#with open(sys.argv[0], 'r') as thisfile:
#    windowsmorse(thisfile.read())
 
while True:
    windowsmorse(input('A string to change into morse: '))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",Python,"class Delegator(object):
    def __init__(self):
        self.delegate = None
    def operation(self):
        if hasattr(self.delegate, 'thing'):
            return self.delegate.thing()
        else:
            return 'default implementation'
 
class Delegate(object):
    def thing(self):
        return 'delegate implementation'
 
if __name__ == '__main__':
    # No delegate
    a = Delegator()
    print a.operation() # prints ""default implementation""
 
    # With a delegate that does not implement ""thing""
    a.delegate = 'A delegate may be any object'
    print a.operation() # prints ""default implementation""
 
    # With delegate that implements ""thing""
    a.delegate = Delegate()
    print a.operation() # prints ""delegate implementation""",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Water_collected_between_towers,Water collected between towers,"Task

In a two-dimensional world, we begin with any bar-chart (or row of close-packed 'towers', each of unit width), and then it rains,
completely filling all convex enclosures in the chart with water.



9               ██           9               ██    
8               ██           8               ██    
7     ██        ██           7     ██≈≈≈≈≈≈≈≈██    
6     ██  ██    ██           6     ██≈≈██≈≈≈≈██    
5 ██  ██  ██  ████           5 ██≈≈██≈≈██≈≈████    
4 ██  ██  ████████           4 ██≈≈██≈≈████████    
3 ██████  ████████           3 ██████≈≈████████    
2 ████████████████  ██       2 ████████████████≈≈██
1 ████████████████████       1 ████████████████████


In the example above, a bar chart representing the values [5, 3, 7, 2, 6, 4, 5, 9, 1, 2] has filled, collecting 14 units of water.

Write a function, in your language, from a given array of heights, to the number of water units that can be held in this way, by a corresponding bar chart.

Calculate the number of water units that could be collected by bar charts representing each of the following seven series:

   [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]


See, also:

 Four Solutions to a Trivial Problem – a Google Tech Talk by Guy Steele
 Water collected between towers on Stack Overflow, from which the example above is taken)
 An interesting Haskell solution, using the Tardis monad, by Phil Freeman in a Github gist.

",Python,"def a(array):
    n = len(array)
    left = {}
    right = {}
    left[0] = array[0]
    i = 1
    while i < n:
        left[i] = max(left[i - 1], array[i])
        i += 1
    right[n - 1] = array[n - 1]
    i = n - 2
    while i >= 0:
        right[i] = max(right[i + 1], array[i])
        i -= 1
    i = 0
    water = 0
    while i < n:
        water += min(left[i], right[i]) - array[i]
        i += 1
    print(water)

a([5, 3, 7, 2, 6, 4, 5, 9, 1, 2])
a([2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1])
a([5, 5, 5, 5])
a([5, 6, 7, 8])
a([8, 7, 7, 6])
a([6, 7, 10, 7, 6])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Penney%27s_game,Penney's game,"Penney's game is a game where two players bet on being the first to see a particular sequence of heads or tails in consecutive tosses of a fair coin.

It is common to agree on a sequence length of three then one player will openly choose a sequence, for example:

 Heads,  Tails,  Heads, or HTH for short.

The other player on seeing the first players choice will choose his sequence. The coin is tossed and the first player to see his sequence in the sequence of coin tosses wins.



Example

One player might choose the sequence HHT and the other THT.

Successive coin tosses of HTTHT gives the win to the second player as the last three coin tosses are his sequence.



Task
Create a program that tosses the coin, keeps score and plays Penney's game against a human opponent.

 Who chooses and shows their sequence of three should be chosen randomly.
 If going first, the computer should randomly choose its sequence of three.
 If going second, the computer should automatically play the optimum sequence.
 Successive coin tosses should be shown.


Show output of a game where the computer chooses first and a game where the user goes first here on this page.



See also
 The Penney Ante Part 1 (Video).
 The Penney Ante Part 2 (Video).

",Python,"import random
def main():
    y = 1
    while y == 1:
        print(""Enter your sequence:"")
        inp = input()
        Ai = [0, 0, 0]
        user = [0, 0, 0]
        for j in range(0, 3):
            if inp[j] == 104:
                user[j] = 1
            else:
                user[j] = 0
        for k in range(0, 3):
            Ai[k] = random.randint(0, 1)
        while user[0] == Ai[0] and user[1] == Ai[1] and user[2] == Ai[2]:
            for k in range(0, 3):
                Ai[k] = random.randint(0, 1)
        print(""You gave the sequence:"")
        printht(user)
        print()
        print(""The computer generated sequence is:"")
        printht(Ai)
        print()
        a1 = random.randint(0, 1)
        a2 = random.randint(0, 1)
        a3 = random.randint(0, 1)
        print(""The generated sequence is:"", end = "" "")
        printh(a1)
        printh(a2)
        printh(a3)
        match = 0
        while match == 0:
            if matches(user, a1, a2, a3) == 1:
                print()
                print(""You have won!!!"")
                match = 1
            elif matches(Ai, a1, a2, a3) == 1:
                print()
                print(""You lost!! Computer wins"")
                match = 1
            else:
                a1 = a2
                a2 = a3
                a3 = random.randint(0, 1)
                printh(a3)
        print(""Do you want to continue(0/1):"")
        y = int(input())
def printht(a):
    for i in range(0, 3):
        if a[i] == 1:
            print(""h"", end = """")
        else:
            print(""t"", end = """")
def printh(a):
    if a == 1:
        print(""h"", end = """")
    else:
        print(""t"", end = """")
def matches(a, p, q, r):
    if a[0] == p and a[1] == q and a[2] == r:
        return 1
    else:
        return 0
main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Zero_to_the_zero_power,Zero to the zero power,"Some computer programming languages are not exactly consistent   (with other computer programming languages)  

when   raising zero to the zeroth power:     00



Task

Show the results of raising   zero   to the   zeroth   power.



If your computer language objects to      0**0      or      0^0      at compile time,   you may also try something like:

           x = 0
           y = 0
           z = x**y
           say  'z='  z


Show the result here.

And of course use any symbols or notation that is supported in your computer programming language for exponentiation.



See also

 The Wiki entry: Zero to the power of zero. 
 The Wiki entry: History of differing points of view.
 The MathWorld™ entry: exponent laws.
 Also, in the above MathWorld™ entry, see formula (9): 




x

0


=
1


{\displaystyle x^{0}=1}

.
 The OEIS entry: The special case of zero to the zeroth power

",Python,"from decimal import Decimal
from fractions import Fraction
from itertools import product
 
zeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]
for i, j in product(zeroes, repeat=2):
    try:
        ans = i**j
    except:
        ans = '<Exception raised>'
    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Classes,Classes,"In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.

The first type T from the class T sometimes is called the root type of the class.

A class of types itself, as a type, has the values and operations of its own.
The operations of are usually called methods of the root type.
Both operations and values are called  polymorphic.

A polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.

The action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.
Operations with multiple arguments and/or the results of the class are called multi-methods.
A further generalization of is the operation with arguments and/or results from different classes.

 single-dispatch languages are those that allow only one argument or result to control the dispatch. Usually it is the first parameter, often hidden, so that a prefix notation x.f() is used instead of mathematical f(x).
 multiple-dispatch languages allow many arguments and/or results to control the dispatch.


A polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.
This type is sometimes called the most specific type of a [polymorphic] value.
The type tag of the value is used in order to resolve the dispatch.
The set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.

In many  OO languages
the type of the class of T and T itself are considered equivalent.
In some languages they are distinct (like in Ada).
When class T and T are equivalent, there is no way to distinguish
polymorphic and specific values.



Task

Create a basic class with a method, a constructor, an instance variable and how to instantiate it.



",Python,"class MyClass:
    name2 = 2 # Class attribute
 
    def __init__(self):
        """"""
        Constructor  (Technically an initializer rather than a true ""constructor"")
        """"""
        self.name1 = 0 # Instance attribute
 
    def someMethod(self):
        """"""
        Method
        """"""
        self.name1 = 1
        MyClass.name2 = 3
 
 
myclass = MyClass() # class name, invoked as a function is the constructor syntax.
 
class MyOtherClass:
    count = 0  # Population of ""MyOtherClass"" objects
    def __init__(self, name, gender=""Male"", age=None):
        """"""
        One initializer required, others are optional (with different defaults)
        """"""
        MyOtherClass.count += 1
        self.name = name
        self.gender = gender
        if age is not None:
            self.age = age
    def __del__(self):
        MyOtherClass.count -= 1
 
person1 = MyOtherClass(""John"")
print person1.name, person1.gender  # ""John Male""
print person1.age                   # Raises AttributeError exception!
person2 = MyOtherClass(""Jane"", ""Female"", 23)
print person2.name, person2.gender, person2.age  # ""Jane Female 23""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",Python,"from sympy import sieve # library for primes
 
def get_pfct(n): 
	i = 2; factors = []
	while i * i <= n:
		if n % i:
			i += 1
		else:
			n //= i
			factors.append(i)
	if n > 1:
		factors.append(n)
	return len(factors) 
 
sieve.extend(110) # first 110 primes...
primes=sieve._list
 
pool=[]
 
for each in xrange(0,121):
	pool.append(get_pfct(each))
 
for i,each in enumerate(pool):
	if each in primes:
		print i,",Human_written,Python_from_C
http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,"# version 1.1.2
 
def fibN(initial, numTerms):
    n = len(initial)
    assert n >= 2 and numTerms >= 0
    fibs = initial[:]
    if numTerms <= n: return fibs
    for i in range(n, numTerms):
        sum = 0
        for j in range(i - n, i): sum += fibs[j]
        fibs.append(sum)
    return fibs
 
def main():
    names = [""fibonacci"",  ""tribonacci"", ""tetranacci"", ""pentanacci"", ""hexanacci"",
             ""heptanacci"", ""octonacci"",  ""nonanacci"",  ""decanacci""]
    initial = [1, 1, 2, 4, 8, 16, 32, 64, 128, 256]
    print("" n  name        values"")
    values = fibN([2, 1], 15)
    print(""%2d  %-10s  %s"" % (2, ""lucas"", "", "".join(map(str, values))))
    for i in range(9):
        values = fibN(initial[:i + 2], 15)
        print(""%2d  %-10s  %s"" % (i + 2, names[i], "", "".join(map(str, values))))
 
main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Hello_world/Newline_omission,Hello world/Newline omission,"Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.



Task

Display the string   Goodbye, World!   without a trailing newline.



Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Standard error
   Hello world/Text

",Python,"from sys import stdout
 
def main():
  stdout.write(""Hello, World!"")    # No automatic newline
  return 0
 
if __name__ == ""__main__"":
  main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Terminal_control/Cursor_positioning,Terminal control/Cursor positioning,"

Task

Move the cursor to column   3,   row   6,   and display the word   ""Hello""   (without the quotes),   so that the letter   H   is in column   3   on row   6.



",Python,"print(""\033[6;3HHello"")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Check_Machin-like_formulas,Check Machin-like formulas,"Machin-like formulas   are useful for efficiently computing numerical approximations for 



π


{\displaystyle \pi }





Task

Verify the following Machin-like formulas are correct by calculating the value of tan   (right hand side) for each equation using exact arithmetic and showing they equal 1:

 





π
4


=
arctan
⁡


1
2


+
arctan
⁡


1
3




{\displaystyle {\pi \over 4}=\arctan {1 \over 2}+\arctan {1 \over 3}}

 
 





π
4


=
2
arctan
⁡


1
3


+
arctan
⁡


1
7




{\displaystyle {\pi \over 4}=2\arctan {1 \over 3}+\arctan {1 \over 7}}


 





π
4


=
4
arctan
⁡


1
5


−
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=4\arctan {1 \over 5}-\arctan {1 \over 239}}


 





π
4


=
5
arctan
⁡


1
7


+
2
arctan
⁡


3
79




{\displaystyle {\pi \over 4}=5\arctan {1 \over 7}+2\arctan {3 \over 79}}


 





π
4


=
5
arctan
⁡


29
278


+
7
arctan
⁡


3
79




{\displaystyle {\pi \over 4}=5\arctan {29 \over 278}+7\arctan {3 \over 79}}


 





π
4


=
arctan
⁡


1
2


+
arctan
⁡


1
5


+
arctan
⁡


1
8




{\displaystyle {\pi \over 4}=\arctan {1 \over 2}+\arctan {1 \over 5}+\arctan {1 \over 8}}

 
 





π
4


=
4
arctan
⁡


1
5


−
arctan
⁡


1
70


+
arctan
⁡


1
99




{\displaystyle {\pi \over 4}=4\arctan {1 \over 5}-\arctan {1 \over 70}+\arctan {1 \over 99}}

 
 





π
4


=
5
arctan
⁡


1
7


+
4
arctan
⁡


1
53


+
2
arctan
⁡


1
4443




{\displaystyle {\pi \over 4}=5\arctan {1 \over 7}+4\arctan {1 \over 53}+2\arctan {1 \over 4443}}


 





π
4


=
6
arctan
⁡


1
8


+
2
arctan
⁡


1
57


+
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=6\arctan {1 \over 8}+2\arctan {1 \over 57}+\arctan {1 \over 239}}


 





π
4


=
8
arctan
⁡


1
10


−
arctan
⁡


1
239


−
4
arctan
⁡


1
515




{\displaystyle {\pi \over 4}=8\arctan {1 \over 10}-\arctan {1 \over 239}-4\arctan {1 \over 515}}


 





π
4


=
12
arctan
⁡


1
18


+
8
arctan
⁡


1
57


−
5
arctan
⁡


1
239




{\displaystyle {\pi \over 4}=12\arctan {1 \over 18}+8\arctan {1 \over 57}-5\arctan {1 \over 239}}


 





π
4


=
16
arctan
⁡


1
21


+
3
arctan
⁡


1
239


+
4
arctan
⁡


3
1042




{\displaystyle {\pi \over 4}=16\arctan {1 \over 21}+3\arctan {1 \over 239}+4\arctan {3 \over 1042}}


 





π
4


=
22
arctan
⁡


1
28


+
2
arctan
⁡


1
443


−
5
arctan
⁡


1
1393


−
10
arctan
⁡


1
11018




{\displaystyle {\pi \over 4}=22\arctan {1 \over 28}+2\arctan {1 \over 443}-5\arctan {1 \over 1393}-10\arctan {1 \over 11018}}


 





π
4


=
22
arctan
⁡


1
38


+
17
arctan
⁡


7
601


+
10
arctan
⁡


7
8149




{\displaystyle {\pi \over 4}=22\arctan {1 \over 38}+17\arctan {7 \over 601}+10\arctan {7 \over 8149}}


 





π
4


=
44
arctan
⁡


1
57


+
7
arctan
⁡


1
239


−
12
arctan
⁡


1
682


+
24
arctan
⁡


1
12943




{\displaystyle {\pi \over 4}=44\arctan {1 \over 57}+7\arctan {1 \over 239}-12\arctan {1 \over 682}+24\arctan {1 \over 12943}}


 





π
4


=
88
arctan
⁡


1
172


+
51
arctan
⁡


1
239


+
32
arctan
⁡


1
682


+
44
arctan
⁡


1
5357


+
68
arctan
⁡


1
12943




{\displaystyle {\pi \over 4}=88\arctan {1 \over 172}+51\arctan {1 \over 239}+32\arctan {1 \over 682}+44\arctan {1 \over 5357}+68\arctan {1 \over 12943}}


and confirm that the following formula is incorrect by showing   tan   (right hand side)   is not   1:

 





π
4


=
88
arctan
⁡


1
172


+
51
arctan
⁡


1
239


+
32
arctan
⁡


1
682


+
44
arctan
⁡


1
5357


+
68
arctan
⁡


1
12944




{\displaystyle {\pi \over 4}=88\arctan {1 \over 172}+51\arctan {1 \over 239}+32\arctan {1 \over 682}+44\arctan {1 \over 5357}+68\arctan {1 \over 12944}}


These identities are useful in calculating the values:

 



tan
⁡
(
a
+
b
)
=



tan
⁡
(
a
)
+
tan
⁡
(
b
)


1
−
tan
⁡
(
a
)
tan
⁡
(
b
)





{\displaystyle \tan(a+b)={\tan(a)+\tan(b) \over 1-\tan(a)\tan(b)}}


 



tan
⁡

(
arctan
⁡


a
b


)

=


a
b




{\displaystyle \tan \left(\arctan {a \over b}\right)={a \over b}}


 



tan
⁡
(
−
a
)
=
−
tan
⁡
(
a
)


{\displaystyle \tan(-a)=-\tan(a)}




You can store the equations in any convenient data structure, but for extra credit parse them from human-readable text input.

Note: to formally prove the formula correct, it would have to be shown that 






−
3
p
i

4




{\displaystyle {-3pi \over 4}}

 < right hand side < 






5
p
i

4




{\displaystyle {5pi \over 4}}

 due to 



tan
⁡
(
)


{\displaystyle \tan()}

 periodicity.


",Python,"from fractions import Fraction
 
class mTerm:
    def __init__(self, a, n, d):
        self.a = a
        self.n = n
        self.d = d
 
testCases = [
    [mTerm(1, 1, 2), mTerm(1, 1, 3)],
    [mTerm(2, 1, 3), mTerm(1, 1, 7)],
    [mTerm(4, 1, 5), mTerm(-1, 1, 239)],
    [mTerm(5, 1, 7), mTerm(2, 3, 79)],
    [mTerm(1, 1, 2), mTerm(1, 1, 5), mTerm(1, 1, 8)],
    [mTerm(4, 1, 5), mTerm(-1, 1, 70), mTerm(1, 1, 99)],
    [mTerm(5, 1, 7), mTerm(4, 1, 53), mTerm(2, 1, 4443)],
    [mTerm(6, 1, 8), mTerm(2, 1, 57), mTerm(1, 1, 239)],
    [mTerm(8, 1, 10), mTerm(-1, 1, 239), mTerm(-4, 1, 515)],
    [mTerm(12, 1, 18), mTerm(8, 1, 57), mTerm(-5, 1, 239)],
    [mTerm(16, 1, 21), mTerm(3, 1, 239), mTerm(4, 3, 1042)],
    [mTerm(22, 1, 28), mTerm(2, 1, 443), mTerm(-5, 1, 1393), mTerm(-10, 1, 11018)],
    [mTerm(22, 1, 38), mTerm(17, 7, 601), mTerm(10, 7, 8149)],
    [mTerm(44, 1, 57), mTerm(7, 1, 239), mTerm(-12, 1, 682), mTerm(24, 1, 12943)],
    [mTerm(88, 1, 172), mTerm(51, 1, 239), mTerm(32, 1, 682), mTerm(44, 1, 5357), mTerm(68, 1, 12943)],
    [mTerm(88, 1, 172), mTerm(51, 1, 239), mTerm(32, 1, 682), mTerm(44, 1, 5357), mTerm(68, 1, 12944)],
]
 
def tans(m):
    if len(m) == 1:
        return tanEval(m[0].a, Fraction(m[0].n, m[0].d))
    half = len(m) // 2
    a = tans(m[:half])
    b = tans(m[half:])
    return (a + b) / (1 - a * b)
 
def tanEval(coef, f):
    if coef == 1:
        return f
    if coef < 0:
        return -tanEval(-coef, f)
    ca = coef // 2
    cb = coef - ca
    a = tanEval(ca, f)
    b = tanEval(cb, f)
    return (a + b) / (1 - a * b)
 
for m in testCases:
    print(""tan"", m, ""="", tans(m))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",Python,"def is_leap_year(year):
    if year % 400 == 0:
        return True
    elif year % 100 == 0:
        return False
    elif year % 4 == 0:
        return True
    else:
        return False",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",Python,"majors   = 'north east south west'.split()
majors   *= 2 # no need for modulo later
quarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')
quarter2 = [p.replace('NE','EN') for p in quarter1]
 
def degrees2compasspoint(d):
    d = (d % 360) + 360/64
    majorindex, minor = divmod(d, 90.)
    majorindex = int(majorindex)
    minorindex  = int( (minor*4) // 45 )
    p1, p2 = majors[majorindex: majorindex+2]
    if p1 in {'north', 'south'}:
        q = quarter1
    else:
        q = quarter2
    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()
 
if __name__ == '__main__':
    for i in range(33):
        d = i * 11.25
        m = i % 3
        if   m == 1: d += 5.62
        elif m == 2: d -= 5.62
        n = i % 32 + 1
        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"import argparse
import random
import shapely.geometry as geometry
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
 
 
def main(args):
    # Styles
    plt.style.use(""ggplot"")
 
    # Creating figure
    fig = plt.figure()
    line, = plt.plot([], [], ""."")
 
    # Limit axes
    plt.xlim(0, 1)
    plt.ylim(0, 1)
 
    # Titles
    title = ""Chaos Game""
    plt.title(title)
    fig.canvas.set_window_title(title)
 
    # Getting data
    data = get_data(args.frames)
 
    # Creating animation
    line_ani = animation.FuncAnimation(
        fig=fig,
        func=update_line,
        frames=args.frames,
        fargs=(data, line),
        interval=args.interval,
        repeat=False
    )
 
    # To save the animation install ffmpeg and uncomment
    # line_ani.save(""chaos_game.gif"")
 
    plt.show()
 
 
def get_data(n):
    """"""
    Get data to plot
    """"""
    leg = 1
    triangle = get_triangle(leg)
    cur_point = gen_point_within_poly(triangle)
    data = []
    for _ in range(n):
        data.append((cur_point.x, cur_point.y))
        cur_point = next_point(triangle, cur_point)
    return data
 
 
def get_triangle(n):
    """"""
    Create right triangle
    """"""
    ax = ay = 0.0
    a = ax, ay
 
    bx = 0.5  *  n
    by = 0.75 * (n ** 2)
    b = bx, by
 
    cx = n
    cy = 0.0
    c = cx, cy
 
    triangle = geometry.Polygon([a, b, c])
    return triangle
 
 
def gen_point_within_poly(poly):
    """"""
    Generate random point inside given polygon
    """"""
    minx, miny, maxx, maxy = poly.bounds
    while True:
        x = random.uniform(minx, maxx)
        y = random.uniform(miny, maxy)
        point = geometry.Point(x, y)
        if point.within(poly):
            return point
 
 
def next_point(poly, point):
    """"""
    Generate next point according to chaos game rules
    """"""
    vertices = poly.boundary.coords[:-1]  # Last point is the same as the first one
    random_vertex = geometry.Point(random.choice(vertices))
    line = geometry.linestring.LineString([point, random_vertex])
    return line.centroid
 
 
def update_line(num, data, line):
    """"""
    Update line with new points
    """"""
    new_data = zip(*data[:num]) or [(), ()]
    line.set_data(new_data)
    return line,
 
 
if __name__ == ""__main__"":
    arg_parser = argparse.ArgumentParser(description=""Chaos Game by Suenweek (c) 2017"")
    arg_parser.add_argument(""-f"", dest=""frames"", type=int, default=1000)
    arg_parser.add_argument(""-i"", dest=""interval"", type=int, default=10)
 
    main(arg_parser.parse_args())",Human_written,Python_from_C#
http://rosettacode.org/wiki/Convex_hull,Convex hull,"Find the points which form a convex hull from a set of arbitrary two dimensional points.

For example, given the points (16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2) and (12,10) the convex hull would be (-9,-3), (-3,-9), (19,-8), (17,5), (12,17), (5,19) and (-3,15).




See also
 Convex Hull (youtube)
 http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/

",Python,"import operator
 
def print(os, p):
    return os + ""("" + str(p[0]) + "", "" + str(p[1]) + "")""
 
def print_vector(os, v):
    it = iter(v)
    end = len(v)
 
    os += ""[""
 
    if end > 0:
        os = print(os, next(it))
    while end > 0:
        os += "", ""
        os = print(os, next(it))
        end -= 1
 
    return os + ""]""
 
# returns true if the three points make a counter-clockwise turn
def ccw(a, b, c):
    return ((b[0] - a[0]) * (c[1] - a[1])) > ((b[1] - a[1]) * (c[0] - a[0]))
 
def convexHull(p):
    if len(p) == 0:
        return []
    p.sort(key=operator.itemgetter(0))
 
    h = []
 
    # lower hull
    for pt in p:
        while len(h) >= 2 and not ccw(h[-2], h[-1], pt):
            h.pop()
        h.append(pt)
 
    # upper hull
    t = len(h) + 1
    for pt in reversed(p):
        while len(h) >= t and not ccw(h[-2], h[-1], pt):
            h.pop()
        h.append(pt)
 
    h.pop()
    return h
 
if __name__ == ""__main__"":
    points = [
        (16, 3),  (12, 17), (0,  6),  (-4, -6), (16,  6),
        (16, -7), (16, -3), (17, -4), (5, 19),  (19, -8),
        (3, 16),  (12, 13), (3, -4),  (17,  5), (-3, 15),
        (-3, -9), (0, 11),  (-9, -3), (-4, -2), (12, 10)
    ]
 
    hull = convexHull(points)
    print(""Convex Hull: "", end="""")
    print_vector(print("""", hull), hull)
    print()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/RIPEMD-160,RIPEMD-160,"RIPEMD-160 is another hash function; it computes a 160-bit message digest.

There is a RIPEMD-160 home page, with test vectors and pseudocode for RIPEMD-160.
For padding the message, RIPEMD-160 acts like MD4 (RFC 1320).

Find the RIPEMD-160 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code”.
You may either call an RIPEMD-160 library, or implement RIPEMD-160 in your language.
",Python,"import hashlib
 
def ripemd160(text):
    return hashlib.new('ripemd160', text.encode('utf-8')).hexdigest()
 
if __name__ == '__main__':
    print(ripemd160('Rosetta Code'))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Eban_numbers,Eban numbers,"

Definition

An   eban   number is a number that has no letter    e    in it when the number is spelled in English.

Or more literally,   spelled numbers that contain the letter   e   are banned.



The American version of spelling numbers will be used here   (as opposed to the British).

2,000,000,000   is two billion,   not   two milliard.



Only numbers less than   one sextillion   (1021)   will be considered in/for this task.

This will allow optimizations to be used.



Task

   show all eban numbers   ≤   1,000   (in a horizontal format),   and a count
   show all eban numbers between   1,000   and   4,000   (inclusive),   and a count
   show a count of all eban numbers up and including           10,000
   show a count of all eban numbers up and including         100,000
   show a count of all eban numbers up and including      1,000,000
   show a count of all eban numbers up and including    10,000,000
   show all output here.


See also

   The MathWorld entry:   eban numbers.
   The OEIS entry:   A6933, eban numbers.

",Python,"# Use inflect
 
""""""
 
  show all eban numbers <= 1,000 (in a horizontal format), and a count
  show all eban numbers between 1,000 and 4,000 (inclusive), and a count
  show a count of all eban numbers up and including 10,000
  show a count of all eban numbers up and including 100,000
  show a count of all eban numbers up and including 1,000,000
  show a count of all eban numbers up and including 10,000,000
 
""""""
 
import inflect
import time
 
before = time.perf_counter()
 
p = inflect.engine()
 
# eban numbers <= 1000
 
print(' ')
print('eban numbers up to and including 1000:')
print(' ')
 
count = 0
 
for i in range(1,1001):
    if not 'e' in p.number_to_words(i):
        print(str(i)+' ',end='')
        count += 1
 
print(' ')
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers 1000 to 4000
 
print(' ')
print('eban numbers between 1000 and 4000 (inclusive):')
print(' ')
 
count = 0
 
for i in range(1000,4001):
    if not 'e' in p.number_to_words(i):
        print(str(i)+' ',end='')
        count += 1
 
print(' ')
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 10000
 
print(' ')
print('eban numbers up to and including 10000:')
print(' ')
 
count = 0
 
for i in range(1,10001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 100000
 
print(' ')
print('eban numbers up to and including 100000:')
print(' ')
 
count = 0
 
for i in range(1,100001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 1000000
 
print(' ')
print('eban numbers up to and including 1000000:')
print(' ')
 
count = 0
 
for i in range(1,1000001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 10000000
 
print(' ')
print('eban numbers up to and including 10000000:')
print(' ')
 
count = 0
 
for i in range(1,10000001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
after = time.perf_counter()
 
print("" "")
print(""Run time in seconds: ""+str(after - before))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Read_a_configuration_file,Read a configuration file,"The task is to read a configuration file in standard configuration file format,
and set variables accordingly.

For this task, we have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines beginning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# This is the fullname parameter
FULLNAME Foo Barber

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# Configuration option names are not case sensitive, but configuration parameter
# data is case sensitive and may be preserved by the application program.

# An optional equals sign can be used to separate configuration parameter data
# from the option name. This is dropped by the parser. 

# A configuration option may take multiple parameters separated by commas.
# Leading and trailing whitespace around parameter names and parameter data fields
# are ignored by the application program.

OTHERFAMILY Rhu Barber, Harry Barber



For the task we need to set four variables according to the configuration entries as follows:

fullname = Foo Barber
favouritefruit = banana
needspeeling = true
seedsremoved = false


We also have an option that contains multiple parameters. These may be stored in an array.

 otherfamily(1) = Rhu Barber
 otherfamily(2) = Harry Barber


Related tasks
 Update a configuration file

",Python,"def readconf(fn):
    ret = {}
    with file(fn) as fp:
        for line in fp:
            # Assume whitespace is ignorable
            line = line.strip()
            if not line or line.startswith('#'): continue
 
            boolval = True
            # Assume leading "";"" means a false boolean
            if line.startswith(';'):
                # Remove one or more leading semicolons
                line = line.lstrip(';')
                # If more than just one word, not a valid boolean
                if len(line.split()) != 1: continue
                boolval = False
 
            bits = line.split(None, 1)
            if len(bits) == 1:
                # Assume booleans are just one standalone word
                k = bits[0]
                v = boolval
            else:
                # Assume more than one word is a string value
                k, v = bits
            ret[k.lower()] = v
    return ret
 
 
if __name__ == '__main__':
    import sys
    conf = readconf(sys.argv[1])
    for k, v in sorted(conf.items()):
        print k, '=', v",Human_written,Python_from_C++
http://rosettacode.org/wiki/Pentagram,Pentagram,"
A pentagram is a star polygon, consisting of a central pentagon of which each side forms the base of an isosceles triangle. The vertex of each triangle, a point of the star, is 36 degrees.




Task

Draw (or print) a regular pentagram, in any orientation. Use a different color (or token) for stroke and fill, and background. For the fill it should be assumed that all points inside the triangles and the pentagon are inside the pentagram.




See also
 Angle sum of a pentagram

",Python,"import math
import cairocffi as cairo
 
def pentagram(x, y, r):
    points = []
    for i in range(5):
        fi = i
        angle = 2 * math.pi * fi / 5 - math.pi / 2
        points.append((x + r * math.cos(angle), y + r * math.sin(angle)))
    return points
 
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 640, 640)
ctx = cairo.Context(surface)
ctx.set_source_rgb(1, 1, 1) # White
ctx.paint()
points = pentagram(320, 320, 250)
ctx.move_to(points[0][0], points[0][1])
for i in range(5):
    index = (i * 2) % 5
    p = points[index]
    ctx.line_to(p[0], p[1])
ctx.set_source_rgb(0.392, 0.584, 0.929) # Cornflower Blue
ctx.set_fill_rule(cairo.FILL_RULE_WINDING)
ctx.fill_preserve()
ctx.set_source_rgb(0, 0, 0) # Black
ctx.set_line_width(5)
ctx.stroke()
surface.write_to_png(""pentagram.png"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class Node(object):
     def __init__(self, data = None, prev = None, next = None):
         self.prev = prev
         self.next = next
         self.data = data
     def __str__(self):
         return str(self.data)
     def __repr__(self):
         return repr(self.data)
     def iter_forward(self):
         c = self
         while c != None:
             yield c
             c = c.next
     def iter_backward(self):
         c = self
         while c != None:
             yield c
             c = c.prev",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,"def sort_disjoint(values, indices):
    sublist = []
    indices.sort(reverse=True)

    for i in range(len(indices)):
        sublist.append(values[indices[i]])

    sublist.sort()

    for i in range(len(indices)):
        values[indices[i]] = sublist.pop()

    return values",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape,Create a file on magnetic tape,"The task is to create a new file called ""TAPE.FILE"" of any size on Magnetic Tape.
",Python,">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\n')
... 
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/FizzBuzz,FizzBuzz,"Task

Write a program that prints the integers from   1   to   100   (inclusive).



But:

   for multiples of three,   print   Fizz     (instead of the number)
   for multiples of five,   print   Buzz     (instead of the number)
   for multiples of both three and five,   print   FizzBuzz     (instead of the number) 


The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.



Also see

   (a blog)   dont-overthink-fizzbuzz
   (a blog)   fizzbuzz-the-programmers-stairway-to-heaven

",Python,"v = [1, 2, 3, 4, 5]
for val in v:
    print(""Got: {}"".format(val))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Levenshtein_distance/Alignment,Levenshtein distance/Alignment,"The Levenshtein distance algorithm returns the number of atomic operations (insertion, deletion or edition) that must be performed on a string in order to obtain an other one, but it does not say anything about the actual operations used or their order.

An alignment is a notation used to describe the operations used to turn a string into an other. At some point in the strings, the minus character ('-') is placed in order to signify that a character must be added at this very place. For instance, an alignment between the words 'place' and 'palace' is:

P-LACE
PALACE



Task

Write a function that shows the alignment of two strings for the corresponding levenshtein distance.

As an example, use the words ""rosettacode"" and ""raisethysword"".

You can either implement an algorithm, or use a dedicated library (thus showing us how it is named in your language).



",Python,"# version 1.1.3
 
def levenshteinAlign(a, b):
    aa = a.lower()
    bb = b.lower()
    costs = [[j for j in range(len(bb) + 1)] for i in range(len(aa) + 1)]
    for j in range(1, len(bb) + 1):
        costs[0][j] = j
    for i in range(1, len(aa) + 1):
        costs[i][0] = i
        for j in range(1, len(bb) + 1):
            temp = costs[i - 1][j - 1] + (0 if aa[i - 1] == bb[j - 1] else 1)
            costs[i][j] = min(1 + min(costs[i - 1][j], costs[i][j - 1]), temp)
 
    # walk back through matrix to figure out path
    aPathRev = []
    bPathRev = []
    i = len(aa)
    j = len(bb)
    while i!= 0 and j!= 0:
        temp = costs[i - 1][j - 1] + (0 if aa[i - 1] == bb[j - 1] else 1)
        if costs[i][j] == temp:
            aPathRev.append(aa[i - 1])
            bPathRev.append(bb[j - 1])
            i -= 1
            j -= 1
        elif 1 + costs[i - 1][j] == costs[i][j]:
            aPathRev.append(aa[i - 1])
            bPathRev.append('-')
            i -= 1
        elif 1 + costs[i][j - 1] == costs[i][j]:
            aPathRev.append('-')
            bPathRev.append(bb[j - 1])
            j -= 1
 
    return [''.join(reversed(aPathRev)), ''.join(reversed(bPathRev))]
 
if __name__ == '__main__':
    result = levenshteinAlign(""place"", ""palace"")
    print(result[0])
    print(result[1])
    print()    
    result = levenshteinAlign(""rosettacode"",""raisethysword"")
    print(result[0])
    print(result[1])",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Combinations,Combinations,"Task

Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).



Example

3   comb    5      is:

0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

If it is more ""natural"" in your language to start counting from    1   (unity) instead of    0   (zero),

the combinations can be of the integers from    1   to    n. 



See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"def comb(m, n):
    return [list(i) for i in itertools.combinations(range(n), m)]
 
comb(3, 5)  # => [[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",Python,"import os
import sys
 
tree = set()
 
for entry in os.listdir(os.getcwd()):
    tree.add(entry)
 
for entry in tree:
    print(entry)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running,Determine if only one instance is running,"This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.
",Python,"import socket
 
def create_app_lock(port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind((""0.0.0.0"", port))
        return sock
    except socket.error:
        raise Exception(""Couldn't lock port {}: another instance already running?"".format(port))
 
def remove_app_lock(sock):
    sock.close()
 
if __name__ == ""__main__"":
    sock = create_app_lock(12345)
    #...
    # your code here
    #...
    remove_app_lock(sock)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Fixed_length_records,Fixed length records,"Fixed length read/write

Before terminals, computers commonly used punch card readers or paper tape input.

A common format before these devices were superseded by terminal technology was based on the Hollerith code, Hollerith code.

These input devices handled 80 columns per card and had a limited character set, encoded by punching holes in one or more rows of the card for each column.

These devices assumed/demanded a fixed line width of 80 characters, newlines were not required (and could not even be encoded in some systems).

Task

Write a program to read 80 column fixed length records (no newline terminators (but newline characters allowed in the data)) and then write out the reverse of each line as fixed length 80 column records.

Samples here use printable characters, but that is not a given with fixed length data. Filenames used are sample.txt, infile.dat, outfile.dat.

Note: There are no newlines, inputs and outputs are fixed at 80 columns, no more, no less, space padded. Fixed length data is 8 bit complete. NUL bytes of zero are allowed.

These fixed length formats are still in wide use on mainframes, with JCL and with COBOL (which commonly use EBCDIC encoding and not ASCII). Most of the large players in day to day financial transactions know all about fixed length records and the expression logical record length.

Sample data

To create the sample input file, use an editor that supports fixed length records or use a conversion utility. For instance, most GNU/Linux versions of dd support blocking and unblocking records with a conversion byte size.

Line 1...1.........2.........3.........4.........5.........6.........7.........8
Line 2
Line 3
Line 4

Line 6
Line 7
     Indented line 8............................................................
Line 9                                                                 RT MARGIN


prompt$ dd if=sample.txt of=infile.dat cbs=80 conv=block
prompt$ dd if=infile.dat cbs=80 conv=unblock


Bonus round

Forth systems often include BLOCK words. A block is 1024 bytes. Source code is stored as 16 lines of 64 characters each (again, no newline character or sequence to mark the end of a line).

Write a program to convert a block file to text (using newlines). Trailing spaces should be excluded from the output.

Also demonstrate how to convert from a normal text file to block form. All lines either truncated or padded to 64 characters with no newline terminators. The last block filled to be exactly 1024 characters by adding blanks if needed. Assume a full range of 8 bit byte values for each character.

The COBOL example uses forth.txt and forth.blk filenames.



",Python,"import sys
from pathlib import Path
 
def reverse_file(input_filename, output_filename, record_len):
    with open(input_filename, ""rb"") as input:
        with open(output_filename, ""wb"") as output:
            buffer = bytearray(record_len)
            while input.readinto(buffer) == record_len:
                buffer.reverse()
                output.write(buffer)
 
if __name__ == ""__main__"":
    if len(sys.argv)!= 4:
        print(""Usage: {} infile.dat outfile.dat record_len"".format(sys.argv[0]))
        sys.exit(1)
    input_filename = sys.argv[1]
    output_filename = sys.argv[2]
    record_len = int(sys.argv[3])
    try:
        reverse_file(input_filename, output_filename, record_len)
    except OSError as error:
        print(""I/O error: {}"".format(error))
        sys.exit(1)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Factorions,Factorions,"

Definition

A factorion is a natural number that equals the sum of the factorials of its digits.



Example
 
145   is a factorion in base 10 because:


          1! + 4! + 5!   =   1 + 24 + 120   =   145 





It can be shown (see talk page) that no factorion in base 10 can exceed   1,499,999.



Task

Write a program in your language to demonstrate, by calculating and printing out the factorions, that:

   There are   3   factorions in base   9
   There are   4   factorions in base 10
   There are   5   factorions in base 11 
   There are   2   factorions in base 12     (up to the same upper bound as for base 10)


See also

 Wikipedia article
 OEIS:A014080 - Factorions in base 10
 OEIS:A193163 - Factorions in base n

",Python,"import math
import sys
 
def main():
    # cache factorials from 0 to 11
    fact = [1]
    for n in range(1, 12):
        fact.append(fact[n-1] * n)
 
    for b in range(9, 13):
        print(""The factorions for base %d are:"" % b)
        for i in range(1, 1500000):
            digits = str(i).translate(None, ""0123456789"")
            sum = 0
            for digit in digits:
                sum += fact[int(digit)]
            if sum == i:
                print(i),
        print(""\n"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Combinations,Combinations,"Task

Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).



Example

3   comb    5      is:

0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

If it is more ""natural"" in your language to start counting from    1   (unity) instead of    0   (zero),

the combinations can be of the integers from    1   to    n. 



See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,">>> from itertools import combinations
>>> list(combinations(range(5),3))
[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]",Human_written,Python_from_C
http://rosettacode.org/wiki/Yahoo!_search_interface,Yahoo! search interface,"Create a class for searching Yahoo! results.

It must implement a Next Page method, and read URL, Title and Content from results.



",Python,"import urllib
import re
 
def fix(x):
    p = re.compile(r'<[^<]*?>')
    return p.sub('', x).replace('&amp;', '&')
 
class YahooSearch:
    def __init__(self, query, page=1):       
        self.query = query
        self.page = page
        self.url = ""http://search.yahoo.com/search?p=%s&b=%s"" %(self.query, ((self.page - 1) * 10 + 1))
        self.content = urllib.urlopen(self.url).read()        
 
    def getresults(self):
        self.results = []
 
        for i in re.findall('<a class=""yschttl spt"" href="".+?"">(.+?)</a></h3></div>(.+?)</div>.*?<span class=url>(.+?)</span>', self.content):
 
            title = fix(i[0])
            content = fix(i[1])
            url = fix(i[2])
 
            self.results.append(YahooResult(title, content, url))
 
        return self.results
 
    def getnextpage(self):
        return YahooSearch(self.query, self.page+1)
 
    search_results = property(fget=getresults)
    nextpage = property(fget=getnextpage)
 
class YahooResult:
    def __init__(self,title,content,url):
        self.title = title
        self.content = content
        self.url = url
 
# Usage:
 
x = YahooSearch(""test"")
 
for result in x.search_results:
    print result.title",Human_written,Python_from_C#
http://rosettacode.org/wiki/Lychrel_numbers,Lychrel numbers,"   Take an integer n, greater than zero.
   Form the next n of its series by reversing the digits of the current n and adding the result to the current n.
   Stop when n becomes palindromic - i.e. the digits of n in reverse order == n.


The above recurrence relation when applied to most starting numbers n = 1, 2, ... terminates in a palindrome quite quickly.



Example

If n0 = 12 we get

       12
       12 +  21 =  33,   a palindrome!

And if n0 = 55 we get

       55
       55 +  55 = 110
      110 + 011 = 121,   a palindrome!

Notice that the check for a palindrome happens   after   an addition.



Some starting numbers seem to go on forever; the recurrence relation for 196 has been calculated for millions of repetitions forming numbers with millions of digits, without forming a palindrome.

These numbers that do not end in a palindrome are called Lychrel numbers.

For the purposes of this task a Lychrel number is any starting number that does not form a palindrome within 500 (or more) iterations.



Seed and related Lychrel numbers

Any integer produced in the sequence of a Lychrel number is also a Lychrel number.

In general, any sequence from one Lychrel number might converge to join the sequence from a prior Lychrel number candidate; for example the sequences for the numbers 196 and then 689 begin:

        196
        196 +    691 =   887
        887 +    788 =  1675
       1675 +   5761 =  7436
       7436 +   6347 = 13783
      13783 +  38731 = 52514
      52514 +  41525 = 94039
       ...


        689
        689 +    986 =  1675
       1675 +   5761 =  7436
       ...

So we see that the sequence starting with 689 converges to, and continues with the same numbers as that for 196.

Because of this we can further split the Lychrel numbers into true Seed Lychrel number candidates, and Related numbers that produce no palindromes but have integers in their sequence seen as part of the sequence generated from a lower Lychrel number.



Task

   Find the number of seed Lychrel number candidates and related numbers for n in the range 1..10000 inclusive. (With that iteration limit of 500).
   Print the number of seed Lychrels found; the actual seed Lychrels; and just the number of relateds found.
   Print any seed Lychrel or related number that is itself a palindrome.


Show all output here.



References

   What's special about 196? Numberphile video.
   A023108 Positive integers which apparently never result in a palindrome under repeated applications of the function f(x) = x + (x with digits reversed).
   Status of the 196 conjecture? Mathoverflow.

",Python,"from typing import List, Tuple
from collections import defaultdict
 
def reverse(n: int) -> int:
    rev = 0
    while n > 0:
        rev = rev * 10 + (n % 10)
        n //= 10
    return rev
 
def print_vector(vec: List[int]) -> None:
    if not vec:
        return
    print(vec[0], end='')
    for i in range(1, len(vec)):
        print(f"", {vec[i]}"", end='')
    print()
 
def main() -> None:
    cache: defaultdict[int, Tuple[bool, int]] = defaultdict(lambda: (True, 0))
    seeds: List[int] = []
    related: List[int] = []
    palindromes: List[int] = []
    for n in range(1, 10001):
        p: Tuple[bool, int] = (True, n)
        seen: List[int] = []
        rev = reverse(n)
        sum_ = n
        for i in range(500):
            sum_ += rev
            rev = reverse(sum_)
            if rev == sum_:
                p = (False, 0)
                break
            if sum_ in cache:
                p = cache[sum_]
                break
            seen.append(sum_)
        for s in seen:
            cache[s] = p
        if not p[0]:
            continue
        if p[1] == n:
            seeds.append(n)
        else:
            related.append(n)
        if n == reverse(n):
            palindromes.append(n)
    print(f""number of seeds: {len(seeds)}"")
    print(""seeds: "", end='')
    print_vector(seeds)
    print(f""number of related: {len(related)}"")
    print(""palindromes: "", end='')
    print_vector(palindromes)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bitmap,Bitmap,"Show a basic storage type to handle a simple RGB raster graphics image,
and some primitive associated functions.

If possible provide a function to allocate an uninitialised image,
given its width and height, and provide 3 additional functions:

   one to fill an image with a plain RGB color,
   one to set a given pixel with a color,
   one to get the color of a pixel.


(If there are specificities about the storage or the allocation, explain those.)

These functions are used as a base for the articles in the category raster graphics operations, 
and a basic output function to check the results
is available in the article write ppm file.



",Python,"class RGBColour(object):
    def __init__(self, red, green, blue):
        if not (0 <= red <= 255 and 0 <= green <= 255 and 0 <= blue <= 255):
            raise ValueError(""invalid RGB parameters: %s"" % ([red, green, blue]))
        self.red, self.green, self.blue = red, green, blue
    def __getattr__(self, name):
        if name == 'r':
            return self.red
        elif name == 'g':
            return self.green
        elif name == 'b':
            return self.blue
        else:
            raise AttributeError(name)
    RED   = RGBColour(255,0,0)
    GREEN = RGBColour(0,255,0)
    BLUE  = RGBColour(0,0,255)
    BLACK = RGBColour(0,0,0)
    WHITE = RGBColour(255,255,255)
 
class Pixmap(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.data = self.fill(RGBColour.WHITE)
    def fill(self, colour):
        return [[colour for y in range(self.height)] for x in range(self.width)]
    def validate_pixel(self, x, y):
        if not (0 <= x < self.width and 0 <= y < self.height):
            raise ValueError(""requested pixel (%d, %d) is outside dimensions of this bitmap"" % (x, y))
    def __getitem__(self, (x, y)):
        self.validate_pixel(x, y)
        return self.data[x][y]
    def __setitem__(self, (x, y), colour):
        self.validate_pixel(x, y)
        self.data[x][y] = colour",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists,Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",Python,"from typing import List
 
def print(v: List[List[int]]) -> None:
    print(""{ "", end="""")
    for p in v:
        print(""("", end="""")
        for e in p:
            print(e, end="" "")
        print("") "", end="""")
    print(""}"")
 
def product(lists: List[List[int]]) -> List[List[int]]:
    result = []
    if any(len(e) == 0 for e in lists):
        return result
    for e in lists[0]:
        result.append([e])
    for i in range(1, len(lists)):
        temp = []
        for e in result:
            for f in lists[i]:
                e_tmp = e.copy()
                e_tmp.append(f)
                temp.append(e_tmp)
        result = temp
    return result
 
prods = [
    [[1, 2], [3, 4]],
    [[3, 4], [1, 2]],
    [[1, 2], []],
    [[], [1, 2]],
    [[1776, 1789], [7, 12], [4, 14, 23], [0, 1]],
    [[1, 2, 3], [30], [500, 100]],
    [[1, 2, 3], [], [500, 100]]
]
 
for p in prods:
    print(product(p))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",Python,"import sys
with open(sys.argv[0]) as quine:
    code = raw_input(""Enter source code: "")
    if code == quine.read():
        print(""Accept"")
    else:
        print(""Reject"")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Color_wheel,Color wheel,"Task

Write a function to draw a HSV color wheel completely with code.

This is strictly for learning purposes only. It's highly recommended that you use an image in an actual application to actually draw the color wheel   (as procedurally drawing is super slow). This does help you understand how color wheels work and this can easily be used to determine a color value based on a position within a circle.


",Python,"import java.awt.*;
import javax.swing.*;
 
public class ColorWheel {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                ColorWheelFrame frame = new ColorWheelFrame();
                frame.setVisible(true);
            }
        });
    }
 
    private static class ColorWheelFrame extends JFrame {
        private ColorWheelFrame() {
            super(""Color Wheel"");
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            getContentPane().add(new ColorWheelPanel());
            pack();
        }
    }
 
    private static class ColorWheelPanel extends JComponent {
        private ColorWheelPanel() {
            setPreferredSize(new Dimension(400, 400));
        }
        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D)g;
            int w = getWidth();
            int h = getHeight();
            int margin = 10;
            int radius = (Math.min(w, h) - 2 * margin)/2;
            int cx = w/2;
            int cy = h/2;
            float[] dist = {0.F, 1.0F};
            g2.setColor(Color.BLACK);
            g2.fillRect(0, 0, w, h);
            for (int angle = 0; angle < 360; ++angle) {
                Color color = hsvToRgb(angle, 1.0, 1.0);
                Color[] colors = {Color.WHITE, color};
                RadialGradientPaint paint = new RadialGradientPaint(cx, cy,
                        radius, dist, colors);
                g2.setPaint(paint);
                g2.fillArc(cx - radius, cy - radius, radius*2, radius*2,
                        angle, 1);
            }
        }
    }
 
    private static Color hsvToRgb(int h, double s, double v) {
        double hp = h/60.0;
        double c = s * v;
        double x = c * (1 - Math.abs(hp % 2.0 - 1));
        double m = v - c;
        double r = 0, g = 0, b = 0;
        if (hp <= 1) {
            r = c;
            g = x;
        } else if (hp <= 2) {
            r = x;
            g = c;
        } else if (hp <= 3) {
            g = c;
            b = x;
        } else if (hp <= 4) {
            g = x;
            b = c;
        } else if (hp <= 5) {
            r = x;
            b = c;
        } else {
            r = c;
            b = x;
        }
        r += m;
        g += m;
        b += m;
        return new Color((int)(r * 255), (int)(g * 255), (int)(b * 255));
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"import sys
from array import array
 
MAX_CELLS = 19
 
def getCells(cells, index):
    i1 = index - 1
    i2 = index
    i3 = index + 1
 
    if i1 < 0:
        i1 = MAX_CELLS - 1
    if i3 >= MAX_CELLS:
        i3 -= MAX_CELLS
 
    b = 4 * int(cells[i1]) + 2 * int(cells[i2]) + int(cells[i3])
    return b
 
def getBase2(i):
    s = bin(i)[2:]
    while len(s) < 8:
        s = ""0"" + s
    return s
 
def doRule(rule):
    print(""Rule: "" + str(rule) + ""\n----------\n"")
    cells = array('B', [0] * MAX_CELLS)
    ncells = array('B', [0] * MAX_CELLS)
    cells[MAX_CELLS // 2] = 1
 
    for gen in range(51):
        print(""{0:4d}: "".format(gen), end="""")
        for b in cells:
            print(""#"" if b else ""."", end="""")
        print("""")
 
        i = 0
        while True:
            b = getCells(cells, i)
            ncells[i] = 1 if getBase2(rule)[7 - b] == '1' else 0
            i += 1
            if i == MAX_CELLS:
                break
 
        i = 0
        for b in ncells:
            cells[i] = b
            i += 1
 
    print("""")
 
def run():
    while True:
        print(""What Rule do you want to visualize"")
        doRule(int(input()))
        print(""Press any key to continue..."")
        input()
 
if __name__ == ""__main__"":
    run()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Dot_product,Dot product,"Task

Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.

If possible, make the vectors of arbitrary length.



As an example, compute the dot product of the vectors:

     [1,  3, -5]       and 
     [4, -2, -1]   


If implementing the dot product of two vectors directly:

   each vector must be the same length
   multiply corresponding terms from each vector
   sum the products   (to produce the answer)


Related task

   Vector products

",Python,"def dotp(a,b):
    assert len(a) == len(b), 'Vector sizes must match'
    return sum(aterm * bterm for aterm,bterm in zip(a, b))
 
if __name__ == '__main__':
    a, b = [1, 3, -5], [4, -2, -1]
    assert dotp(a,b) == 3",Human_written,Python_from_C
http://rosettacode.org/wiki/Old_lady_swallowed_a_fly,Old lady swallowed a fly,"Task

Present a program which emits the lyrics to the song   I Knew an Old Lady Who Swallowed a Fly,   taking advantage of the repetitive structure of the song's lyrics. 

This song has multiple versions with slightly different lyrics, so all these programs might not emit identical output.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import zlib, base64
 
b64 = b'''
eNrtVE1rwzAMvedXaKdeRn7ENrb21rHCzmrs1m49K9gOJv9+cko/HBcGg0LHcpOfnq2np0QL
2FuKgBbICDAoeoiKwEc0hqIUgLAxfV0tQJCdhQM7qh68kheswKeBt5ROYetTemYMCC3rii//
WMS3WkhXVyuFAaLT261JuBWwu4iDbvYp1tYzHVS68VEIObwFgaDB0KizuFs38aSdqKv3TgcJ
uPYdn2B1opwIpeKE53qPftxRd88Y6uoVbdPzWxznrQ3ZUi3DudQ/bcELbevqM32iCIrj3IIh
W6plOJf6L6xaajZjzqW/qAsKIvITBGs9Nm3glboZzkVP5l6Y+0bHLnedD0CttIyrpEU5Kv7N
Mz3XkPBc/TSN3yxGiqMiipHRekycK0ZwMhM8jerGC9zuZaoTho3kMKSfJjLaF8v8wLzmXMqM
zJvGew/jnZPzclA08yAkikegDTTUMfzwDXBcwoE='''
print(zlib.decompress(base64.b64decode(b64)).decode(""utf-8"", ""strict""))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Handle_a_signal,Handle a signal,"Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.
Unhandled signals generally terminate a program in a disorderly manner.
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second.
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.



",Python,"import time
 
def counter():
    n = 0
    t1 = time.time()
    while True:
        try:
            time.sleep(0.5)
            n += 1
            print n
        except KeyboardInterrupt, e:
            print 'Program has run for %5.3f seconds.' % (time.time() - t1)
            break
 
counter()",Human_written,Python_from_C
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,"from typing import List
 
def disjoint_sort(array: List[int], indices: List[int]) -> None:
    sorted_indices = sorted(indices, key=lambda k: array[k])
    for a, b in sorted(zip(indices, sorted_indices), key=lambda x: x[0] > x[1]):
        array[a], array[b] = array[b], array[a]
 
if __name__ == ""__main__"":
    array = [7, 6, 5, 4, 3, 2, 1, 0]
    indices = [6, 1, 7]
    disjoint_sort(array, indices)
    print(array)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sum_multiples_of_3_and_5,Sum multiples of 3 and 5,"Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

This is is the same as Project Euler problem 1.

Extra credit: do this efficiently for n = 1e20 or higher.



",Python,"# version 1.1.2
 
from math import floor
 
def sum35(n):
    nn = n - 1
    num3 = floor(nn / 3)
    end3 = num3 * 3
    sum3 = (3 + end3) * num3 // 2
    num5 = floor(nn / 5)
    end5 = num5 * 5
    sum5 = (5 + end5) * num5 // 2
    num15 = floor(nn / 15)
    end15 = num15 * 15
    sum15 = (15 + end15) * num15 // 2
    return sum3 + sum5 - sum15
 
print(""The sum of multiples of 3 or 5 below 1000 is"", sum35(1000))
print(""The sum of multiples of 3 or 5 below 1e20 is"", sum35(100000000000000000000))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Cheryl%27s_birthday,Cheryl's birthday,"Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.

Cheryl gave them a list of ten possible dates:

     May 15,     May 16,     May 19
     June 17,    June 18
     July 14,    July 16
     August 14,  August 15,  August 17

Cheryl then tells Albert the   month   of birth,   and Bernard the   day   (of the month)   of birth.

 1)  Albert:   I don't know when Cheryl's birthday is, but I know that Bernard does not know too.
 2)  Bernard:  At first I don't know when Cheryl's birthday is, but I know now.
 3)  Albert:   Then I also know when Cheryl's birthday is.



Task
Write a computer program to deduce, by successive elimination, Cheryl's birthday.



Related task

 Sum and Product Puzzle


References
 Wikipedia article of the same name.
 Tuple Relational Calculus

",Python,"'''Cheryl's Birthday'''
 
from itertools import groupby
from re import split
 
 
# main :: IO ()
def main():
    '''Derivation of the date.'''
 
    month, day = 0, 1
    print(
        # (3 :: A ""Then I also know"")
        # (A's month contains only one remaining day)
        uniquePairing(month)(
            # (2 :: B ""I know now"")
            # (B's day is paired with only one remaining month)
            uniquePairing(day)(
                # (1 :: A ""I know that Bernard does not know"")
                # (A's month is not among those with unique days)
                monthsWithUniqueDays(False)([
                    # 0 :: Cheryl's list:
                    tuple(x.split()) for x in
                    split(
                        ', ',
                        'May 15, May 16, May 19, ' +
                        'June 17, June 18, ' +
                        'July 14, July 16, ' +
                        'Aug 14, Aug 15, Aug 17'
                    )
                ])
            )
        )
    )
 
 
# ------------------- QUERY FUNCTIONS --------------------
 
# monthsWithUniqueDays :: Bool -> [(Month, Day)] -> [(Month, Day)]
def monthsWithUniqueDays(blnInclude):
    '''The subset of months with (or without) unique days.
    '''
    def go(xs):
        month, day = 0, 1
        months = [fst(x) for x in uniquePairing(day)(xs)]
        return [
            md for md in xs
            if blnInclude or not (md[month] in months)
        ]
    return go
 
 
# uniquePairing :: DatePart -> [(Month, Day)] -> [(Month, Day)]
def uniquePairing(i):
    '''Subset of months (or days) with a unique intersection.
    '''
    def go(xs):
        def inner(md):
            dct = md[i]
            uniques = [
                k for k in dct.keys()
                if 1 == len(dct[k])
            ]
            return [tpl for tpl in xs if tpl[i] in uniques]
        return inner
    return ap(bindPairs)(go)
 
 
# bindPairs :: [(Month, Day)] ->
# ((Dict String [String], Dict String [String])
# -> [(Month, Day)]) -> [(Month, Day)]
def bindPairs(xs):
    '''List monad injection operator for lists
       of (Month, Day) pairs.
    '''
    return lambda f: f(
        (
            dictFromPairs(xs),
            dictFromPairs(
                [(b, a) for (a, b) in xs]
            )
        )
    )
 
 
# dictFromPairs :: [(Month, Day)] -> Dict Text [Text]
def dictFromPairs(xs):
    '''A dictionary derived from a list of
       month day pairs.
    '''
    return {
        k: [snd(x) for x in m] for k, m in groupby(
            sorted(xs, key=fst), key=fst
        )
    }
 
 
# ----------------------- GENERIC ------------------------
 
# ap :: (a -> b -> c) -> (a -> b) -> a -> c
def ap(f):
    '''Applicative instance for functions.
    '''
    def go(g):
        def fxgx(x):
            return f(x)(
                g(x)
            )
        return fxgx
    return go
 
 
# fst :: (a, b) -> a
def fst(tpl):
    '''First component of a pair.
    '''
    return tpl[0]
 
 
# snd :: (a, b) -> b
def snd(tpl):
    '''Second component of a pair.
    '''
    return tpl[1]
 
 
if __name__ == '__main__':
    main()",Human_written,Python_from_C
http://rosettacode.org/wiki/Index_finite_lists_of_positive_integers,Index finite lists of positive integers,"It is known that the set of finite lists of positive integers is    countable.

This means that there exists a subset of natural integers which can be mapped to the set of finite lists of positive integers.



Task

Implement such a mapping:

   write a function     rank     which assigns an integer to any finite, arbitrarily long list of arbitrary large positive integers.
   write a function   unrank   which is the   rank    inverse function.


Demonstrate your solution by:

   picking a random-length list of random positive integers
   turn it into an integer,   and 
   get the list back.


There are many ways to do this.   Feel free to choose any one you like.



Extra credit

Make the   rank   function as a    bijection   and show   unrank(n)   for   n   varying from   0   to   10.



",Python,"from math import log
 
def rank(l):
    r = 0
    for n in l:
        r <<= n + 1
        r |= 1 << n
    return r
 
def unrank(n):
    l = []
    while n:
        n &= n - 1
        l.append(int(log(n & -n, 2)))
    return l
 
if __name__ == '__main__':
    for i in range(11):
        u = unrank(i)
        r = rank(u)
        print(i, u, r)
    u = unrank(12345678901234567890)
    r = rank(u)
    print('\n%d\n%s\n%d' % (12345678901234567890, u, r))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/LU_decomposition,LU decomposition,"Every square matrix 



A


{\displaystyle A}

 can be decomposed into a product of a lower triangular matrix 



L


{\displaystyle L}

 and a upper triangular matrix 



U


{\displaystyle U}

,
as described in LU decomposition.





A
=
L
U


{\displaystyle A=LU}


It is a modified form of Gaussian elimination.
While the Cholesky decomposition only works for symmetric,
positive definite matrices, the more general LU decomposition
works for any square matrix.

There are several algorithms for calculating L and U.
To derive Crout's algorithm for a 3x3 example,
we have to solve the following system:





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}=LU}


We now would have to solve 9 equations with 12 unknowns. To make the system uniquely solvable, usually the diagonal elements of 



L


{\displaystyle L}

 are set to 1






l

11


=
1


{\displaystyle l_{11}=1}







l

22


=
1


{\displaystyle l_{22}=1}







l

33


=
1


{\displaystyle l_{33}=1}


so we get a solvable system of 9 unknowns and 9 equations.





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(



1


0


0





l

21




1


0





l

31





l

32




1



)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=


(




u

11





u

12





u

13







u

11



l

21





u

12



l

21


+

u

22





u

13



l

21


+

u

23







u

11



l

31





u

12



l

31


+

u

22



l

32





u

13



l

31


+

u

23



l

32


+

u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}1&0&0\\l_{21}&1&0\\l_{31}&l_{32}&1\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}={\begin{pmatrix}u_{11}&u_{12}&u_{13}\\u_{11}l_{21}&u_{12}l_{21}+u_{22}&u_{13}l_{21}+u_{23}\\u_{11}l_{31}&u_{12}l_{31}+u_{22}l_{32}&u_{13}l_{31}+u_{23}l_{32}+u_{33}\end{pmatrix}}=LU}


Solving for the other 



l


{\displaystyle l}

 and 



u


{\displaystyle u}

, we get the following equations:






u

11


=

a

11




{\displaystyle u_{11}=a_{11}}







u

12


=

a

12




{\displaystyle u_{12}=a_{12}}







u

13


=

a

13




{\displaystyle u_{13}=a_{13}}







u

22


=

a

22


−

u

12



l

21




{\displaystyle u_{22}=a_{22}-u_{12}l_{21}}







u

23


=

a

23


−

u

13



l

21




{\displaystyle u_{23}=a_{23}-u_{13}l_{21}}







u

33


=

a

33


−
(

u

13



l

31


+

u

23



l

32


)


{\displaystyle u_{33}=a_{33}-(u_{13}l_{31}+u_{23}l_{32})}


and for 



l


{\displaystyle l}

:






l

21


=


1

u

11





a

21




{\displaystyle l_{21}={\frac {1}{u_{11}}}a_{21}}







l

31


=


1

u

11





a

31




{\displaystyle l_{31}={\frac {1}{u_{11}}}a_{31}}







l

32


=


1

u

22




(

a

32


−

u

12



l

31


)


{\displaystyle l_{32}={\frac {1}{u_{22}}}(a_{32}-u_{12}l_{31})}


We see that there is a calculation pattern, which can be expressed as the following formulas, first for 



U


{\displaystyle U}








u

i
j


=

a

i
j


−

∑

k
=
1


i
−
1



u

k
j



l

i
k




{\displaystyle u_{ij}=a_{ij}-\sum _{k=1}^{i-1}u_{kj}l_{ik}}


and then for 



L


{\displaystyle L}








l

i
j


=


1

u

j
j




(

a

i
j


−

∑

k
=
1


j
−
1



u

k
j



l

i
k


)


{\displaystyle l_{ij}={\frac {1}{u_{jj}}}(a_{ij}-\sum _{k=1}^{j-1}u_{kj}l_{ik})}


We see in the second formula that to get the 




l

i
j




{\displaystyle l_{ij}}

 below the diagonal, we have to divide by the diagonal element (pivot) 




u

j
j




{\displaystyle u_{jj}}

, so we get problems when 




u

j
j




{\displaystyle u_{jj}}

 is either 0 or very small, which leads to numerical instability.

The solution to this problem is pivoting 



A


{\displaystyle A}

, which means rearranging the rows of 



A


{\displaystyle A}

, prior to the 



L
U


{\displaystyle LU}

 decomposition, in a way that the largest element of each column gets onto the diagonal of 



A


{\displaystyle A}

. Rearranging the rows means to multiply 



A


{\displaystyle A}

 by a permutation matrix 



P


{\displaystyle P}

:





P
A
⇒

A
′



{\displaystyle PA\Rightarrow A'}


Example:







(



0


1




1


0



)




(



1


4




2


3



)


⇒


(



2


3




1


4



)




{\displaystyle {\begin{pmatrix}0&1\\1&0\end{pmatrix}}{\begin{pmatrix}1&4\\2&3\end{pmatrix}}\Rightarrow {\begin{pmatrix}2&3\\1&4\end{pmatrix}}}


The decomposition algorithm is then applied on the rearranged matrix so that





P
A
=
L
U


{\displaystyle PA=LU}




Task description

The task is to implement a routine which will take a square nxn matrix 



A


{\displaystyle A}

 and return a lower triangular matrix 



L


{\displaystyle L}

, a upper triangular matrix 



U


{\displaystyle U}

 and a permutation matrix 



P


{\displaystyle P}

,
so that the above equation is fulfilled.

You should then test it on the following two examples and include your output.



Example 1

A

1   3   5
2   4   7
1   1   0

L

1.00000   0.00000   0.00000
0.50000   1.00000   0.00000
0.50000  -1.00000   1.00000

U

2.00000   4.00000   7.00000
0.00000   1.00000   1.50000
0.00000   0.00000  -2.00000

P

0   1   0
1   0   0
0   0   1

Example 2

A

11    9   24    2
 1    5    2    6
 3   17   18    1
 2    5    7    1

L

1.00000   0.00000   0.00000   0.00000
0.27273   1.00000   0.00000   0.00000
0.09091   0.28750   1.00000   0.00000
0.18182   0.23125   0.00360   1.00000

U

11.00000    9.00000   24.00000    2.00000
 0.00000   14.54545   11.45455    0.45455
 0.00000    0.00000   -3.47500    5.68750
 0.00000    0.00000    0.00000    0.51079

P

1   0   0   0
0   0   1   0
0   1   0   0
0   0   0   1


",Python,"import numpy as np
 
def zero(n):
    return np.zeros((n, n))
 
def eye(n):
    return np.eye(n)
 
def pivotize(a):
    p = eye(len(a))
    for j, r in enumerate(a):
        max = r[j]
        row = j
        for i in range(j, len(a)):
            if a[i][j] > max:
                max = a[i][j]
                row = i
        if j!= row:
            # swap rows
            p[j], p[row] = p[row], p[j]
    return p
 
def mul(m1, m2):
    r = zero(len(m1))
    for i, r1 in enumerate(m1):
        for j in range(len(m2)):
            for k in range(len(m1)):
                r[i][j] += r1[k] * m2[k][j]
    return r
 
def lu(a):
    l = zero(len(a))
    u = zero(len(a))
    p = pivotize(a)
    a = mul(p, a)
    for j in range(len(a)):
        l[j][j] = 1
        for i in range(0, j+1):
            sum = 0.
            for k in range(0, i):
                sum += u[k][j] * l[i][k]
            u[i][j] = a[i][j] - sum
        for i in range(j, len(a)):
            sum = 0.
            for k in range(0, j):
                sum += u[k][j] * l[i][k]
            l[i][j] = (a[i][j] - sum) / u[j][j]
    return l, u, p
 
def showLU(a):
    print(""\na"")
    print(a)
    l, u, p = lu(a)
    print(""l"")
    print(l)
    print(""u"")
    print(u)
    print(""p"")
    print(p)
 
showLU(np.array([[1, 3, 5], [2, 4, 7], [1, 1, 0]]))
showLU(np.array([[11, 9, 24, 2], [1, 5, 2, 6], [3, 17, 18, 1], [2, 5, 7, 1]]))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/N-smooth_numbers,N-smooth numbers,"n-smooth   numbers are positive integers which have no prime factors  >  n.

The   n   (when using it in the expression)   n-smooth   is always prime,

there are   no   9-smooth numbers.

1   (unity)   is always included in n-smooth numbers.




2-smooth   numbers are non-negative powers of two.

5-smooth   numbers are also called   Hamming numbers.

7-smooth   numbers are also called    humble   numbers.



A way to express   11-smooth   numbers is:

  11-smooth  =  2i × 3j × 5k × 7m × 11p

           where     i, j, k, m, p ≥ 0  



Task

   calculate and show the first   25   n-smooth numbers   for   n=2   ───►   n=29
   calculate and show   three numbers starting with   3,000   n-smooth numbers   for   n=3   ───►   n=29
   calculate and show twenty numbers starting with  30,000   n-smooth numbers   for   n=503   ───►   n=521   (optional)


All ranges   (for   n)   are to be inclusive, and only prime numbers are to be used.

The (optional) n-smooth numbers for the third range are:   503,   509,   and   521.

Show all n-smooth numbers for any particular   n   in a horizontal list.

Show all output here on this page.



Related tasks

   Hamming numbers
   humble numbers


References

   Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
   Wikipedia entry:   Smooth number
   OEIS entry:   A000079    2-smooth numbers or non-negative powers of two
   OEIS entry:   A003586    3-smooth numbers
   OEIS entry:   A051037    5-smooth numbers or Hamming numbers
   OEIS entry:   A002473    7-smooth numbers or humble numbers
   OEIS entry:   A051038   11-smooth numbers
   OEIS entry:   A080197   13-smooth numbers
   OEIS entry:   A080681   17-smooth numbers
   OEIS entry:   A080682   19-smooth numbers
   OEIS entry:   A080683   23-smooth numbers

",Python,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
 
def isPrime(n):
    if n < 2:
        return False
 
    for i in primes:
        if n == i:
            return True
        if n % i == 0:
            return False
        if i * i > n:
            return True
    print ""Oops,"", n, "" is too large""
 
def init():
    s = 24
    while s < 600:
        if isPrime(s - 1) and s - 1 > primes[-1]:
            primes.append(s - 1)
        if isPrime(s + 1) and s + 1 > primes[-1]:
            primes.append(s + 1)
        s += 6
 
def nsmooth(n, size):
    if n < 2 or n > 521:
        raise Exception(""n"")
    if size < 1:
        raise Exception(""n"")
 
    bn = n
    ok = False
    for prime in primes:
        if bn == prime:
            ok = True
            break
    if not ok:
        raise Exception(""must be a prime number: n"")
 
    ns = [0] * size
    ns[0] = 1
 
    next = []
    for prime in primes:
        if prime > bn:
            break
        next.append(prime)
 
    indicies = [0] * len(next)
    for m in xrange(1, size):
        ns[m] = min(next)
        for i in xrange(0, len(indicies)):
            if ns[m] == next[i]:
                indicies[i] += 1
                next[i] = primes[i] * ns[indicies[i]]
 
    return ns
 
def main():
    init()
 
    for p in primes:
        if p >= 30:
            break
        print ""The first"", p, ""-smooth numbers are:""
        print nsmooth(p, 25)
        print
 
    for p in primes[1:]:
        if p >= 30:
            break
        print ""The 3000 to 3202"", p, ""-smooth numbers are:""
        print nsmooth(p, 3002)[2999:]
        print
 
    for p in [503, 509, 521]:
        print ""The 30000 to 3019"", p, ""-smooth numbers are:""
        print nsmooth(p, 30019)[29999:]
        print
 
main()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Partition_function_P,Partition function P,"

The Partition Function P, often notated P(n) is the number of solutions where n∈ℤ can be expressed as the sum of a set of positive integers.



Example

 P(4) = 5   because   4 = Σ(4) = Σ(3,1) = Σ(2,2) = Σ(2,1,1) = Σ(1,1,1,1)



P(n) can be expressed as the recurrence relation:

 P(n) = P(n-1) +P(n-2) -P(n-5) -P(n-7) +P(n-12) +P(n-15) -P(n-22) -P(n-26) +P(n-35) +P(n-40) ...

The successive numbers in the above equation have the differences:   1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8 ...

This task may be of popular interest because Mathologer made the video, The hardest ""What comes next?"" (Euler's pentagonal formula), where he asks the programmers among his viewers to calculate P(666). The video has been viewed more than 100,000 times in the first couple of weeks since its release.

In Wolfram Language, this function has been implemented as PartitionsP.



Task

Write a function which returns the value of PartitionsP(n). Solutions can be iterative or recursive.

Bonus task: show how long it takes to compute PartitionsP(6666).



References

 The hardest ""What comes next?"" (Euler's pentagonal formula) The explanatory video by Mathologer that makes this task a popular interest.
 Partition Function P Mathworld entry for the Partition function.
 Partition function (number theory) Wikipedia entry for the Partition function.


Related tasks

 9 billion names of God the integer



",Python,"import time
from math import sqrt
from functools import reduce
from operator import mul
from itertools import count
 
def partitions(n):
    p = [1] + [0] * n
    for i in range(1, n + 1):
        for k in count(1):
            j = (k * (3 * k - 1)) // 2
            if j > i:
                break
            p[i] += (-1) ** (k + 1) * p[i - j]
            j += k
            if j > i:
                break
            p[i] += (-1) ** (k + 1) * p[i - j]
    return p[n]
 
if __name__ == '__main__':
    start = time.time()
    result = partitions(6666)
    end = time.time()
    print(""P(6666) ="", result)
    print(""elapsed time:"", end - start, ""seconds"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Partition_function_P,Partition function P,"

The Partition Function P, often notated P(n) is the number of solutions where n∈ℤ can be expressed as the sum of a set of positive integers.



Example

 P(4) = 5   because   4 = Σ(4) = Σ(3,1) = Σ(2,2) = Σ(2,1,1) = Σ(1,1,1,1)



P(n) can be expressed as the recurrence relation:

 P(n) = P(n-1) +P(n-2) -P(n-5) -P(n-7) +P(n-12) +P(n-15) -P(n-22) -P(n-26) +P(n-35) +P(n-40) ...

The successive numbers in the above equation have the differences:   1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8 ...

This task may be of popular interest because Mathologer made the video, The hardest ""What comes next?"" (Euler's pentagonal formula), where he asks the programmers among his viewers to calculate P(666). The video has been viewed more than 100,000 times in the first couple of weeks since its release.

In Wolfram Language, this function has been implemented as PartitionsP.



Task

Write a function which returns the value of PartitionsP(n). Solutions can be iterative or recursive.

Bonus task: show how long it takes to compute PartitionsP(6666).



References

 The hardest ""What comes next?"" (Euler's pentagonal formula) The explanatory video by Mathologer that makes this task a popular interest.
 Partition Function P Mathworld entry for the Partition function.
 Partition function (number theory) Wikipedia entry for the Partition function.


Related tasks

 9 billion names of God the integer



",Python,"from itertools import islice
 
def posd():
    ""diff between position numbers. 1, 2, 3... interleaved with  3, 5, 7...""
    count, odd = 1, 3
    while True:
        yield count
        yield odd
        count, odd = count + 1, odd + 2
 
def pos_gen():
    ""position numbers. 1 3 2 5 7 4 9 ...""
    val = 1
    diff = posd()
    while True:
        yield val
        val += next(diff)
 
def plus_minus():
    ""yield (list_offset, sign) or zero for Partition calc""
    n, sign = 0, [1, 1]
    p_gen = pos_gen()
    out_on = next(p_gen)
    while True:
        n += 1
        if n == out_on:
            next_sign = sign.pop(0)
            if not sign:
                sign = [-next_sign] * 2
            yield -n, next_sign
            out_on = next(p_gen)
        else:
            yield 0
 
def part(n):
    ""Partition numbers""
    p = [1]
    p_m = plus_minus()
    mods = []
    for _ in range(n):
        next_plus_minus = next(p_m)
        if next_plus_minus:
            mods.append(next_plus_minus)
        p.append(sum(p[offset] * sign for offset, sign in mods))
    return p[-1]
 
print(""(Intermediaries):"")
print(""    posd:"", list(islice(posd(), 10)))
print(""    pos_gen:"", list(islice(pos_gen(), 10)))
print(""    plus_minus:"", list(islice(plus_minus(), 15)))
print(""\nPartitions:"", [part(x) for x in range(15)])",Human_written,Python_from_C++
http://rosettacode.org/wiki/Mouse_position,Mouse position,"Task

Get the current location of the mouse cursor relative to the active window.

Please specify if the window may be externally created.



",Python,"from shoes import *

Shoes.app(title=""Mouse Position"", width=400, height=400) do
  @position = para ""Position : ?, ?"", size=12, margin=10

  motion do |x, y|
    @position.text = ""Position : #{x}, #{y}""
  end
end",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",Python,"flat = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []].flatten()
print(flat)  # => [1, 2, 3, 4, 5, 6, 7, 8]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Python,"class NewClass:
    def __init__(self):
        self.first(lambda: self.second())

    def first(self, obj):
        obj()

    def second(self):
        print(""Second"")

if __name__ == ""__main__"":
    NewClass()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort,Sorting Algorithms/Circle Sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of integers (of any convenient size) into ascending order using Circlesort.

In short, compare the first element to the last element, then the second element to the second last element, etc.

Then split the array in two and recurse until there is only one single element in the array, like this:

Before:
6 7 8 9 2 5 3 4 1
After:
1 4 3 5 2 9 8 7 6

Repeat this procedure until quiescence (i.e. until there are no swaps).

Show both the initial, unsorted list and the final sorted list. (Intermediate steps during sorting are optional.)

Optimizations (like doing 0.5 log2(n) iterations and then continue with an Insertion sort) are optional. 


Pseudo code:

 function circlesort (index lo, index hi, swaps)
 {
   if lo == hi return (swaps)
   high := hi
   low := lo
   mid := int((hi-lo)/2)
   while lo < hi {
     if  (value at lo) > (value at hi) {
        swap.values (lo,hi)
        swaps++
     }
     lo++
     hi--
   }
   if lo == hi
     if (value at lo) > (value at hi+1) {
         swap.values (lo,hi+1)
         swaps++
     }
   swaps := circlesort(low,low+mid,swaps)
   swaps := circlesort(low+mid+1,high,swaps)
   return(swaps)
 }
 while circlesort (0, sizeof(array)-1, 0)



See also

 For more information on Circle sorting, see Sourceforge.

",Python,"#python3
#tests: expect no output.
#doctest with  python3 -m doctest thisfile.py
#additional tests:  python3 thisfile.py
 
def circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':
    '''
        >>> L = [3, 2, 8, 28, 2,]
        >>> circle_sort(L)
        3
        >>> print(L)
        [2, 2, 3, 8, 28]
        >>> L = [3, 2, 8, 28,]
        >>> circle_sort(L)
        1
        >>> print(L)
        [2, 3, 8, 28]
    '''
    n = R-L
    if n < 2:
        return 0
    swaps = 0
    m = n//2
    for i in range(m):
        if A[R-(i+1)] < A[L+i]:
            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)
            swaps += 1
    if (n & 1) and (A[L+m] < A[L+m-1]):
        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)
        swaps += 1
    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)
 
def circle_sort(L:list)->'sort A in place, returning the number of swaps':
    swaps = 0
    s = 1
    while s:
        s = circle_sort_backend(L, 0, len(L))
        swaps += s
    return swaps
 
# more tests!
if __name__ == '__main__':
    from random import shuffle
    for i in range(309):
        L = list(range(i))
        M = L[:]
        shuffle(L)
        N = L[:]
        circle_sort(L)
        if L != M:
            print(len(L))
            print(N)
            print(L)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",Python,"from math import sqrt
 
n = 200
 
def gcd(a, b):
    leftover = 1
    dividend = a if a > b else b
    divisor = a if a > b else b
    while leftover!= 0:
        leftover = dividend % divisor
        if leftover > 0:
            dividend = divisor
            divisor = leftover
    return divisor
 
def isHeron(h):
    return h % 1 == 0 and h > 0
 
def sort(l):
    swapped = True
    while swapped:
        swapped = False
        for i in range(1, len(l)):
            if l[i][4] < l[i - 1][4] or l[i][4] == l[i - 1][4] and l[i][3] < l[i - 1][3]:
                temp = l[i]
                l[i] = l[i - 1]
                l[i - 1] = temp
                swapped = True
 
def run():
    l = []
    for c in range(1, n + 1):
        for b in range(1, c + 1):
            for a in range(1, b + 1):
                if gcd(gcd(a, b), c) == 1:
                    p = a + b + c
                    s = p / 2.0
                    area = sqrt(s * (s - a) * (s - b) * (s - c))
                    if isHeron(area):
                        l.append([a, b, c, p, int(area)])
    print(""Number of primitive Heronian triangles with sides up to %d: %d"" % (n, len(l)))
 
    sort(l)
    print(""\n\nFirst ten when ordered by increasing area, then perimeter:"")
    print(""Sides           Perimeter   Area"")
    for i in range(10):
        print(""%3d x %3d x %3d %5d %10d"" % (l[i][0], l[i][1], l[i][2], l[i][3], l[i][4]))
    a = 210
    print(""\n\nArea = %d"" % a)
    print(""Sides           Perimeter   Area"")
    for i in range(len(l)):
        if l[i][4] == a:
            print(""%3d x %3d x %3d %5d %10d"" % (l[i][0], l[i][1], l[i][2], l[i][3], l[i][4]))
 
run()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Morse_code,Morse code,"Morse code
It has been in use for more than 175 years — longer than any other electronic encoding system.



Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).



As the standard Morse code does not contain all possible characters,
you may either ignore unknown characters in the file,
or indicate them somehow   (e.g. with a different pitch).



",Python,"import math
import numpy as np
import pyaudio
import wave

def morsecode(text, unit, freq):
    # defaults
    unit = unit if unit else 0.05
    freq = freq if freq else 700
    time = 0

    # morsecode
    code = {
        'a': '._',    'b': '_...',  'c': '_._.',  'd': '_..',   'e': '.',     'f': '.._.',
        'g': '__.',   'h': '....',  'i': '..',    'j': '.___',  'k': '_._',   'l': '._..',
       'm': '__',    'n': '_.',    'o': '___',   'p': '.__.',  'q': '__._',  'r': '._.',
       's': '...',   't': '_',     'u': '.._',   'v': '..._',  'w': '.__',   'x': '_.._',
        'y': '_.__',  'z': '__..',  '0': '_____', '1': '.____', '2': '..___', '3': '...__',
        '4': '...._', '5': '.....', '6': '_....', '7': '__...', '8': '___..', '9': '____.'
    }

    # generate code for text
    def makecode(data):
        for i in range(len(data)):
            codedata = data[i].lower()
            codedata = code[codedata]
            # recognised character
            if codedata is not None:
                maketime(codedata)
            # unrecognised character
            else:
                time += unit * 7

    # generate time for code
    def maketime(data):
        for i in range(len(data)):
            timedata = data[i]
            timedata = 1 if timedata == '.' else 3 if timedata == '_' else 0
            timedata *= unit
            if timedata > 0:
                maketone(timedata)
                time += timedata
                # tone gap
                time += unit * 1
        # char gap
        time += unit * 2

    # generate tone for time
    def maketone(data):
        start = time
        stop = time + data
        # filter: envelope the tone slightly
        gain.gain.linearRampToValueAtTime(0, start)
        gain.gain.linearRampToValueAtTime(1, start + (unit / 8))
        gain.gain.linearRampToValueAtTime(1, stop - (unit / 16))
        gain.gain.linearRampToValueAtTime(0, stop)

    # create: oscillator, gain, destination
    osci = cont.createOscillator()
    osci.frequency.value = freq
    gain = cont.createGainNode()
    gain.gain.value = 0
    dest = cont.destination
    # connect: oscillator -> gain -> destination
    osci.connect(gain)
    gain.connect(dest)
    # start oscillator
    osci.start(time)

    # begin encoding: text -> code -> time -> tone
    makecode(text)

    # return web audio context for reuse / control
    return cont",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Totient_function,Totient function,"The   totient   function is also known as:

   Euler's totient function
   Euler's phi totient function
   phi totient function
    Φ    function   (uppercase Greek phi)
    φ     function   (lowercase Greek phi)


Definitions   (as per number theory)

The totient function:

   counts the integers up to a given positive integer   n   that are relatively prime to   n
   counts the integers   k   in the range   1 ≤ k ≤ n   for which the greatest common divisor   gcd(n,k)   is equal to   1
   counts numbers   ≤ n   and   prime to   n


If the totient number   (for N)   is one less than   N,   then   N   is prime.



Task

Create a   totient   function and:

   Find and display   (1 per line)   for the 1st   25   integers:
   the integer   (the index)
   the totient number for that integer
   indicate if that integer is prime
   Find and display the   count   of the primes up to          100
   Find and display the   count   of the primes up to       1,000
   Find and display the   count   of the primes up to     10,000
   Find and display the   count   of the primes up to   100,000     (optional)
Show all output here.



Related task

   Perfect totient numbers


Also see

   Wikipedia: Euler's totient function.
   MathWorld: totient function.
   OEIS: Euler totient function phi(n).

",Python,"import math
 
class totient_calculator:
    def __init__(self, max):
        self.totient = [i for i in range(max + 1)]
        for i in range(2, max + 1):
            if self.totient[i] < i:
                continue
            for j in range(i, max + 1, i):
                self.totient[j] -= self.totient[j] / i
    def totient(self, n):
        assert n >= 1 and n < len(self.totient)
        return self.totient[n]
    def is_prime(self, n):
        return self.totient(n) == n - 1
 
def count_primes(tc, min, max):
    count = 0
    for i in range(min, max + 1):
        if tc.is_prime(i):
            count += 1
    return count
 
max = 10000000
tc = totient_calculator(max)
print("" n  totient  prime?"")
for i in range(1, 26):
    print(""%2d %9d %8s"" % (i, tc.totient(i), ""yes"" if tc.is_prime(i) else ""no""))
for n in [100, 1000, 10000, 100000, 1000000, 10000000]:
    print(""Count of primes up to %d: %d"" % (n, count_primes(tc, 1, n)))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Terminal_control/Ringing_the_terminal_bell,Terminal control/Ringing the terminal bell,"

Task

Make the terminal running the program ring its ""bell"".



On modern terminal emulators, this may be done by playing some other sound which might or might not be configurable, or by flashing the title bar or inverting the colors of the screen, but was classically a physical bell within the terminal.   It is usually used to indicate a problem where a wrong character has been typed.

In most terminals, if the   Bell character   (ASCII code 7,    \a  in C)   is printed by the program, it will cause the terminal to ring its bell.   This is a function of the terminal, and is independent of the programming language of the program, other than the ability to print a particular character to standard out.



",Python,"print ""\a""",Human_written,Python_from_C
http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",Python,"import math
 
def isqrt(x):
    q = 1
    while q <= x:
        q <<= 2
    r = 0
    while q > 1:
        q >>= 2
        t = x - r - q
        r >>= 1
        if t >= 0:
            x = t
            r += q
    return r
 
def commatize(n):
    str = str(n)
    result = ''
    digits = len(str)
    for i in range(digits):
        if i > 0 and i % 3 == digits % 3:
            result += ','
        result += str[i]
    return result
 
print(""Integer square root for numbers 0 to 65:"")
for n in range(66):
    print(isqrt(n), end=' ')
print()
 
print(""Integer square roots of odd powers of 7 from 1 to 73:"")
power_width = 83
isqrt_width = 42
print("" n |"" + str(power_width).rjust(power_width) + "" |"" + str(isqrt_width).rjust(isqrt_width))
print(""-"" * (6 + power_width + isqrt_width))
p = 7
for n in range(1, 74, 2):
    print(str(n).rjust(2) + "" |"" + commatize(p).rjust(power_width) + "" |"" + commatize(isqrt(p)).rjust(isqrt_width))
    p *= 49",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",Python,"#!/usr/bin/env python
# canonicalize a CIDR block specification:
# make sure none of the host bits are set
 
import sys
from socket import inet_aton, inet_ntoa
from struct import pack, unpack
 
args = sys.argv[1:]
if len(args) == 0:
    args = sys.stdin.readlines()
 
for cidr in args:
   # IP in dotted-decimal / bits in network part
   dotted, size_str = cidr.split('/')
   size = int(size_str)
 
   numeric = unpack('!I', inet_aton(dotted))[0]  # IP as an integer
   binary = f'{numeric:#034b}'                   # then as a padded binary string
   prefix = binary[:size + 2]                    # just the network part
                                                 #   (34 and +2 are to account
                                                 #    for leading '0b')
 
   canon_binary = prefix + '0' * (32 - size)     # replace host part with all zeroes
   canon_numeric = int(canon_binary, 2)          # convert back to integer
   canon_dotted = inet_ntoa(pack('!I',
                            (canon_numeric)))    # and then to dotted-decimal
   print(f'{canon_dotted}/{size}')               # output result",Human_written,Python_from_Java
http://rosettacode.org/wiki/Remove_lines_from_a_file,Remove lines from a file,"Task

Remove a specific line or a number of lines from a file.

This should be implemented as a routine that takes three parameters (filename, starting line, and the number of lines to be removed).

For the purpose of this task, line numbers and the number of lines start at one, so to remove the first two lines from the file foobar.txt, the parameters should be: foobar.txt, 1, 2

Empty lines are considered and should still be counted, and if the specified line is empty, it should still be removed.

An appropriate message should appear if an attempt is made to remove lines beyond the end of the file.



",Python,"import os
import sys
import itertools
 
def remove_lines(filename, start, count=1):
    with open(filename, 'r') as f:
        lines = f.readlines()
    with open(filename, 'w') as f:
        for i, line in enumerate(lines):
            if i < start - 1 or i >= start + count - 1:
                f.write(line)
 
if __name__ == '__main__':
    remove_lines('foobar.txt', start=1, count=2)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Subleq,Subleq,"Subleq is an example of a One-Instruction Set Computer (OISC).

It is named after its only instruction, which is SUbtract and Branch if Less than or EQual to zero.

Task
Your task is to create an interpreter which emulates a SUBLEQ machine.

The machine's memory consists of an array of signed integers.   These integers may be interpreted in three ways:

   simple numeric values 
   memory addresses 
   characters for input or output
Any reasonable word size that accommodates all three of the above uses is fine.

The program should load the initial contents of the emulated machine's memory, set the instruction pointer to the first address (which is defined to be address 0), and begin emulating the machine, which works as follows:

   Let A be the value in the memory location identified by the instruction pointer;   let B and C be the values stored in the next two consecutive addresses in memory.
   Advance the instruction pointer three words, to point at the address after the address containing C.
   If A is   -1   (negative unity),   then a character is read from the machine's input and its numeric value stored in the address given by B.   C is unused.
   If B is   -1   (negative unity),   then the number contained in the address given by A is interpreted as a character and written to the machine's output.   C is unused.
   Otherwise, both A and B are treated as addresses.   The number contained in address A is subtracted from the number in address B (and the difference left in address B).   If the result is positive, execution continues uninterrupted; if the result is zero or negative, the number in C becomes the new instruction pointer.
   If the instruction pointer becomes negative, execution halts.
Your solution may initialize the emulated machine's memory in any convenient manner, but if you accept it as input, it should be a separate input stream from the one fed to the emulated machine once it is running. And if fed as text input, it should be in the form of raw subleq ""machine code"" - whitespace-separated decimal numbers, with no symbolic names or other assembly-level extensions, to be loaded into memory starting at address   0   (zero).

For purposes of this task, show the output of your solution when fed the below   ""Hello, world!""   program.

As written, this example assumes ASCII or a superset of it, such as any of the Latin-N character sets or Unicode;   you may translate the numbers representing characters (starting with 72=ASCII 'H') into another character set if your implementation runs in a non-ASCII-compatible environment. If 0 is not an appropriate terminator in your character set, the program logic will need some adjustment as well.

15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0
The above ""machine code"" corresponds to something like this in a hypothetical assembler language for a signed 8-bit version of the machine:

start:
    0f 11 ff subleq (zero), (message), -1
    11 ff ff subleq (message), -1, -1    ; output character at message
    10 01 ff subleq (neg1), (start+1), -1
    10 03 ff subleq (neg1), (start+3), -1
    0f 0f 00 subleq (zero), (zero), start
; useful constants
zero: 
    00      .data 0  
neg1: 
    ff      .data -1
; the message to print
message: .data ""Hello, world!\n\0""
    48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 0a 00

",Python,"import sys
 
def subleq(a):
    i = 0
    try:
        while i >= 0:
            if a[i] == -1:
                a[a[i + 1]] = ord(sys.stdin.read(1))
            elif a[i + 1] == -1:
                print(chr(a[a[i]]), end="""")
            else:
                a[a[i + 1]] -= a[a[i]]
                if a[a[i + 1]] <= 0:
                    i = a[i + 2]
                    continue
            i += 3
    except (ValueError, IndexError, KeyboardInterrupt):
        print(""abort"")
        print(a)
 
subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,
        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,
        114, 108, 100, 33, 10, 0])",Human_written,Python_from_C++
http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",Python,"def r2cf(n1,n2):
  while n2:
    n1, (t1, n2) = n2, divmod(n1, n2)
    yield t1
 
print(list(r2cf(1,2)))    # => [0, 2]
print(list(r2cf(3,1)))    # => [3]
print(list(r2cf(23,8)))    # => [2, 1, 7]
print(list(r2cf(13,11)))    # => [1, 5, 2]
print(list(r2cf(22,7)))    # => [3, 7]
print(list(r2cf(14142,10000)))    # => [1, 2, 2, 2, 2, 2, 1, 1, 29]
print(list(r2cf(141421,100000)))    # => [1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]
print(list(r2cf(1414214,1000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]
print(list(r2cf(14142136,10000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]",Human_written,Python_from_C
http://rosettacode.org/wiki/Amicable_pairs,Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",Python,"def sum_of_divisors(val):
    return sum(n for n in range(1, val/2+1) if val % n == 0)

for i in range(1, 20000):
    sum1 = sum_of_divisors(i)
    if i > sum1 and sum_of_divisors(sum1) == i:
        print(i, sum1)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice,Seven-sided dice from five-sided dice,"Task

(Given an equal-probability generator of one of the integers 1 to 5
as dice5),   create dice7 that generates a pseudo-random integer from
1 to 7 in equal probability using only dice5 as a source of random
numbers,   and check the distribution for at least one million calls using the function created in   Simple Random Distribution Checker.


Implementation suggestion:
dice7 might call dice5 twice, re-call if four of the 25
combinations are given, otherwise split the other 21 combinations
into 7 groups of three, and return the group index from the rolls.

(Task adapted from an answer here)
",Python,"from random import randint
 
def dice5():
    return randint(1, 5)
 
def dice7():
    r = dice5() + dice5() * 5 - 6
    return (r % 7) + 1 if r < 21 else dice7()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Factorial,Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",Python,"import java.math.BigInteger;
import java.util.InputMismatchException;
import java.util.Scanner;

public class RecursiveFactorial {

  public BigInteger factorial(BigInteger n) {
    if ( n == null ) {
      throw new IllegalArgumentException();
    }
    else if ( n.signum() == - 1 ) {
      // negative
      throw new IllegalArgumentException(""Argument must be a non-negative integer"");
    }
    else if ( n.compareTo(BigInteger.ZERO) == 0 ) {
      return BigInteger.ONE;
    }
    else {
      return n.multiply(factorial(n.subtract(BigInteger.ONE)));
    }
  }

  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    BigInteger number, result;
    boolean error = false;
    System.out.println(""FACTORIAL OF A NUMBER"");
    do {
      System.out.println(""Enter a number:"");
      try {
        number = scanner.nextBigInteger();
        result = new RecursiveFactorial().factorial(number);
        error = false;
        System.out.println(""Factorial of "" + number + "": "" + result);
      }
      catch ( InputMismatchException e ) {
        error = true;
        scanner.nextLine();
      }

      catch ( IllegalArgumentException e ) {
        error = true;
        scanner.nextLine();
      }
    }
    while ( error );
    scanner.close();
  }

}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Longest_increasing_subsequence,Longest increasing subsequence,"Calculate and show here a longest increasing subsequence of the list:





{
3
,
2
,
6
,
4
,
5
,
1
}


{\displaystyle \{3,2,6,4,5,1\}}


And of the list:





{
0
,
8
,
4
,
12
,
2
,
10
,
6
,
14
,
1
,
9
,
5
,
13
,
3
,
11
,
7
,
15
}


{\displaystyle \{0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15\}}


Note that a list may have more than one subsequence that is of the maximum length.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Ref

 Dynamic Programming #1: Longest Increasing Subsequence on YouTube
 An efficient solution can be based on Patience sorting.

",Python,"def longest_increasing_subsequence(X):
    """"""Returns the Longest Increasing Subsequence in the Given List/Array""""""
    N = len(X)
    P = [0] * N
    M = [0] * (N+1)
    L = 0
    for i in range(N):
       lo = 1
       hi = L
       while lo <= hi:
           mid = (lo+hi)//2
           if (X[M[mid]] < X[i]):
               lo = mid+1
           else:
               hi = mid-1
 
       newL = lo
       P[i] = M[newL-1]
       M[newL] = i
 
       if (newL > L):
           L = newL
 
    S = []
    k = M[L]
    for i in range(L-1, -1, -1):
        S.append(X[k])
        k = P[k]
    return S[::-1]
 
if __name__ == '__main__':
    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:
        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Array_length,Array length,"Task

Determine the amount of elements in an array.



As an example use an array holding the strings 'apple' and 'orange'.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"print(len(['apple', 'orange']))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Tokenize_a_string,Tokenize a string,"Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word.

Display the words to the 'user', in the simplest manner possible, separated by a period.

To simplify, you may display a trailing period.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
s = ""Hello,How,Are,You,Today""
a = re.split(r',', s)
print '.'.join(a)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",Python,"def ack1(M, N):
   return (N + 1) if M == 0 else (
      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Combinations_with_repetitions,Combinations with repetitions,"The set of combinations with repetitions is computed from a set, 



S


{\displaystyle S}

 (of cardinality 



n


{\displaystyle n}

), and a size of resulting selection, 



k


{\displaystyle k}

, by reporting the sets of cardinality 



k


{\displaystyle k}

 where each member of those sets is chosen from 



S


{\displaystyle S}

.
In the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.
For example:

Q: How many ways can a person choose two doughnuts from a store selling three types of doughnut: iced, jam, and plain? (i.e., 



S


{\displaystyle S}

 is 



{

i
c
e
d

,

j
a
m

,

p
l
a
i
n

}


{\displaystyle \{\mathrm {iced} ,\mathrm {jam} ,\mathrm {plain} \}}

, 




|

S

|

=
3


{\displaystyle |S|=3}

, and 



k
=
2


{\displaystyle k=2}

.)
A: 6: {iced, iced}; {iced, jam}; {iced, plain}; {jam, jam}; {jam, plain}; {plain, plain}.
Note that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.
Also note that doughnut can also be spelled donut.



Task

 Write a function/program/routine/.. to generate all the combinations with repetitions of 



n


{\displaystyle n}

 types of things taken 



k


{\displaystyle k}

 at a time and use it to show an answer to the doughnut example above.
 For extra credit, use the function to compute and show just the number of ways of choosing three doughnuts from a choice of ten types of doughnut. Do not show the individual choices for this part.


References

 k-combination with repetitions


See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,">>> from itertools import combinations_with_replacement
>>> n, k = 'iced jam plain'.split(), 2
>>> list(combinations_with_replacement(n,k))
[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]
>>> # Extra credit
>>> len(list(combinations_with_replacement(range(10), 3)))
220
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Munching_squares,Munching squares,"Render a graphical pattern where each pixel is colored by the value of 'x xor y' from an arbitrary color table.
",Python,"import math
import struct
 
def hue_to_rgb(hue, sat):
	x = 0
	c = 255 * sat
	hue /= 60
	x = (1 - abs(math.fmod(hue, 2) - 1)) * 255
 
	if hue == 0:
		return (c, x, 0)
	elif hue == 1:
		return (x, c, 0)
	elif hue == 2:
		return (0, c, x)
	elif hue == 3:
		return (0, x, c)
	elif hue == 4:
		return (x, 0, c)
	elif hue == 5:
		return (c, 0, x)
 
size = 512
colors = [hue_to_rgb(i * 240. / size, i * 1. / size) for i in range(size)]
pix = [colors[(i ^ j)] for i in range(size) for j in range(size)]
 
with open(""xor.ppm"", ""wb"") as f:
	f.write(""P6\n%d %d\n255\n"" % (size, size))
	f.write(struct.pack(""%dB"" % (size * size * 3), *sum(pix, ())))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,">>> def fiblike(start):
	addnum = len(start)
	memo = start[:]
	def fibber(n):
		try:
			return memo[n]
		except IndexError:
			ans = sum(fibber(i) for i in range(n-addnum, n))
			memo.append(ans)
			return ans
	return fibber
 
>>> fibo = fiblike([1,1])
>>> [fibo(i) for i in range(10)]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> lucas = fiblike([2,1])
>>> [lucas(i) for i in range(10)]
[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]
>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :
	fibber = fiblike([1] + [2**i for i in range(n-1)])
	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))
 
 
n= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...
n= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...
n= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...
n= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...
n= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...
n= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...
n= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...
n= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...
n=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Digital_root,Digital root,"The digital root, 



X


{\displaystyle X}

, of a number, 



n


{\displaystyle n}

, is calculated:

 find 



X


{\displaystyle X}

 as the sum of the digits of 



n


{\displaystyle n}


 find a new 



X


{\displaystyle X}

 by summing the digits of 



X


{\displaystyle X}

, repeating until 



X


{\displaystyle X}

 has only one digit.
The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:





627615


{\displaystyle 627615}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;




39390


{\displaystyle 39390}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



6


{\displaystyle 6}

;




588225


{\displaystyle 588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



3


{\displaystyle 3}

;




393900588225


{\displaystyle 393900588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;
The digital root may be calculated in bases other than 10.



See

 Casting out nines for this wiki's use of this procedure.
 Digital root/Multiplicative digital root
 Sum digits of an integer
 Digital root sequence on OEIS
 Additive persistence sequence on OEIS
 Iterated digits squaring

",Python,"import math
import sys
 
def sum(i, base):
	b64 = base
	sum = 0
	while i > 0:
		sum += i % b64
		i /= b64
	return sum
 
def digital_root(n, base):
	root = n
	for x in range(n, base, -1):
		root = sum(x, base)
	return root
 
def persistence(n, base):
	persistence = 0
	root = n
	for x in range(n, base, -1):
		root = sum(x, base)
		persistence += 1
	return persistence
 
def main():
	test_cases = [
		(""627615"", 10, 2, 9),
		(""39390"", 10, 2, 6),
		(""588225"", 10, 2, 3),
		(""393900588225"", 10, 2, 9),
		(""1"", 10, 0, 1),
		(""11"", 10, 1, 2),
		(""e"", 16, 0, 0xe),
		(""87"", 16, 1, 0xf),
		# From Applesoft BASIC example:
		(""DigitalRoot"", 30, 2, 26), # 26 is Q base 30
		# From C++ example:
		(""448944221089"", 10, 3, 1),
		(""7e0"", 16, 2, 0x6),
		(""14e344"", 16, 2, 0xf),
		(""d60141"", 16, 2, 0xa),
		(""12343210"", 16, 2, 0x1),
		# From the D example:
		(""1101122201121110011000000"", 3, 3, 1),
	]
	for tc in test_cases:
		n = int(tc[0], tc[1])
		p = persistence(n, tc[1])
		r = digital_root(n, tc[1])
		print ""%12v (base %2d) has additive persistence %d and digital root %s"" % (tc[0], tc[1], p, r)
		if p!= tc[2] or r!= tc[3]:
			print ""bad result:"", tc, p, r
			sys.exit(1)
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Matrix_chain_multiplication,Matrix chain multiplication,"Problem
Using the most straightfoward algorithm (which we assume here), computing the product of two matrices of dimensions (n1,n2) and (n2,n3) requires n1*n2*n3 FMA operations. The number of operations required to compute the product of matrices A1, A2... An depends on the order of matrix multiplications, hence on where parens are put. Remember that the matrix product is associative, but not commutative, hence only the parens can be moved.

For instance, with four matrices, one can compute A(B(CD)), A((BC)D), (AB)(CD), (A(BC))D, (AB)C)D. The number of different ways to put the parens is a Catalan number, and grows exponentially with the number of factors.

Here is an example of computation of the total cost, for matrices A(5,6), B(6,3), C(3,1):

 AB costs 5*6*3=90 and produces a matrix of dimensions (5,3), then (AB)C costs 5*3*1=15. The total cost is 105.
 BC costs 6*3*1=18 and produces a matrix of dimensions (6,1), then A(BC) costs 5*6*1=30. The total cost is 48.
In this case, computing (AB)C requires more than twice as many operations as A(BC). The difference can be much more dramatic in real cases.

Task
Write a function which, given a list of the successive dimensions of matrices A1, A2... An, of arbitrary length, returns the optimal way to compute the matrix product, and the total cost. Any sensible way to describe the optimal solution is accepted. The input list does not duplicate shared dimensions: for the previous example of matrices A,B,C, one will only pass the list [5,6,3,1] (and not [5,6,6,3,3,1]) to mean the matrix dimensions are respectively (5,6), (6,3) and (3,1). Hence, a product of n matrices is represented by a list of n+1 dimensions.

Try this function on the following two lists:

 [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2]
 [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]
To solve the task, it's possible, but not required, to write a function that enumerates all possible ways to parenthesize the product. This is not optimal because of the many duplicated computations, and this task is a classic application of dynamic programming.

See also Matrix chain multiplication on Wikipedia.
",Python,"# Version 1.2.31
 
m = []
s = []
 
def optimalMatrixChainOrder(dims):
    n = len(dims) - 1
    m = [[0 for x in range(n)] for y in range(n)]
    s = [[0 for x in range(n)] for y in range(n)]
    for len in range(1, n):
        for i in range(0, n - len):
            j = i + len
            m[i][j] = float('inf')
            for k in range(i, j):
                temp = dims[i] * dims [k + 1] * dims[j + 1]
                cost = m[i][k] + m[k + 1][j] + temp
                if cost < m[i][j]:
                    m[i][j] = cost
                    s[i][j] = k
    return m, s
 
def printOptimalChainOrder(i, j, s):
    if i == j:
        print(chr(i + 65), end='')
    else:
        print(""("", end='')
        printOptimalChainOrder(i, s[i][j], s)
        printOptimalChainOrder(s[i][j] + 1, j, s)
        print("")"", end='')
 
def main():
    dimsList = [
        [5, 6, 3, 1],
        [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2],
        [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]
    ]
    for dims in dimsList:
        print(""Dims  : {}"".format(dims))
        m, s = optimalMatrixChainOrder(dims)
        print(""Order : "", end='')
        printOptimalChainOrder(0, len(s) - 1, s)
        print(""\nCost  : {}\n"".format(m[0][len(s) - 1]))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def shortest_abbreviation_length(line, list_size):
    words = line.split()
    word_count = len(words)
    # Can't give true answer with unexpected number of entries
    if word_count != list_size:
        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')
 
    # Find the small slice length that gives list_size unique values
    abbreviation_length = 1
    abbreviations = set()
    while(True):
        abbreviations = {word[:abbreviation_length] for word in words}
        if len(abbreviations) == list_size:
            return abbreviation_length
        abbreviation_length += 1
        abbreviations.clear()
 
def automatic_abbreviations(filename, words_per_line):
    with open(filename) as file:
        for line in file:
            line = line.rstrip()
            if len(line) > 0:
                length = shortest_abbreviation_length(line, words_per_line)
                print(f'{length:2} {line}')
            else:
                print()
 
automatic_abbreviations('daysOfWeek.txt', 7)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Copy_stdin_to_stdout,Copy stdin to stdout,"Create an executable file that copies stdin to stdout, or else a script that does so through the invocation of an interpreter at the command line.
",Python,"import sys
 
for line in sys.stdin:
    print(line, end='')",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Polymorphism,Polymorphism,"Task

Create two classes   Point(x,y)   and   Circle(x,y,r)   with a polymorphic function print, accessors for (x,y,r), copy constructor, assignment and destructor and every possible default constructors



",Python,"# version 1.1.2
 
class Point(x, y):
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def __init__(self, x):
        self.x = x
        self.y = 0
 
    def __init__(self, p):
        self.x = p.x
        self.y = p.y
 
    def finalize(self):
        print(""Finalizing %s..."" % self)
 
    def __str__(self):
        return ""Point at (%d, %d)"" % (self.x, self.y)
 
    def print(self):
        print(self)
 
class Circle(x, y, r):
    def __init__(self, x, y, r):
        self.x = x
        self.y = y
        self.r = r
 
    def __init__(self):
        self.x = 0
        self.y = 0
        self.r = 0
 
    def __init__(self, x):
        self.x = x
        self.y = 0
        self.r = 0
 
    def __init__(self, x, r):
        self.x = x
        self.y = 0
        self.r = r
 
    def __init__(self, c):
        self.x = c.x
        self.y = c.y
        self.r = c.r
 
    def finalize(self):
        print(""Finalizing %s..."" % self)
 
    def __str__(self):
        return ""Circle at center (%d, %d), radius %d"" % (self.x, self.y, self.r)
 
    def print(self):
        print(self)
 
def createObjects():
    points = [Point(), Point(1), Point(2, 3), Point(Point(3, 4))]
    for point in points:
        point.print()
    circles = [Circle(), Circle(1), Circle(2, 3), Circle(4, 5, 6), Circle(Circle(7, 8, 9))]
    for circle in circles:
        circle.print()
    print()
 
def main(args):
    createObjects()
    # try and force garbage collection
    # allow time for finalizers to run
    print()
    p = Point(5, 6)
    p.print()
    p.y = 7  # change y coordinate
    p.print()
    c = Circle(5, 6, 7)
    c.print()
    c.r = 8
    c.print()  # change radius
    # note that finalizers for p and c are not called
 
if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Word_wrap,Word wrap,"Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column.



Basic task

The basic task is to wrap a paragraph of text in a simple way in your language.

If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.

Show your routine working on a sample of text at two different wrap columns.



Extra credit

Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you must reference documentation indicating that the algorithm
is something better than a simple minimum length algorithm.

If you have both basic and extra credit solutions, show an example where
the two algorithms give different results.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import chain
from functools import reduce
from operator import add

lorem_ipsum = """"""
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien
vel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu
pharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus
consectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque
penatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt
purus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel
felis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta
tortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,
condimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed
venenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu
nibh.""""""

def wrap(text, line_width):
    return ''.join(wrap_words(text.split(), line_width))

def wrap_words(words, line_width):
    current_width = 0
    for word in words:
        if current_width!= 0:
            if current_width + len(word) < line_width:
                current_width += 1
                yield''
            else:
                current_width = 0
                yield '\n'
        current_width += len(word)
        yield word

for line_width in (72, 80):
    print('-' * line_width)
    print(wrap(lorem_ipsum, line_width))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Loops/Foreach,Loops/Foreach,"Loop through and print each element in a collection in order.

Use your language's ""for each"" loop if it has one, otherwise iterate through the collection in order with some other loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"list = [""Red"",""Green"",""Blue"",""Black"",""White""]
for ix in range(len(list)):
   print(list[ix])",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"a = int(input(""enter a value for a: ""))
b = int(input(""enter a value for b: ""))
 
if a < b:
    print(f""{a} is less than {b}"")
elif a > b:
    print(f""{a} is greater than {b}"")
else:
    print(f""{a} is equal to {b}"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",Python,"import numpy as np
import matplotlib.pyplot as plt

maxIterations = 450
minX = -.5
maxX =.5
minY = -.5
maxY =.5
wid = 800
hei = 800
jsX = 0.285
jsY = 0.01

def remap(x, t1, t2, s1, s2):
    f = (x - t1) / (t2 - t1)
    g = f * (s2 - s1) + s1
    return g

def getColor(c):
    p = c / 32
    l = int(p * 6)
    o = p * 6 - l
    q = 1 - o
    if l % 6 == 0:
        r = 1
        g = o
        b = 0
    elif l % 6 == 1:
        r = q
        g = 1
        b = 0
    elif l % 6 == 2:
        r = 0
        g = 1
        b = o
    elif l % 6 == 3:
        r = 0
        g = q
        b = 1
    elif l % 6 == 4:
        r = o
        g = 0
        b = 1
    elif l % 6 == 5:
        r = 1
        g = 0
        b = q
    c = ""#"" + (""00"" + str(int(r * 255))).zfill(2) + (""00"" + str(int(g * 255))).zfill(2) + (""00"" + str(int(b * 255))).zfill(2)
    return c

def drawFractal():
    for j in range(hei):
        for i in range(wid):
            a = remap(i, 0, wid, minX, maxX)
            b = remap(j, 0, hei, minY, maxY)
            cnt = 0
            while cnt < maxIterations:
                za = a * a
                zb = b * b
                if za + zb > 4:
                    break
                as_ = za - zb
                bs = 2 * a * b
                a = as_ + jsX
                b = bs + jsY
                cnt += 1
            if cnt < maxIterations:
                plt.plot(i, j, color=getColor(cnt))
    plt.show()

drawFractal()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane,Find the intersection of a line with a plane,"Finding the intersection of an infinite ray with a plane in 3D is an important topic in collision detection.



Task

Find the point of intersection for the infinite ray with direction   (0, -1, -1)   passing through position   (0, 0, 10)   with the infinite plane with a normal vector of   (0, 0, 1)   and which passes through [0, 0, 5].



",Python,"#!/bin/python
from __future__ import print_function
import numpy as np
 
def LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6):
 
	ndotu = planeNormal.dot(rayDirection)
	if abs(ndotu) < epsilon:
		raise RuntimeError(""no intersection or line is within plane"")
 
	w = rayPoint - planePoint
	si = -planeNormal.dot(w) / ndotu
	Psi = w + si * rayDirection + planePoint
	return Psi
 
 
if __name__==""__main__"":
	#Define plane
	planeNormal = np.array([0, 0, 1])
	planePoint = np.array([0, 0, 5]) #Any point on the plane
 
	#Define ray
	rayDirection = np.array([0, -1, -1])
	rayPoint = np.array([0, 0, 10]) #Any point along the ray
 
	Psi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)
	print (""intersection at"", Psi)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Unbias_a_random_generator,Unbias a random generator,"




P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}




Task details

 Use your language's random number generator to create a function/method/subroutine/... randN that returns a one or a zero, but with one occurring, on average, 1 out of N times, where N is an integer from the range 3 to 6 inclusive.
 Create a function unbiased that uses only randN as its source of randomness to become an unbiased generator of random ones and zeroes.
 For N over its range, generate and show counts of the outputs of randN and unbiased(randN).


The actual unbiasing should be done by generating two numbers at a time from randN and only returning a 1 or 0 if they are different. As long as you always return the first number or always return the second number, the probabilities discussed above should take over the biased probability of randN.

This task is an implementation of Von Neumann debiasing, first described in a 1951 paper.



",Python,"import random
 
def biased(bias):
	""""""
	balance out the bins, being pedantic
	""""""
	rand_max = random.RAND_MAX - (random.RAND_MAX % bias)
	r = random.rand()
	while r > rand_max:
		r = random.rand()
	return r < rand_max / bias
 
def unbiased(bias):
	a = biased(bias)
	while a == biased(bias):
		a = biased(bias)
	return a
 
def main():
	n = 10000
	for b in range(3, 7):
		cb = cu = 0
		for i in range(n):
			cb += biased(b)
			cu += unbiased(b)
		print ""bias %d: %5.3f%% vs %5.3f%%"" % (b, 100. * cb / n, 100. * cu / n)
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Random_number_generator_(included),Random number generator (included),"The task is to:

 State the type of random number generator algorithm used in a language's built-in random number generator. If the language or its immediate libraries don't provide a random number generator, skip this task.
 If possible, give a link to a wider explanation of the algorithm used.
Note: the task is not to create an RNG, but to report on the languages in-built RNG that would be the most likely RNG used.

The main types of pseudo-random number generator (PRNG) that are in use are the Linear Congruential Generator (LCG), and the Generalized Feedback Shift Register (GFSR), (of which the Mersenne twister generator is a subclass). The last main type is where the output of one of the previous ones (typically a Mersenne twister) is fed through a cryptographic hash function to maximize unpredictability of individual bits.

Note that neither LCGs nor GFSRs should be used for the most demanding applications (cryptography) without additional steps.
",Python,"import random
random.seed(3)
random.randint(1,6)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Web_scraping,Web scraping,"Task

Create a program that downloads the time from this URL:   http://tycho.usno.navy.mil/cgi-bin/timer.pl   and then prints the current UTC time by extracting just the UTC time from the web page's HTML. Alternatively, if the above url is not working, grab the first date/time off this page's talk page.



If possible, only use libraries that come at no extra monetary cost with the programming language and that are widely available and popular such as CPAN for Perl or Boost for C++.



",Python,"import urllib
page = urllib.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl')
for line in page:
    if ' UTC' in line:
        print line.strip()[4:]
        break
page.close()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Combinations_with_repetitions,Combinations with repetitions,"The set of combinations with repetitions is computed from a set, 



S


{\displaystyle S}

 (of cardinality 



n


{\displaystyle n}

), and a size of resulting selection, 



k


{\displaystyle k}

, by reporting the sets of cardinality 



k


{\displaystyle k}

 where each member of those sets is chosen from 



S


{\displaystyle S}

.
In the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.
For example:

Q: How many ways can a person choose two doughnuts from a store selling three types of doughnut: iced, jam, and plain? (i.e., 



S


{\displaystyle S}

 is 



{

i
c
e
d

,

j
a
m

,

p
l
a
i
n

}


{\displaystyle \{\mathrm {iced} ,\mathrm {jam} ,\mathrm {plain} \}}

, 




|

S

|

=
3


{\displaystyle |S|=3}

, and 



k
=
2


{\displaystyle k=2}

.)
A: 6: {iced, iced}; {iced, jam}; {iced, plain}; {jam, jam}; {jam, plain}; {plain, plain}.
Note that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.
Also note that doughnut can also be spelled donut.



Task

 Write a function/program/routine/.. to generate all the combinations with repetitions of 



n


{\displaystyle n}

 types of things taken 



k


{\displaystyle k}

 at a time and use it to show an answer to the doughnut example above.
 For extra credit, use the function to compute and show just the number of ways of choosing three doughnuts from a choice of ten types of doughnut. Do not show the individual choices for this part.


References

 k-combination with repetitions


See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"import itertools
 
def generate_combinations(combination_list, k):
    combinations = []
 
    if k == 0:
        empty_combination = []
        combinations.append(empty_combination)
 
        return combinations
 
    if len(combination_list) == 0:
        return combinations
 
    head = combination_list[0]
    copied_combination_list = combination_list[:]
 
    subcombinations = generate_combinations(copied_combination_list, k - 1)
 
    for subcombination in subcombinations:
        subcombination.insert(0, head)
        combinations.append(subcombination)
 
    combination_list.remove(head)
    combinations.extend(generate_combinations(combination_list, k))
 
    return combinations
 
if __name__ == '__main__':
    set = ['iced', 'jam', 'plain']
    combinations = generate_combinations(set, 2)
 
    for combination in combinations:
        combination_str =''.join(combination)
        print(combination_str)
 
    donuts = list(range(1, 11))
 
    donuts_combinations_number = len(list(itertools.combinations(donuts, 3)))
 
    print('{0} ways to order 3 donuts given 10 types'.format(donuts_combinations_number))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Idiomatically_determine_all_the_lowercase_and_uppercase_letters,Idiomatically determine all the lowercase and uppercase letters,"
Idiomatically determine all the lowercase and uppercase letters   (of the Latin [English] alphabet)   being used currently by a computer programming language.
The method should find the letters regardless of the hardware architecture that is being used (ASCII, EBCDIC, or other).



Task requirements
Display the set of all:

   lowercase letters 
   uppercase letters

that can be used (allowed) by the computer program,


where   letter   is a member of the Latin (English) alphabet:     a ──► z     and     A ──► Z.



You may want to mention what hardware architecture is being used, and if applicable, the operating system.



See also
 Idiomatically determine all the characters that can be used for symbols.

",Python,"# version 1.0.6

def main(args):
    print(""Lower case : "")
    for ch in range(ord('a'), ord('z') + 1):
        print(chr(ch), end='')
    print(""\nUpper case : "")
    for ch in range(ord('A'), ord('Z') + 1):
        print(chr(ch), end='')
    print()

if __name__ == '__main__':
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",Python,"#!/usr/bin/env python
print 2**64*2**64",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Temperature_conversion,Temperature conversion,"There are quite a number of temperature scales. For this task we will concentrate on four of the perhaps best-known ones:
Kelvin, Celsius, Fahrenheit, and Rankine.

The Celsius and Kelvin scales have the same magnitude, but different null points.

 0 degrees Celsius corresponds to 273.15 kelvin.
 0 kelvin is absolute zero.
The Fahrenheit and Rankine scales also have the same magnitude, but different null points.

 0 degrees Fahrenheit corresponds to 459.67 degrees Rankine.
 0 degrees Rankine is absolute zero.
The Celsius/Kelvin and Fahrenheit/Rankine scales have a ratio of 5 : 9.



Task
Write code that accepts a value of kelvin, converts it to values of the three other scales, and prints the result.



Example

K  21.00

C  -252.15

F  -421.87

R  37.80


",Python,"import sys
 
def kelvinToCelsius(k):
    return k - 273.15
 
def kelvinToFahrenheit(k):
    return k * 1.8 - 459.67
 
def kelvinToRankine(k):
    return k * 1.8
 
def convertKelvin(kelvin):
    print(""K %.2f"" % kelvin)
    print(""C %.2f"" % kelvinToCelsius(kelvin))
    print(""F %.2f"" % kelvinToFahrenheit(kelvin))
    print(""R %.2f"" % kelvinToRankine(kelvin))
 
if __name__ == ""__main__"":
    if len(sys.argv) > 1:
        kelvin = float(sys.argv[1])
        convertKelvin(kelvin)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm,Bitmap/Bresenham's line algorithm,"Task

Using the data storage type defined on the Bitmap page for raster graphics images,

draw a line given two points with Bresenham's line algorithm.



",Python,"import math
from PIL import Image, ImageDraw

def draw_line(bitmap, x0, y0, x1, y1, color):
    dx = abs(x1 - x0)
    sx = 1 if x0 < x1 else -1
    dy = abs(y1 - y0)
    sy = 1 if y0 < y1 else -1
    err = (dx if dx > dy else -dy) / 2
    e2 = 0
    while True:
        bitmap.putpixel((x0, y0), color)
        if x0 == x1 and y0 == y1:
            break
        e2 = err
        if e2 > -dx:
            err -= dy
            x0 += sx
        if e2 < dy:
            err += dx
            y0 += sy
    return bitmap

def main():
    bitmap = Image.new('RGB', (200, 200))
    draw_line(bitmap, 0, 0, 199, 199, (0, 0, 0))
    draw_line(bitmap, 199, 0, 0, 199, (0, 0, 0))
    draw_line(bitmap, 50, 75, 150, 125, (0, 0, 255))
    draw_line(bitmap, 150, 75, 50, 125, (0, 0, 255))
    bitmap.save('line.png')

if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",Python,"def y(f):
    def g(x):
        return x(x)
    return g(lambda x: f(lambda *args: x(x)(*args)))
 
def fac(n):
    return y(lambda f, x: 1 if x == 0 else x * f(x - 1))(n)
 
def fib(n):
    return y(lambda f, (a0, a1, x): a0 if x == 0 else a1 if x == 1 else f((a1, a0 + a1, x - 1)))(1, 1, n)
 
print(fac(10))
print(fib(10))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Thue-Morse,Thue-Morse,"Task

Create a Thue-Morse sequence.



See also
   YouTube entry: The Fairest Sharing Sequence Ever
   YouTube entry: Math and OCD - My story with the Thue-Morse sequence
   Task: Fairshare between two and more

",Python,"m='0'
print(m)
for i in range(0,6):
     m0=m
     m=m.replace('0','a')
     m=m.replace('1','0')
     m=m.replace('a','1')
     m=m0+m
     print(m)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Pascal%27s_triangle,Pascal's triangle,"Pascal's triangle is an arithmetic and geometric figure often associated with the name of Blaise Pascal, but also studied centuries earlier in India, Persia, China and elsewhere.

Its first few rows look like this: 

    1
   1 1
  1 2 1
 1 3 3 1 

where each element of each row is either 1 or the sum of the two elements right above it.

For example, the next row of the triangle would be:

   1   (since the first element of each row doesn't have two elements above it)
   4   (1 + 3)
   6   (3 + 3)
   4   (3 + 1)
   1   (since the last element of each row doesn't have two elements above it) 
So the triangle now looks like this: 

    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1 

Each row    n    (starting with row   0   at the top) shows the coefficients of the binomial expansion of    (x + y)n. 



Task

Write a function that prints out the first    n    rows of the triangle   (with    f(1)    yielding the row consisting of only the element 1).

This can be done either by summing elements from the previous rows or using a binary coefficient or combination function.

Behavior for    n ≤ 0    does not need to be uniform, but should be noted.



See also

 Evaluate binomial coefficients

",Python,"def genPyrN(rows):
	if rows < 0:
		return
	#save the last row here
	last = [1]
	print(last)
	for i in range(1, rows + 1):
		#work on the next row
		thisRow = [last[0]] #beginning
		for j in range(1, i):#loop the number of elements in this row
			#sum from the last row
			thisRow.append(last[j - 1] + last[j])
		thisRow.append(last[0]) #end
		last = thisRow#save this row
		print(thisRow)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def remove_comments(line, sep):
    for s in sep:
        i = line.find(s)
        if i >= 0:
            line = line[:i]
    return line.strip()
 
# test
print remove_comments('apples ; pears # and bananas', ';#')
print remove_comments('apples ; pears # and bananas', '!')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def main(args):
    s = ""Hello""
    print(s.contains(""H"")) # True
    print(s.contains(""e"")) # True
    print(s.contains(""l"")) # True
    print(s.contains(""o"")) # True
    print(s.contains(""x"")) # False
    print(s.contains(""He"")) # True
    print(s.contains(""el"")) # True
    print(s.contains(""ll"")) # True
    print(s.contains(""lo"")) # True
    print(s.contains(""lx"")) # False
    print(s.contains(""Hell"")) # True
    print(s.contains(""ell"")) # True
    print(s.contains(""llo"")) # True
    print(s.contains(""llox"")) # False
    print(s.contains(""Hello"")) # True
    print(s.contains(""ello"")) # True
    print(s.contains(""lloo"")) # False
    print(s.contains(""lloox"")) # False",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Soundex,Soundex,"Soundex is an algorithm for creating indices for words based on their pronunciation.



Task

The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling   (from the   soundex   Wikipedia article).

Caution

There is a major issue in many of the implementations concerning the separation of two consonants that have the same soundex code! According to the official Rules [[1]]. So check for instance if Ashcraft is coded to A-261.

 If a vowel (A, E, I, O, U) separates two consonants that have the same soundex code, the consonant to the right of the vowel is coded. Tymczak is coded as T-522 (T, 5 for the M, 2 for the C, Z ignored (see ""Side-by-Side"" rule above), 2 for the K). Since the vowel ""A"" separates the Z and K, the K is coded.
 If ""H"" or ""W"" separate two consonants that have the same soundex code, the consonant to the right of the vowel is not coded. Example: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226.

",Python,"from itertools import groupby
 
def soundex(word):
   codes = (""bfpv"",""cgjkqsxz"", ""dt"", ""l"", ""mn"", ""r"")
   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)
   cmap2 = lambda kar: soundDict.get(kar, '9')
   sdx =  ''.join(cmap2(kar) for kar in word.lower())
   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')
   sdx3 = sdx2[0:4].ljust(4,'0')
   return sdx3",Human_written,Python_from_C#
http://rosettacode.org/wiki/Keyboard_macros,Keyboard macros,"Show how to link user defined methods to user defined keys.

An example of this is the facility provided by emacs for key bindings.

These key bindings may be application-specific or system-wide; state which you have done.



",Python,"import javax.swing.JFrame
import javax.swing.JLabel
import java.awt.event.KeyAdapter
import java.awt.event.KeyEvent
 
class KeyboardMacroDemo:
    def __init__(self):
        frame = JFrame()
 
        directions = ""<html><b>Ctrl-S</b> to show frame title<br>"" + ""<b>Ctrl-H</b> to hide it</html>""
 
        frame.add(JLabel(directions))
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
 
        frame.addKeyListener(KeyAdapter(self))
        frame.pack()
        frame.setVisible(True)
 
    def keyReleased(self, e):
        if e.isControlDown() and e.getKeyCode() == KeyEvent.VK_S:
            frame.setTitle(""Hello there"")
        elif e.isControlDown() and e.getKeyCode() == KeyEvent.VK_H:
            frame.setTitle("""")
 
KeyboardMacroDemo()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Unprimeable_numbers,Unprimeable numbers,"Definitions

As used here, all unprimeable numbers   (positive integers)   are always expressed in base ten.



───── Definition from OEIS ─────:

Unprimeable numbers are composite numbers that always remain composite when a single decimal digit of the number is changed.



───── Definition from Wiktionary   (referenced from Adam Spencer's book) ─────:

(arithmetic)   that cannot be turned into a prime number by changing just one of its digits to any other
digit.   (sic)



Unprimeable numbers are also spelled:   unprimable.

All one─ and two─digit numbers can be turned into primes by changing a single decimal digit.



Examples

190   isn't unprimeable,   because by changing the zero digit into a three yields   193,   which is a prime.



The number   200   is unprimeable,   since none of the numbers   201, 202, 203, ··· 209   are
prime, and all the other numbers obtained by changing a single digit to
produce   100, 300, 400, ··· 900,   or   210, 220, 230, ··· 290   which are all even.



It is valid to change   189   into   089   by changing the   1   (one)   into
a   0   (zero),   which then the leading zero can be removed,   and then treated as if
the   ""new""   number is   89.



Task

   show the first   35   unprimeable numbers   (horizontally, on one line, preferably with a title)
   show the   600th   unprimeable number
   (optional) show the lowest unprimeable number ending in a specific decimal digit   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
   (optional) use commas in the numbers where appropriate


Show all output here, on this page.



Also see

   the     OEIS     entry:   A118118 (unprimeable)
   with some useful counts to compare unprimeable number
   the Wiktionary entry (reference from below):   (arithmetic definition) unprimeable
   from the Adam Spencer book   (page 200):   Adam Spencer's World of Numbers       (Xoum Publishing)

",Python,"MAX = 10000000
primes = [True] * MAX
 
def sieve():
    #  primes
    for i in range(2, MAX):
        primes[i] = True
    for i in range(2, MAX):
        if primes[i]:
            j = 2 * i
            while j < MAX:
                primes[j] = False
                j += i
 
def unPrimable(test):
    if primes[test]:
        return False
    s = str(test)
    for i in range(len(s)):
        for j in range(10):
            if primes[replace(s, i, j)]:
                return False
    return True
 
def replace(s, position, value):
    sChar = list(s)
    sChar[position] = str(value)
    return int("""".join(sChar))
 
def displayUnprimeableNumbers(maxCount):
    test = 1
    count = 0
    while count < maxCount:
        test += 1
        if unPrimable(test):
            count += 1
            print(test, end="" "")
    print()
 
def nthUnprimeableNumber(maxCount):
    test = 1
    count = 0
    result = 0
    while count < maxCount:
        test += 1
        if unPrimable(test):
            count += 1
            result = test
    return result
 
def genLowest():
    lowest = [0] * 10
    count = 0
    test = 1
    while count < 10:
        test += 1
        if unPrimable(test) and lowest[test % 10] == 0:
            lowest[test % 10] = test
            count += 1
    return lowest
 
if __name__ == ""__main__"":
    sieve()
    print(""First 35 unprimeable numbers:"")
    displayUnprimeableNumbers(35)
    n = 600
    print()
    print(""The"", n, ""th unprimeable number ="", nthUnprimeableNumber(n))
    print()
    lowest = genLowest()
    print(""Least unprimeable number that ends in:"")
    for i in range(10):
        print("" "", i, ""is"", lowest[i])",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Program_termination,Program termination,"

Task

Show the syntax for a complete stoppage of a program inside a   conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.



",Python,"import sys
if problem:
    sys.exit(1)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",Python,"import sys
 
integers = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]
length = len(integers)
maxsum = beginmax = sum = 0
endmax = -1
 
for i in range(0, length):
    sum = 0
    for k in range(i, length):
        sum += integers[k]
        if sum > maxsum:
            maxsum = sum
            beginmax = i
            endmax = k
 
for i in range(beginmax, endmax + 1):
    print(integers[i])
 
input()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Loops/For_with_a_specified_step,Loops/For with a specified step,"

Task

Demonstrate a   for-loop   where the step-value is greater than one.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"for i in xrange(2, 9, 2):
    print ""%d,"" % i,
print ""who do we appreciate?""",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Solve_a_Numbrix_puzzle,Solve a Numbrix puzzle,"Numbrix puzzles are similar to Hidato.
The most important difference is that it is only possible to move 1 node left, right, up, or down (sometimes referred to as the Von Neumann neighborhood).
Published puzzles also tend not to have holes in the grid and may not always indicate the end node.
Two examples follow:

Example 1
Problem.

 0  0  0  0  0  0  0  0  0
 0  0 46 45  0 55 74  0  0
 0 38  0  0 43  0  0 78  0
 0 35  0  0  0  0  0 71  0
 0  0 33  0  0  0 59  0  0
 0 17  0  0  0  0  0 67  0
 0 18  0  0 11  0  0 64  0
 0  0 24 21  0  1  2  0  0
 0  0  0  0  0  0  0  0  0

Solution.

 49 50 51 52 53 54 75 76 81
 48 47 46 45 44 55 74 77 80
 37 38 39 40 43 56 73 78 79
 36 35 34 41 42 57 72 71 70
 31 32 33 14 13 58 59 68 69
 30 17 16 15 12 61 60 67 66
 29 18 19 20 11 62 63 64 65
 28 25 24 21 10  1  2  3  4
 27 26 23 22  9  8  7  6  5

Example 2
Problem.

 0  0  0  0  0  0  0  0  0
 0 11 12 15 18 21 62 61  0
 0  6  0  0  0  0  0 60  0
 0 33  0  0  0  0  0 57  0
 0 32  0  0  0  0  0 56  0
 0 37  0  1  0  0  0 73  0
 0 38  0  0  0  0  0 72  0
 0 43 44 47 48 51 76 77  0
 0  0  0  0  0  0  0  0  0

Solution.

  9 10 13 14 19 20 63 64 65
  8 11 12 15 18 21 62 61 66
  7  6  5 16 17 22 59 60 67
 34 33  4  3 24 23 58 57 68
 35 32 31  2 25 54 55 56 69
 36 37 30  1 26 53 74 73 70
 39 38 29 28 27 52 75 72 71
 40 43 44 47 48 51 76 77 78
 41 42 45 46 49 50 81 80 79

Task
Write a program to solve puzzles of this ilk,
demonstrating your program by solving the above examples.
Extra credit for other interesting examples.



Related tasks

 A* search algorithm
 Solve a Holy Knight's tour
 Knight's tour
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve the no connection puzzle

",Python,"import java.util.*;
 
public class Numbrix {
 
    final static String[] board = {
        ""00,00,00,00,00,00,00,00,00"",
        ""00,00,46,45,00,55,74,00,00"",
        ""00,38,00,00,43,00,00,78,00"",
        ""00,35,00,00,00,00,00,71,00"",
        ""00,00,33,00,00,00,59,00,00"",
        ""00,17,00,00,00,00,00,67,00"",
        ""00,18,00,00,11,00,00,64,00"",
        ""00,00,24,21,00,01,02,00,00"",
        ""00,00,00,00,00,00,00,00,00""};
 
    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
 
    static int[][] grid;
    static int[] clues;
    static int totalToFill;
 
    public static void main(String[] args) {
        int nRows = board.length + 2;
        int nCols = board[0].split("","").length + 2;
        int startRow = 0, startCol = 0;
 
        grid = new int[nRows][nCols];
        totalToFill = (nRows - 2) * (nCols - 2);
        List<Integer> lst = new ArrayList<>();
 
        for (int r = 0; r < nRows; r++) {
            Arrays.fill(grid[r], -1);
 
            if (r >= 1 && r < nRows - 1) {
 
                String[] row = board[r - 1].split("","");
 
                for (int c = 1; c < nCols - 1; c++) {
                    int val = Integer.parseInt(row[c - 1]);
                    if (val > 0)
                        lst.add(val);
                    if (val == 1) {
                        startRow = r;
                        startCol = c;
                    }
                    grid[r][c] = val;
                }
            }
        }
 
        clues = lst.stream().sorted().mapToInt(i -> i).toArray();
 
        if (solve(startRow, startCol, 1, 0))
            printResult();
    }
 
    static boolean solve(int r, int c, int count, int nextClue) {
        if (count > totalToFill)
            return true;
 
        if (grid[r][c]!= 0 && grid[r][c]!= count)
            return false;
 
        if (grid[r][c] == 0 && nextClue < clues.length)
            if (clues[nextClue] == count)
                return false;
 
        int back = grid[r][c];
        if (back == count)
            nextClue++;
 
        grid[r][c] = count;
        for (int[] move : moves)
            if (solve(r + move[1], c + move[0], count + 1, nextClue))
                return true;
 
        grid[r][c] = back;
        return false;
    }
 
    static void printResult() {
        for (int[] row : grid) {
            for (int i : row) {
                if (i == -1)
                    continue;
                System.out.printf(""%2d "", i);
            }
            System.out.println();
        }
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Dining_philosophers,Dining philosophers,"The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.

Five philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.

It can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.

There are many solutions of the problem, program at least one, and explain how the deadlock is prevented.
",Python,"import threading
import time
 
class Philosopher(threading.Thread):
    def __init__(self, name, left, right):
        threading.Thread.__init__(self)
        self.name = name
        self.left = left
        self.right = right
 
    def eat(self, table):
        left = table.forks[self.left]
        right = table.forks[self.right]
 
        left.acquire()
        right.acquire()
 
        print(self.name, ""is eating."")
 
        time.sleep(1)
 
        print(self.name, ""is done eating."")
 
        left.release()
        right.release()
 
class Table:
    def __init__(self):
        self.forks = [threading.Lock() for n in range(5)]
 
if __name__ == ""__main__"":
    table = Table()
 
    philosophers = [
        Philosopher("""", 0, 1),
        Philosopher("""", 1, 2),
        Philosopher("""", 2, 3),
        Philosopher("""", 3, 4),
        Philosopher("""", 0, 4),
    ]
 
    for p in philosophers:
        p.eat(table)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Vigenère cipher,"Task

Implement a   Vigenère cypher,   both encryption and decryption.

The program should handle keys and text of unequal length,
and should capitalize everything and discard non-alphabetic characters. 

(If your program handles non-alphabetic characters in another way,
make a note of it.)



Related tasks

   Caesar cipher
   Rot-13
   Substitution Cipher

",Python,"# The following code was written by a Ruby program translator written by  on April 19th, 2008
# Translated by Yan Ko on April 21st, 2008
# Contact Yan at: 
# http://www.rubybrain.com
 
# Begin Translating VigenereCipher
 
import string
 
class VigenereCipher:
 
    BASE = ord('A')
    SIZE = ord('Z') - BASE + 1
 
    def encrypt(self, text, key):
        return self.crypt(text, key, '+')
 
    def decrypt(self, text, key):
        return self.crypt(text, key, '-')
 
    def crypt(self, text, key, dir):
        text = text.upper().replace(string.punctuation, '')
        key_iterator = iter(map(lambda c: ord(c) - self.BASE, key.upper().replace(string.punctuation, '')))
        return ''.join(map(lambda char: chr((ord(char) - self.BASE + (dir == '+' and 1 or -1) * key_iterator.next()) % self.SIZE + self.BASE), text))
 
# End Translating VigenereCipher",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Enumerations,Enumerations,"Task

Create an enumeration of constants with and without explicit values.



",Python,"person = {""Name"": ""John"", ""Age"": 20}",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/ISBN13_check_digit,ISBN13 check digit,"Task

Validate the check digit of an ISBN-13 code:

   Multiply every other digit by  3.
   Add these numbers and the other digits.
   Take the remainder of this number after division by  10.
   If it is  0,   the ISBN-13 check digit is correct.


Use the following codes for testing:

   978-1734314502       (good)
   978-1734314509         (bad)
   978-1788399081       (good)
   978-1788399083         (bad)


Show output here, on this page



See also

   for details:   13-digit ISBN method of validation.       (installs cookies.)

",Python,"def validISBN13(str):
    cleaned = [int(d) for d in str if d.isdigit()]
    if len(cleaned)!= 13:
        return False
    return sum(cleaned[::2]) + 3*sum(cleaned[1::2]) % 10 == 0
 
isbns = [""978-1734314502"", ""978-1734314509"", ""978-1788399081"", ""978-1788399083""]
for isbn in isbns:
    print(f""{isbn}: {validISBN13(isbn)}"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Unprimeable_numbers,Unprimeable numbers,"Definitions

As used here, all unprimeable numbers   (positive integers)   are always expressed in base ten.



───── Definition from OEIS ─────:

Unprimeable numbers are composite numbers that always remain composite when a single decimal digit of the number is changed.



───── Definition from Wiktionary   (referenced from Adam Spencer's book) ─────:

(arithmetic)   that cannot be turned into a prime number by changing just one of its digits to any other
digit.   (sic)



Unprimeable numbers are also spelled:   unprimable.

All one─ and two─digit numbers can be turned into primes by changing a single decimal digit.



Examples

190   isn't unprimeable,   because by changing the zero digit into a three yields   193,   which is a prime.



The number   200   is unprimeable,   since none of the numbers   201, 202, 203, ··· 209   are
prime, and all the other numbers obtained by changing a single digit to
produce   100, 300, 400, ··· 900,   or   210, 220, 230, ··· 290   which are all even.



It is valid to change   189   into   089   by changing the   1   (one)   into
a   0   (zero),   which then the leading zero can be removed,   and then treated as if
the   ""new""   number is   89.



Task

   show the first   35   unprimeable numbers   (horizontally, on one line, preferably with a title)
   show the   600th   unprimeable number
   (optional) show the lowest unprimeable number ending in a specific decimal digit   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
   (optional) use commas in the numbers where appropriate


Show all output here, on this page.



Also see

   the     OEIS     entry:   A118118 (unprimeable)
   with some useful counts to compare unprimeable number
   the Wiktionary entry (reference from below):   (arithmetic definition) unprimeable
   from the Adam Spencer book   (page 200):   Adam Spencer's World of Numbers       (Xoum Publishing)

",Python,"# unprimeable.py
from prime_sieve import PrimeSieve
 
# return number of decimal digits
def count_digits(n):
    digits = 0
    while n > 0:
        n //= 10
        digits += 1
    return digits
 
# return the number with one digit replaced
def change_digit(n, index, new_digit):
    p = 1
    changed = 0
    while index > 0:
        changed += p * (n % 10)
        p *= 10
        n //= 10
        index -= 1
    changed += (10 * (n // 10) + new_digit) * p
    return changed
 
def unprimeable(sieve, n):
    if sieve.is_prime(n):
        return False
    d = count_digits(n)
    for i in range(d):
        for j in range(10):
            m = change_digit(n, i, j)
            if m != n and sieve.is_prime(m):
                return False
    return True
 
def main():
    count = 0
    n = 100
    lowest = [0] * 10
    found = 0
    sieve = PrimeSieve(10000000)
    print(""First 35 unprimeable numbers:"")
    while count < 600 or found < 10:
        if unprimeable(sieve, n):
            if count < 35:
                if count > 0:
                    print("", "", end="""")
                print(n, end="""")
            count += 1
            if count == 600:
                print(""\n600th unprimeable number: {}"".format(n))
            last_digit = n % 10
            if lowest[last_digit] == 0:
                lowest[last_digit] = n
                found += 1
        n += 1
    for i in range(10):
        print(""Least unprimeable number ending in {}: {}"".format(i, lowest[i]))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Create_an_HTML_table,Create an HTML table,"Create an HTML table.

 The table body should have at least three rows of three columns.
 Each of these three columns should be labelled ""X"", ""Y"", and ""Z"". 
 An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. 
 The rows of the ""X"", ""Y"", and ""Z"" columns should be filled with random or sequential integers having 4 digits or less. 
 The numbers should be aligned in the same fashion for all columns.

",Python,"def array2HTML(array):
	html = ""<table>""
	for elem in array[0]:
		html += ""<th>"" + str(elem) + ""</th>""
	for i in range(1, len(array)):
		row = array[i]
		html += ""<tr>""
		for elem in row:
			html += ""<td>"" + str(elem) + ""</td>""
		html += ""</tr>""
	html += ""</table>""
	return html

def main():
	ints = [["""",""X"",""Y"",""Z""],[1,1,2,3],[2,4,5,6],[3,7,8,9],[4,10,11,12]]
	print(array2HTML(ints))

if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",Python,"def ack1(M, N):
   return (N + 1) if M == 0 else (
      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort,Sorting algorithms/Comb sort,"Sorting algorithms/Comb sort

You are encouraged to solve this task according to the task description, using any language you may know.

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a   comb sort.



The Comb Sort is a variant of the Bubble Sort.

Like the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.

Dividing the gap by   



(
1
−

e

−
φ



)

−
1


≈
1.247330950103979


{\displaystyle (1-e^{-\varphi })^{-1}\approx 1.247330950103979}

    works best, but    1.3   may be more practical.



Some implementations use the insertion sort once the gap is less than a certain amount.



Also see

   the Wikipedia article:   Comb sort.


Variants:

 Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.
 Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small).   Comb sort with a low gap isn't much better than the Bubble Sort.


Pseudocode:

function combsort(array input)
    gap := input.size //initialize gap size
    loop until gap = 1 and swaps = 0
        //update the gap value for a next comb. Below is an example
        gap := int(gap / 1.25)
        if gap < 1
          //minimum gap is 1
          gap := 1
        end if
        i := 0
        swaps := 0 //see Bubble Sort for an explanation
        //a single ""comb"" over the input list
        loop until i + gap >= input.size //see Shell sort for similar idea
            if input[i] > input[i+gap]
                swap(input[i], input[i+gap])
                swaps := 1 // Flag a swap has occurred, so the
                           // list is not guaranteed sorted
            end if
            i := i + 1
        end loop
    end loop
end function


",Python,"# version 1.1.2
 
def combSort(input):
    gap = len(input)
    if gap <= 1: return  # already sorted
    swaps = False
    while gap > 1 or swaps:
        gap = int(gap / 1.247331)
        if gap < 1: gap = 1
        i = 0
        swaps = False
        while i + gap < len(input):
            if input[i] > input[i + gap]:
                tmp = input[i]
                input[i] = input[i + gap]
                input[i + gap] = tmp
                swaps = True 
            i += 1
 
if __name__ == '__main__':
    ia = [28, 44, 46, 24, 19, 2, 17, 11, 25, 4]
    print(""Unsorted : {}"".format(ia)) 
    combSort(ia)
    print(""Sorted   : {}"".format(ia)) 
    print()
    ca = ['X', 'B', 'E', 'A', 'Z', 'M', 'S', 'L', 'Y', 'C']
    print(""Unsorted : {}"".format(ca)) 
    combSort(ca)
    print(""Sorted   : {}"".format(ca))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Generator/Exponential,Generator/Exponential,"A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.

Generators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.

Generators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.



Task

 Create a function that returns a generation of the m'th powers of the positive integers starting from zero, in order, and without obvious or simple upper limit. (Any upper limit to the generator should not be stated in the source but should be down to factors such as the languages natural integer size limit or computational time/size).
 Use it to create a generator of:
   Squares.
   Cubes. 
 Create a new generator that filters all cubes from the generator of squares.
 Drop the first 20 values from this last generator of filtered results, and then show the next 10 values.


Note that this task requires the use of generators in the calculation of the result.



Also see

 Generator

",Python,"from itertools import islice, count
 
def powers(m):
    for n in count():
        yield n ** m
 
def filtered(s1, s2):
    v, f = next(s1), next(s2)
    while True:
        if v > f:
            f = next(s2)
            continue
        elif v < f:
            yield v
        v = next(s1)
 
squares, cubes = powers(2), powers(3)
f = filtered(squares, cubes)
print(list(islice(f, 20, 30)))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",Python,"array = [0] * 10 #optionally, replace ""[0] * 10"" with a list of ints like [1, 2, 3]
array[0] = 42
print(array[3])",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/De_Bruijn_sequences,de Bruijn sequences,"The sequences are named after the Dutch mathematician   Nicolaas Govert de Bruijn.



A note on Dutch capitalization:   Nicolaas' last name is   de Bruijn,   the   de   isn't normally capitalized
unless it's the first word in a sentence.   Rosetta Code (more or less by default or by fiat) requires the first word in the task name to be
capitalized.



In combinatorial mathematics,   a   de Bruijn sequence   of order    n    on
a    size-k    alphabet (computer science)    A    is a cyclic sequence in which every
possible    length-n    string (computer science, formal theory)   on    A    occurs
exactly once as a contiguous substring.

Such a sequence is denoted by    B(k, n)    and has
length   kn,   which is also the number of distinct substrings of
length   n   on   A;    

de Bruijn sequences are therefore optimally short.

There are:

                         (k!)k(n-1)   ÷   kn

distinct de Bruijn sequences    B(k, n). 



Task

For this Rosetta Code task,   a   de Bruijn   sequence is to be generated that can be used to shorten a brute-force attack on
a   PIN-like   code lock that does not have an ""enter""
key and accepts the last    n    digits entered.



Note:   automated teller machines (ATMs)   used to work like
this,   but their software has been updated to not allow a brute-force attack.



Example

A   digital door lock   with a 4-digit code would
have B (10, 4) solutions,   with a length of   10,000   (digits).

Therefore, only at most     10,000 + 3     (as the solutions are cyclic or wrap-around)   presses are needed to
open the lock.

Trying all 4-digit codes separately would require   4 × 10,000   or   40,000   presses.



Task requirements

   Generate a de Bruijn sequence for a 4-digit (decimal) PIN code.
   Show the length of the generated de Bruijn sequence.
   (There are many possible de Bruijn sequences that solve this task,   one solution is shown on the discussion page).
   Show the first and last   130   digits of the de Bruijn sequence.
   Verify that all four-digit (decimal)   1,000   PIN codes are contained within the de Bruijn sequence.
   0000, 0001, 0002, 0003,   ...   9996, 9997, 9998, 9999   (note the leading zeros).
   Reverse the de Bruijn sequence.
   Again, perform the (above) verification test.
   Replace the 4,444th digit with a period (.) in the original de Bruijn sequence.
   Perform the verification test (again).   There should be four PIN codes missing.


(The last requirement is to ensure that the verification tests performs correctly.   The verification processes should list
any and all missing PIN codes.)

Show all output here, on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

   Wikipedia entry:   de Bruijn sequence.
   MathWorld entry:   de Bruijn sequence.
   An  OEIS  entry:   A166315 lexicographically earliest binary de Bruijn sequences, B(2,n)     --- Not B(10,4),   but possibly relevant.

",Python,"from itertools import product
from typing import List
 
def de_bruijn(k: int, n: int) -> str:
    """"""
    Return a de Bruijn sequence of order n over the alphabet [0, k).
    """"""
    a = [0] * (k * n)
    seq = []
    def db(t: int, p: int) -> None:
        if t > n:
            if n % p == 0:
                seq.extend(a[1:p + 1])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            j = a[t - p] + 1
            while j < k:
                a[t] = j
                db(t + 1, t)
                j += 1
    db(1, 1)
    return """".join(map(str, seq)) + """".join(map(str, seq[:n - 1]))
 
def all_digits(s: str) -> bool:
    return all(c.isdigit() for c in s)
 
def validate(db: str) -> None:
    le = len(db)
    found = [0] * 10_000
    errs: List[str] = []
    # Check all strings of 4 consecutive digits within 'db'
    # to see if all 10,000 combinations occur without duplication.
    for i in range(le - 3):
        s = db[i:i + 4]
        if all_digits(s):
            n = int(s)
            found[n] += 1
    for i in range(10_000):
        if found[i] == 0:
            errs.append(""    PIN number %04d missing"" % i)
        elif found[i] > 1:
            errs.append(""    PIN number %04d occurs %d times"" % (i, found[i]))
    lerr = len(errs)
    if lerr == 0:
        print(""  No errors found"")
    else:
        pl = """" if lerr == 1 else ""s""
        print(""  %d error%s found:"" % (lerr, pl))
        print(""\n"".join(errs))
 
def main() -> None:
    db = de_bruijn(10, 4)
    le = len(db)
 
    print(""The length of the de Bruijn sequence is %d"" % le)
    print(""\nThe first 130 digits of the de Bruijn sequence are: %s"" % db[:130])
    print(""\nThe last 130 digits of the de Bruijn sequence are: %s"" % db[-130:])
 
    print(""\nValidating the deBruijn sequence:"")
    validate(db)
 
    print(""\nValidating the reversed deBruijn sequence:"")
    validate(db[::-1])
 
    bytes = list(db)
    bytes[4443] = "".""
    db = """".join(bytes)
    print(""\nValidating the overlaid deBruijn sequence:"")
    validate(db)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle,Catalan numbers/Pascal's triangle,"Task

Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.



See

   Catalan Numbers and the Pascal Triangle.     This method enables calculation of Catalan Numbers using only addition and subtraction.
   Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition.
   Sequence A000108 on OEIS has a lot of information on Catalan Numbers.
Related Tasks

Pascal's triangle
",Python,">>> n = 15
>>> t = [0] * (n + 2)
>>> t[1] = 1
>>> for i in range(1, n + 1):
	for j in range(i, 1, -1): t[j] += t[j - 1]
	t[i + 1] = t[i]
	for j in range(i + 1, 1, -1): t[j] += t[j - 1]
	print(t[i+1] - t[i], end=' ')
 
 
1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845 
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Naming_conventions,Naming conventions,"Many languages have naming conventions regarding the identifiers used in the language, its libraries, and programs written in the language. Such conventions, which may be classified as de facto or de jure depending on how they are enforced,
often take the form of rules regarding prefixes, suffixes, and the use of upper-case and lower-case characters.

The naming conventions are sometimes a bit haphazard, especially if the language and/or library has gone through periods of evolution. (In this case: give a brief example and description.)

Document (with simple examples where possible) the evolution and current status of these naming conventions.
For example, name conventions for:

 Procedure and operator names. (Intrinsic or external)
 Class, Subclass and instance names.
 Built-in versus libraries names.


If possible, indicate where the naming conventions are implicit, explicit, mandatory or discretionary.
Any tools that enforced the the naming conventions.
Any cases where the naming convention as commonly violated.

If possible, indicate where the convention is used to hint at other issues. For example the C standard library uses a prefix of ""_"" to ""hide"" raw Operating System calls from the non systems-programmer, whereas Python embeds member functions in between ""__"" to make a member function ""private"".

See also

 Wikipedia: Naming convention (programming)

",Python,"isinstance(1, int)    # => True
isinstance(1, float)  # => False",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Fractran,Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",Python,"from fractions import Fraction
 
def fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'
                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'
                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):
    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]
 
    n = Fraction(n)
    while True:
        yield n.numerator
        for f in flist:
            if (n * f).denominator == 1:
                break
        else:
            break
        n *= f
 
if __name__ == '__main__':
    n, m = 2, 15
    print('First %i members of fractran(%i):\n  ' % (m, n) +
          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",Python,"from __future__ import print_function
from fractions import Fraction
 
class Gospers(object):
    def __init__(self):
        self.q = Fraction(1, 1)
        self.r = Fraction(0, 1)
        self.t = Fraction(1, 1)
        self.i = Fraction(1, 1)
        self.n = Fraction(0, 1)
        self.next() # move to the first digit
 
    def next(self):
        self.n = (self.q*(27*self.i-12)+5*self.r) / (5*self.t)
 
        while self.n!= (self.q*(675*self.i-216)+125*self.r)/(125*self.t):
            self.r = 3*(3*self.i+1)*(3*self.i+2)*((5*self.i-2)*self.q+self.r)
            self.q = self.i*(2*self.i-1)*self.q
            self.t = 3*(3*self.i+1)*(3*self.i+2)*self.t
            self.i += 1
 
            self.n = (self.q*(27*self.i-12)+5*self.r) / (5*self.t)
 
        self.q = 10*self.q
        self.r = 10*self.r-10*self.n*self.t
 
    def __next__(self):
        self.next()
        return self.n
 
    def __iter__(self):
        return self
 
if __name__ == '__main__':
    g = Gospers()
    print(int(g.n), end='.')  # print the first digit and the decimal point
 
    for n in g:
        print(int(n), end='')  # print the next digit",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Hello_world/Newbie,Hello world/Newbie,"Task

Guide a new user of a language through the steps necessary
to install the programming language and selection of a text editor if needed,
to run the languages' example in the Hello world/Text task.

 Assume the language-newbie is a programmer in another language.
 Assume the language-newbie is competent in installing software for the platform.
 Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor).
 Refer to, (and link to), already existing documentation as much as possible (but provide a summary here).
 Remember to state where to view the output.
 If particular IDE's or editors are required that are not standard, then point to/explain their installation too.


Note:
 If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated.
 You may use sub-headings if giving instructions for multiple platforms.

",Python,>>> print('hello world'),Human_written,Python_from_C
http://rosettacode.org/wiki/Least_common_multiple,Least common multiple,"Least common multiple

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Compute the   least common multiple   (LCM)   of two integers.

Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.



Example

The least common multiple of   12   and   18   is   36,       because:

   12   is a factor     (12 × 3 = 36),     and 
   18   is a factor     (18 × 2 = 36),     and 
   there is no positive integer less than   36   that has both factors. 


As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.



One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.

If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.



 



lcm
⁡
(
m
,
n
)
=




|

m
×
n

|



gcd
⁡
(
m
,
n
)





{\displaystyle \operatorname {lcm} (m,n)={\frac {|m\times n|}{\operatorname {gcd} (m,n)}}}




One can also find   lcm   by merging the prime decompositions of both   m   and   n.



Related task
   greatest common divisor.


See also

   MathWorld entry:   Least Common Multiple.
   Wikipedia entry:   Least common multiple.

",Python,"from boost.math import erf, erfc

print(""The error function of 1 is"", erf(1), "",\nand the complementary error function of 1 is"", erfc(1), ""!"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Legendre_prime_counting_function,Legendre prime counting function,"The prime-counting function π(n) computes the number of primes not greater than n. Legendre was the first mathematician to create a formula to compute π(n) based on the inclusion/exclusion principle.

To calculate:

Define

φ(x, 0) = x
φ(x, a) = φ(x, a−1) − φ(⌊x/pa⌋, a−1), where pa is the ath prime number.

then

π(n) = 0 when n < 2
π(n) = φ(n, a) + a - 1, where a = π(√n), n ≥ 2

The Legendre formula still requires the use of a sieve to enumerate primes; however it's only required to sieve up to the √n, and for counting primes, the Legendre method is generally much faster than sieving up to n.

Task

Calculate π(n) for values up to 1 billion. Show π(n) for n = 1, 10, 100, ... 109.

For this task, you may refer to a prime number sieve (such as the Sieve of Eratosthenes or the extensible sieve) in an external library to enumerate the primes required by the formula. Also note that it will be necessary to memoize the results of φ(x, a) in order to have reasonable performance, since the recurrence relation would otherwise take exponential time.




",Python,"from primesieve import primes
from math import isqrt
from functools import cache
 
p = primes(isqrt(1_000_000_000))
 
@cache
def phi(x, a):
    res = 0
    while True:
        if not a or not x:
            return x + res
 
        a -= 1
        res -= phi(x//p[a], a) # partial tail recursion
 
def legpi(n):
    if n < 2: return 0
 
    a = legpi(isqrt(n))
    return phi(n, a) + a - 1
 
for e in range(10):
    print(f'10^{e}', legpi(10**e))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Largest_number_divisible_by_its_digits,Largest number divisible by its digits,"Task

Find the largest base 10 integer whose digits are all different,   and   is evenly divisible by each of its individual digits.



These numbers are also known as   Lynch-Bell numbers,   numbers   n   such that the
(base ten) digits are all different (and do not include zero)   and   n   is divisible by each of its individual digits.



Example

135   is evenly divisible by   1,   3,   and   5.



Note that the digit zero (0) can not be in the number as integer division by zero is undefined.

The digits must all be unique so a base ten number will have at most 9 digits.

Feel free to use analytics and clever algorithms to reduce the search space your example needs to visit, but it must do an actual search. (Don't just feed it the answer and verify it is correct.)



Stretch goal

Do the same thing for hexadecimal.



Related tasks

   gapful numbers.
   palindromic gapful numbers. 


Also see

   The OEIS sequence:   A115569: Lynch-Bell numbers. 

",Python,"'''Largest number divisible by its digits'''
 
from itertools import (chain, permutations)
from functools import (reduce)
from math import (gcd)
 
 
# main :: IO ()
def main():
    '''Tests'''
 
    # (Division by zero is not an option, so 0 and 5 are omitted)
    digits = [1, 2, 3, 4, 6, 7, 8, 9]
 
    # Least common multiple of the digits above
    lcmDigits = reduce(lcm, digits)
 
    # Any 7 items drawn from the digits above,
    # including any two of [1, 4, 7]
    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])
 
    print(
        max(
            (
                intFromDigits(x) for x
                in concatMap(permutations)(sevenDigits)
            ),
            key=lambda n: n if 0 == n % lcmDigits else 0
        )
    )
 
 
# intFromDigits :: [Int] -> Int
def intFromDigits(xs):
    '''An integer derived from an
       ordered list of digits.
    '''
    return reduce(lambda a, x: a * 10 + x, xs, 0)
 
 
# ----------------------- GENERIC ------------------------
 
# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f):
    '''A concatenated list over which a function has been
       mapped. The list monad can be derived by using a
       function f which wraps its output in a list,
       (using an empty list to represent computational failure).
    '''
    def go(xs):
        return chain.from_iterable(map(f, xs))
    return go
 
 
# delete :: Eq a => [a] -> a -> [a]
def delete(xs):
    '''xs with the first instance of
       x removed.
    '''
    def go(x):
        ys = xs.copy()
        ys.remove(x)
        return ys
    return go
 
 
# lcm :: Int -> Int -> Int
def lcm(x, y):
    '''The smallest positive integer divisible
       without remainder by both x and y.
    '''
    return 0 if (0 == x or 0 == y) else abs(
        y * (x // gcd(x, y))
    )
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",Python,">>> import os
>>> print('\n'.join(sorted(os.listdir('.'))))
DLLs
Doc
LICENSE.txt
Lib
NEWS.txt
README.txt
Scripts
Tools
include
libs
python.exe
pythonw.exe
tcl
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/URL_encoding,URL encoding,"Task

Provide a function or mechanism to convert a provided string into URL encoding representation.

In URL encoding, special characters, control characters and extended characters
are converted into a percent symbol followed by a two digit hexadecimal code,
So a space character encodes into %20 within the string.

For the purposes of this task, every character except 0-9, A-Z and a-z requires conversion, so the following characters all require conversion by default:

 ASCII control codes (Character ranges 00-1F hex (0-31 decimal) and 7F (127 decimal).
 ASCII symbols (Character ranges 32-47 decimal (20-2F hex))
 ASCII symbols (Character ranges 58-64 decimal (3A-40 hex))
 ASCII symbols (Character ranges 91-96 decimal (5B-60 hex))
 ASCII symbols (Character ranges 123-126 decimal (7B-7E hex))
 Extended characters with character codes of 128 decimal (80 hex) and above.


Example

The string ""http://foo bar/"" would be encoded as ""http%3A%2F%2Ffoo%20bar%2F"".



Variations

 Lowercase escapes are legal, as in ""http%3a%2f%2ffoo%20bar%2f"".
 Some standards give different rules: RFC 3986, Uniform Resource Identifier (URI): Generic Syntax, section 2.3, says that ""-._~"" should not be encoded. HTML 5, section 4.10.22.5 URL-encoded form data, says to preserve ""-._*"", and to encode space "" "" to ""+"". The options below provide for utilization of an exception string, enabling preservation (non encoding) of particular characters to meet specific standards.


Options

It is permissible to use an exception string (containing a set of symbols
that do not need to be converted).
However, this is an optional feature and is not a requirement of this task.



Related tasks
 
   URL decoding
   URL parser

",Python,"import urllib
s = 'http://foo/bar/'
s = urllib.quote(s)",Human_written,Python_from_Java
http://rosettacode.org/wiki/100_doors,100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",Python,"is_open = [False] * 100
for pass in range(100):
    for door in range(pass, 100, pass + 1):
        is_open[door] = not is_open[door]
for door in range(100):
    print(""door #%d is %s."" % (door + 1, ""open"" if is_open[door] else ""closed""))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Loops/Downward_for,Loops/Downward for,"Task

Write a    for    loop which writes a countdown from   10   to   0.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"for i in xrange(10, -1, -1):
    print i",Human_written,Python_from_Java
http://rosettacode.org/wiki/Maze_generation,Maze generation,"

 This page uses content from Wikipedia. The original article was at Maze generation algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)




Task

Generate and show a maze, using the simple Depth-first search algorithm.

Start at a random cell.
Mark the current cell as visited, and get a list of its neighbors. For each neighbor, starting with a randomly selected neighbor:
If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then recurse with that neighbor as the current cell.


 Related tasks
 Maze solving.

",Python,"from random import shuffle, randrange
 
def make_maze(w = 16, h = 8):
    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]
    ver = [[""|  ""] * w + ['|'] for _ in range(h)] + [[]]
    hor = [[""+--""] * w + ['+'] for _ in range(h + 1)]
 
    def walk(x, y):
        vis[y][x] = 1
 
        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]
        shuffle(d)
        for (xx, yy) in d:
            if vis[yy][xx]: continue
            if xx == x: hor[max(y, yy)][x] = ""+  ""
            if yy == y: ver[y][max(x, xx)] = ""   ""
            walk(xx, yy)
 
    walk(randrange(w), randrange(h))
 
    s = """"
    for (a, b) in zip(hor, ver):
        s += ''.join(a + ['\n'] + b + ['\n'])
    return s
 
if __name__ == '__main__':
    print(make_maze())",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Polynomial_regression,Polynomial regression,"Find an approximating polynomial of known degree for a given data.

Example:
For input data:

x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};
y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};

The approximating polynomial is:

3 x2 + 2 x + 1

Here, the polynomial's coefficients are (3, 2, 1).

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.
",Python,"import numpy as np
 
x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
y = np.array([1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321])
 
degree = 2
 
a = np.vander(x, degree + 1)
b = y.reshape(-1, 1)
c = np.linalg.lstsq(a, b, rcond=None)[0]
 
print(c)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",Python,">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]
>>> def stoogesort(L, i=0, j=None):
	if j is None:
		j = len(L) - 1
	if L[j] < L[i]:
		L[i], L[j] = L[j], L[i]
	if j - i > 1:
		t = (j - i + 1) // 3
		stoogesort(L, i  , j-t)
		stoogesort(L, i+t, j  )
		stoogesort(L, i  , j-t)
	return L
 
>>> stoogesort(data)
[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]",Human_written,Python_from_C
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]",Human_written,Python_from_Rust
http://rosettacode.org/wiki/First_power_of_2_that_has_leading_decimal_digits_of_12,First power of 2 that has leading decimal digits of 12,"(This task is taken from a   Project Euler   problem.)

(All numbers herein are expressed in base ten.)


27   =   128   and   7   is
the first power of   2   whose leading decimal digits are   12.

The next power of   2   whose leading decimal digits
are   12   is   80,

280   =   1208925819614629174706176.



Define        p(L,n)      to be the  nth-smallest
value of    j    such that the base ten representation
of    2j    begins with the digits of    L .

    So   p(12, 1) =  7    and
         p(12, 2) = 80



You are also given that:

         p(123, 45)   =   12710



Task

   find: 
     p(12, 1)  
     p(12, 2)  
     p(123, 45)  
     p(123, 12345)  
     p(123, 678910)  
   display the results here, on this page.

",Python,"import math
 
def p(l, n):
    test = 0
    logv = math.log(2.0) / math.log(10.0)
    factor = 1
    loop = l
    while loop > 10:
        factor *= 10
        loop /= 10
    while n > 0:
        val = int(factor * pow(10.0, math.fmod(test * logv, 1)))
        if val == l:
            n -= 1
        test += 1
    return test
 
def runTest(l, n):
    print(""p(%d, %d) = %d"" % (l, n, p(l, n)))
 
runTest(12, 1)
runTest(12, 2)
runTest(123, 45)
runTest(123, 12345)
runTest(123, 678910)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/UTF-8_encode_and_decode,UTF-8 encode and decode,"As described in UTF-8 and in Wikipedia, UTF-8 is a popular encoding of (multi-byte) Unicode code-points into eight-bit octets.

The goal of this task is to write a encoder that takes a unicode code-point (an integer representing a unicode character) and returns a sequence of 1-4 bytes representing that character in the UTF-8 encoding.

Then you have to write the corresponding decoder that takes a sequence of 1-4 UTF-8 encoded bytes and return the corresponding unicode character.

Demonstrate the functionality of your encoder and decoder on the following five characters:

Character   Name                                  Unicode    UTF-8 encoding (hex)
---------------------------------------------------------------------------------
A           LATIN CAPITAL LETTER A                U+0041     41
ö           LATIN SMALL LETTER O WITH DIAERESIS   U+00F6     C3 B6
Ж           CYRILLIC CAPITAL LETTER ZHE           U+0416     D0 96
€           EURO SIGN                             U+20AC     E2 82 AC
𝄞           MUSICAL SYMBOL G CLEF                 U+1D11E    F0 9D 84 9E

Provided below is a reference implementation in Common Lisp.
",Python,"def utf8encode(n):
    def m(n):
        if n < 0x80:
            return [n >> 0 & 0x7f | 0x00]
        elif n < 0x800:
            return [n >> 6 & 0x1f | 0xc0, n >> 0 & 0x3f | 0x80]
        elif n < 0x10000:
            return [n >> 12 & 0x0f | 0xe0, n >> 6 & 0x3f | 0x80, n >> 0 & 0x3f | 0x80]
        elif n < 0x110000:
            return [n >> 18 & 0x07 | 0xf0, n >> 12 & 0x3f | 0x80, n >> 6 & 0x3f | 0x80, n >> 0 & 0x3f | 0x80]
        else:
            raise Exception('Invalid Unicode Code Point!')
    if isinstance(n, str):
        return m(ord(n[0]))
    else:
        return m(n & 0x1fffff)
 
def utf8decode(m, n, o, p):
    if m < 0x80:
        return (m & 0x7f) << 0
    elif 0xc1 < m and m < 0xe0 and n == (n & 0xbf):
        return (m & 0x1f) << 6 | (n & 0x3f) << 0
    elif (m == 0xe0 and 0x9f < n and n < 0xc0 or 0xe0 < m and m < 0xed and 0x7f < n and n < 0xc0 or m == 0xed and 0x7f < n and n < 0xa0 or 0xed < m and m < 0xf0 and 0x7f < n and n < 0xc0) and o == o & 0xbf:
        return (m & 0x0f) << 12 | (n & 0x3f) << 6 | (o & 0x3f) << 0
    elif (m == 0xf0 and 0x8f < n and n < 0xc0 or m == 0xf4 and 0x7f < n and n < 0x90 or 0xf0 < m and m < 0xf4 and 0x7f < n and n < 0xc0) and o == o & 0xbf and p == p & 0xbf:
        return (m & 0x07) << 18 | (n & 0x3f) << 12 | (o & 0x3f) << 6 | (p & 0x3f) << 0
    else:
        raise Exception('Invalid UTF-8 encoding!')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",Python,"def maxsubseq(seq):
  return max((seq[begin:end] for begin in xrange(len(seq)+1)
                             for end in xrange(begin, len(seq)+1)),
             key=sum)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",Python,"import os
 
size = os.path.getsize('input.txt')
size = os.path.getsize('/input.txt')",Human_written,Python_from_C++
http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",Python,"import sys
p = ""import sys\np = %r\na = [0]*300\nb = [0]*300\nprint(p%%(p,p))\nprint(1-cmp(a,b))""
a = [0]*300
b = [0]*300
print(p%(p,p))
print(1-cmp(a,b))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Queue/Definition,Queue/Definition,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Implement a FIFO queue.

Elements are added at one side and popped from the other in the order of insertion.



Operations:

   push   (aka enqueue)    - add element
   pop     (aka dequeue)    - pop first element
   empty                             - return truth value when empty


Errors:

   handle the error of trying to pop from an empty queue (behavior depends on the language and platform)


See

   Queue/Usage   for the built-in FIFO or queue of your language or standard library.


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class FIFO(object):
       def __init__(self, *args):
           self.contents = list(args)
       def __call__(self):
           return self.pop()
       def __len__(self):
           return len(self.contents)
       def pop(self):
           return self.contents.pop(0)
       def push(self, item):
           self.contents.append(item)
       def extend(self,*itemlist):
           self.contents += itemlist
       def empty(self):
           return bool(self.contents)
       def __iter__(self):
           return self
       def next(self):
           if self.empty():
               raise StopIteration
           return self.pop()
 
if __name__ == ""__main__"":
    # Sample usage:
    f = FIFO()
    f.push(3)
    f.push(2)
    f.push(1)
    while not f.empty():
        print f.pop(),
    # >>> 3 2 1
    # Another simple example gives the same results:
    f = FIFO(3,2,1)
    while not f.empty():
        print f(),
    # Another using the default ""truth"" value of the object
    # (implicitly calls on the length() of the object after
    # checking for a __nonzero__ method
    f = FIFO(3,2,1)
    while f:
        print f(),
    # Yet another, using more Pythonic iteration:
    f = FIFO(3,2,1)
    for i in f:
        print i,",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters,Determine if a string has all the same characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are the same
   indicate if or which character is different from the previous character
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as all the same character(s)
   process the strings from left─to─right
   if       all the same character,   display a message saying such
   if not all the same character,   then:
   display a message saying such
   display what character is different
   only the 1st different character need be displayed
   display where the different character is in the string
   the above messages can be part of a single message
   display the hexadecimal value of the different character


Use (at least) these seven test values   (strings):

   a string of length   0   (an empty string)
   a string of length   3   which contains three blanks
   a string of length   1   which contains:   2
   a string of length   3   which contains:   333
   a string of length   3   which contains:   .55
   a string of length   6   which contains:   tttTTT
   a string of length   9   with a blank in the middle:   4444   444k


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"strings = ["""", ""   "", ""2"", ""333"", "".55"", ""tttTTT"", ""4444   444k"", ""pépé"", ""🐶🐶🐺🐶"", ""🎄🎄🎄🎄""]
 
for str in strings:
  pos = None if str == """" else str.find(str[0])
  print ""%s  (size %d): "" % (repr(str), len(str)),
  if pos is not None:
    print ""first different char %s (%s) at position %d."" % (repr(str[pos]), hex(ord(str[pos])), pos)
  else:
    print ""all the same.""",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Test_integerness,Test integerness,"Mathematically,

 the integers Z are included in the rational numbers Q,
 which are included in the real numbers R,
 which can be generalized to the complex numbers C.


This means that each of those larger sets, and the data types used to represent them, include some integers.

Task[edit]
Given a rational, real, or complex number of any type, test whether it is mathematically an integer.

Your code should handle all numeric data types commonly used in your programming language.

Discuss any limitations of your code.

Definition
For the purposes of this task, integerness means that a number could theoretically be represented as an integer at no loss of precision (given an infinitely wide integer type).

In other words:



 Set

 Common representation

 C++ type

 Considered an integer...


 rational numbers Q

 fraction

 std::ratio

 ...if its denominator is 1 (in reduced form)


 real numbers Z
(approximated)

 fixed-point



 ...if it has no non-zero digits after the decimal point


 floating-point

 float, double

 ...if the number of significant decimal places of its mantissa isn't greater than its exponent


 complex numbers C

 pair of real numbers

 std::complex

 ...if its real part is considered an integer and its imaginary part is zero

Extra credit
Optionally, make your code accept a tolerance parameter for fuzzy testing. The tolerance is the maximum amount by which the number may differ from the nearest integer, to still be considered an integer.

This is useful in practice, because when dealing with approximate numeric types (such as floating point), there may already be round-off errors from previous calculations. For example, a float value of 0.9999999998 might actually be intended to represent the integer 1.

Test cases


 Input

 Output

 Comment


 Type

 Value

 exact

 tolerance = 0.00001


 decimal

 25.000000

 true




 24.999999

 false

 true




 25.000100

 false




 floating-point

 -2.1e120

 true

 This one is tricky, because in most languages it is too large to fit into a native integer type.
It is, nonetheless, mathematically an integer, and your code should identify it as such.


 -5e-2

 false




 NaN

 false




 Inf

 false

 This one is debatable. If your code considers it an integer, that's okay too.


 complex

 5.0+0.0i

 true




 5-5i

 false



(The types and notations shown in these tables are merely examples – you should use the native data types and number literals of your programming language and standard library. Use a different set of test-cases, if this one doesn't demonstrate all relevant behavior.)

",Python,">>> def isint(f): 
    return complex(f).imag == 0 and complex(f).real.is_integer()
 
>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]
[True, True, True, False, False, False]
 
>>> # Test cases
...
>>> isint(25.000000)
True
>>> isint(24.999999)
False
>>> isint(25.000100)
False
>>> isint(-2.1e120)
True
>>> isint(-5e-2)
False
>>> isint(float('nan'))
False
>>> isint(float('inf'))
False
>>> isint(5.0+0.0j)
True
>>> isint(5-5j)
False",Human_written,Python_from_C#
http://rosettacode.org/wiki/Program_termination,Program termination,"

Task

Show the syntax for a complete stoppage of a program inside a   conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.



",Python,"import sys
if problem:
    sys.exit(1)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Zumkeller_numbers,Zumkeller numbers,"Zumkeller numbers are the set of numbers whose divisors can be partitioned into two disjoint sets that sum to the same value. Each sum must contain divisor values that are not in the other sum, and all of the divisors must be in one or the other. There are no restrictions on how the divisors are partitioned, only that the two partition sums are equal.



E.G.
 6 is a Zumkeller number; The divisors {1 2 3 6} can be partitioned into two groups {1 2 3} and {6} that both sum to 6.
 10 is not a Zumkeller number; The divisors {1 2 5 10} can not be partitioned into two groups in any way that will both sum to the same value.
 12 is a Zumkeller number; The divisors {1 2 3 4 6 12} can be partitioned into two groups {1 3 4 6} and {2 12} that both sum to 14.


Even Zumkeller numbers are common; odd Zumkeller numbers are much less so. For values below 10^6, there is at least one Zumkeller number in every 12 consecutive integers, and the vast majority of them are even. The odd Zumkeller numbers are very similar to the list from the task Abundant odd numbers; they are nearly the same except for the further restriction that the abundance (A(n) = sigma(n) - 2n), must be even: A(n) mod 2 == 0



Task

 Write a routine (function, procedure, whatever) to find Zumkeller numbers.
 Use the routine to find and display here, on this page, the first 220 Zumkeller numbers.
 Use the routine to find and display here, on this page, the first 40 odd Zumkeller numbers.
 Optional, stretch goal: Use the routine to find and display here, on this page, the first 40 odd Zumkeller numbers that don't end with 5.


See Also

 OEIS:A083207 - Zumkeller numbers to get an impression of different partitions OEIS:A083206 Zumkeller partitions
 OEIS:A174865 - Odd Zumkeller numbers


Related Tasks

 Abundant odd numbers
 Abundant, deficient and perfect number classifications
 Proper divisors , Factors of an integer",Python,"from sympy import divisors
 
from sympy.combinatorics.subsets import Subset
 
def isZumkeller(n):
    d = divisors(n)
    s = sum(d)
    if not s % 2 and max(d) <= s/2:
        for x in range(1, 2**len(d)):
            if sum(Subset.unrank_binary(x, d).subset) == s/2:
                return True
 
    return False
 
 
 
def printZumkellers(N, oddonly=False):
    nprinted = 0
    for n in range(1, 10**5):
        if (oddonly == False or n % 2) and isZumkeller(n):
            print(f'{n:>8}', end='')
            nprinted += 1
            if nprinted % 10 == 0:
                print()
            if nprinted >= N:
                return
 
 
print(""220 Zumkeller numbers:"")
printZumkellers(220)
print(""\n\n40 odd Zumkeller numbers:"")
printZumkellers(40, True)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Koch_curve,Koch curve,"Draw a Koch curve. See details: Koch curve
",Python,"# Translate this
# See https://en.wikipedia.org/wiki/Koch_snowflake
import math
from PIL import Image, ImageDraw
 
sqrt3_2 = 0.86602540378444  # sqrt(3)/2
 
def koch_next(points):
    size = len(points)
    output = [None] * (4 * (size - 1) + 1)
    j = 0
    for i in range(size - 1):
        x0, y0 = points[i]
        x1, y1 = points[i + 1]
        dy = y1 - y0
        dx = x1 - x0
        output[j] = (x0, y0)
        j += 1
        output[j] = (x0 + dx / 3, y0 + dy / 3)
        j += 1
        output[j] = (x0 + dx / 2 - dy * sqrt3_2 / 3, y0 + dy / 2 + dx * sqrt3_2 / 3)
        j += 1
        output[j] = (x0 + 2 * dx / 3, y0 + 2 * dy / 3)
        j += 1
    output[j] = (x1, y1)
    return output
 
def koch_points(size, iterations):
    length = size * sqrt3_2 * 0.95
    x = (size - length) / 2
    y = size / 2 - length * sqrt3_2 / 3
    points = [
        (x, y),
        (x + length / 2, y + length * sqrt3_2),
        (x + length, y),
        (x, y)
    ]
    for i in range(iterations):
        points = koch_next(points)
    return points
 
def koch_curve_svg(size, iterations):
    points = koch_points(size, iterations)
    img = Image.new('RGB', (size, size), 'black')
    draw = ImageDraw.Draw(img)
    draw.polygon(points, fill='white')
    img.save('koch_curve.png')
 
koch_curve_svg(600, 5)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Cut_a_rectangle,Cut a rectangle,"A given rectangle is made from m × n squares. If m and n are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180°). All such paths for 2 × 2 and 4 × 3 rectangles are shown below.



Write a program that calculates the number of different ways to cut an m × n rectangle. Optionally, show each of the cuts.

Possibly related task: Maze generation for depth-first search.
",Python,"import java.util.*;
 
public class CutRectangle {
 
    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
 
    public static void main(String[] args) {
        cutRectangle(2, 2);
        cutRectangle(4, 3);
    }
 
    static void cutRectangle(int w, int h) {
        if (w % 2 == 1 && h % 2 == 1)
            return;
 
        int[][] grid = new int[h][w];
        Stack<Integer> stack = new Stack<>();
 
        int half = (w * h) / 2;
        long bits = (long) Math.pow(2, half) - 1;
 
        for (; bits > 0; bits -= 2) {
 
            for (int i = 0; i < half; i++) {
                int r = i / w;
                int c = i % w;
                grid[r][c] = (bits & (1 << i))!= 0? 1 : 0;
                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];
            }
 
            stack.push(0);
            grid[0][0] = 2;
            int count = 1;
            while (!stack.empty()) {
 
                int pos = stack.pop();
                int r = pos / w;
                int c = pos % w;
 
                for (int[] dir : dirs) {
 
                    int nextR = r + dir[0];
                    int nextC = c + dir[1];
 
                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {
 
                        if (grid[nextR][nextC] == 1) {
                            stack.push(nextR * w + nextC);
                            grid[nextR][nextC] = 2;
                            count++;
                        }
                    }
                }
            }
            if (count == half) {
                printResult(grid);
            }
        }
    }
 
    static void printResult(int[][] arr) {
        for (int[] a : arr)
            System.out.println(Arrays.toString(a));
        System.out.println();
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Permutations,Permutations,"Task

Write a program that generates all   permutations   of   n   different objects.   (Practically numerals!)



Related tasks
 
   Find the missing permutation
   Permutations/Derangements



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"def permutations(values):
    if len(values) == 1:
        return [values]
    return [p.insert(0, v) for v in values for p in permutations([x for x in values if x!= v])]",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Population_count,Population count,"Population count

You are encouraged to solve this task according to the task description, using any language you may know.
The   population count   is the number of   1s   (ones)   in the binary representation of a non-negative integer.

Population count   is also known as:

   pop count
   popcount 
   sideways sum
   bit summation 
   Hamming weight 


For example,   5   (which is   101   in binary)   has a population count of   2.


Evil numbers   are non-negative integers that have an   even   population count.

Odious numbers     are  positive integers that have an    odd   population count.



Task

 write a function (or routine) to return the population count of a non-negative integer.
 all computation of the lists below should start with   0   (zero indexed).
 display the   pop count   of the   1st   thirty powers of   3       (30,   31,   32,   33,   34,   ∙∙∙   329).
 display the   1st   thirty     evil     numbers.
 display the   1st   thirty   odious   numbers.
 display each list of integers on one line   (which may or may not include a title),   each set of integers being shown should be properly identified.


See also
 The On-Line Encyclopedia of Integer Sequences:   A000120 population count.
 The On-Line Encyclopedia of Integer Sequences:   A000069 odious numbers.
 The On-Line Encyclopedia of Integer Sequences:   A001969 evil numbers.

",Python,"class Integer:
    def popcount(self):
        return bin(self).count(""1"")

    def evil(self):
        return self >= 0 and self.popcount() % 2 == 0

print(""Powers of 3:"", "" "".join(str(3**n).popcount() for n in range(30)))
print(""Evil:"", "" "".join(str(n) for n in range(30) if n.evil()))
print(""Odious:"", "" "".join(str(n) for n in range(30) if not n.evil()))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation,Permutations/Rank of a permutation,"A particular ranking of a permutation associates an integer with a particular ordering of all the permutations of a set of distinct items.
For our purposes the ranking will assign integers 



0..
(
n
!
−
1
)


{\displaystyle 0..(n!-1)}

 to an ordering of all the permutations of the integers 



0..
(
n
−
1
)


{\displaystyle 0..(n-1)}

.

For example, the permutations of the digits zero to 3 arranged lexicographically have the following rank:

  PERMUTATION      RANK
  (0, 1, 2, 3) ->  0
  (0, 1, 3, 2) ->  1
  (0, 2, 1, 3) ->  2
  (0, 2, 3, 1) ->  3
  (0, 3, 1, 2) ->  4
  (0, 3, 2, 1) ->  5
  (1, 0, 2, 3) ->  6
  (1, 0, 3, 2) ->  7
  (1, 2, 0, 3) ->  8
  (1, 2, 3, 0) ->  9
  (1, 3, 0, 2) -> 10
  (1, 3, 2, 0) -> 11
  (2, 0, 1, 3) -> 12
  (2, 0, 3, 1) -> 13
  (2, 1, 0, 3) -> 14
  (2, 1, 3, 0) -> 15
  (2, 3, 0, 1) -> 16
  (2, 3, 1, 0) -> 17
  (3, 0, 1, 2) -> 18
  (3, 0, 2, 1) -> 19
  (3, 1, 0, 2) -> 20
  (3, 1, 2, 0) -> 21
  (3, 2, 0, 1) -> 22
  (3, 2, 1, 0) -> 23
Algorithms exist that can generate a rank from a permutation for some particular ordering of permutations, and that can generate the same rank from the given individual permutation (i.e. given a rank of 17 produce (2, 3, 1, 0) in the example above).

One use of such algorithms could be in generating a small, random, sample of permutations of 



n


{\displaystyle n}

 items without duplicates when the total number of permutations is large. Remember that the total number of permutations of 



n


{\displaystyle n}

 items is given by 



n
!


{\displaystyle n!}

 which grows large very quickly: A 32 bit integer can only hold 



12
!


{\displaystyle 12!}

, a 64 bit integer only 



20
!


{\displaystyle 20!}

. It becomes difficult to take the straight-forward approach of generating all permutations then taking a random sample of them.

A question on the Stack Overflow site asked how to generate one million random and indivudual permutations of 144 items.



Task

 Create a function to generate a permutation from a rank.
 Create the inverse function that given the permutation generates its rank.
 Show that for 



n
=
3


{\displaystyle n=3}

 the two functions are indeed inverses of each other.
 Compute and show here 4 random, individual, samples of permutations of 12 objects.


Stretch goal

 State how reasonable it would be to use your program to address the limits of the Stack Overflow question.


References

 Ranking and Unranking Permutations in Linear Time by Myrvold & Ruskey. (Also available via Google here).
 Ranks on the DevData site.
 Another answer on Stack Overflow to a different question that explains its algorithm in detail.


Related tasks

Factorial_base_numbers_indexing_permutations_of_a_collection

",Python,"from math import factorial as fact
from random import randrange
from textwrap import wrap
 
def identity_perm(n): 
    return list(range(n))
 
def unranker1(n, r, pi):
    while n > 0:
        n1, (rdivn, rmodn) = n-1, divmod(r, n)
        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]
        n = n1
        r = rdivn
    return pi
 
def init_pi1(n, pi): 
    pi1 = [-1] * n
    for i in range(n): 
        pi1[pi[i]] = i
    return pi1
 
def ranker1(n, pi, pi1):
    if n == 1: 
        return 0
    n1 = n-1
    s = pi[n1]
    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]
    pi1[s], pi1[n1] = pi1[n1], pi1[s]
    return s + n * ranker1(n1, pi, pi1)
 
def unranker2(n, r, pi):
    while n > 0:
        n1 = n-1
        s, rmodf = divmod(r, fact(n1))
        pi[n1], pi[s] = pi[s], pi[n1]
        n = n1
        r = rmodf
    return pi
 
def ranker2(n, pi, pi1):
    if n == 1: 
        return 0
    n1 = n-1
    s = pi[n1]
    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]
    pi1[s], pi1[n1] = pi1[n1], pi1[s]
    return s * fact(n1) + ranker2(n1, pi, pi1)
 
def get_random_ranks(permsize, samplesize):    
    perms = fact(permsize)
    ranks = set()
    while len(ranks) < samplesize:
        ranks |= set( randrange(perms) 
                      for r in range(samplesize - len(ranks)) )
    return ranks    
 
def test1(comment, unranker, ranker):    
    n, samplesize, n2 = 3, 4, 12
    print(comment)
    perms = []
    for r in range(fact(n)):
        pi = identity_perm(n)
        perm = unranker(n, r, pi)
        perms.append((r, perm))
    for r, pi in perms:
        pi1 = init_pi1(n, pi)
        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))
    print('\n  %i random individual samples of %i items:' % (samplesize, n2))
    for r in get_random_ranks(n2, samplesize):
        pi = identity_perm(n2)
        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))
    print('')
 
def test2(comment, unranker):    
    samplesize, n2 = 4, 144
    print(comment)
    print('  %i random individual samples of %i items:' % (samplesize, n2))
    for r in get_random_ranks(n2, samplesize):
        pi = identity_perm(n2)
        print('    ' + '\n      '.join(wrap(repr(unranker(n2, r, pi)))))
    print('')
 
if __name__ == '__main__':
    test1('First ordering:', unranker1, ranker1)
    test1('Second ordering:', unranker2, ranker2)
    test2('First ordering, large number of perms:', unranker1)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Count_in_octal,Count in octal,"Task

Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.

Each number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.



Related task

   Integer sequence   is a similar task without the use of octal numbers.

",Python,"i = 0
while i!= 0:
    print(oct(i))
    i += 1",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",Python,"import time
 
seconds = float(raw_input())
print ""Sleeping...""
time.sleep(seconds) # number is in seconds ... but accepts fractions
print ""Awake!""",Human_written,Python_from_C
http://rosettacode.org/wiki/Averages/Mode,Averages/Mode,"Task[edit]
Write a program to find the mode value of a collection.

The case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.

If it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,"from collections import Counter

def mode(coll):
    seen = Counter(coll)
    max = 0
    maxElems = []
    for value in coll:
        if seen[value] > max:
            max = seen[value]
            maxElems = [value]
        elif seen[value] == max:
            maxElems.append(value)
    return maxElems

print(mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])) # prints [6]
print(mode([1, 1, 2, 4, 4])) # prints [1, 4]",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Prime_decomposition,Prime decomposition,"The prime decomposition of a number is defined as a list of prime numbers
which when all multiplied together, are equal to that number.



Example

 12 = 2 × 2 × 3,  so its prime decomposition is  {2, 2, 3}



Task

Write a function which returns an array or collection which contains the prime decomposition of a given number   



n


{\displaystyle n}

   greater than   1.

If your language does not have an isPrime-like function available,
you may assume that you have a function which determines
whether a number is prime (note its name before your code).

If you would like to test code from this task, you may use code from trial division or the Sieve of Eratosthenes.

Note: The program must not be limited by the word size of your computer or some other artificial limit; it should work for any number regardless of size (ignoring the physical limits of RAM etc).



Related tasks

   count in factors
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"from __future__ import print_function
 
import sys
from itertools import islice, cycle, count
 
try:
    from itertools import compress
except ImportError:
    def compress(data, selectors):
        """"""compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F""""""
        return (d for d, s in zip(data, selectors) if s)
 
 
def is_prime(n):
    return list(zip((True, False), decompose(n)))[-1][0]
 
class IsPrimeCached(dict):
    def __missing__(self, n):
        r = is_prime(n)
        self[n] = r
        return r
 
is_prime_cached = IsPrimeCached()
 
def croft():
    """"""Yield prime integers using the Croft Spiral sieve.
 
    This is a variant of wheel factorisation modulo 30.
    """"""
    # Copied from:
    #   https://code.google.com/p/pyprimes/source/browse/src/pyprimes.py
    # Implementation is based on erat3 from here:
    #   http://stackoverflow.com/q/2211990
    # and this website:
    #   http://www.primesdemystified.com/
    # Memory usage increases roughly linearly with the number of primes seen.
    # dict ``roots`` stores an entry x:p for every prime p.
    for p in (2, 3, 5):
        yield p
    roots = {9: 3, 25: 5}  # Map d**2 -> d.
    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))
    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)
    for q in compress(
            # Iterate over prime candidates 7, 9, 11, 13, ...
            islice(count(7), 0, None, 2),
            # Mask out those that can't possibly be prime.
            cycle(selectors)
            ):
        # Using dict membership testing instead of pop gives a
        # 5-10% speedup over the first three million primes.
        if q in roots:
            p = roots[q]
            del roots[q]
            x = q + 2*p
            while x in roots or (x % 30) not in primeroots:
                x += 2*p
            roots[x] = p
        else:
            roots[q*q] = q
            yield q
primes = croft
 
def decompose(n):
    for p in primes():
        if p*p > n: break
        while n % p == 0:
            yield p
            n //=p
    if n > 1:
        yield n
 
 
if __name__ == '__main__':
    # Example: calculate factors of Mersenne numbers to M59 #
 
    import time
 
    for m in primes():
        p = 2 ** m - 1
        print( ""2**{0:d}-1 = {1:d}, with factors:"".format(m, p) )
        start = time.time()
        for factor in decompose(p):
            print(factor, end=' ')
            sys.stdout.flush()
 
        print( ""=> {0:.2f}s"".format( time.time()-start ) )
        if m >= 59:
            break",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Convert_seconds_to_compound_duration,Convert seconds to compound duration,"Task

Write a function or program which:

   takes a positive integer representing a duration in seconds as input (e.g., 100), and
   returns a string which shows the same duration decomposed into:
   weeks,
   days, 
   hours, 
   minutes,   and 
   seconds.
This is detailed below (e.g., ""2 hr, 59 sec"").



Demonstrate that it passes the following three test-cases:

Test Cases


 input number

 output string


 7259

 2 hr, 59 sec


 86400

 1 d


 6000000

 9 wk, 6 d, 10 hr, 40 min

Details
The following five units should be used:



 unit

 suffix used in output

 conversion


 week

 wk

 1 week = 7 days


 day

 d

 1 day = 24 hours


 hour

 hr

 1 hour = 60 minutes


 minute

 min

 1 minute = 60 seconds


 second

 sec



However, only include quantities with non-zero values in the output (e.g., return ""1 d"" and not ""0 wk, 1 d, 0 hr, 0 min, 0 sec"").

Give larger units precedence over smaller ones as much as possible (e.g., return 2 min, 10 sec and not 1 min, 70 sec or 130 sec)

Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).



",Python,"import sys
from typing import List, Tuple, Dict
 
Entry = Tuple[int, str]
 
def print(entries: List[Entry], out=sys.stdout):
    first = True
    for e in entries:
        if not first:
            out.write("", "")
        first = False
        out.write(f""{e[0]} {e[1]}"")
    out.write(""\n"")
 
def convert(seconds: int) -> List[Entry]:
    time_table: Dict[int, str] = {
        7*24*60*60: ""wk"", 24*60*60: ""d"", 60*60: ""hr"", 60: ""min"", 1: ""sec""
    }
    result: List[Entry] = []
    for e in time_table:
        time = seconds // e
        if time!= 0:
            result.append((time, time_table[e]))
        seconds %= e
    return result
 
if __name__ == ""__main__"":
    print(""   7259 sec is "", convert(   7259))
    print(""  86400 sec is "", convert(  86400))
    print(""6000000 sec is "", convert(6000000))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/UTF-8_encode_and_decode,UTF-8 encode and decode,"As described in UTF-8 and in Wikipedia, UTF-8 is a popular encoding of (multi-byte) Unicode code-points into eight-bit octets.

The goal of this task is to write a encoder that takes a unicode code-point (an integer representing a unicode character) and returns a sequence of 1-4 bytes representing that character in the UTF-8 encoding.

Then you have to write the corresponding decoder that takes a sequence of 1-4 UTF-8 encoded bytes and return the corresponding unicode character.

Demonstrate the functionality of your encoder and decoder on the following five characters:

Character   Name                                  Unicode    UTF-8 encoding (hex)
---------------------------------------------------------------------------------
A           LATIN CAPITAL LETTER A                U+0041     41
ö           LATIN SMALL LETTER O WITH DIAERESIS   U+00F6     C3 B6
Ж           CYRILLIC CAPITAL LETTER ZHE           U+0416     D0 96
€           EURO SIGN                             U+20AC     E2 82 AC
𝄞           MUSICAL SYMBOL G CLEF                 U+1D11E    F0 9D 84 9E

Provided below is a reference implementation in Common Lisp.
",Python,"#!/usr/bin/env python3
from unicodedata import name
 
 
def unicode_code(ch):
    return 'U+{:04x}'.format(ord(ch))
 
 
def utf8hex(ch):
    return "" "".join([hex(c)[2:] for c in ch.encode('utf8')]).upper()
 
 
if __name__ == ""__main__"":
    print('{:<11} {:<36} {:<15} {:<15}'.format('Character', 'Name', 'Unicode', 'UTF-8 encoding (hex)'))
    chars = ['A', 'ö', 'Ж', '€', '𝄞']
    for char in chars:
        print('{:<11} {:<36} {:<15} {:<15}'.format(char, name(char), unicode_code(char), utf8hex(char)))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Barnsley_fern,Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",Python,"import random
from PIL import Image
 
 
class BarnsleyFern(object):
    def __init__(self, img_width, img_height, paint_color=(0, 150, 0),
                 bg_color=(255, 255, 255)):
        self.img_width, self.img_height = img_width, img_height
        self.paint_color = paint_color
        self.x, self.y = 0, 0
        self.age = 0
 
        self.fern = Image.new('RGB', (img_width, img_height), bg_color)
        self.pix = self.fern.load()
        self.pix[self.scale(0, 0)] = paint_color
 
    def scale(self, x, y):
        h = (x + 2.182)*(self.img_width - 1)/4.8378
        k = (9.9983 - y)*(self.img_height - 1)/9.9983
        return h, k
 
    def transform(self, x, y):
        rand = random.uniform(0, 100)
        if rand < 1:
            return 0, 0.16*y
        elif 1 <= rand < 86:
            return 0.85*x + 0.04*y, -0.04*x + 0.85*y + 1.6
        elif 86 <= rand < 93:
            return 0.2*x - 0.26*y, 0.23*x + 0.22*y + 1.6
        else:
            return -0.15*x + 0.28*y, 0.26*x + 0.24*y + 0.44
 
    def iterate(self, iterations):
        for _ in range(iterations):
            self.x, self.y = self.transform(self.x, self.y)
            self.pix[self.scale(self.x, self.y)] = self.paint_color
        self.age += iterations
 
fern = BarnsleyFern(500, 500)
fern.iterate(1000000)
fern.fern.show()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Priority_queue,Priority queue,"A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.



Task

Create a priority queue.   The queue must support at least two operations:

   Insertion.   An element is added to the queue with a priority (a numeric value).
   Top item removal.   Deletes the element or one of the elements with the current top priority and return it.


Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.



To test your implementation, insert a number of elements into the queue, each with some random priority.

Then dequeue them sequentially; now the elements should be sorted by priority.

You can use the following task/priority items as input data:

        Priority         Task
       ══════════   ════════════════
           3         Clear drains
           4         Feed cat
           5         Make tea
           1         Solve RC tasks
           2         Tax return



The implementation should try to be efficient.   A typical implementation has   O(log n)   insertion and extraction time,   where   n   is the number of items in the queue.

You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc.   If so, discuss the reasons behind it.



",Python,"import heapq
 
class Item(object):
    def __init__(self, priority, task):
        self.priority = priority
        self.task = task
 
    def __lt__(self, other):
        return self.priority < other.priority
 
queue = []
heapq.heappush(queue, Item(3, ""Clear drains""))
heapq.heappush(queue, Item(4, ""Feed cat""))
heapq.heappush(queue, Item(5, ""Make tea""))
heapq.heappush(queue, Item(1, ""Solve RC tasks""))
heapq.heappush(queue, Item(2, ""Tax return""))
 
while queue:
    item = heapq.heappop(queue)
    print(item.task)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Vector,Vector,"Task
Implement a Vector class (or a set of functions) that models a Physical Vector. The four basic operations and a pretty print function should be implemented.



The Vector may be initialized in any reasonable way.

 Start and end points, and direction
 Angular coefficient and value (length)


The four operations to be implemented are:

 Vector  +  Vector addition
 Vector  -  Vector subtraction
 Vector  *  scalar multiplication
 Vector  /  scalar division

",Python,"class Vector:
    def __init__(self,m,value):
        self.m = m
        self.value = value
        self.angle = math.degrees(math.atan(self.m))
        self.x = self.value * math.sin(math.radians(self.angle))
        self.y = self.value * math.cos(math.radians(self.angle))
 
    def __add__(self,vector):
        """"""
        >>> Vector(1,10) + Vector(1,2)
        Vector:
            - Angular coefficient: 1.0
            - Angle: 45.0 degrees
            - Value: 12.0
            - X component: 8.49
            - Y component: 8.49
        """"""
        final_x = self.x + vector.x
        final_y = self.y + vector.y
        final_value = pytagoras(final_x,final_y)
        final_m = final_y / final_x
        return Vector(final_m,final_value)
 
    def __neg__(self):
        return Vector(self.m,-self.value)
 
    def __sub__(self,vector):
        return self + (- vector)
 
    def __mul__(self,scalar):
        """"""
        >>> Vector(4,5) * 2
        Vector:
            - Angular coefficient: 4
            - Angle: 75.96 degrees
            - Value: 10
            - X component: 9.7
            - Y component: 2.43
 
        """"""
        return Vector(self.m,self.value*scalar)
 
    def __div__(self,scalar):
        return self * (1 / scalar)
 
    def __repr__(self):
        """"""
        Returns a nicely formatted list of the properties of the Vector.
 
        >>> Vector(1,10)
        Vector:
            - Angular coefficient: 1
            - Angle: 45.0 degrees
            - Value: 10
            - X component: 7.07
            - Y component: 7.07
 
        """"""
        return """"""Vector:
    - Angular coefficient: {}
    - Angle: {} degrees
    - Value: {}
    - X component: {}
    - Y component: {}"""""".format(self.m.__round__(2),
               self.angle.__round__(2),
               self.value.__round__(2),
               self.x.__round__(2),
               self.y.__round__(2))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Averages/Arithmetic_mean,Averages/Arithmetic mean,"Task[edit]
Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"def sum(arr):
    return sum(arr)
 
def mean(arr):
    return sum(arr) / len(arr)
 
if __name__ == '__main__':
    v = [2.0, 3.0, 5.0, 7.0, 13.0, 21.0, 33.0, 54.0]
    print('mean of {}: {}'.format(v, mean(v)))
 
    w = []
    print('mean of {}: {}'.format(w, mean(w)))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"from itertools import combinations, product

teams = ['a', 'b', 'c', 'd']
matches = list(combinations(teams, 2))
outcomes = ['win', 'draw', 'loss']
gains = {'win': [3, 0], 'draw': [1, 1], 'loss': [0, 3]}
places_histogram = [[0] * 10 for _ in range(4)]

for outcome in product(outcomes, repeat=6):
    results = [0] * 4
    for decision, (team1, team2) in zip(outcome, matches):
        results[teams.index(team1)] += gains[decision][0]
        results[teams.index(team2)] += gains[decision][1]
    for place, points in enumerate(sorted(results, reverse=True), 1):
        places_histogram[place - 1][points] += 1

fmt = '{:>2s} :'+'{:>3s}' * 10
print(fmt.format(' ', *range(10)))
print(fmt.format('-', *['---'] * 10))
for place, hist in enumerate(places_histogram, 1):
    print(fmt.format(str(place), *hist))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Biorhythms,Biorhythms,"For a while in the late 70s, the pseudoscience of biorhythms was popular enough to rival astrology, with kiosks in malls that would give you your weekly printout. It was also a popular entry in ""Things to Do with your Pocket Calculator"" lists. You can read up on the history at Wikipedia, but the main takeaway is that unlike astrology, the math behind biorhythms is dead simple.

It's based on the number of days since your birth. The premise is that three cycles of unspecified provenance govern certain aspects of everyone's lives – specifically, how they're feeling physically, emotionally, and mentally. The best part is that not only do these cycles somehow have the same respective lengths for all humans of any age, gender, weight, genetic background, etc, but those lengths are an exact number of days. And the pattern is in each case a perfect sine curve. Absolutely miraculous!

To compute your biorhythmic profile for a given day, the first thing you need is the number of days between that day and your birth, so the answers in Days between dates are probably a good starting point. (Strictly speaking, the biorhythms start at 0 at the moment of your birth, so if you know time of day you can narrow things down further, but in general these operate at whole-day granularity.) Then take the residue of that day count modulo each of the the cycle lengths to calculate where the day falls on each of the three sinusoidal journeys.

The three cycles and their lengths are as follows:



 Cycle

 Length


Physical

 23 days


Emotional

 28 days


Mental

 33 days

The first half of each cycle is in ""plus"" territory, with a peak at the quarter-way point; the second half in ""minus"" territory, with a valley at the three-quarters mark. You can calculate a specific value between -1 and +1 for the kth day of an n-day cycle by computing sin( 2πk / n ). The days where a cycle crosses the axis in either direction are called ""critical"" days, although with a cycle value of 0 they're also said to be the most neutral, which seems contradictory.

The task: write a subroutine, function, or program that will, given a birthdate and a target date, output the three biorhythmic values for the day. You may optionally include a text description of the position and the trend (e.g. ""up and rising"", ""peak"", ""up but falling"", ""critical"", ""down and falling"", ""valley"", ""down but rising""), an indication of the date on which the next notable event (peak, valley, or crossing) falls, or even a graph of the cycles around the target date. Demonstrate the functionality for dates of your choice.

Example run of my Raku implementation:

raku br.raku 1943-03-09 1972-07-11

Output:
Day 10717:
Physical day 22: -27% (down but rising, next transition 1972-07-12)
Emotional day 21: valley
Mental day 25: valley

Double valley! This was apparently not a good day for Mr. Fischer to begin a chess tournament...
",Python,"""""""
 
Python implementation of
 
http://rosettacode.org/wiki/Biorhythms
 
""""""
 
from datetime import date, timedelta
from math import floor, sin, pi
 
def biorhythms(birthdate,targetdate):
    """"""
    Print out biorhythm data for targetdate assuming you were
    born on birthdate.
 
    birthdate and targetdata are strings in this format:
 
    YYYY-MM-DD e.g. 1964-12-26
    """"""
 
    # print dates
 
    print(""Born: ""+birthdate+"" Target: ""+targetdate)    
 
    # convert to date types - Python 3.7 or later
 
    birthdate = date.fromisoformat(birthdate)
    targetdate = date.fromisoformat(targetdate)
 
    # days between
 
    days = (targetdate - birthdate).days
 
    print(""Day: ""+str(days))
 
    # cycle logic - mostly from Julia example
 
    cycle_labels = [""Physical"", ""Emotional"", ""Mental""]
    cycle_lengths = [23, 28, 33]
    quadrants = [(""up and rising"", ""peak""), (""up but falling"", ""transition""),
                   (""down and falling"", ""valley""), (""down but rising"", ""transition"")]
 
    for i in range(3):
        label = cycle_labels[i]
        length = cycle_lengths[i]
        position = days % length
        quadrant = int(floor((4 * position) / length))
        percentage = int(round(100 * sin(2 * pi * position / length),0))
        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)
        trend, next = quadrants[quadrant]
 
        if percentage > 95:
            description = ""peak""
        elif percentage < -95:
             description = ""valley""
        elif abs(percentage) < 5:
             description = ""critical transition""
        else:
             description = str(percentage)+""% (""+trend+"", next ""+next+"" ""+str(transition_date)+"")""
        print(label+"" day ""+str(position)+"": ""+description)
 
 
biorhythms(""1943-03-09"",""1972-07-11"")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Yellowstone_sequence,Yellowstone sequence,"The Yellowstone sequence, also called the Yellowstone permutation, is defined as:

For n <= 3,

   a(n) = n

For n >= 4,

   a(n) = the smallest number not already in sequence such that a(n) is relatively prime to a(n-1) and 
          is not relatively prime to a(n-2).



The sequence is a permutation of the natural numbers, and gets its name from what its authors felt was a spiking, geyser like appearance of a plot of the sequence.



Example

a(4) is 4 because 4 is the smallest number following 1, 2, 3 in the sequence that is relatively prime to the entry before it (3), and is not relatively prime to the number two entries before it (2).



Task
 Find and show as output the first  30  Yellowstone numbers.


Extra
 Demonstrate how to plot, with x = n and y coordinate a(n), the first 100 Yellowstone numbers.


Related tasks

   Greatest common divisor.
   Plot coordinate pairs.


See also

   The OEIS entry:   A098550 The Yellowstone permutation.
   Applegate et al, 2015: The Yellowstone Permutation [1].

",Python,"'''Yellowstone permutation OEIS A098550'''
 
from itertools import chain, count, islice
from operator import itemgetter
from math import gcd
 
from matplotlib import pyplot
 
 
# yellowstone :: [Int]
def yellowstone():
    '''A non-finite stream of terms from
       the Yellowstone permutation.
       OEIS A098550.
    '''
    # relativelyPrime :: Int -> Int -> Bool
    def relativelyPrime(a):
        return lambda b: 1 == gcd(a, b)
 
    # nextWindow :: (Int, Int, [Int]) -> (Int, Int, [Int])
    def nextWindow(triple):
        p2, p1, rest = triple
        [rp2, rp1] = map(relativelyPrime, [p2, p1])
 
        # match :: [Int] -> (Int, [Int])
        def match(xxs):
            x, xs = uncons(xxs)['Just']
            return (x, xs) if rp1(x) and not rp2(x) else (
                second(cons(x))(
                    match(xs)
                )
            )
        n, residue = match(rest)
        return (p1, n, residue)
 
    return chain(
        range(1, 3),
        map(
            itemgetter(1),
            iterate(nextWindow)(
                (2, 3, count(4))
            )
        )
    )
 
 
# TEST ----------------------------------------------------
# main :: IO ()
def main():
    '''Terms of the Yellowstone permutation.'''
 
    print(showList(
        take(30)(yellowstone())
    ))
    pyplot.plot(
        take(100)(yellowstone())
    )
    pyplot.xlabel(main.__doc__)
    pyplot.show()
 
 
# GENERIC -------------------------------------------------
 
# Just :: a -> Maybe a
def Just(x):
    '''Constructor for an inhabited Maybe (option type) value.
       Wrapper containing the result of a computation.
    '''
    return {'type': 'Maybe', 'Nothing': False, 'Just': x}
 
 
# Nothing :: Maybe a
def Nothing():
    '''Constructor for an empty Maybe (option type) value.
       Empty wrapper returned where a computation is not possible.
    '''
    return {'type': 'Maybe', 'Nothing': True}
 
 
# cons :: a -> [a] -> [a]
def cons(x):
    '''Construction of a list from x as head,
       and xs as tail.
    '''
    return lambda xs: [x] + xs if (
        isinstance(xs, list)
    ) else x + xs if (
        isinstance(xs, str)
    ) else chain([x], xs)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
# second :: (a -> b) -> ((c, a) -> (c, b))
def second(f):
    '''A simple function lifted to a function over a tuple,
       with f applied only to the second of two values.
    '''
    return lambda xy: (xy[0], f(xy[1]))
 
 
# showList :: [a] -> String
def showList(xs):
    '''Stringification of a list.'''
    return '[' + ','.join(repr(x) for x in xs) + ']'
 
 
# take :: Int -> [a] -> [a]
# take :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.
    '''
    return lambda xs: (
        xs[0:n]
        if isinstance(xs, (list, tuple))
        else list(islice(xs, n))
    )
 
 
# uncons :: [a] -> Maybe (a, [a])
def uncons(xs):
    '''The deconstruction of a non-empty list
       (or generator stream) into two parts:
       a head value, and the remaining values.
    '''
    if isinstance(xs, list):
        return Just((xs[0], xs[1:])) if xs else Nothing()
    else:
        nxt = take(1)(xs)
        return Just((nxt[0], xs)) if nxt else Nothing()
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Probabilistic_choice,Probabilistic choice,"Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
Related task

 Random number generator (device)

",Python,"import random, bisect
 
def probchoice(items, probs):
  '''\
  Splits the interval 0.0-1.0 in proportion to probs
  then finds where each random.random() choice lies
  '''
 
  prob_accumulator = 0
  accumulator = []
  for p in probs:
    prob_accumulator += p
    accumulator.append(prob_accumulator)
 
  while True:
    r = random.random()
    yield items[bisect.bisect(accumulator, r)]
 
def probchoice2(items, probs, bincount=10000):
  '''\
  Puts items in bins in proportion to probs
  then uses random.choice() to select items.
 
  Larger bincount for more memory use but
  higher accuracy (on avarage).
  '''
 
  bins = []
  for item,prob in zip(items, probs):
    bins += [item]*int(bincount*prob)
  while True:
    yield random.choice(bins)
 
 
def tester(func=probchoice, items='good bad ugly'.split(),
                    probs=[0.5, 0.3, 0.2],
                    trials = 100000
                    ):
  def problist2string(probs):
    '''\
    Turns a list of probabilities into a string
    Also rounds FP values
    '''
    return "","".join('%8.6f' % (p,) for p in probs)
 
  from collections import defaultdict
 
  counter = defaultdict(int)
  it = func(items, probs)
  for dummy in xrange(trials):
    counter[it.next()] += 1
  print ""\n##\n## %s\n##"" % func.func_name.upper()  
  print ""Trials:              "", trials
  print ""Items:               "", ' '.join(items)
  print ""Target probability:  "", problist2string(probs)
  print ""Attained probability:"", problist2string(
    counter[x]/float(trials) for x in items)
 
if __name__ == '__main__':
  items = 'aleph beth gimel daleth he waw zayin heth'.split()
  probs = [1/(float(n)+5) for n in range(len(items))]
  probs[-1] = 1-sum(probs[:-1])
  tester(probchoice, items, probs, 1000000)
  tester(probchoice2, items, probs, 1000000)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Old_Russian_measure_of_length,Old Russian measure of length,"Task

Write a program to perform a conversion of the old Russian measures of length to the metric system   (and vice versa).



It is an example of a linear transformation of several variables.



The program should accept a single value in a selected unit of measurement, and convert and return it to the other units:

vershoks, arshins, sazhens, versts, meters, centimeters and kilometers.



Also see

   Old Russian measure of length

",Python,"from sys import argv
 
unit2mult = {""arshin"": 0.7112, ""centimeter"": 0.01,     ""diuym"":   0.0254,
             ""fut"":    0.3048, ""kilometer"":  1000.0,   ""liniya"":  0.00254,
             ""meter"":  1.0,    ""milia"":      7467.6,   ""piad"":    0.1778,
             ""sazhen"": 2.1336, ""tochka"":     0.000254, ""vershok"": 0.04445,
             ""versta"": 1066.8}
 
if __name__ == '__main__':
    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'
    try:
        value = float(argv[1])
    except:
        print('ERROR. First argument must be a (float) number')
        raise
    unit = argv[2]
    assert unit in unit2mult, ( 'ERROR. Only know the following units: ' 
                                + ' '.join(unit2mult.keys()) )
 
    print(""%g %s to:"" % (value, unit))
    for unt, mlt in sorted(unit2mult.items()):
        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Image_convolution,Image convolution,"One class of image digital filters is described by a rectangular matrix of real coefficients called kernel convoluted in a sliding window of image pixels. Usually the kernel is square 




K

k
l




{\displaystyle K_{kl}}

, where k, l are in the range -R,-R+1,..,R-1,R. W=2R+1 is the kernel width. The filter determines the new value of a monochromatic image pixel Pij as a convolution of the image pixels in the window centered in i, j and the kernel values:







P

i
j


=


∑

k
=
−
R


R



∑

l
=
−
R


R



P

i
+
k
 
j
+
l



K

k
l





{\displaystyle P_{ij}=\displaystyle \sum _{k=-R}^{R}\sum _{l=-R}^{R}P_{i+k\ j+l}K_{kl}}




Color images are usually split into the channels which are filtered independently. A color model can be changed as well, i.e. filtration is performed not necessarily in RGB. Common kernels sizes are 3x3 and 5x5. The complexity of filtrating grows quadratically (O(n2)) with the kernel width.

Task: Write a generic convolution 3x3 kernel filter. Optionally show some end user filters that use this generic one.

(You can use, to test the functions below, these input and output solutions.)
",Python,"#!/bin/python
from PIL import Image, ImageFilter
 
if __name__==""__main__"":
	im = Image.open(""test.jpg"")
 
	kernelValues = [-2,-1,0,-1,1,1,0,1,2] #emboss
	kernel = ImageFilter.Kernel((3,3), kernelValues)
 
	im2 = im.filter(kernel)
 
	im2.show()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Draw_a_sphere,Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Python,"import math
import sys

def normalize(v):
    len = math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
    v[0] /= len
    v[1] /= len
    v[2] /= len

def dot(x, y):
    d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
    return d if d > 0 else -d

def draw_sphere(r, k, ambient):
    shades = "".:!*oe%&#@""
    light = [30, 30, -50]
    normalize(light)
    vec = [0, 0, 0]
    for i in range(int(math.floor(-r)), int(math.ceil(r))):
        x = i +.5
        for j in range(int(math.floor(-2*r)), int(math.ceil(2*r))):
            y = j/2.0 +.5
            if x*x + y*y <= r*r:
                vec[0] = x
                vec[1] = y
                vec[2] = math.sqrt(r*r - x*x - y*y)
                normalize(vec)
                b = math.pow(dot(light, vec), k) + ambient
                intensity = (b <= 0) and len(shades) - 2 or int(max((1 - b)*(len(shades) - 1), 0))
                sys.stdout.write(shades[intensity])
            else:
                sys.stdout.write(' ')
        sys.stdout.write('\n')

draw_sphere(6, 4,.1)
draw_sphere(10, 2,.4)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Python,"import math
from PIL import Image
 
# Constants defining the spiral size.
a = 1.0
b = 9.0
 
# max_angle = number of spirals * 2pi.
max_angle = 5.0 * 2.0 * math.pi
 
# Create a new image.
width = 600
half_width = width // 2
img = Image.new('RGB', (width, width), color=(255, 255, 255))
 
# Draw the spiral.
theta = 0.0
while theta < max_angle:
    theta = theta + 0.002
    r = a + b * theta
    x = int(r * math.cos(theta)) + half_width
    y = int(r * math.sin(theta)) + half_width
    img.putpixel((x, y), (255, 128, 128))
 
# Save the image.
img.save('archimedean_spiral.png')",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Undefined_values,Undefined values,"
",Python,"# Check to see whether a name is defined
try: name
except NameError: print ""name is undefined at first check""
 
# Create a name, giving it a string value
name = ""Chocolate""
 
# Check to see whether the name is defined now.
try: name
except NameError: print ""name is undefined at second check""
 
# Remove the definition of the name.
del name
 
# Check to see whether it is defined after the explicit removal.
try: name
except NameError: print ""name is undefined at third check""
 
# Recreate the name, giving it a value of 42
name = 42
 
# Check to see whether the name is defined now.
try: name
except NameError: print ""name is undefined at fourth check""
 
# Because most of the output is conditional, this serves as
# a clear indicator that the program has run to completion.
print ""Done""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Non-decimal_radices/Input,Non-decimal radices/Input,"It is common to have a string containing a number written in some format, with the most common ones being decimal, hexadecimal, octal and binary. Such strings are found in many places (user interfaces, configuration files, XML data, network protocols, etc.)

This task requires parsing of such a string (which may be assumed to contain nothing else) using the language's built-in facilities if possible. Parsing of decimal strings is required, parsing of other formats is optional but should be shown (i.e., if the language can parse in base-19 then that should be illustrated).

The solutions may assume that the base of the number in the string is known. In particular, if your language has a facility to guess the base of a number by looking at a prefix (e.g. ""0x"" for hexadecimal) or other distinguishing syntax as it parses it, please show that.

The reverse operation is in task Non-decimal radices/Output

For general number base conversion, see Non-decimal radices/Convert.
",Python,"dec1 = ""0123459""
hex2 = ""abcf123""
oct3 = ""7651""
bin4 = ""101011001""
 
print(int(dec1))   # => 123459
print(int(hex2, 16))    # => 180154659
print(int(oct3, 8))    # => 4009
# nothing for binary",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Compare_a_list_of_strings,Compare a list of strings,"Task

Given a   list   of arbitrarily many strings, show how to:

   test if they are all lexically equal
   test if every string is lexically less than the one after it (i.e. whether the list is in strict ascending order)


Each of those two tests should result in a single true or false value, which could be used as the condition of an    if    statement or similar.

If the input list has less than two elements, the tests should always return true.

There is no need to provide a complete program and output.

Assume that the strings are already stored in an array/list/sequence/tuple variable (whatever is most idiomatic) with the name   strings,   and just show the expressions for performing those two tests on it (plus of course any includes and custom functions etc. that it needs),   with as little distractions as possible.

Try to write your solution in a way that does not modify the original list,   but if it does then please add a note to make that clear to readers.

If you need further guidance/clarification,   see #Perl and #Python for solutions that use implicit short-circuiting loops,   and #Raku for a solution that gets away with simply using a built-in language feature. 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"all(a == nexta for a, nexta in zip(strings, strings[1:])) # All equal
all(a < nexta for a, nexta in zip(strings, strings[1:])) # Strictly ascending
 
len(set(strings)) == 1  # Concise all equal
sorted(strings, reverse=True) == strings  # Concise (but not particularly efficient) ascending",Human_written,Python_from_C
http://rosettacode.org/wiki/Exponentiation_order,Exponentiation order,"This task will demonstrate the order of exponentiation   (xy)    when there are multiple exponents.

(Many programming languages,   especially those with extended─precision integer arithmetic,   usually support one of  **, ^, ↑  or some such for exponentiation.)



Task requirements
Show the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



Using whatever operator or syntax your language supports (if any), show the results in three lines (with identification):


   5**3**2 
   (5**3)**2
   5**(3**2)




If there are other methods (or formats) of multiple exponentiations, show them as well.



See also

 MathWorld entry:   exponentiation


Related tasks

   exponentiation operator
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"import math
 
print(""(5 ^ 3) ^ 2 = %.0f"" % (math.pow(math.pow(5,3),2)))
print(""5 ^ (3 ^ 2) = %.0f"" % (math.pow(5,math.pow(3,2))))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Animation,Animation,"
Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.



Task

Create a window containing the string ""Hello World! "" (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.



",Python,"from Tkinter import *
import time
 
str = ""Hello World! ""
dir = ""right""
 
def animate():
  global str, dir
  str = shift_char(str, dir)
  root.after(125, animate)
 
def shift_char(str, dir):
  if dir == ""right"":
    return str[-1] + str[0:-1]
  elif dir == ""left"":
    return str[1:] + str[0]
 
root = Tk()
root.title(""Basic Animation"")
 
label = Label(root, textvariable=str, font=""Courier 14"")
label.pack(side=TOP)
label.bind(""<Button-1>"", lambda event: dir = ""left"" if dir == ""right"" else ""right"")
 
animate()
root.mainloop()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",Python,"import math
import sys

def f(x):
    return x*x*x-3.0*x*x +2.0*x

def secant( xA, xB, f ):
    e = 1.0e-12
    fA = f(xA)
    for i in range(50):
        fB = f(xB)
        d = (xB - xA) / (fB - fA) * fB
        if abs(d) < e:
            break
        xA = xB
        fA = fB
        xB -= d
    else:
        print(""Function is not converging near (%7.4f,%7.4f)."" % (xA,xB))
        return -99.0
    return xB

x = -1.032
s = (f(x)> 0.0)
step = 1.0e-2
e = 1.0e-12

while x < 3.0:
    value = f(x)
    if abs(value) < e:
        print(""Root found at x= %12.9f"" % x)
        s = (f(x+.0001)>0.0)
    elif (value > 0.0)!= s:
        xx = secant(x-step, x,f)
        if xx!= -99.0:   # -99 meaning secand method failed
            print(""Root found at x= %12.9f"" % xx)
        else:
            print(""Root found near x= %7.4f"" % x)
        s = (f(x+.0001)>0.0)
    x += step",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",Python,">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))
>>> [ Y(fac)(i) for i in range(10) ]
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))
>>> [ Y(fib)(i) for i in range(10) ]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",Human_written,Python_from_C
http://rosettacode.org/wiki/Teacup_rim_text,Teacup rim text,"On a set of coasters we have, there's a picture of a teacup.   On the rim of the teacup the word   TEA   appears a number of times separated by bullet characters   (•).

It occurred to me that if the bullet were removed and the words run together,   you could start at any letter and still end up with a meaningful three-letter word.

So start at the   T   and read   TEA.   Start at the   E   and read   EAT,   or start at the   A   and read   ATE.

That got me thinking that maybe there are other words that could be used rather that   TEA.   And that's just English.   What about Italian or Greek or ... um ... Telugu.

For English, we will use the unixdict (now) located at:   unixdict.txt.

(This will maintain continuity with other Rosetta Code tasks that also use it.)



Task

Search for a set of words that could be printed around the edge of a teacup.   The words in each set are to be of the same length, that length being greater than two (thus precluding   AH   and   HA,   for example.)

Having listed a set, for example   [ate tea eat],   refrain from displaying permutations of that set, e.g.:   [eat tea ate]   etc.

The words should also be made of more than one letter   (thus precluding   III   and   OOO   etc.)

The relationship between these words is (using ATE as an example) that the first letter of the first becomes the last letter of the second.   The first letter of the second becomes the last letter of the third.   So   ATE   becomes   TEA   and   TEA   becomes   EAT.

All of the possible permutations, using this particular permutation technique, must be words in the list.

The set you generate for   ATE   will never included the word   ETA   as that cannot be reached via the first-to-last movement method.

Display one line for each set of teacup rim words.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
from collections import deque
 
def load_dictionary(filename):
    with open(filename) as f:
        return set(f.read().split())
 
def find_teacup_words(words):
    found = set()
    for word in words:
        if len(word) < 3 or word in found:
            continue
        teacup_words = deque([word])
        for _ in range(len(word) - 1):
            word = word[1:] + word[0]
            if word == teacup_words[0] or word not in words:
                break
            teacup_words.append(word)
        if len(teacup_words) == len(word):
            found.update(teacup_words)
            print(' '.join(teacup_words))
 
if __name__ == '__main__':
    if len(sys.argv)!= 2:
        sys.exit('usage: {} dictionary'.format(sys.argv[0]))
    try:
        find_teacup_words(load_dictionary(sys.argv[1]))
    except IOError as ex:
        sys.exit(ex)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Knuth_shuffle,Knuth shuffle,"The   Knuth shuffle   (a.k.a. the Fisher-Yates shuffle)   is an algorithm for randomly shuffling the elements of an array.



Task

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).



Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

       for i from last downto 1 do:
           let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 j 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 i
           swap items[i] with items[j]

Notes

   It modifies the input array in-place. 
   If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
   The algorithm can also be amended to iterate from left to right, if that is more convenient.


Test cases



 Input array

 Possible output arrays


 []

 []


 [10]

 [10]


 [10, 20]

 [10, 20]
[20, 10]


 [10, 20, 30]

 [10, 20, 30]
[10, 30, 20]
[20, 10, 30]
[20, 30, 10]
[30, 10, 20]
[30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)



Related task

 Sattolo cycle



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from random import randrange
 
def knuth_shuffle(x):
    for i in range(len(x)-1, 0, -1):
        j = randrange(i + 1)
        x[i], x[j] = x[j], x[i]
 
x = list(range(10))
knuth_shuffle(x)
print(""shuffled:"", x)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Concurrent_computing,Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",Python,"import random
import time
from threading import Thread
 
def main():
    words = [""Enjoy"", ""Rosetta"", ""Code""]
    seed = int(time.time())
    q = []
    for i, w in enumerate(words):
        t = Thread(target=lambda w=w, seed=seed+i: q.append(w))
        t.start()
        time.sleep(random.Random(seed).random())
    for i in range(len(words)):
        print(q.pop(0))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Fermat_numbers,Fermat numbers,"In mathematics, a Fermat number, named after Pierre de Fermat who first studied them, is a positive integer of the form Fn = 22n + 1 where n is a non-negative integer.

Despite the simplicity of generating Fermat numbers, they have some powerful mathematical properties and are extensively used in cryptography & pseudo-random number generation, and are often linked to other number theoric fields.

As of this writing, (mid 2019), there are only five known prime Fermat numbers, the first five (F0 through F4). Only the first twelve Fermat numbers have been completely factored, though many have been partially factored.



Task

 Write a routine (function, procedure, whatever) to generate Fermat numbers.
 Use the routine to find and display here, on this page, the first 10 Fermat numbers - F0 through F9.
 Find and display here, on this page, the prime factors of as many Fermat numbers as you have patience for. (Or as many as can be found in five minutes or less of processing time). Note: if you make it past F11, there may be money, and certainly will be acclaim in it for you.


See also

 Wikipedia - Fermat numbers
 OEIS:A000215 - Fermat numbers
 OEIS:A019434 - Fermat primes

",Python,"def divisor_gen(num):
    for i in range(2, num // 2 + 1):
        yield i
 
def is_prime(num):
    if num == 2 or num == 3:
        return True
    elif num % 2 == 0 or num % 3 == 0 or num <= 1:
        return False
    else:
        for i in divisor_gen(num):
            if num % i == 0:
                return False
    return True
 
def fermat_closure(i):
    return 2 ** (2 ** (i + 1))
 
f_numbers = []
print(""First 4 Fermat numbers:"")
for i in range(4):
    f = fermat_closure(i) + 1
    f_numbers.append(f)
    print(""F{}: {}"".format(i, f))
 
print(""Factor of the first four numbers:"")
for f in f_numbers:
    is_prime = f % 4 == 1 and is_prime(f)
    not_or_not = "" "" if is_prime else "" not ""
    print(""{} is{}prime"".format(f, not_or_not))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Compound_data_type,Compound data type,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.


Task

Create a compound data type:

  Point(x,y) 



A compound data type is one that holds multiple independent values.



Related task

   Enumeration


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import namedtuple
Point = namedtuple('Point', 'x y')
pt = Point(6,7)
print pt.x        #=> 6
pt.y = 3
print pt          #=> Point(x=6, y=3)
 
# The other way of accessing
pt = Point(2,3)
print pt[0]      #=> 2
pt = pt._replace(y=5)
print pt          #=> Point(x=2, y=5)
 
for member, value in pt._asdict().iteritems():
    print ""%s : %s"" % (member, value)
                 #=> x : 2
                 #=> y : 5",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",Python,"a = 2988348162058574136915891421498819466320163312926952423791023078876139
b = 2351399303373464486466122544523690094744975233415544072992656881240319
m = 10 ** 40
print(pow(a, b, m))",Human_written,Python_from_C
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_pal(s):
    mid = len(s) // 2
    last = len(s) - 1
    for i in range(mid):
        if s[i]!= s[last - i]:
            return False
    return True",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",Python,"import math
 
math.e          # e
math.pi         # pi
math.sqrt(x)    # square root  (Also commonly seen as x ** 0.5 to obviate importing the math module)
math.log(x)     # natural logarithm
math.log10(x)   # base 10 logarithm
math.exp(x)     # e raised to the power of x
abs(x)          # absolute value
math.floor(x)   # floor
math.ceil(x)    # ceiling
x ** y          # exponentiation 
pow(x, y[, n])  # exponentiation [, modulo n (useful in certain encryption/decryption algorithms)]
 
# The math module constants and functions can, of course, be imported directly by:
#   from math import e, pi, sqrt, log, log10, exp, floor, ceil",Human_written,Python_from_C++
http://rosettacode.org/wiki/Haversine_formula,Haversine formula,"

 This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".



Task

Implement a great-circle distance function, or use a library function,
to show the great-circle distance between:

 Nashville International Airport (BNA)   in Nashville, TN, USA,   which is: 
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

 Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius. However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased). When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km. This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.





",Python,"import math
 
R = 6372.8 # in kilometers
 
def haversine(lat1, lon1, lat2, lon2):
    λ1 = math.radians(lat1)
    λ2 = math.radians(lat2)
    Δλ = math.radians(lat2 - lat1)
    Δφ = math.radians(lon2 - lon1)
    return 2 * R * math.asin(math.sqrt(math.pow(math.sin(Δλ / 2), 2) + math.pow(math.sin(Δφ / 2), 2) * math.cos(λ1) * math.cos(λ2)))
 
print(""result: "" + str(haversine(36.12, -86.67, 33.94, -118.40)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Runtime_evaluation,Runtime evaluation,"Task

Demonstrate a language's ability for programs to execute code written in the language provided at runtime.

Show what kind of program fragments are permitted (e.g. expressions vs. statements), and how to get values in and out (e.g. environments, arguments, return values), if applicable what lexical/static environment the program is evaluated in, and what facilities for restricting (e.g. sandboxes, resource limits) or customizing (e.g. debugging facilities) the execution.

You may not invoke a separate evaluator program, or invoke a compiler and then its output, unless the interface of that program, and the syntax and means of executing it, are considered part of your language/library/platform.

For a more constrained task giving a specific program fragment to evaluate, see Eval in environment.



",Python,">>> 20 + 22
42
>>> 5 * math.sqrt(81.0)
45.0
>>> def triple(x):
...     return x * 3
...
>>> triple(16)
48
>>> exit()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Logical_operations,Logical operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Write a function that takes two logical (boolean) values, and outputs the result of ""and"" and ""or"" on both arguments as well as ""not"" on the first arguments.

If the programming language doesn't provide a separate type for logical values, use the type most commonly used for that purpose.

If the language supports additional logical operations on booleans such as XOR, list them as well.



",Python,"def logic(a, b):
    print('a and b:', a and b)
    print('a or b:', a or b)
    print('not a:', not a)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Terminal_control/Clear_the_screen,Terminal control/Clear the screen,"Task

Clear the terminal window.



",Python,"class Clear:
    def main(args):
        print(""\033[2J"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Averages/Simple_moving_average,Averages/Simple moving average,"Computing the simple moving average of a series of numbers.

Task[edit]
Create a stateful function/class/instance that takes a period and returns a routine that takes a number as argument and returns a simple moving average of its arguments so far.

Description
A simple moving average is a method for computing an average of a stream of numbers by only averaging the last   P   numbers from the stream,   where   P   is known as the period.

It can be implemented by calling an initialing routine with   P   as its argument,   I(P),   which should then return a routine that when called with individual, successive members of a stream of numbers, computes the mean of (up to), the last   P   of them, lets call this   SMA().

The word   stateful   in the task description refers to the need for   SMA()   to remember certain information between calls to it:

   The period,   P
   An ordered container of at least the last   P   numbers from each of its individual calls.

Stateful   also means that successive calls to   I(),   the initializer,   should return separate routines that do   not   share saved state so they could be used on two independent streams of data.

Pseudo-code for an implementation of   SMA   is:

function SMA(number: N):
    stateful integer: P
    stateful list:    stream
    number:           average

    stream.append_last(N)
    if stream.length() > P:
        # Only average the last P elements of the stream
        stream.delete_first()
    if stream.length() == 0:
        average = 0
    else:    
        average = sum( stream.values() ) / stream.length()
    return average

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,"def simple_moving_average(size):
    nums = []
    sum = 0.0
    def inner(hello):
        nonlocal nums, sum
        nums.append(hello)
        goodbye = nums.pop(0) if len(nums) > size else 0
        sum += hello - goodbye
        return sum / len(nums)
    return inner
 
ma3 = simple_moving_average(3)
ma5 = simple_moving_average(5)
 
for num in (list(range(1, 6)) + list(range(5, 0, -1))):
    print(""Next number = %d, SMA_3 = %.3f, SMA_5 = %.1f"" % (num, ma3(num), ma5(num)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Egyptian_division,Egyptian division,"Egyptian division is a method of dividing integers using addition and
doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

 Start the construction of a table of two columns: powers_of_2, and doublings; by a first row of a 1 (i.e. 2^0) in the first column and 1 times the divisor in the first row second column.
 Create the second row with columns of 2 (i.e 2^1), and 2 * divisor in order.
 Continue with successive i’th rows of 2^i and 2^i * divisor.
 Stop adding rows, and keep only those rows, where 2^i * divisor is less than or equal to the dividend.
 We now assemble two separate sums that both start as zero, called here answer and accumulator
 Consider each row of the table, in the reverse order of its construction.
 If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers_of_2 cell value to the answer.
 When the first row has been considered as above, then the integer division of dividend by divisor is given by answer.
 (And the remainder is given by the absolute value of accumulator - dividend).


Example: 580 / 34

 Table creation: 



 powers_of_2

 doublings


 1

 34


 2

 68


 4

 136


 8

 272


 16

 544

 Initialization of sums: 



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544










 0

 0

 Considering table rows, bottom-up: 

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544

 16

 544



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272

 16

 544


 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136

 16

 544


 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68

 16

 544


 4

 136






 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34

 17

 578


 2

 68






 4

 136






 8

 272






 16

 544





Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.



Task

The task is to create a function that does Egyptian division. The function should

closely follow the description above in using a list/array of powers of two, and

another of doublings.

 Functions should be clear interpretations of the algorithm.
 Use the function to divide 580 by 34 and show the answer here, on this page.


Related tasks

   Egyptian fractions


References

   Egyptian Number System

",Python,"from itertools import product
 
def egyptian_divmod(dividend, divisor):
    assert divisor != 0
    pwrs, dbls = [1], [divisor]
    while dbls[-1] <= dividend:
        pwrs.append(pwrs[-1] * 2)
        dbls.append(pwrs[-1] * divisor)
    ans, accum = 0, 0
    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):
        if accum + dbl <= dividend:
            accum += dbl
            ans += pwr
    return ans, abs(accum - dividend)
 
if __name__ == ""__main__"":
    # Test it gives the same results as the divmod built-in
    for i, j in product(range(13), range(1, 13)):
            assert egyptian_divmod(i, j) == divmod(i, j)
    # Mandated result
    i, j = 580, 34
    print(f'{i} divided by {j} using the Egyption method is %i remainder %i'
          % egyptian_divmod(i, j))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",Python,">>> # Bin(leading 0b or 0B), Oct(leading 0o or 0O), Dec, Hex(leading 0x or 0X), in order:
>>> 0b1011010111 == 0o1327 == 727 == 0x2d7
True
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Subtractive_generator,Subtractive generator,"A subtractive generator calculates a sequence of random numbers, where each number is congruent to the subtraction of two previous numbers from the sequence. 

The formula is

 




r

n


=

r

(
n
−
i
)


−

r

(
n
−
j
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-i)}-r_{(n-j)}{\pmod {m}}}


for some fixed values of 



i


{\displaystyle i}

, 



j


{\displaystyle j}

 and 



m


{\displaystyle m}

, all positive integers. Supposing that 



i
>
j


{\displaystyle i>j}

, then the state of this generator is the list of the previous numbers from 




r

n
−
i




{\displaystyle r_{n-i}}

 to 




r

n
−
1




{\displaystyle r_{n-1}}

. Many states generate uniform random integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

, but some states are bad. A state, filled with zeros, generates only zeros. If 



m


{\displaystyle m}

 is even, then a state, filled with even numbers, generates only even numbers. More generally, if 



f


{\displaystyle f}

 is a factor of 



m


{\displaystyle m}

, then a state, filled with multiples of 



f


{\displaystyle f}

, generates only multiples of 



f


{\displaystyle f}

.

All subtractive generators have some weaknesses. The formula correlates 




r

n




{\displaystyle r_{n}}

, 




r

(
n
−
i
)




{\displaystyle r_{(n-i)}}

 and 




r

(
n
−
j
)




{\displaystyle r_{(n-j)}}

; these three numbers are not independent, as true random numbers would be. Anyone who observes 



i


{\displaystyle i}

 consecutive numbers can predict the next numbers, so the generator is not cryptographically secure. The authors of Freeciv (utility/rand.c) and xpat2 (src/testit2.c) knew another problem: the low bits are less random than the high bits.

The subtractive generator has a better reputation than the linear congruential generator, perhaps because it holds more state. A subtractive generator might never multiply numbers: this helps where multiplication is slow. A subtractive generator might also avoid division: the value of 




r

(
n
−
i
)


−

r

(
n
−
j
)




{\displaystyle r_{(n-i)}-r_{(n-j)}}

 is always between 



−
m


{\displaystyle -m}

 and 



m


{\displaystyle m}

, so a program only needs to add 



m


{\displaystyle m}

 to negative numbers.

The choice of 



i


{\displaystyle i}

 and 



j


{\displaystyle j}

 affects the period of the generator. A popular choice is 



i
=
55


{\displaystyle i=55}

 and 



j
=
24


{\displaystyle j=24}

, so the formula is

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {m}}}


The subtractive generator from xpat2 uses

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod


10

9


)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {10^{9}}}}


The implementation is by J. Bentley and comes from program_tools/universal.c of the DIMACS (netflow) archive at Rutgers University. It credits Knuth, TAOCP, Volume 2, Section 3.2.2 (Algorithm A).

Bentley uses this clever algorithm to seed the generator.

 Start with a single 



s
e
e
d


{\displaystyle seed}

 in range 



0


{\displaystyle 0}

 to 




10

9


−
1


{\displaystyle 10^{9}-1}

.
 Set 




s

0


=
s
e
e
d


{\displaystyle s_{0}=seed}

 and 




s

1


=
1


{\displaystyle s_{1}=1}

. The inclusion of 




s

1


=
1


{\displaystyle s_{1}=1}

 avoids some bad states (like all zeros, or all multiples of 10).
 Compute 




s

2


,

s

3


,
.
.
.
,

s

54




{\displaystyle s_{2},s_{3},...,s_{54}}

 using the subtractive formula 




s

n


=

s

(
n
−
2
)


−

s

(
n
−
1
)




(
mod


10

9


)



{\displaystyle s_{n}=s_{(n-2)}-s_{(n-1)}{\pmod {10^{9}}}}

.
 Reorder these 55 values so 




r

0


=

s

34




{\displaystyle r_{0}=s_{34}}

, 




r

1


=

s

13




{\displaystyle r_{1}=s_{13}}

, 




r

2


=

s

47




{\displaystyle r_{2}=s_{47}}

, ..., 




r

n


=

s

(
34
∗
(
n
+
1
)


(
mod

55
)

)




{\displaystyle r_{n}=s_{(34*(n+1){\pmod {55}})}}

.
 This is the same order as 




s

0


=

r

54




{\displaystyle s_{0}=r_{54}}

, 




s

1


=

r

33




{\displaystyle s_{1}=r_{33}}

, 




s

2


=

r

12




{\displaystyle s_{2}=r_{12}}

, ..., 




s

n


=

r

(
(
34
∗
n
)
−
1


(
mod

55
)

)




{\displaystyle s_{n}=r_{((34*n)-1{\pmod {55}})}}

.
 This rearrangement exploits how 34 and 55 are relatively prime.
 Compute the next 165 values 




r

55




{\displaystyle r_{55}}

 to 




r

219




{\displaystyle r_{219}}

. Store the last 55 values.
This generator yields the sequence 




r

220




{\displaystyle r_{220}}

, 




r

221




{\displaystyle r_{221}}

, 




r

222




{\displaystyle r_{222}}

 and so on. For example, if the seed is 292929, then the sequence begins with 




r

220


=
467478574


{\displaystyle r_{220}=467478574}

, 




r

221


=
512932792


{\displaystyle r_{221}=512932792}

, 




r

222


=
539453717


{\displaystyle r_{222}=539453717}

. By starting at 




r

220




{\displaystyle r_{220}}

, this generator avoids a bias from the first numbers of the sequence. This generator must store the last 55 numbers of the sequence, so to compute the next 




r

n




{\displaystyle r_{n}}

. Any array or list would work; a ring buffer is ideal but not necessary.

Implement a subtractive generator that replicates the sequences from xpat2.



",Python,"# version 1.1.51
 
MOD = 1_000_000_000
 
state = [0] * 55
si = 0
sj = 0
 
def subrandSeed(p):
    global state, si, sj
    p1 = p
    p2 = 1
    state[0] = p1 % MOD
    j = 21
    for i in range(1, 55):
        if j >= 55:
            j -= 55
        state[j] = p2
        p2 = p1 - p2
        if p2 < 0:
            p2 += MOD
        p1 = state[j]
        j += 21
    si = 0
    sj = 24
    for _ in range(165):
        subrand()
 
def subrand():
    global state, si, sj
    if si == sj:
        subrandSeed(0)
    si -= 1
    if si == 0:
        si = 54
    sj -= 1
    if sj == 0:
        sj = 54
    x = state[si] - state[sj]
    if x < 0:
        x += MOD
    state[si] = x
    return x
 
subrandSeed(292_929)
for i in range(10):
    print(f""r[{i + 220}] = {subrand()}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Nth_root,Nth root,"Task

Implement the algorithm to compute the principal   nth   root   





A

n





{\displaystyle {\sqrt[{n}]{A}}}

   of a positive real number   A,   as explained at the   Wikipedia page.


",Python,"from math import pow
from sys import float_info
 
def pow_(x, e):
    r = 1
    for i in range(e):
        r *= x
    return r
 
def root(n, x):
    d = 0
    r = 1
    if not x:
        return 0
    if n < 1 or (x < 0 and not (n&1)):
        return 0.0 / 0.0
    while True:
        d = (x / pow_(r, n - 1) - r) / n
        r += d
        if d >= float_info.epsilon * 10 or d <= -float_info.epsilon * 10:
            break
    return r
 
if __name__ == ""__main__"":
    n = 15
    x = pow(-3.14159, 15)
    print(""root(%d, %g) = %g"" % (n, x, root(n, x)))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import string
import itertools
 
lower = string.ascii_lowercase",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sort_stability,Sort stability,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


When sorting records in a table by a particular column or field, a stable sort will always retain the relative order of records that have the same key.



Example

In this table of countries and cities, a stable sort on the second column, the cities, would keep the   US Birmingham   above the   UK Birmingham.

(Although an unstable sort might, in this case, place the   US Birmingham   above the   UK Birmingham,   a stable sort routine would guarantee it).

UK  London
US  New York
US  Birmingham
UK  Birmingham

Similarly, stable sorting on just the first column would generate UK London as the first item and US Birmingham as the last item   (since the order of the elements having the same first word –   UK or US   – would be maintained).



Task

   Examine the documentation on any in-built sort routines supplied by a language.
   Indicate if an in-built routine is supplied
   If supplied, indicate whether or not the in-built routine is stable.


(This Wikipedia table shows the stability of some common sort routines).



",Python,"# First, define a bernoulli sample, of length 26.
x <- sample(c(0, 1), 26, replace=T)
 
x
# [1] 1 1 1 1 0 1 1 0 1 0 1 1 1 0 1 1 0 1 0 1 0 1 1 0 1 0
 
# Give names to the entries. ""letters"" is a builtin value
names(x) <- letters
 
x
# a b c d e f g h i j k l m n o p q r s t u v w x y z
# 1 1 1 1 0 1 1 0 1 0 1 1 1 0 1 1 0 1 0 1 0 1 1 0 1 0
 
# The unstable one, see how ""a"" appears after ""l"" now
sort(x, method=""quick"")
# z h s u e q x n j r t v w y p o m l a i g f d c b k
# 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 
# The stable sort, letters are ordered in each section
sort(x, method=""shell"")
# e h j n q s u x z a b c d f g i k l m o p r t v w y
# 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"import os

os.popen(""lpr"", ""w"").write(""Hello World!"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Scope/Function_names_and_labels,Scope/Function names and labels,"Task

Explain or demonstrate the levels of visibility of function names and labels within the language.



See also

 Variables for levels of scope relating to visibility of program variables
 Scope modifiers for general scope modification facilities

",Python,"import ex
import sys
import inspect
import types
import runtime

def main():
    # func nested() {... not allowed here
    # this is okay, variable f declared and assigned a function literal.
    f = lambda: None
    f = types.FunctionType(f.__code__, f.__globals__, name=f.__name__, argdefs=f.__defaults__, closure=f.__closure__)
    # this mess prints the name of the function to show that it's an
    # anonymous function defined in package main
    pc, _, _, _ = runtime.Caller(0)
    print(runtime.FuncForPC(pc).Name(), ""here!"")
    ex.X(f) # function value passed to exported function
    # ex.x() non-exported function not visible here

if __name__ == ""__main__"":
    sys.exit(main())",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",Python,"import re
 
string = ""This is a string""
 
if re.search('string$', string):
    print(""Ends with string."")
 
string = re.sub("" a "", "" another "", string)
print(string)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Knight%27s_tour,Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"from itertools import product
 
class Square:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
    def __repr__(self):
        return ""Square({}, {})"".format(self.x, self.y)
 
board = [Square(x, y) for x, y in product(range(1, 9), range(1, 9))]
axis_moves = [1, 2, -1, -2]
 
def all_pairs(a):
    return [(i, j) for i in a for j in a]
 
def knight_moves(s):
    moves = [m for m in all_pairs(axis_moves) if abs(m[0])!= abs(m[1])]
    return [Square(s.x + m[0], s.y + m[1]) for m in moves if Square(s.x + m[0], s.y + m[1]) in board]
 
def knight_tour(moves):
    def find_moves(s):
        return [m for m in knight_moves(s) if m not in moves]
    new_square = min(find_moves(moves[-1]), key=lambda s: len(find_moves(s)))
    return moves if new_square is None else knight_tour(moves + [new_square])
 
def knight_tour_from(start):
    return knight_tour([start])
 
def main():
    for x, y in knight_tour_from(Square(1, 1)):
        print(""{},{}"".format(x, y), end="" "" if x % 8!= 0 else ""\n"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Vogel%27s_approximation_method,Vogel's approximation method,"Vogel's Approximation Method (VAM) is a technique for finding a good initial feasible solution to an allocation problem.

The powers that be have identified 5 tasks that need to be solved urgently. Being imaginative chaps, they have called them “A”, “B”, “C”, “D”, and “E”. They estimate that:

 A will require 30 hours of work,
 B will require 20 hours of work,
 C will require 70 hours of work,
 D will require 30 hours of work, and
 E will require 60 hours of work.
They have identified 4 contractors willing to do the work, called “W”, “X”, “Y”, and “Z”.

 W has 50 hours available to commit to working,
 X has 60 hours available,
 Y has 50 hours available, and
 Z has 50 hours available.
The cost per hour for each contractor for each task is summarized by the following table:

   A  B  C  D  E
W 16 16 13 22 17
X 14 14 13 19 15
Y 19 19 20 23 50
Z 50 12 50 15 11

The task is to use VAM to allocate contractors to tasks. It scales to large problems, so ideally keep sorts out of the iterative cycle. It works as follows:

Step 1: Balance the given transportation problem if either (total supply>total demand) or (total supply<total demand)
Step 2: Determine the penalty cost for each row and column by subtracting the lowest cell cost in the row or column from the next lowest cell cost in the same row or column.
Step 3: Select the row or column with the highest penalty cost (breaking ties arbitrarily or choosing the lowest-cost cell).
Step 4: Allocate as much as possible to the feasible cell with the lowest transportation cost in the row or column with the highest penalty cost.
Step 5: Repeat steps 2, 3 and 4 until all requirements have been meet.
Step 6: Compute total transportation cost for the feasible allocations.
For this task assume that the model is balanced.

For each task and contractor (row and column above) calculating the difference between the smallest two values produces:

        A       B       C       D       E       W       X       Y       Z
1       2       2       0       4       4       3       1       0       1   E-Z(50)

Determine the largest difference (D or E above). In the case of ties I shall choose the one with the lowest price (in this case E because the lowest price for D is Z=15, whereas for E it is Z=11). For your choice determine the minimum cost (chosen E above so Z=11 is chosen now). Allocate as much as possible from Z to E (50 in this case limited by Z's supply).
Adjust the supply and demand accordingly. If demand or supply becomes 0 for a given task or contractor it plays no further part. In this case Z is out of it. If you choose arbitrarily, and chose D see here for the working.

Repeat until all supply and demand is met:

2       2       2       0       3       2       3       1       0       -   C-W(50)
3       5       5       7       4      35       -       1       0       -   E-X(10)
4       5       5       7       4       -       -       1       0       -   C-X(20)
5       5       5       -       4       -       -       0       0       -   A-X(30)
6       -      19       -      23       -       -       -       4       -   D-Y(30)
        -       -       -       -       -       -       -       -       -   B-Y(20)

Finally calculate the cost of your solution. In the example given it is £3100:

   A  B  C  D  E
W       50
X 30    20    10
Y    20    30
Z             50

The optimal solution determined by GLPK is £3100:

   A  B  C  D  E
W       50
X 10 20 20    10
Y 20       30
Z             50

Cf.
 Transportation problem",Python,"# version 1.1.3
 
supply = [50, 60, 50, 50]
demand = [30, 20, 70, 30, 60]
 
costs = [
    [16, 16, 13, 22, 17],
    [14, 14, 13, 19, 15],
    [19, 19, 20, 23, 50],
    [50, 12, 50, 15, 11]
]
 
nRows = len(supply)
nCols = len(demand)
 
rowDone = [False] * nRows
colDone = [False] * nCols
results = [[0] * nCols for _ in range(nRows)]
 
def nextCell():
    res1 = maxPenalty(nRows, nCols, True)
    res2 = maxPenalty(nCols, nRows, False)
    if res1[3] == res2[3]:
        return res1 if res1[2] < res2[2] else res2
    return res2 if res1[3] > res2[3] else res1
 
def diff(j, len, isRow):
    min1 = min2 = 1000000
    minP = -1
    for i in range(len):
        done = colDone[i] if isRow else rowDone[i]
        if done: continue
        c = costs[j][i] if isRow else costs[i][j]
        if c < min1:
            min2 = min1
            min1 = c
            minP = i
        elif c < min2:
            min2 = c
    return [min2 - min1, min1, minP]
 
def maxPenalty(len1, len2, isRow):
    md = -1000000
    pc = pm = mc = -1
    for i in range(len1):
        done = rowDone[i] if isRow else colDone[i]
        if done: continue
        res = diff(i, len2, isRow)
        if res[0] > md:
            md = res[0]  # max diff
            pm = i       # pos of max diff
            mc = res[1]  # min cost
            pc = res[2]  # pos of min cost
    return [pm, pc, mc, md] if isRow else [pc, pm, mc, md]
 
supplyLeft = sum(supply)
totalCost = 0
while supplyLeft > 0:
    cell = nextCell()
    r = cell[0]
    c = cell[1]
    q = min(demand[c], supply[r])
    demand[c] -= q
    if demand[c] == 0: colDone[c] = True
    supply[r] -= q
    if supply[r] == 0: rowDone[r] = True
    results[r][c] = q
    supplyLeft -= q
    totalCost += q * costs[r][c]
 
print(""    A   B   C   D   E"")
for i, result in enumerate(results):
    print(chr(ord('W') + i), end='')
    for item in result: print(""  %2d"" % item, end='')
    print()
print(""\nTotal Cost = %d"" % totalCost)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",Python,">>> def maprange( a, b, s):
	(a1, a2), (b1, b2) = a, b
	return  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))
 
>>> for s in range(11):
	print(""%2g maps to %g"" % (s, maprange( (0, 10), (-1, 0), s)))
 
 
 0 maps to -1
 1 maps to -0.9
 2 maps to -0.8
 3 maps to -0.7
 4 maps to -0.6
 5 maps to -0.5
 6 maps to -0.4
 7 maps to -0.3
 8 maps to -0.2
 9 maps to -0.1
10 maps to 0",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/EKG_sequence_convergence,EKG sequence convergence,"The sequence is from the natural numbers and is defined by:

 a(1) = 1; 
 a(2) = Start = 2;
 for n > 2, a(n) shares at least one prime factor with a(n-1) and is the smallest such natural number not already used.

The sequence is called the EKG sequence (after its visual similarity to an electrocardiogram when graphed).

Variants of the sequence can be generated starting 1, N where N is any natural number larger than one. For the purposes of this task let us call:

 The sequence described above , starting 1, 2, ... the EKG(2) sequence;
 the sequence starting 1, 3, ... the EKG(3) sequence; 
 ... the sequence starting 1, N, ... the EKG(N) sequence.


Convergence
If an algorithm that keeps track of the minimum amount of numbers and their corresponding prime factors used to generate the next term is used, then this may be known as the generators essential state. Two EKG generators with differing starts can converge to produce the same sequence after initial differences.

EKG(N1) and EKG(N2) are said to to have converged at and after generation a(c) if state_of(EKG(N1).a(c)) == state_of(EKG(N2).a(c)).



Task

 Calculate and show here the first 10 members of EKG(2).
 Calculate and show here the first 10 members of EKG(5).
 Calculate and show here the first 10 members of EKG(7).
 Calculate and show here the first 10 members of EKG(9).
 Calculate and show here the first 10 members of EKG(10).
 Calculate and show here at which term EKG(5) and EKG(7) converge   (stretch goal).
Related Tasks

 Greatest common divisor
 Sieve of Eratosthenes


Reference

 The EKG Sequence and the Tree of Numbers. (Video).

",Python,"import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
 
public class EKGSequenceConvergence {
 
    public static void main(String[] args) {
        System.out.println(""Calculate and show here the first 10 members of EKG[2], EKG[5], EKG[7], EKG[9] and EKG[10]."");
        for ( int i : new int[] {2, 5, 7, 9, 10} ) {
            System.out.printf(""EKG[%d] = %s%n"", i, ekg(i, 10));
        }
        System.out.println(""Calculate and show here at which term EKG[5] and EKG[7] converge."");
        List<Integer> ekg5 = ekg(5, 100);
        List<Integer> ekg7 = ekg(7, 100);
        for ( int i = 1 ; i < ekg5.size() ; i++ ) {
            if ( ekg5.get(i) == ekg7.get(i) && sameSeq(ekg5, ekg7, i)) {
                System.out.printf(""EKG[%d](%d) = EKG[%d](%d) = %d, and are identical from this term on%n"", 5, i+1, 7, i+1, ekg5.get(i));
                break;
            }
        }
    }
 
    #  Same last element, and all elements in sequence are identical
    def sameSeq(seq1, seq2, n):
        list1 = sorted(seq1[:n])
        list2 = sorted(seq2[:n])
        for i in range(n):
            if list1[i]!= list2[i]:
                return False
        return True
 
    #  Without HashMap to identify seen terms, need to examine list.
    #    Calculating 3000 terms in this manner takes 10 seconds
    #  With HashMap to identify the seen terms, calculating 3000 terms takes.1 sec.
    def ekg(two, maxN):
        result = [1, two]
        seen = {1:1, two:1}
        minUnseen = two == 2 and 3 or 2
        prev = two
        for n in range(3, maxN+1):
            test = minUnseen - 1
            while True:
                test += 1
                if test not in seen and gcd(test, prev) > 1:
                    result.append(test)
                    seen[test] = n
                    prev = test
                    if minUnseen == test:
                        while minUnseen in seen:
                            minUnseen += 1
                    break
        return result
 
    def gcd(a, b):
        if b == 0:
            return a
        return gcd(b, a%b)
 
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Halt_and_catch_fire,Halt and catch fire,"Task
Create a program that crashes as soon as possible, with as few lines of code as possible. Be smart and don't damage your computer, ok?

The code should be syntactically valid. It should be possible to insert [a subset of] your submission into another program, presumably to help debug it, or perhaps for use when an internal corruption has been detected and it would be dangerous and irresponsible to continue.

References
 Wikipedia: Halt and Catch Fire


Related Tasks
 Program termination

",Python,"raise ImportError(""Error: "" + message)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",Python,"#!/usr/bin/env python
# -*- coding: latin-1 -*-
 
u = 'abcdé'
print(ord(u[-1]))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Base64_decode_data,Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",Python,"import base64
data = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g='
print(base64.b64decode(data).decode('utf-8'))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Department_numbers,Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",Python,"from itertools import permutations
 
def solve():
    c, p, f, s = ""\\,Police,Fire,Sanitation"".split(',')
    print(f""{c:>3}  {p:^6} {f:^4} {s:^10}"")
    c = 1
    for p, f, s in permutations(range(1, 8), r=3):
        if p + s + f == 12 and p % 2 == 0:
            print(f""{c:>3}: {p:^6} {f:^4} {s:^10}"")
            c += 1
 
if __name__ == '__main__':
    solve()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Esthetic_numbers,Esthetic numbers,"An esthetic number is a positive integer where every adjacent digit differs from its neighbour by 1.



E.G.
 12 is an esthetic number. One and two differ by 1.
 5654 is an esthetic number. Each digit is exactly 1 away from its neighbour.
 890 is not an esthetic number. Nine and zero differ by 9.


These examples are nominally in base 10 but the concept extends easily to numbers in other bases. Traditionally, single digit numbers are included in esthetic numbers; zero may or may not be. For our purposes, for this task, do not include zero (0) as an esthetic number. Do not include numbers with leading zeros.

Esthetic numbers are also sometimes referred to as stepping numbers.



Task
 Write a routine (function, procedure, whatever) to find esthetic numbers in a given base.
 Use that routine to find esthetic numbers in bases 2 through 16 and display, here on this page, the esthectic numbers from index (base × 4) through index (base × 6), inclusive. (E.G. for base 2: 8th through 12th, for base 6: 24th through 36th, etc.)
 Find and display, here on this page, the base 10 esthetic numbers with a magnitude between 1000 and 9999.
 Stretch: Find and display, here on this page, the base 10 esthetic numbers with a magnitude between 1.0e8 and 1.3e8.


Related task

   numbers with equal rises and falls


See also

OEIS A033075 - Positive numbers n such that all pairs of consecutive decimal digits differ by 1
Numbers Aplenty - Esthetic numbers
Geeks for Geeks - Stepping numbers

",Python,"from collections import deque
from itertools import dropwhile, islice, takewhile
from textwrap import wrap
from typing import Iterable, Iterator
 
 
Digits = str  # Alias for the return type of to_digits()
 
 
def esthetic_nums(base: int) -> Iterator[int]:
    """"""Generate the esthetic number sequence for a given base
 
    >>> list(islice(esthetic_nums(base=10), 20))
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21, 23, 32, 34, 43, 45, 54, 56, 65]
    """"""
    queue: deque[tuple[int, int]] = deque()
    queue.extendleft((d, d) for d in range(1, base))
    while True:
        num, lsd = queue.pop()
        yield num
        new_lsds = (d for d in (lsd - 1, lsd + 1) if 0 <= d < base)
        num *= base  # Shift num left one digit
        queue.extendleft((num + d, d) for d in new_lsds)
 
 
def to_digits(num: int, base: int) -> Digits:
    """"""Return a representation of an integer as digits in a given base
 
    >>> to_digits(0x3def84f0ce, base=16)
    '3def84f0ce'
    """"""
    digits: list[str] = []
    while num:
        num, d = divmod(num, base)
        digits.append(""0123456789abcdef""[d])
    return """".join(reversed(digits)) if digits else ""0""
 
 
def pprint_it(it: Iterable[str], indent: int = 4, width: int = 80) -> None:
    """"""Pretty print an iterable which returns strings
 
    >>> pprint_it(map(str, range(20)), indent=0, width=40)
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
    12, 13, 14, 15, 16, 17, 18, 19
    <BLANKLINE>
    """"""
    joined = "", "".join(it)
    lines = wrap(joined, width=width - indent)
    for line in lines:
        print(f""{indent*' '}{line}"")
    print()
 
 
def task_2() -> None:
    nums: Iterator[int]
    for base in range(2, 16 + 1):
        start, stop = 4 * base, 6 * base
        nums = esthetic_nums(base)
        nums = islice(nums, start - 1, stop)  # start and stop are 1-based indices
        print(
            f""Base-{base} esthetic numbers from ""
            f""index {start} through index {stop} inclusive:\n""
        )
        pprint_it(to_digits(num, base) for num in nums)
 
 
def task_3(lower: int, upper: int, base: int = 10) -> None:
    nums: Iterator[int] = esthetic_nums(base)
    nums = dropwhile(lambda num: num < lower, nums)
    nums = takewhile(lambda num: num <= upper, nums)
    print(
        f""Base-{base} esthetic numbers with ""
        f""magnitude between {lower:,} and {upper:,}:\n""
    )
    pprint_it(to_digits(num, base) for num in nums)
 
 
if __name__ == ""__main__"":
    print(""======\nTask 2\n======\n"")
    task_2()
 
    print(""======\nTask 3\n======\n"")
    task_3(1_000, 9_999)
 
    print(""======\nTask 4\n======\n"")
    task_3(100_000_000, 130_000_000)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Bitwise_operations,Bitwise operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.



",Python,"def bitwise_built_ins(width, a, b):
    mask = (1 << width) - 1
    print(f""""""\
    AND:     0b{a :0{width}b} 
           & 0b{b :0{width}b} 
           = 0b{(a & b) & mask :0{width}b}
 
    OR:      0b{a :0{width}b} 
           | 0b{b :0{width}b} 
           = 0b{(a | b) & mask :0{width}b}
 
    XOR:     0b{a :0{width}b} 
           ^ 0b{b :0{width}b} 
           = 0b{(a ^ b) & mask :0{width}b}
 
    NOT:   ~ 0b{a :0{width}b} 
           = 0b{(~a) & mask :0{width}b}
 
    SHIFTS
 
      RIGHT:   0b{a :0{width}b} >> 1
             = 0b{(a >> 1) & mask :0{width}b}      
 
      LEFT:    0b{a :0{width}b} << 1
             = 0b{(a << 1) & mask :0{width}b}      
"""""")
 
def rotr(width, a, n):
    ""Rotate a, n times to the right""
    if n < 0:
        return rotl(width, a, -n)
    elif n == 0:
        return a
    else:
        mask = (1 << width) - 1
        a, n = a & mask, n % width
        return ((a >> n)    # top moved down
                | ((a & ((1 << n) - 1))   # Bottom masked...
                   << (width - n)))  # ... then moved up    
 
def rotl(width, a, n):
    ""Rotate a, n times to the left""
    if n < 0:
        return rotr(width, a, -n)
    elif n == 0:
        return a
    else:
        mask = (1 << width) - 1
        a, n = a & mask, n % width
        return (((a << n) & mask)      # bottom shifted up and masked
                | (a >> (width - n)))  # Top moved down  
 
def asr(width, a, n):
    ""Arithmetic shift a, n times to the right. (sign preserving).""
    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)
    if n < 0:
        return  (a << -n) & mask
    elif n == 0:
        return a
    elif n >= width:
        return mask if a & top_bit_mask else 0
    else:
        a = a & mask
        if a & top_bit_mask:    # Sign bit set?
            signs = (1 << n) - 1
            return a >> n | (signs << width - n)
        else:
            return a >> n
 
 
def helper_funcs(width, a):
    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)
    aa = a | top_bit_mask  # a with top bit set
    print(f""""""\
    ROTATIONS
 
      RIGHT:   rotr({width}, 0b{a :0{width}b}, 1)
               =       0b{rotr(width, a, 1) :0{width}b}      
               rotr({width}, 0b{a :0{width}b}, 2)
               =       0b{rotr(width, a, 2) :0{width}b}      
               rotr({width}, 0b{a :0{width}b}, 4)
               =       0b{rotr(width, a, 4) :0{width}b}      
 
      LEFT:    rotl({width}, 0b{a :0{width}b}, 1)
               =       0b{rotl(width, a, 1) :0{width}b}      
               rotl({width}, 0b{a :0{width}b}, 2)
               =       0b{rotl(width, a, 2) :0{width}b}      
               rotl({width}, 0b{a :0{width}b}, 4)
               =       0b{rotl(width, a, 4) :0{width}b}    
 
    SIGN-EXTENDING ARITHMETIC SHIFT RIGHT
 
               asr({width}, 0b{a :0{width}b}, 1)
               =      0b{asr(width, a, 1) :0{width}b}      
               asr({width}, 0b{aa :0{width}b}, 1)
               =      0b{asr(width, aa, 1) :0{width}b}      
               asr({width}, 0b{a :0{width}b}, 2)
               =      0b{asr(width, a, 2) :0{width}b}      
               asr({width}, 0b{aa :0{width}b}, 2)
               =      0b{asr(width, aa, 2) :0{width}b}      
               asr({width}, 0b{a :0{width}b}, 4)
               =      0b{asr(width, a, 4) :0{width}b} 
               asr({width}, 0b{aa :0{width}b}, 4)
               =      0b{asr(width, aa, 4) :0{width}b} 
"""""")
 
if __name__ == '__main__':
    bitwise_built_ins(8, 27, 125)
    helper_funcs(8, 27)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Find_palindromic_numbers_in_both_binary_and_ternary_bases,Find palindromic numbers in both binary and ternary bases,"Find palindromic numbers in both binary and ternary bases

You are encouraged to solve this task according to the task description, using any language you may know.
Task

   Find and show (in decimal) the first six numbers (non-negative integers) that are   palindromes   in   both:
   base 2
   base 3
   Display   0   (zero) as the first number found, even though some other definitions ignore it.
   Optionally, show the decimal number found in its binary and ternary form.
   Show all output here.


It's permissible to assume the first two numbers and simply list them.



See also
   Sequence A60792,   numbers that are palindromic in bases 2 and 3 on The On-Line Encyclopedia of Integer Sequences.

",Python,"from itertools import islice
 
digits = ""0123456789abcdefghijklmnopqrstuvwxyz""
 
def baseN(num,b):
  if num == 0: return ""0""
  result = """"
  while num != 0:
    num, d = divmod(num, b)
    result += digits[d]
  return result[::-1] # reverse
 
def pal2(num):
    if num == 0 or num == 1: return True
    based = bin(num)[2:]
    return based == based[::-1]
 
def pal_23():
    yield 0
    yield 1
    n = 1
    while True:
        n += 1
        b = baseN(n, 3)
        revb = b[::-1]
        #if len(b) > 12: break
        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),
                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):
            t = int(trial, 3)
            if pal2(t):
                yield t
 
for pal23 in islice(pal_23(), 6):
    print(pal23, baseN(pal23, 3), baseN(pal23, 2))",Human_written,Python_from_C
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"import bpy
 
# select default cube
bpy.data.objects['Cube'].select_set(True)
 
# delete default cube
bpy.ops.object.delete(True)
 
# add text to Blender scene  
bpy.data.curves.new(type=""FONT"", name=""Font Curve"").body = ""Hello World""
font_obj = bpy.data.objects.new(name=""Font Object"", object_data=bpy.data.curves[""Font Curve""])
bpy.context.scene.collection.objects.link(font_obj)
 
# camera center to text
bpy.context.scene.camera.location = (2.5,0.3,10)
 
# camera orient angle to text
bpy.context.scene.camera.rotation_euler = (0,0,0)
 
# change 3D scene to view from the camera
area = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')
area.spaces[0].region_3d.view_perspective = 'CAMERA'",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sierpinski_carpet,Sierpinski carpet,"Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N.



For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art.

The important requirement is the placement of whitespace and non-whitespace characters.



Related task

   Sierpinski triangle

",Python,"def in_carpet(x, y):
    while True:
        if x == 0 or y == 0:
            return True
        elif x % 3 == 1 and y % 3 == 1:
            return False
 
        x /= 3
        y /= 3
 
def carpet(n):
    for i in xrange(3 ** n):
        for j in xrange(3 ** n):
            if in_carpet(i, j):
                print '*',
            else:
                print ' ',
        print",Human_written,Python_from_Java
http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# From the standard library:
from string import ascii_lowercase
 
# Generation:
lower = [chr(i) for i in range(ord('a'), ord('z') + 1)]",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",Python,">>> def strcat(sequence):
    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1]
 
>>> for seq in ([], [""ABC""], [""ABC"", ""DEF""], [""ABC"", ""DEF"", ""G"", ""H""]):
    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))
 
 
Input: []                       -> Output: '{}'
Input: ['ABC']                  -> Output: '{ABC}'
Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'
Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Hash_from_two_arrays,Hash from two arrays,"Task

Using two Arrays of equal length, create a Hash object
where the elements from one array (the keys) are linked
to the elements of the other (the values)



Related task

   Associative arrays/Creation

",Python,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
#define KeyType const char *
#define ValType int
 
#define HASH_SIZE 4096
 
// hash function useful when KeyType is char * (string)
unsigned strhashkey( const char * key, int max)
{
    unsigned h=0;
    unsigned hl, hr;
 
    while(*key) {
        h += *key;
        hl= 0x5C5 ^ (h&0xfff00000 )>>18;
        hr =(h&0x000fffff );
        h = hl ^ hr ^ *key++;
    }
    return h % max;
}
 
typedef struct sHme {
    KeyType    key;
    ValType    value;
    struct sHme  *link;
} *MapEntry;
 
typedef struct he {
    MapEntry  first, last;
} HashElement;
 
HashElement hash[HASH_SIZE];
 
typedef void (*KeyCopyF)(KeyType *kdest, KeyType ksrc);
typedef void (*ValCopyF)(ValType *vdest, ValType vsrc);
typedef unsigned (*KeyHashF)( KeyType key, int upperBound );
typedef int (*KeyCmprF)(KeyType key1, KeyType key2);
 
void HashAddH( KeyType key, ValType value,
        KeyCopyF copyKey, ValCopyF copyVal, KeyHashF hashKey, KeyCmprF keySame )
{
    unsigned hix = (*hashKey)(key, HASH_SIZE);
    MapEntry m_ent;
 
    for (m_ent= hash[hix].first;
            m_ent &&!(*keySame)(m_ent->key,key); m_ent=m_ent->link);
    if (m_ent) {
        (*copyVal)(&m_ent->value, value);
    }
    else {
        MapEntry last;
        MapEntry hme = malloc(sizeof(struct sHme));
        (*copyKey)(&hme->key, key);
        (*copyVal)(&hme->value, value);
        hme->link = NULL;
        last = hash[hix].last;
        if (last) {
//	    printf(""Dup. hash key\n"");
            last->link = hme;
        }
        else
            hash[hix].first = hme;
        hash[hix].last = hme;
    }
}
 
int HashGetH(ValType *val, KeyType key, KeyHashF hashKey, KeyCmprF keySame )
{
    unsigned hix = (*hashKey)(key, HASH_SIZE);
    MapEntry m_ent;
    for (m_ent= hash[hix].first;
            m_ent &&!(*keySame)(m_ent->key,key); m_ent=m_ent->link);
    if (m_ent) {
        *val = m_ent->value;
    }
    return (m_ent!= NULL);
}
 
void copyStr(const char**dest, const char *src)
{
    *dest = strdup(src);
}
void copyInt( int *dest, int src)
{
    *dest = src;
}
int strCompare( const char *key1, const char *key2)
{
    return strcmp(key1, key2) == 0;
}
 
void HashAdd( KeyType key, ValType value )
{
    HashAddH( key, value, &copyStr, &copyInt, &strhashkey, &strCompare);
}
 
int HashGet(ValType *val, KeyType key)
{
    return HashGetH( val, key, &strhashkey, &strCompare);
}
 
int main() 
{
    static const char * keyList[] = {""red"",""orange"",""yellow"",""green"", ""blue"", ""violet"" };
    static int valuList[] = {1,43,640, 747, 42, 42};
    int ix;
 
    for (ix=0; ix<6; ix++) {
        HashAdd(keyList[ix], valuList[ix]);
    }
    return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Semiprime,Semiprime,"Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.


Semiprimes   are also known as:

   semi-primes
   biprimes
   bi-primes
    2-almost    primes
   or simply:    P2  


Example
 
   1679  =  23 × 73  

(This particular number was chosen as the length of the Arecibo message).



Task

Write a function determining whether a given number is semiprime.



See also

 The Wikipedia article:  semiprime.
 The Wikipedia article:  almost prime.
 The OEIS sequence:  A001358: semiprimes  which has a shorter definition: the product of two primes.

",Python,"import math
 
def is_prime(n):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True
 
def prime_factors(n):
    factors = []
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 2:
        factors.append(n)
    return factors
 
def semi_prime(n):
    return len(prime_factors(n)) == 2
 
print(semi_prime(1679))
print([i for i in range(1, 101) if semi_prime(i)])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Zig-zag_matrix,Zig-zag matrix,"Task

Produce a zig-zag array.



A   zig-zag   array is a square arrangement of the first   N2   natural numbers,   where the

numbers increase sequentially as you zig-zag along the array's   anti-diagonals.

For a graphical representation, see   JPG zigzag   (JPG uses such arrays to encode images).



For example, given   5,   produce this array:

 0  1  5  6 14
 2  4  7 13 15
 3  8 12 16 21
 9 11 17 20 22
10 18 19 23 24



Related tasks

   Spiral matrix
   Identity matrix
   Ulam spiral (for primes)


See also

   Wiktionary entry:   anti-diagonals

",Python,"from itertools import repeat
from typing import List
 
class SortIndex:
    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y
 
    def __lt__(self, other: 'SortIndex') -> bool:
        if self.x + self.y == other.x + other.y:
            if (self.x + self.y) % 2 == 0:
                return self.x < other.x
            else:
                return self.y < other.y
        else:
            return (self.x + self.y) < (other.x + other.y)
 
    def __eq__(self, other: 'SortIndex') -> bool:
        return self.x == other.x and self.y == other.y
 
def zigzag(n: int) -> List[List[int]]:
    l = [SortIndex(i % n, i // n) for i in range(n * n)]
    l.sort()
 
    result = [[0] * n for _ in repeat(None, n)]
    for i, SortIndex(x, y) in enumerate(l):
        result[y][x] = i
    return result
 
if __name__ == '__main__':
    print(zigzag(5))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"'''
Note that this code is broken, e.g., it won't work when 
blocks = [(""A"", ""B""), (""A"",""C"")] and the word is ""AB"", where the answer
should be True, but the code returns False.
'''
blocks = [(""B"", ""O""),
          (""X"", ""K""),
          (""D"", ""Q""),
          (""C"", ""P""),
          (""N"", ""A""),
          (""G"", ""T""),
          (""R"", ""E""),
          (""T"", ""G""),
          (""Q"", ""D""),
          (""F"", ""S""),
          (""J"", ""W""),
          (""H"", ""U""),
          (""V"", ""I""),
          (""A"", ""N""),
          (""O"", ""B""),
          (""E"", ""R""),
          (""F"", ""S""),
          (""L"", ""Y""),
          (""P"", ""C""),
          (""Z"", ""M"")]
 
 
def can_make_word(word, block_collection=blocks):
    """"""
    Return True if `word` can be made from the blocks in `block_collection`.
 
    >>> can_make_word("""")
    False
    >>> can_make_word(""a"")
    True
    >>> can_make_word(""bark"")
    True
    >>> can_make_word(""book"")
    False
    >>> can_make_word(""treat"")
    True
    >>> can_make_word(""common"")
    False
    >>> can_make_word(""squad"")
    True
    >>> can_make_word(""coNFused"")
    True
    """"""
    if not word:
        return False
 
    blocks_remaining = block_collection[:]
    for char in word.upper():
        for block in blocks_remaining:
            if char in block:
                blocks_remaining.remove(block)
                break
        else:
            return False
    return True
 
 
if __name__ == ""__main__"":
    import doctest
    doctest.testmod()
    print("", "".join(""'%s': %s"" % (w, can_make_word(w)) for w in
                    ["""", ""a"", ""baRk"", ""booK"", ""treat"", 
                     ""COMMON"", ""squad"", ""Confused""]))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"import bpy
 
# select default cube
bpy.data.objects['Cube'].select_set(True)
 
# delete default cube
bpy.ops.object.delete(True)
 
# add text to Blender scene  
bpy.data.curves.new(type=""FONT"", name=""Font Curve"").body = ""Hello World""
font_obj = bpy.data.objects.new(name=""Font Object"", object_data=bpy.data.curves[""Font Curve""])
bpy.context.scene.collection.objects.link(font_obj)
 
# camera center to text
bpy.context.scene.camera.location = (2.5,0.3,10)
 
# camera orient angle to text
bpy.context.scene.camera.rotation_euler = (0,0,0)
 
# change 3D scene to view from the camera
area = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')
area.spaces[0].region_3d.view_perspective = 'CAMERA'",Human_written,Python_from_C
http://rosettacode.org/wiki/Detect_division_by_zero,Detect division by zero,"Task

Write a function to detect a   divide by zero error   without checking if the denominator is zero.



",Python,"def test_division(numerator, denominator):
    result = numerator / denominator
    print(f""{numerator} / {denominator} = {result}"")

test_division(5, 4)
test_division(4, 0)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Guess_the_number/With_feedback,Guess the number/With feedback,"Task

Write a game (computer program) that follows the following rules:

 The computer chooses a number between given set limits.
 The player is asked for repeated guesses until the the target number is guessed correctly
 At each guess, the computer responds with whether the guess is:
 higher than the target,
 equal to the target, 
 less than the target,   or
 the input was inappropriate. 


Related task

   Guess the number/With Feedback (Player)

",Python,"import random
 
inclusive_range = (1, 100)
 
print(""Guess my target number that is between %i and %i (inclusive).\n""
      % inclusive_range)
target = random.randint(*inclusive_range)
answer, i = None, 0
while answer != target:
    i += 1
    txt = input(""Your guess(%i): "" % i)
    try:
        answer = int(txt)
    except ValueError:
        print(""  I don't understand your input of '%s' ?"" % txt)
        continue
    if answer < inclusive_range[0] or answer > inclusive_range[1]:
        print(""  Out of range!"")
        continue
    if answer == target:
        print(""  Ye-Haw!!"")
        break
    if answer < target: print(""  Too low."")
    if answer > target: print(""  Too high."")
 
print(""\nThanks for playing."")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/GUI_component_interaction,GUI component interaction,"

Almost every application needs to communicate with the user in some way.
Therefore, a substantial part of the code deals with the interaction
of program logic with GUI components.

Typically, the following is needed:

 put values into input fields under program control
 read and check input from the user
 pop up dialogs to query the user for further information


Task

For a minimal ""application"", write a program that presents a form with three components to the user:

 a numeric input field (""Value"") 
 a button (""increment"")
 a button (""random"")


The field is initialized to zero.

The user may manually enter a new value into the field,
or increment its value with the ""increment"" button.

Entering a non-numeric value should be either impossible,
or issue an error message.

Pressing the ""random"" button presents a confirmation dialog,
and resets the field's value to a random value if the answer is ""Yes"".

(This task may be regarded as an extension of the task Simple windowed application).


",Python,"import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
 
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
 
public class Interact extends JFrame:
	final JTextField numberField;
	final JButton incButton, randButton;
 
	public Interact():
		#stop the GUI threads when the user hits the X button
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
 
		numberField = new JTextField();
		incButton = new JButton(""Increment"");
		randButton = new JButton(""Random"");
 
		numberField.setText(""0"");#start at 0
 
		#listen for button presses in the text field
		numberField.addKeyListener(new KeyListener():
			@Override
			public void keyTyped(KeyEvent e):
				#if the entered character is not a digit
				if(!Character.isDigit(e.getKeyChar()):
					#eat the event (i.e. stop it from being processed)
					e.consume();
			@Override
			public void keyReleased(KeyEvent e):
			@Override
			public void keyPressed(KeyEvent e):
		);
 
		#listen for button clicks on the increment button
		incButton.addActionListener(new ActionListener():
			@Override
			public void actionPerformed(ActionEvent e):
				String text = numberField.getText();
				if(text.isEmpty():
					numberField.setText(""1"");
				else:
					numberField.setText((Long.valueOf(text) + 1) + """");
			:
		);
 
		#listen for button clicks on the random button
		randButton.addActionListener(new ActionListener():
			@Override
			public void actionPerformed(ActionEvent e):
				#show a dialog and if they answer ""Yes""
				if(JOptionPane.showConfirmDialog(null, ""Are you sure?"") ==
					JOptionPane.YES_OPTION):
					#set the text field text to a random positive long
					numberField.setText(Long.toString((long)(Math.random() 
							* Long.MAX_VALUE)));
			:
		);
 
		#arrange the components in a grid with 2 rows and 1 column
		setLayout(new GridLayout(2, 1));
 
		#a secondary panel for arranging both buttons in one grid space in the window
		JPanel buttonPanel = new JPanel();
 
		#the buttons are in a grid with 1 row and 2 columns
		buttonPanel.setLayout(new GridLayout(1, 2));
		#add the buttons
		buttonPanel.add(incButton);
		buttonPanel.add(randButton);
 
		#put the number field on top of the buttons
		add(numberField);
		add(buttonPanel);
		#size the window appropriately
		pack();
 
	:
 
	public static void main(String[] args):
		new Interact().setVisible(true);
	:",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Colour_pinstripe/Printer,Colour pinstripe/Printer,"The task is to create 1 point wide colour vertical pinstripes with a sufficient number of pinstripes to span the entire width of the colour graphics printer. The pinstripes should alternate between each individual cartridge ink and ink pair and black and white pinstripes should be included. A typical pinstripe sequence woud be black, red, green, blue, magenta, cyan, yellow, white.

After the first inch of printing, we switch to a wider 2 pixel wide vertical pinstripe pattern. and to 3 point wide vertical for the next inch, and then 4 point wide, etc. This trend continues for the entire length of the page (or for 12 inches of run length in the case of a printer using continuous roll stationery). After printing the test pattern the page is ejected (or the test pattern is rolled clear of the printer enclosure, in the case of continuous roll printers).

Note that it is an acceptable solution to use the smallest marks that the language provides, rather than working at native printer resolution, where this is not achievable from within the language.

Optionally, on systems where the printer resolution cannot be determined, it is permissible to prompt the user for printer resolution, and to calculate point size based on user input, enabling fractional point sizes to be used.
",Python,"import os
import subprocess
import sys
from PIL import Image, ImageDraw
 
palette = [
    ""000000"", # black
    ""FF0000"", # red
    ""00FF00"", # green
    ""0000FF"", # blue
    ""FF00FF"", # magenta
    ""00FFFF"", # cyan
    ""FFFF00"", # yellow
    ""FFFFFF"", # white
]
 
def pinstripe(dc):
    w, h = dc.size
    h = h // 7
    for b in range(1, 12):
        for x, ci in zip(range(0, w, b), range(0, w, b)):
            dc.rectangle((x, h * (b - 1), x + b, h * b), fill=palette[ci % 8])
 
if __name__ == ""__main__"":
    dc = Image.new(""RGB"", (842, 595))
    pinstripe(dc)
    fileName = ""color_pinstripe.png""
    dc.save(fileName)
    if sys.platform == ""win32"":
        subprocess.call([""mspaint"", ""/pt"", fileName])
    else:
        subprocess.call([""lp"", fileName])",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Knapsack_problem/Bounded,Knapsack problem/Bounded,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature.   So he needs some items during the trip.   Food, clothing, etc.   He has a good knapsack for carrying the things, but he knows that he can carry only 4 kg weight in his knapsack, because they will make the trip from morning to evening.

He creates a list of what he wants to bring for the trip, but the total weight of all items is too much.   He adds a value to each item.   The value represents how important the thing for the tourist.

The list contains which items are the wanted things for the trip, what is the weight and value of an item, and how many units does he have from each items.



This is the list:


 Table of potential knapsack items


 item 
 weight (dag) (each) 
 value (each) 
 piece(s)


 map 
 9 
 150 
 1


 compass 
 13 
 35 
 1


 water 
 153 
 200 
 2


 sandwich 
 50 
 60 
 2


 glucose 
 15 
 60 
 2


 tin 
 68 
 45 
 3


 banana 
 27 
 60 
 3


 apple 
 39 
 40 
 3


 cheese 
 23 
 30 
 1


 beer 
 52 
 10 
 3


 suntan cream 
 11 
 70 
 1


 camera 
 32 
 30 
 1


 T-shirt 
 24 
 15 
 2


 trousers 
 48 
 10 
 2


 umbrella 
 73 
 40 
 1


 waterproof trousers 
 42 
 70 
 1


 waterproof overclothes 
 43 
 75 
 1


 note-case 
 22 
 80 
 1


 sunglasses 
 7 
 20 
 1


 towel 
 18 
 12 
 2


 socks 
 4 
 50 
 1


 book 
 30 
 10 
 2


 knapsack 
 ≤400 dag 
 ? 
 ?



The tourist can choose to take any combination of items from the list, and some number of each item is available   (see the column   piece(s)   in the list above).

He may not cut the items, so he can only take whole units of any item.



Task

Show which items does the tourist carry in his knapsack so that their total weight does not exceed 4 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   Knapsack problem/0-1

",Python,"from itertools import groupby
from collections import namedtuple
 
def anyvalidcomb(items, maxwt, val=0, wt=0):
    ' All combinations below the maxwt '
    if not items:
        yield [], val, wt
    else:
        this, *items = items            # car, cdr
        for n in range(this.number + 1):
            w = wt  + n * this.weight
            if w > maxwt:
                break
            v = val + n * this.value
            this_comb = [this] * n
            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):
                yield this_comb + comb, value, weight
 
maxwt = 400
COMB, VAL, WT = range(3)
Item  = namedtuple('Items', 'name weight value number')
items = [ Item(*x) for x in
          (
            (""map"", 9, 150, 1),
            (""compass"", 13, 35, 1),
            (""water"", 153, 200, 3),
            (""sandwich"", 50, 60, 2),
            (""glucose"", 15, 60, 2),
            (""tin"", 68, 45, 3),
            (""banana"", 27, 60, 3),
            (""apple"", 39, 40, 3),
            (""cheese"", 23, 30, 1),
            (""beer"", 52, 10, 3),
            (""suntan cream"", 11, 70, 1),
            (""camera"", 32, 30, 1),
            (""t-shirt"", 24, 15, 2),
            (""trousers"", 48, 10, 2),
            (""umbrella"", 73, 40, 1),
            (""waterproof trousers"", 42, 70, 1),
            (""waterproof overclothes"", 43, 75, 1),
            (""note-case"", 22, 80, 1),
            (""sunglasses"", 7, 20, 1),
            (""towel"", 18, 12, 2),
            (""socks"", 4, 50, 1),
            (""book"", 30, 10, 2),
           ) ]  
 
bagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal
print(""Bagged the following %i items"" % len(bagged[COMB]))
print('\n\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))
print(""for a total value of %i and a total weight of %i"" % bagged[1:])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Guess_the_number,Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",Python,"import random
import time
 
print(""Guess number from 1 to 10: "")
n = random.randint(1, 10)
while True:
    guess = int(input(""No. Try again: ""))
    if guess == n:
        print(""Well guessed!"")
        break",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",Python,"# Example serves as an example but does nothing useful.
#
# A package comment preceeds the package clause and explains the purpose
# of the package.

# Exported variables.
X, Y, Z = 0, 0, 0  # popular names

# XP does nothing.
#
# Here's a block comment.
def XP():  # here we go!
    # comments inside
    pass

# Non-exported.
def nonXP():
    pass

# Doc not extracted.

MEMEME = 0",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",Python,"def main():
    print(""Hello!"")

main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"import os
os.environ['HOME']",Human_written,Python_from_C
http://rosettacode.org/wiki/Base64_decode_data,Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",Python,"import base64
data = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g='
print(base64.b64decode(data).decode('utf-8'))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",Python,"class Delegator:
   def __init__(self):
      self.delegate = None
   def operation(self):
       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):
          return self.delegate.thing()
       return 'default implementation'
 
class Delegate:
   def thing(self):
      return 'delegate implementation'
 
if __name__ == '__main__':
 
   # No delegate
   a = Delegator()
   assert a.operation() == 'default implementation'
 
   # With a delegate that does not implement ""thing""
   a.delegate = 'A delegate may be any object'
   assert a.operation() == 'default implementation'
 
   # With delegate that implements ""thing""
   a.delegate = Delegate()
   assert a.operation() == 'delegate implementation'",Human_written,Python_from_C++
http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Python,"import itertools
 
def top_floor(permutation, person):
    return permutation.endswith(person)
 
def bottom_floor(permutation, person):
    return permutation.startswith(person)
 
def lives_above(permutation, upper_person, lower_person):
    return permutation.index(upper_person) > permutation.index(lower_person)
 
def adjacent(permutation, person1, person2):
    return abs(permutation.index(person1) - permutation.index(person2)) == 1
 
def is_possible(s):
    if top_floor(s, ""B""):
        return False
    if bottom_floor(s, ""C""):
        return False
    if top_floor(s, ""F"") or bottom_floor(s, ""F""):
        return False
    if not lives_above(s, ""M"", ""C""):
        return False
    if adjacent(s, ""S"", ""F""):
        return False
    return not adjacent(s, ""F"", ""C"")
 
def main():
    set = set()
    for permutation in itertools.permutations(""BCFMS""):
        if is_possible(permutation):
            set.add(permutation)
    for permutation in set:
        print(""Possible arrangement: "" + """".join(permutation))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Exceptions,Exceptions,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

This task is to give an example of an exception handling routine
and to ""throw"" a new exception.



Related task

   Exceptions Through Nested Calls

",Python,"import exceptions
class SillyError(exceptions.Exception):
    def __init__(self,args=None):
         self.args=args",Human_written,Python_from_Java
http://rosettacode.org/wiki/Brazilian_numbers,Brazilian numbers,"Brazilian numbers are so called as they were first formally presented at the 1994 math Olympiad Olimpiada Iberoamericana de Matematica in Fortaleza, Brazil.

Brazilian numbers are defined as:

The set of positive integer numbers where each number N has at least one natural number B where 1 < B < N-1 where the representation of N in base B has all equal digits.



E.G.

 1, 2 & 3 can not be Brazilian; there is no base B that satisfies the condition 1 < B < N-1.
 4 is not Brazilian; 4 in base 2 is 100. The digits are not all the same.
 5 is not Brazilian; 5 in base 2 is 101, in base 3 is 12. There is no representation where the digits are the same.
 6 is not Brazilian; 6 in base 2 is 110, in base 3 is 20, in base 4 is 12. There is no representation where the digits are the same.
 7 is Brazilian; 7 in base 2 is 111. There is at least one representation where the digits are all the same.
 8 is Brazilian; 8 in base 3 is 22. There is at least one representation where the digits are all the same.
 and so on...


All even integers 2P >= 8 are Brazilian because 2P = 2(P-1) + 2, which is 22 in base P-1 when P-1 > 2. That becomes true when P >= 4.

More common: for all all integers R and S, where R > 1 and also S-1 > R, then R*S is Brazilian because R*S = R(S-1) + R, which is RR in base S-1

The only problematic numbers are squares of primes, where R = S. Only 11^2 is brazilian to base 3.

All prime integers, that are brazilian, can only have the digit 1. Otherwise one could factor out the digit, therefore it cannot be a prime number. Mostly in form of 111 to base Integer(sqrt(prime number)). Must be an odd count of 1 to stay odd like primes > 2


Task

Write a routine (function, whatever) to determine if a number is Brazilian and use the routine to show here, on this page;

 the first 20 Brazilian numbers;
 the first 20 odd Brazilian numbers;
 the first 20 prime Brazilian numbers;


See also

 OEIS:A125134 - Brazilian numbers
 OEIS:A257521 - Odd Brazilian numbers
 OEIS:A085104 - Prime Brazilian numbers

",Python,"def same_digits(n, b):
    n2 = n
    f = n % b
    while True:
        n2 //= b
        if n2 > 0:
            if n2 % b!= f:
                return False
        else:
            break
    return True
 
def is_brazilian(n):
    if n < 7:
        return False
    if n % 2 == 0:
        return True
    for b in range(2, n - 1):
        if same_digits(n, b):
            return True
    return False
 
def is_prime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0:
            return False
        d += 2
        if n % d == 0:
            return False
        d += 4
    return True
 
def main():
    big_lim = 99999
    limit = 20
    for kind in "",odd,prime"".split(','):
        quiet = False
        print(""First %d %sBrazilian numbers:"" % (limit, kind))
        c = 0
        n = 7
        while c < big_lim:
            if is_brazilian(n):
                if not quiet:
                    print(""%d "" % n, end='')
                c += 1
                if c == limit:
                    print(""\n\n"")
                    quiet = True
            if quiet and kind!= """":
                continue
            if kind == """":
                n += 1
            elif kind == ""odd "":
                n += 2
            elif kind == ""prime"":
                while True:
                    n += 2
                    if is_prime(n):
                        break
        if kind == """":
            print(""The %,dth Brazilian number is: %,d"" % (big_lim + 1, n))
 
main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Department_numbers,Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",Python,"from itertools import permutations
 
def solve():
    c, p, f, s = ""\\,Police,Fire,Sanitation"".split(',')
    print(f""{c:>3}  {p:^6} {f:^4} {s:^10}"")
    c = 1
    for p, f, s in permutations(range(1, 8), r=3):
        if p + s + f == 12 and p % 2 == 0:
            print(f""{c:>3}: {p:^6} {f:^4} {s:^10}"")
            c += 1
 
if __name__ == '__main__':
    solve()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file,Bitmap/Write a PPM file,"Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered).

(Read the definition of PPM file on Wikipedia.)



",Python,"# String masquerading as ppm file (version P3)
import io
ppmfileout = io.StringIO('')
 
def writeppmp3(self, f):
    self.writeppm(f, ppmformat='P3')
 
def writeppm(self, f, ppmformat='P6'):
    assert ppmformat in ['P3', 'P6'], 'Format wrong'
    magic = ppmformat + '\n'
    comment = '# generated from Bitmap.writeppm\n'
    maxval = max(max(max(bit) for bit in row) for row in self.map)
    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'
    if ppmformat == 'P6':
        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))
        maxval = 255
    else:
        fwrite = f.write
        numsize=len(str(maxval))
    fwrite(magic)
    fwrite(comment)
    fwrite('%i %i\n%i\n' % (self.width, self.height, maxval))
    for h in range(self.height-1, -1, -1):
        for w in range(self.width):
            r, g, b = self.get(w, h)
            if ppmformat == 'P3':
                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))
            else:
                fwrite('%c%c%c' % (r, g, b))
        if ppmformat == 'P3':
            fwrite('\n')
 
Bitmap.writeppmp3 = writeppmp3
Bitmap.writeppm = writeppm
 
# Draw something simple
bitmap = Bitmap(4, 4, black)
bitmap.fillrect(1, 0, 1, 2, white)
bitmap.set(3, 3, Colour(127, 0, 63))
# Write to the open 'file' handle
bitmap.writeppmp3(ppmfileout)
# Whats in the generated PPM file
print(ppmfileout.getvalue())
 
'''
The print statement above produces the following output :
 
P3
# generated from Bitmap.writeppmp3
4 4
255
     0   0   0     0   0   0     0   0   0   127   0  63
     0   0   0     0   0   0     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
 
'''
 
# Write a P6 file
ppmfileout = open('tmp.ppm', 'wb')
bitmap.writeppm(ppmfileout)
ppmfileout.close()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Combinations_with_repetitions,Combinations with repetitions,"The set of combinations with repetitions is computed from a set, 



S


{\displaystyle S}

 (of cardinality 



n


{\displaystyle n}

), and a size of resulting selection, 



k


{\displaystyle k}

, by reporting the sets of cardinality 



k


{\displaystyle k}

 where each member of those sets is chosen from 



S


{\displaystyle S}

.
In the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.
For example:

Q: How many ways can a person choose two doughnuts from a store selling three types of doughnut: iced, jam, and plain? (i.e., 



S


{\displaystyle S}

 is 



{

i
c
e
d

,

j
a
m

,

p
l
a
i
n

}


{\displaystyle \{\mathrm {iced} ,\mathrm {jam} ,\mathrm {plain} \}}

, 




|

S

|

=
3


{\displaystyle |S|=3}

, and 



k
=
2


{\displaystyle k=2}

.)
A: 6: {iced, iced}; {iced, jam}; {iced, plain}; {jam, jam}; {jam, plain}; {plain, plain}.
Note that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.
Also note that doughnut can also be spelled donut.



Task

 Write a function/program/routine/.. to generate all the combinations with repetitions of 



n


{\displaystyle n}

 types of things taken 



k


{\displaystyle k}

 at a time and use it to show an answer to the doughnut example above.
 For extra credit, use the function to compute and show just the number of ways of choosing three doughnuts from a choice of ten types of doughnut. Do not show the individual choices for this part.


References

 k-combination with repetitions


See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"possible_doughnuts = ['iced', 'jam', 'plain'].repeated_combination(2)
print(""There are {0} possible doughnuts:"".format(len(possible_doughnuts)))
for doughnut_combi in possible_doughnuts:
    print("" "".join(doughnut_combi))
 
# Extra credit
possible_doughnuts = list(itertools.combinations(range(1, 1001), 30))
# size returns the size of the enumerator, or nil if it can’t be calculated lazily.
print(""\n{0} ways to order 30 donuts given 1000 types."".format(len(possible_doughnuts)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",Python,"MAX = 120
 
def IsPrime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0:
            return False
        d += 2
        if n % d == 0:
            return False
        d += 4
    return True
 
def PrimeFactorCount(n):
    if n == 1:
        return 0
    if IsPrime(n):
        return 1
    count = 0
    f = 2
    while True:
        if n % f == 0:
            count += 1
            n //= f
            if n == 1:
                return count
            if IsPrime(n):
                f = n
        elif f >= 3:
            f += 2
        else:
            f = 3
 
print(""The attractive numbers up to and including {0} are:"".format(MAX))
i = 1
count = 0
while i <= MAX:
    n = PrimeFactorCount(i)
    if IsPrime(n):
        print(""{0,4}"".format(i), end="""")
        count += 1
        if count % 20 == 0:
            print()
    i += 1
print()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",Python,"from sys import stdout
 
 
def factors(n):
    rt = []
    f = 2
    if n == 1:
        rt.append(1);
    else:
        while 1:
            if 0 == ( n % f ):
                rt.append(f);
                n //= f
                if n == 1:
                    return rt
            else:
                f += 1
    return rt
 
 
def sum_digits(n):
    sum = 0
    while n > 0:
        m = n % 10
        sum += m
        n -= m
        n //= 10
 
    return sum
 
 
def add_all_digits(lst):
    sum = 0
    for i in range (len(lst)):
        sum += sum_digits(lst[i])
 
    return sum
 
 
def list_smith_numbers(cnt):
    for i in range(4, cnt):
        fac = factors(i)
        if len(fac) > 1:
            if sum_digits(i) == add_all_digits(fac):
                stdout.write(""{0} "".format(i) )
 
# entry point
list_smith_numbers(10_000)",Human_written,Python_from_C
http://rosettacode.org/wiki/Program_termination,Program termination,"

Task

Show the syntax for a complete stoppage of a program inside a   conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.



",Python,"import sys
if problem:
    sys.exit(1)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/FASTA_format,FASTA format,"In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.



Task

Write a program that reads a FASTA file such as:

>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED


Output:
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.



",Python,"import sys

def main():
    headerFound = False
    for line in sys.stdin:
        line = line.rstrip()
        if line == """":
            continue
        if line[0]!= "">"":
            if not headerFound:
                print(""missing header"")
                return
            print(line)
        elif headerFound:
            print()
        else:
            print(line[1:], end="": "")
            headerFound = True
    if headerFound:
        print()

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Detect_division_by_zero,Detect division by zero,"Task

Write a function to detect a   divide by zero error   without checking if the denominator is zero.



",Python,"def div_check(x, y):
  try:
    x / y
  except ZeroDivisionError:
    return True
  else:
    return False",Human_written,Python_from_C#
http://rosettacode.org/wiki/Factorial,Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",Python,"def factorial(n):
    result = 1
    for i in range(1, n+1):
        result *= i
    return result",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Longest_string_challenge,Longest string challenge,"Background

This ""longest string challenge"" is inspired by a problem that used to be given to students learning Icon. Students were expected to try to solve the problem in Icon and another language with which the student was already familiar. The basic problem is quite simple; the challenge and fun part came through the introduction of restrictions. Experience has shown that the original restrictions required some adjustment to bring out the intent of the challenge and make it suitable for Rosetta Code.



Basic problem statement
Write a program that reads lines from standard input and, upon end of file, writes the longest line to standard output.
If there are ties for the longest line, the program writes out all the lines that tie.
If there is no input, the program should produce no output.



Task 
Implement a solution to the basic problem that adheres to the spirit of the restrictions (see below).

Describe how you circumvented or got around these 'restrictions' and met the 'spirit' of the challenge. Your supporting description may need to describe any challenges to interpreting the restrictions and how you made this interpretation. You should state any assumptions, warnings, or other relevant points. The central idea here is to make the task a bit more interesting by thinking outside of the box and perhaps by showing off the capabilities of your language in a creative way. Because there is potential for considerable variation between solutions, the description is key to helping others see what you've done.

This task is likely to encourage a variety of different types of solutions. They should be substantially different approaches.

Given the input:

a
bb
ccc
ddd
ee
f
ggg

the output should be (possibly rearranged):

ccc
ddd
ggg



Original list of restrictions
 No comparison operators may be used.
 No arithmetic operations, such as addition and subtraction, may be used.
 The only datatypes you may use are integer and string. In particular, you may not use lists.
 Do not re-read the input file. Avoid using files as a replacement for lists (this restriction became apparent in the discussion).


Intent of restrictions

Because of the variety of languages on Rosetta Code and the wide variety of concepts used in them, there needs to be a bit of clarification and guidance here to get to the spirit of the challenge and the intent of the restrictions.

The basic problem can be solved very conventionally, but that's boring and pedestrian. The original intent here wasn't to unduly frustrate people with interpreting the restrictions, it was to get people to think outside of their particular box and have a bit of fun doing it.

The guiding principle here should be to be creative in demonstrating some of the capabilities of the programming language being used. If you need to bend the restrictions a bit, explain why and try to follow the intent. If you think you've implemented a 'cheat', call out the fragment yourself and ask readers if they can spot why. If you absolutely can't get around one of the restrictions, explain why in your description.

Now having said that, the restrictions require some elaboration.

 In general, the restrictions are meant to avoid the explicit use of these features.
 ""No comparison operators may be used"" - At some level there must be some test that allows the solution to get at the length and determine if one string is longer. Comparison operators, in particular any less/greater comparison should be avoided. Representing the length of any string as a number should also be avoided. Various approaches allow for detecting the end of a string. Some of these involve implicitly using equal/not-equal; however, explicitly using equal/not-equal should be acceptable.
 ""No arithmetic operations"" - Again, at some level something may have to advance through the string. Often there are ways a language can do this implicitly advance a cursor or pointer without explicitly using a +, - , ++, --, add, subtract, etc.
 The datatype restrictions are amongst the most difficult to reinterpret. In the language of the original challenge strings are atomic datatypes and structured datatypes like lists are quite distinct and have many different operations that apply to them. This becomes a bit fuzzier with languages with a different programming paradigm. The intent would be to avoid using an easy structure to accumulate the longest strings and spit them out. There will be some natural reinterpretation here.


To make this a bit more concrete, here are a couple of specific examples:
In C, a string is an array of chars, so using a couple of arrays as strings is in the spirit while using a second array in a non-string like fashion would violate the intent.
In APL or J, arrays are the core of the language so ruling them out is unfair. Meeting the spirit will come down to how they are used.

Please keep in mind these are just examples and you may hit new territory finding a solution. There will be other cases like these. Explain your reasoning. You may want to open a discussion on the talk page as well.

 The added ""No rereading"" restriction is for practical reasons, re-reading stdin should be broken. I haven't outright banned the use of other files but I've discouraged them as it is basically another form of a list. Somewhere there may be a language that just sings when doing file manipulation and where that makes sense; however, for most there should be a way to accomplish without resorting to an externality.


At the end of the day for the implementer this should be a bit of fun. As an implementer you represent the expertise in your language, the reader may have no knowledge of your language. For the reader it should give them insight into how people think outside the box in other languages. Comments, especially for non-obvious (to the reader) bits will be extremely helpful. While the implementations may be a bit artificial in the context of this task, the general techniques may be useful elsewhere.



",Python,"import fileinput
 
# This returns True if the second string has a value on the 
# same index as the last index of the first string. It runs
# faster than trimming the strings because it runs len once
# and is a single index lookup versus slicing both strings 
# one character at a time.
def longer(a, b):
    try:
        b[len(a)-1]
        return False
    except:
        return True
 
longest, lines = '', ''
for x in fileinput.input():
    if longer(x, longest):
        lines, longest = x, x
    elif not longer(longest, x):
        lines += x
 
print(lines, end='')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",Python,"from string import letters
from random import choice, random
 
target  = list(""METHINKS IT IS LIKE A WEASEL"")
charset = letters + ' '
parent  = [choice(charset) for _ in range(len(target))]
minmutaterate  = .09
C = range(100)
 
perfectfitness = float(len(target))
 
def fitness(trial):
    'Sum of matching chars by position'
    return sum(t==h for t,h in zip(trial, target))
 
def mutaterate():
    'Less mutation the closer the fit of the parent'
    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))
 
def mutate(parent, rate):
    return [(ch if random() <= rate else choice(charset)) for ch in parent]
 
def que():
    '(from the favourite saying of Manuel in Fawlty Towers)'
    print (""#%-4i, fitness: %4.1f%%, '%s'"" %
           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))
 
def mate(a, b):
    place = 0
    if choice(xrange(10)) < 7:
        place = choice(xrange(len(target)))
    else:
        return a, b
 
    return a, b, a[:place] + b[place:], b[:place] + a[place:]
 
iterations = 0
center = len(C)/2
while parent != target:
    rate = mutaterate()
    iterations += 1
    if iterations % 100 == 0: que()
    copies = [ mutate(parent, rate) for _ in C ]  + [parent]
    parent1 = max(copies[:center], key=fitness)
    parent2 = max(copies[center:], key=fitness)
    parent = max(mate(parent1, parent2), key=fitness)
que()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Solve_a_Hidato_puzzle,Solve a Hidato puzzle,"The task is to write a program which solves Hidato (aka Hidoku) puzzles.

The rules are:

 You are given a grid with some numbers placed in it. The other squares in the grid will be blank.
 The grid is not necessarily rectangular.
 The grid may have holes in it.
 The grid is always connected.
 The number “1” is always present, as is another number that is equal to the number of squares in the grid. Other numbers are present so as to force the solution to be unique.
 It may be assumed that the difference between numbers present on the grid is not greater than lucky 13.
 The aim is to place a natural number in each blank square so that in the sequence of numbered squares from “1” upwards, each square is in the wp:Moore neighborhood of the squares immediately before and after it in the sequence (except for the first and last squares, of course, which only have one-sided constraints).
 Thus, if the grid was overlaid on a chessboard, a king would be able to make legal moves along the path from first to last square in numerical order.
 A square may only contain one number.
 In a proper Hidato puzzle, the solution is unique.

For example the following problem


has the following solution, with path marked on it:




Related tasks

 A* search algorithm
 N-queens problem
 Solve a Holy Knight's tour
 Solve a Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle;

",Python,"# Solve a Hidato Puzzle
#
class Hidato:
    Cell = namedtuple('Cell', 'value used adj')
    ADJUST = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

    def __init__(self, board, pout=True):
        self.board = []
        for line in board.splitlines():
            self.board.append([Cell(int(n), False) if n.isdigit() else None for n in line.split()] + [None])
        self.board.append([])  # frame (Sentinel value : None)
        for x, row in enumerate(self.board):
            for y, cell in enumerate(row):
                if cell:
                    if cell.value == 1:  # start position
                        self.sx, self.sy = x, y
                    cell.adj = [
                        (x + dx, y + dy)
                        for dx, dy in self.ADJUST
                        if self.board[x + dx][y + dy]
                    ]
        self.xmax = len(self.board) - 1
        self.ymax = max(len(row) for row in self.board) - 1
        self.end = sum(1 for cell in chain.from_iterable(self.board) if cell)
        if pout:
            print(self.to_s('Problem:'))

    def solve(self):
        self.zbl = [False] * (self.end + 1)
        for cell in chain.from_iterable(self.board):
            if cell:
                self.zbl[cell.value] = True
        print(self.to_s('Solution:') if self.try(self.board[self.sx][self.sy], 1) else 'No solution')

    def try(self, cell, seq_num):
        if seq_num > self.end:
            return True
        if cell.used:
            return False
        value = cell.value
        if value > 0 and value!= seq_num:
            return False
        if value == 0 and self.zbl[seq_num]:
            return False
        cell.used = True
        for x, y in cell.adj:
            if self.try(self.board[x][y], seq_num + 1):
                cell.value = seq_num
                return True
        cell.used = False

    def to_s(self, msg=None):
        str = [
           ''.join(f'{c.value:3}' if c else' 'for c in self.board[x])
            for x in range(self.xmax)
        ]
        return (msg + '\n') if msg else '' + '\n'.join(str) + '\n'",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sum_of_a_series,Sum of a series,"Compute the   nth   term of a series,   i.e. the sum of the   n   first terms of the corresponding sequence.

Informally this value, or its limit when   n   tends to infinity, is also called the sum of the series, thus the title of this task.

For this task, use:

 




S

n


=

∑

k
=
1


n




1

k

2






{\displaystyle S_{n}=\sum _{k=1}^{n}{\frac {1}{k^{2}}}}




 and compute   




S

1000




{\displaystyle S_{1000}}




This approximates the   zeta function   for   S=2,   whose exact value

 



ζ
(
2
)
=



π

2


6




{\displaystyle \zeta (2)={\pi ^{2} \over 6}}


is the solution of the Basel problem.



",Python,"print ( sum(1.0 / (x * x) for x in range(1, 1001)) )",Human_written,Python_from_C
http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Python,"def genfizzbuzz(factorwords, numbers):
    # sort entries by factor
    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])
    lines = []
    for num in numbers:
        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)
        lines.append(words if words else str(num))
    return '\n'.join(lines)
 
if __name__ == '__main__':
    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",Python,"def hanoi(ndisks, startPeg=1, endPeg=3):
    if ndisks:
        hanoi(ndisks-1, startPeg, 6-startPeg-endPeg)
        print ""Move disk %d from peg %d to peg %d"" % (ndisks, startPeg, endPeg)
        hanoi(ndisks-1, 6-startPeg-endPeg, endPeg)
 
hanoi(ndisks=4)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Cramer%27s_rule,Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",Python,"def cramers_rule(matrix, free_terms):
    det = detr(matrix)
    return_array = []
    for i in range(len(matrix[0])):
        tmp_matrix = insert_in_terms(matrix, free_terms, i)
        return_array.append(detr(tmp_matrix) / det)
    return return_array

def insert_in_terms(matrix, ins, at):
    tmp_matrix = clone(matrix)
    for i in range(len(matrix)):
        tmp_matrix[i][at] = ins[i]
    return tmp_matrix

def detr(m):
    ret = 1
    k = 0
    A = clone(m)
    n = len(m[0])
    alpha = 0
    for j in range(n - 1):
        k = j
        for i in range(j + 1, n):
            if abs(A[i][j]) > abs(A[k][j]):
                k = i
        if k!= j:
            temp = A[k]
            A[k] = A[j]
            A[j] = temp
            ret *= -1
        Aj = A[j]
        for i in range(j + 1, n):
            Ai = A[i]
            alpha = Ai[j] / Aj[j]
            for k in range(j + 1, n - 1, 2):
                k1 = k + 1
                Ai[k] -= Aj[k] * alpha
                Ai[k1] -= Aj[k1] * alpha
            if k!= n:
                Ai[k] -= Aj[k] * alpha
        if Aj[j] == 0:
            return 0
        ret *= Aj[j]
    return round(ret * A[j][j] * 100) / 100

def clone(m):
    return list(map(lambda a: a[:], m))

matrix = [
    [2, -1, 5, 1],
    [3, 2, 2, -6],
    [1, 3, 3, -1],
    [5, -2, -3, 3]
]
free_terms = [-3, -32, -47, 49]

result = cramers_rule(matrix, free_terms)
print(result)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Galton_box_animation,Galton box animation," Example of a Galton Box at the end of animation.


A   Galton device   Sir Francis Galton's device   is also known as a   bean machine,   a   Galton Board,   or a   quincunx.



Description of operation

In a Galton box, there are a set of pins arranged in a triangular pattern.   A number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin.   The ball continues to fall to the left or right of lower pins before arriving at one of the collection points between and to the sides of the bottom row of pins.

Eventually the balls are collected into bins at the bottom   (as shown in the image),   the ball column heights in the bins approximate a   bell curve.   Overlaying   Pascal's triangle   onto the pins shows the number of different paths that can be taken to get to each bin.



Task

Generate an animated simulation of a Galton device.



Task requirements

   The box should have at least 5 pins on the bottom row. 
   A solution can use graphics or ASCII animation. 
   Provide a sample of the output/display such as a screenshot.
   There can be one or more balls in flight at the same time. 
   If multiple balls are in flight, ensure they don't interfere with each other.
   A solution should allow users to specify the number of balls, or it should run until full or a preset limit. 
   Optionally,   display the number of balls.

",Python,"#!/usr/bin/python
 
import sys, os
import random
import time
 
def print_there(x, y, text):
     sys.stdout.write(""\x1b7\x1b[%d;%df%s\x1b8"" % (x, y, text))
     sys.stdout.flush()
 
 
class Ball():
    def __init__(self):
        self.x = 0
        self.y = 0
 
    def update(self):
        self.x += random.randint(0,1)
        self.y += 1
 
    def fall(self):
        self.y +=1
 
 
class Board():
    def __init__(self, width, well_depth, N):
        self.balls = []
        self.fallen = [0] * (width + 1)
        self.width = width
        self.well_depth = well_depth
        self.N = N
        self.shift = 4
 
    def update(self):
        for ball in self.balls:
            if ball.y < self.width:
                ball.update()
            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:
                ball.fall()
            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:
                self.fallen[ball.x] += 1
            else:
                pass
 
    def balls_on_board(self):
        return len(self.balls) - sum(self.fallen)
 
    def add_ball(self):
        if(len(self.balls) <= self.N):
            self.balls.append(Ball())
 
    def print_board(self):
        for y in range(self.width + 1):
            for x in range(y):
                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, ""#"")
    def print_ball(self, ball):
        if ball.y <= self.width:
            x = self.width - ball.y + 2*ball.x + self.shift
        else:
            x = 2*ball.x + self.shift
        y = ball.y + 1
        print_there(y, x, ""*"")
 
    def print_all(self):
        print(chr(27) + ""[2J"")
        self.print_board();
        for ball in self.balls:
            self.print_ball(ball)
 
 
def main():
    board = Board(width = 15, well_depth = 5, N = 10)
    board.add_ball() #initialization
    while(board.balls_on_board() > 0):
         board.print_all()
         time.sleep(0.25)
         board.update()
         board.print_all()
         time.sleep(0.25)
         board.update()
         board.add_ball()
 
 
if __name__==""__main__"":
    main()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Narcissistic_decimal_number,Narcissistic decimal number,"A   Narcissistic decimal number   is a non-negative integer,   



n


{\displaystyle n}

,   that is equal to the sum of the   



m


{\displaystyle m}

-th   powers of each of the digits in the decimal representation of   



n


{\displaystyle n}

,   where   



m


{\displaystyle m}

   is the number of digits in the decimal representation of   



n


{\displaystyle n}

.



Narcissistic (decimal) numbers are sometimes called   Armstrong   numbers, named after Michael F. Armstrong.

They are also known as   Plus Perfect   numbers.



An example

   if   



n


{\displaystyle n}

   is   153 
   then   



m


{\displaystyle m}

,   (the number of decimal digits)   is   3 
   we have    13 + 53 + 33   =   1 + 125 + 27   =   153  
   and so   153   is a narcissistic decimal number


Task

Generate and show here the first   25   narcissistic decimal numbers.



Note:   




0

1


=
0


{\displaystyle 0^{1}=0}

,   the first in the series.



See also

   the  OEIS entry:     Armstrong (or Plus Perfect, or narcissistic) numbers.
   MathWorld entry:   Narcissistic Number.
   Wikipedia entry:     Narcissistic number.

",Python,"import math
 
class NarcissisticDecs:
 
    def __init__(self):
        self.narc = []
        self.powr = [0] * 10
        self.digs = [0] * 10
 
    def makeList(self, mx):
        st = 0
        tl = 0
        pwr = 0
        len = 0
        while len(self.narc) < mx:
            len = self.getDigs(st)
            if pwr!= len:
                pwr = len
                self.fillPower(pwr)
            tl = 0
            for i in range(1, 10):
                tl += self.powr[i] * self.digs[i]
 
            if tl == st:
                self.narc.append(st)
            st += 1
 
    def display(self):
        for i in self.narc:
            print(i, end="" "")
        print()
 
    def getDigs(self, st):
        for i in range(10):
            self.digs[i] = 0
        r = 0
        while st:
            self.digs[st % 10] += 1
            st //= 10
            r += 1
        return r
 
    def fillPower(self, z):
        for i in range(1, 10):
            self.powr[i] = math.pow(i, z)
 
n = NarcissisticDecs()
n.makeList(25)
n.display()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Man_or_boy_test,Man or boy test,"Man or boy test

You are encouraged to solve this task according to the task description, using any language you may know.

Background: The man or boy test was proposed by computer scientist Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The aim of the test was to distinguish compilers that correctly implemented ""recursion and non-local references"" from those that did not.


I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers'
 — Donald Knuth
Task: Imitate Knuth's example in Algol 60 in another language, as far as possible.

Details: Local variables of routines are often kept in activation records (also call frames). In many languages, these records are kept on a call stack. In Algol (and e.g. in Smalltalk), they are allocated on a heap instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the Funarg Problem.

In Knuth's example, each call to A allocates an activation record for the variable A. When B is called from A, any access to k now refers to this activation record. Now B in turn calls A, but passes itself as an argument. This argument remains bound to the activation record. This call to A also ""shifts"" the variables xi by one place, so eventually the argument B (still bound to its particular
activation record) will appear as x4 or x5 in a call to A. If this happens when the expression x4 + x5 is evaluated, then this will again call B, which in turn will update k in the activation record it was originally bound to. As this activation record is shared with other instances of calls to A and B, it will influence the whole computation.

So all the example does is to set up a convoluted calling structure, where updates to k can influence the behavior
in completely different parts of the call tree.

Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be −67.

Performance and Memory: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error. Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.

The table below shows the result, call depths, and total calls for a range of k:



 k

 0

 1

 2

 3

 4

 5

 6

 7

 8

 9

 10

 11

 12

 13

 14

 15

 16

 17

 18

 19

 20

 21

 22

 23

 24

 25

 26

 27

 28

 29

 30


 A

 1

 0

 -2

 0

 1

 0

 1

 -1

 -10

 -30

 -67

 -138

 -291

 -642

 -1,446

 -3,250

 -7,244

 -16,065

 -35,601

 -78,985

 -175,416

 -389,695

 -865,609

 -1,922,362

 -4,268,854

 -9,479,595

 -21,051,458

 -46,750,171

 -103,821,058

 -230,560,902

 -512,016,658


 A called

 1

 2

 3

 4

 8

 18

 38

 80

 167

 347

 722

 1,509

 3,168

 6,673

 14,091

 29,825

 63,287

 134,652

 287,264

 614,442

 1,317,533

 2,831,900

 6,100,852

 13,172,239

 28,499,827

 61,786,266

 134,202,509

 292,011,464

 

 

 


 A depth

 1

 2

 3

 4

 8

 16

 32

 64

 128

 256

 512

 1,024

 2,048

 4,096

 8,192

 16,384

 32,768

 65,536

 131,072

 262,144

 524,288

 1,048,576

 2,097,152

 4,194,304

 8,388,608

 

 

 

 

 

 


 B called

 0

 1

 2

 3

 7

 17

 37

 79

 166

 346

 721

 1,508

 3,167

 6,672

 14,090

 29,824

 63,286

 134,651

 287,263

 614,441

 1,317,532

 2,831,899

 6,100,851

 13,172,238

 28,499,826

 

 

 

 

 

 


 B depth

 0

 1

 2

 3

 7

 15

 31

 63

 127

 255

 511

 1,023

 2,047

 4,095

 8,191

 16,383

 32,767

 65,535

 131,071

 262,143

 524,287

 1,048,575

 2,097,151

 4,194,303

 8,388,607

 

 

 

 

 

 



Related tasks

   Jensen's Device

",Python,"def a(k, x1, x2, x3, x4, x5):
    b = lambda: (k -= 1; a(k, b, x1, x2, x3, x4))
    return x4() + x5() if k <= 0 else b()
 
print(a(10, lambda: 1, lambda: -1, lambda: -1, lambda: 1, lambda: 0))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Tree_traversal,Tree traversal,"Task

Implement a binary tree where each node carries an integer,   and implement:

   pre-order,
   in-order, 
   post-order,     and 
   level-order   traversal. 


Use those traversals to output the following tree:

         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9

The correct output should look like this:

preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9



See also

   Wikipedia article:   Tree traversal.

",Python,"class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
 
def tree(v, l, r):
    return Node(v, l, r)
 
def destroy_tree(n):
    if n.left:
        destroy_tree(n.left)
    if n.right:
        destroy_tree(n.right)
 
def preorder(n, f):
    f(n.value)
    if n.left:
        preorder(n.left, f)
    if n.right:
        preorder(n.right, f)
 
def inorder(n, f):
    if n.left:
        inorder(n.left, f)
    f(n.value)
    if n.right:
        inorder(n.right, f)
 
def postorder(n, f):
    if n.left:
        postorder(n.left, f)
    if n.right:
        postorder(n.right, f)
    f(n.value)
 
def levelorder(n, f):
    q = [n]
    while q:
        next = q.pop(0)
        f(next.value)
        if next.left:
            q.append(next.left)
        if next.right:
            q.append(next.right)
 
def print(n):
    print(n, end=' ')
 
if __name__ == '__main__':
    n = tree(1,
             tree(2,
                  tree(4,
                       tree(7, None, None),
                       None),
                  tree(5, None, None)),
             tree(3,
                  tree(6,
                       tree(8, None, None),
                       tree(9, None, None)),
                  None))
 
    print(""preorder:    "", end='')
    preorder(n, print)
    print()
 
    print(""inorder:     "", end='')
    inorder(n, print)
    print()
 
    print(""postorder:   "", end='')
    postorder(n, print)
    print()
 
    print(""level-order: "", end='')
    levelorder(n, print)
    print()
 
    destroy_tree(n)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/M%C3%B6bius_function,Möbius function,"The classical Möbius function: μ(n) is an important multiplicative function in number theory and combinatorics.

There are several ways to implement a Möbius function.

A fairly straightforward method is to find the prime factors of a positive integer n, then define μ(n) based on the sum of the primitive factors. It has the values {−1, 0, 1} depending on the factorization of n:

 μ(1) is defined to be 1.
 μ(n) = 1 if n is a square-free positive integer with an even number of prime factors.
 μ(n) = −1 if n is a square-free positive integer with an odd number of prime factors.
 μ(n) = 0 if n has a squared prime factor.


Task

 Write a routine (function, procedure, whatever) μ(n) to find the Möbius number for a positive integer n.
 Use that routine to find and display here, on this page, at least the first 99 terms in a grid layout. (Not just one long line or column of numbers.)


See also

 Wikipedia: Möbius function


Related Tasks

 Mertens function

",Python,"# Python Program to evaluate
# Mobius def M(N) = 1 if N = 1
# M(N) = 0 if any prime factor
# of N is contained twice
# M(N) = (-1)^(no of distinct
# prime factors)
# Python Program to
# evaluate Mobius def
# M(N) = 1 if N = 1
# M(N) = 0 if any
# prime factor of
# N is contained twice
# M(N) = (-1)^(no of
# distinct prime factors)
 
# def to check if
# n is prime or not
def isPrime(n) :
 
    if (n < 2) :
        return False
    for i in range(2, n + 1) :
        if (i * i <= n and n % i == 0) :
            return False
    return True
 
def mobius(N) :
 
    # Base Case
    if (N == 1) :
        return 1
 
    # For a prime factor i
    # check if i^2 is also
    # a factor.
    p = 0
    for i in range(1, N + 1) :
        if (N % i == 0 and
                isPrime(i)) :
 
            # Check if N is
            # divisible by i^2
            if (N % (i * i) == 0) :
                return 0
            else :
 
                # i occurs only once,
                # increase f
                p = p + 1
 
    # All prime factors are
    # contained only once
    # Return 1 if p is even
    # else -1
    if(p % 2 != 0) :
        return -1
    else :
        return 1
 
# Driver Code
print(""Mobius numbers from 1..99:"")
 
for i in range(1, 100):
  print(f""{mobius(i):>4}"", end = '')
 
  if i % 20 == 0: print()
# This code is contributed by
# Manish Shaw(manishshaw1)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Menu,Menu,"Task

Given a prompt and a list containing a number of strings of which one is to be selected, create a function that:

 prints a textual menu formatted as an index value followed by its corresponding string for each item in the list;
 prompts the user to enter a number;
 returns the string corresponding to the selected index number.


The function should reject input that is not an integer or is out of range by redisplaying the whole menu before asking again for a number. The function should return an empty string if called with an empty list.

For test purposes use the following four phrases in a list:

   fee fie
   huff and puff
   mirror mirror
   tick tock

Note

This task is fashioned after the action of the Bash select statement.
",Python,"def _menu(items):
    for indexitem in enumerate(items):
        print (""  %2i) %s"" % indexitem)
 
def _ok(reply, itemcount):
    try:
        n = int(reply)
        return 0 <= n < itemcount
    except:
        return False
 
def selector(items, prompt):
    'Prompt to select an item from the items'
    if not items: return ''
    reply = -1
    itemcount = len(items)
    while not _ok(reply, itemcount):
        _menu(items)
        # Use input instead of raw_input for Python 3.x
        reply = raw_input(prompt).strip()
    return items[int(reply)]
 
if __name__ == '__main__':
    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']
    item = selector(items, 'Which is from the three pigs: ')
    print (""You chose: "" + item)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Old_lady_swallowed_a_fly,Old lady swallowed a fly,"Task

Present a program which emits the lyrics to the song   I Knew an Old Lady Who Swallowed a Fly,   taking advantage of the repetitive structure of the song's lyrics. 

This song has multiple versions with slightly different lyrics, so all these programs might not emit identical output.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import zlib, base64
 
b64 = b'''
eNrtVE1rwzAMvedXaKdeRn7ENrb21rHCzmrs1m49K9gOJv9+cko/HBcGg0LHcpOfnq2np0QL
2FuKgBbICDAoeoiKwEc0hqIUgLAxfV0tQJCdhQM7qh68kheswKeBt5ROYetTemYMCC3rii//
WMS3WkhXVyuFAaLT261JuBWwu4iDbvYp1tYzHVS68VEIObwFgaDB0KizuFs38aSdqKv3TgcJ
uPYdn2B1opwIpeKE53qPftxRd88Y6uoVbdPzWxznrQ3ZUi3DudQ/bcELbevqM32iCIrj3IIh
W6plOJf6L6xaajZjzqW/qAsKIvITBGs9Nm3glboZzkVP5l6Y+0bHLnedD0CttIyrpEU5Kv7N
Mz3XkPBc/TSN3yxGiqMiipHRekycK0ZwMhM8jerGC9zuZaoTho3kMKSfJjLaF8v8wLzmXMqM
zJvGew/jnZPzclA08yAkikegDTTUMfzwDXBcwoE='''
print(zlib.decompress(base64.b64decode(b64)).decode(""utf-8"", ""strict""))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Set_puzzle,Set puzzle,"Set Puzzles are created with a deck of cards from the Set Game™. The object of the puzzle is to find sets of 3 cards in a rectangle of cards that have been dealt face up. 


There are 81 cards in a deck.
Each card contains a unique variation of the following four features: color, symbol, number and shading.

 there are three colors:
    red, green, purple

 there are three symbols:
    oval, squiggle, diamond

 there is a number of symbols on the card:
    one, two, three

 there are three shadings:
    solid, open, striped

Three cards form a set if each feature is either the same on each card, or is different on each card. For instance: all 3 cards are red, all 3 cards have a different symbol, all 3 cards have a different number of symbols, all 3 cards are striped.

There are two degrees of difficulty: basic and advanced. The basic mode deals 9 cards, that contain exactly 4 sets; the advanced mode deals 12 cards that contain exactly 6 sets.

When creating sets you may use the same card more than once.




Task
Write code that deals the cards (9 or 12, depending on selected mode) from a shuffled deck in which the total number of sets that could be found is 4 (or 6, respectively); and print the contents of the cards and the sets.

For instance:



DEALT 9 CARDS:

green, one, oval, striped
green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid
purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open
red, three, oval, open
red, three, diamond, solid

CONTAINING 4 SETS:

green, one, oval, striped
purple, two, squiggle, open
red, three, diamond, solid


green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid


green, one, diamond, open
purple, two, squiggle, open
red, three, oval, open


purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open

",Python,"import random
import time
 
number = [""1"", ""2"", ""3""]
color = [""red"", ""green"", ""purple""]
shade = [""solid"", ""open"", ""striped""]
shape = [""oval"", ""squiggle"", ""diamond""]
 
class Card(object):
    def __init__(self, n, c, s, sh):
        self.number = n
        self.color = c
        self.shade = s
        self.shape = sh
    def __str__(self):
        return ""%s %s %s %s"" % (number[self.number], color[self.color], shade[self.shade], shape[self.shape])
 
def game(level, cards, sets):
    # create deck
    d = []
    for i in range(81):
        d.append(Card(i/27, i/9%3, i/3%3, i%3))
    found = []
    while len(found)!= sets:
        found = []
        # deal
        random.shuffle(d)
        #  consider all triplets
        for i in range(2, cards):
            c1 = d[i]
            for j in range(1, i):
                c2 = d[j]
                for k in range(j):
                    c3 = d[k]
                    if (c1.number + c2.number + c3.number) % 3!= 0:
                        continue
                    if (c1.color + c2.color + c3.color) % 3!= 0:
                        continue
                    if (c1.shade + c2.shade + c3.shade) % 3!= 0:
                        continue
                    if (c1.shape + c2.shape + c3.shape) % 3!= 0:
                        continue
                    # it's a set
                    found.append((c1, c2, c3))
    # found the right number
    print ""%s game.  %d cards, %d sets."" % (level, cards, sets)
    print ""Cards:""
    for c in d[:cards]:
        print ""  "", c
    print ""Sets:""
    for s in found:
        print ""  %s\n  %s\n  %s"" % s
 
random.seed(time.time())
game(""Basic"", 9, 4)
game(""Advanced"", 12, 6)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running,Determine if only one instance is running,"This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.
",Python,"import socket
import time
 
lNet = ""tcp""
lAddr = "":12345""
 
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(lAddr)
    print(""single instance started"")
    time.sleep(10)
except socket.error:
    print(""an instance was already running"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"import sys
import bitstring

SIZE = 80
RULE = 30

def RULE_TEST(x):
    return (RULE & 1 << (7 & (x)))

def evolve(s):
    t = bitstring.BitArray(SIZE)
    t[SIZE-1] = RULE_TEST( s[0] << 2 | s[SIZE-1] << 1 | s[SIZE-2] )
    t[0] = RULE_TEST( s[1] << 2 | s[0] << 1 | s[SIZE-1] )
    for i in range(1, SIZE-1):
        t[i] = RULE_TEST( s[i+1] << 2 | s[i] << 1 | s[i-1] )
    for i in range(SIZE):
        s[i] = t[i]

def show(s):
    for i in range(SIZE):
        if s[i]:
            sys.stdout.write('#')
        else:
            sys.stdout.write(' ')
    sys.stdout.write('\n')

def main():
    state = bitstring.BitArray(1)
    state <<= SIZE / 2
    for i in range(10):
        show(state)
        evolve(state)

if __name__ == '__main__':
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"import sys

try:
    lp0 = open(""/dev/lp0"", ""w"")
    lp0.write(""Hello World!"")
    lp0.close()
except IOError:
    print ""Error: can\'t find file or read data""",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Abelian_sandpile_model,Abelian sandpile model,"

 This page uses content from Wikipedia. The original article was at Abelian sandpile model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Implement the Abelian sandpile model also known as Bak–Tang–Wiesenfeld model. Its history, mathematical definition and properties can be found under its wikipedia article.

The task requires the creation of a 2D grid of arbitrary size on which ""piles of sand"" can be placed. Any ""pile"" that has 4 or more sand particles on it collapses, resulting in four particles being subtracted from the pile and distributed among its neighbors.

It is recommended to display the output in some kind of image format, as terminal emulators are usually too small to display images larger than a few dozen characters tall. As an example of how to accomplish this, see the Bitmap/Write a PPM file task.

Examples up to 2^30, wow!
javascript running on web
Examples:

0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 1 0 0
0 0 4 0 0 -> 0 1 0 1 0
0 0 0 0 0    0 0 1 0 0
0 0 0 0 0    0 0 0 0 0

0 0 0 0 0    0 0 0 0 0
0 0 0 0 0    0 0 1 0 0
0 0 6 0 0 -> 0 1 2 1 0
0 0 0 0 0    0 0 1 0 0
0 0 0 0 0    0 0 0 0 0

0  0 0  0  0    0 0 1 0 0
0  0 0  0  0    0 2 1 2 0
0  0 16 0  0 -> 1 1 0 1 1
0  0 0  0  0    0 2 1 2 0
0  0 0  0  0    0 0 1 0 0
",Python,"import sys
import numpy as np
from PIL import Image

dim = 16

def handle_pile(x, y, pile):
    if pile[y][x] >= 4:
        pile[y][x] -= 4
        if y > 0:
            pile[y-1][x] += 1
            if pile[y-1][x] >= 4:
                handle_pile(x, y-1, pile)
        if x > 0:
            pile[y][x-1] += 1
            if pile[y][x-1] >= 4:
                handle_pile(x-1, y, pile)
        if y < dim-1:
            pile[y+1][x] += 1
            if pile[y+1][x] >= 4:
                handle_pile(x, y+1, pile)
        if x < dim-1:
            pile[y][x+1] += 1
            if pile[y][x+1] >= 4:
                handle_pile(x+1, y, pile)
        handle_pile(x, y, pile)

def draw_pile(pile):
    chars = "" ░▓█""
    for row in pile:
        line = """"
        for elem in row:
            if elem > 3:
                elem = 3
            line += chars[elem]
        print(line)

def write_pile(pile):
    img = Image.new(""RGB"", (dim, dim))
    pixels = img.load()
    bcolors = [(125, 0, 25), (125, 80, 0), (186, 118, 0), (224, 142, 0)]
    for y in range(dim):
        for x in range(dim):
            pixels[x, y] = bcolors[pile[y][x]]
    img.save(""output.png"")

pile = np.zeros((dim, dim), dtype=np.uint8)
hdim = dim//2 - 1
pile[hdim][hdim] = 16
handle_pile(hdim, hdim, pile)
draw_pile(pile)
write_pile(pile)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Parallel_brute_force,Parallel brute force,"Task

Find, through brute force, the five-letter passwords corresponding with the following SHA-256 hashes:

1. 1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad
2. 3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b
3. 74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f

Your program should naively iterate through all possible passwords consisting only of five lower-case ASCII English letters. It should use concurrent or parallel processing, if your language supports that feature. You may calculate SHA-256 hashes by calling a library or through a custom implementation. Print each matching password, along with its SHA-256 hash.

Related task: SHA-256
",Python,"import multiprocessing
from hashlib import sha256
 
h1 = bytes().fromhex(""1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad"")
h2 = bytes().fromhex(""3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b"")
h3 = bytes().fromhex(""74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f"")
 
def brute(firstletterascii: int):
    global h1, h2, h3
    letters = bytearray(5)
    letters[0] = firstletterascii
    for letters[1] in range(97, 97 + 26):
        for letters[2] in range(97, 97 + 26):
            for letters[3] in range(97, 97 + 26):
                for letters[4] in range(97, 97 + 26):
                    digest = sha256(letters).digest()
                    if digest == h1 or digest == h2 or digest == h3:
                        password = """".join(chr(x) for x in letters)
                        print(password + "" => "" + digest.hex())
    return 0
 
def main():
    with multiprocessing.Pool() as p:
        p.map(brute, range(97, 97 + 26))
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Input_loop,Input loop,"Input loop is part of Short Circuit's Console Program Basics selection.
Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data.

The stream will have an unknown amount of data on it.



",Python,"while(True):
      x = input(""What is your age? "")
      print(x)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Extend_your_language,Extend your language,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are ""true""). In a C-like language this could look like the following:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.
",Python,"a, b = 1, 0
 
if (c1 := a == 1) and (c2 := b == 3):
  print('a = 1 and b = 3')
elif c1:
  print('a = 1 and b <> 3')
elif c2:
  print('a <> 1 and b = 3')
else:
  print('a <> 1 and b <> 3')",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Guess_the_number/With_feedback,Guess the number/With feedback,"Task

Write a game (computer program) that follows the following rules:

 The computer chooses a number between given set limits.
 The player is asked for repeated guesses until the the target number is guessed correctly
 At each guess, the computer responds with whether the guess is:
 higher than the target,
 equal to the target, 
 less than the target,   or
 the input was inappropriate. 


Related task

   Guess the number/With Feedback (Player)

",Python,"import random
 
lower_limit = 0
upper_limit = 100
 
number = random.randint(lower_limit, upper_limit)
 
guess = int(input(""Guess the number between %d and %d: "" % (lower_limit, upper_limit)))
 
while guess!= number:
  print(""Your guess was too %s."" % (""high"" if number < guess else ""low""))
  guess = int(input(""Try again: ""))
 
print(""You guessed correctly!"")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification,Ramer-Douglas-Peucker line simplification,"Ramer-Douglas-Peucker line simplification

You are encouraged to solve this task according to the task description, using any language you may know.
The   Ramer–Douglas–Peucker   algorithm is a line simplification algorithm for reducing the number of points used to define its shape.



Task

Using the   Ramer–Douglas–Peucker   algorithm, simplify the   2D   line defined by the points:

   (0,0)  (1,0.1)  (2,-0.1)  (3,5)  (4,6)  (5,7)  (6,8.1)  (7,9)  (8,9)  (9,9) 

The error threshold to be used is:   1.0.

Display the remaining points here.



Reference

   the Wikipedia article:   Ramer-Douglas-Peucker algorithm.

",Python,"from typing import List
from dataclasses import dataclass
from math import hypot

@dataclass
class Point:
    x: float
    y: float

    def __str__(self):
        return f""({self.x}, {self.y})""

def perpendicular_distance(pt: Point, line_start: Point, line_end: Point) -> float:
    dx = line_end.x - line_start.x
    dy = line_end.y - line_start.y

    # Normalize
    mag = hypot(dx, dy)
    if mag > 0.0:
        dx /= mag
        dy /= mag
    pvx = pt.x - line_start.x
    pvy = pt.y - line_start.y

    # Get dot product (project pv onto normalized direction)
    pvdot = dx * pvx + dy * pvy

    # Scale line direction vector and subtract it from pv
    ax = pvx - pvdot * dx
    ay = pvy - pvdot * dy

    return hypot(ax, ay)

def ramer_douglas_peucker(point_list: List[Point], epsilon: float, out: List[Point]) -> None:
    if len(point_list) < 2:
        raise ValueError(""Not enough points to simplify"")

    # Find the point with the maximum distance from line between the start and end
    dmax = 0.0
    index = 0
    end = len(point_list) - 1
    for i in range(1, end):
        d = perpendicular_distance(point_list[i], point_list[0], point_list[end])
        if d > dmax:
            index = i
            dmax = d

    # If max distance is greater than epsilon, recursively simplify
    if dmax > epsilon:
        rec_results1 = []
        rec_results2 = []
        first_line = point_list[:index + 1]
        last_line = point_list[index:]
        ramer_douglas_peucker(first_line, epsilon, rec_results1)
        ramer_douglas_peucker(last_line, epsilon, rec_results2)

        # build the result list
        out.extend(rec_results1[:-1])
        out.extend(rec_results2)
        if len(out) < 2:
            raise RuntimeError(""Problem assembling output"")
    else:
        # Just return start and end points
        out.clear()
        out.append(point_list[0])
        out.append(point_list[-1])

if __name__ == ""__main__"":
    point_list = [
        Point(0.0, 0.0),
        Point(1.0, 0.1),
        Point(2.0, -0.1),
        Point(3.0, 5.0),
        Point(4.0, 6.0),
        Point(5.0, 7.0),
        Point(6.0, 8.1),
        Point(7.0, 9.0),
        Point(8.0, 9.0),
        Point(9.0, 9.0),
    ]
    point_list_out = []
    ramer_douglas_peucker(point_list, 1.0, point_list_out)
    print(""Points remaining after simplification:"")
    for point in point_list_out:
        print(point)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Anagrams/Deranged_anagrams,Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import urllib.request
from collections import defaultdict
from itertools import combinations
 
def getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):
    return list(set(urllib.request.urlopen(url).read().decode().split()))
 
def find_anagrams(words):
    anagram = defaultdict(list) # map sorted chars to anagrams
    for word in words:
        anagram[tuple(sorted(word))].append( word )
    return dict((key, words) for key, words in anagram.items()
                if len(words) > 1)
 
def is_deranged(words):
    'returns pairs of words that have no character in the same position'
    return [ (word1, word2)
             for word1,word2 in combinations(words, 2)
             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]
 
def largest_deranged_ana(anagrams):
    ordered_anagrams = sorted(anagrams.items(),
                              key=lambda x:(-len(x[0]), x[0]))
    for _, words in ordered_anagrams:
        deranged_pairs = is_deranged(words)
        if deranged_pairs:
            return deranged_pairs
    return []
 
if __name__ == '__main__':
    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')
    print(""Word count:"", len(words))
 
    anagrams = find_anagrams(words)
    print(""Anagram count:"", len(anagrams),""\n"")
 
    print(""Longest anagrams with no characters in the same position:"")
    print('  ' + '\n  '.join(', '.join(pairs)
                             for pairs in largest_deranged_ana(anagrams)))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Lah_numbers,Lah numbers,"Lah numbers, sometimes referred to as Stirling numbers of the third kind, are coefficients of polynomial expansions expressing rising factorials in terms of falling factorials.

Unsigned Lah numbers count the number of ways a set of n elements can be partitioned into k non-empty linearly ordered subsets.

Lah numbers are closely related to Stirling numbers of the first & second kinds, and may be derived from them.

Lah numbers obey the identities and relations:

  L(n, 0), L(0, k) = 0   # for n, k > 0
  L(n, n) = 1
  L(n, 1) = n!
  L(n, k) =           ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For unsigned Lah numbers
     or
  L(n, k) = (-1)**n * ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For   signed Lah numbers

Task

 Write a routine (function, procedure, whatever) to find unsigned Lah numbers. There are several methods to generate unsigned Lah numbers. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the unsigned Lah numbers, L(n, k), up to L(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where L(n, k) == 0 (when k > n).
 If your language supports large integers, find and show here, on this page, the maximum value of L(n, k) where n == 100.


See also

 Wikipedia - Lah number
 OEIS:A105278 - Unsigned Lah numbers
 OEIS:A008297 - Signed Lah numbers


Related Tasks

 Stirling numbers of the first kind
 Stirling numbers of the second kind
 Bell numbers

",Python,"def fact(n):
    return 1 if n == 0 else n * fact(n-1)
 
def lah(n, k):
    if k == 1:
        return fact(n)
    elif k == n:
        return 1
    elif k < 1 or k > n:
        return 0
    else:
        return (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)
 
r = range(13)
print(""Unsigned Lah numbers: L(n, k):"")
print(""n/k "" + "" "".join(""%11d"" % n for n in r))
 
for row in r:
    print(""%-4s"" % row, end="""")
    print("" "".join(""%11d"" % lah(row,col) for col in r))
 
print(""\nMaximum value from the L(100, *) row:"")
print(max(lah(100,a) for a in range(1,101)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",Python,"print ""Hello world!""",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",Python,"def isPrime(n):
	if n%2==0: return n==2
	if n%3==0: return n==3
	d=5
	while d*d<=n:
		if n%d==0: return 0
		d+=2
		if n%d==0: return 0
		d+=4
	return 1

q=929
if not isPrime(q): return 1
r=q
while r>0: r<<=1
d=2*q+1
while 1:
	for p in range(r):
		i=((long long)i * i) % d
		if p < 0: i *= 2
		if i > d: i -= d
	if i!= 1: d += 2*q
	else: break
print(""2^%d - 1 = 0 (mod %d)"" % (q, d))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Concurrent_computing,Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",Python,"import threading
import time
import random

def thread_function(name):
    time.sleep(random.random())
    print(name)

threads = []
for x in ['Enjoy', 'Rosetta', 'Code']:
    x = threading.Thread(target=thread_function, args=(x,))
    threads.append(x)
    x.start()

for thread in threads:
    thread.join()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Huffman_coding,Huffman coding,"Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:


 Create a leaf node for each symbol and add it to the priority queue.
 While there is more than one node in the queue:
 Remove the node of highest priority (lowest probability) twice to get two nodes.
 Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
 Add the new node to the queue.
 The remaining node is the root node and the tree is complete.


Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:



Task

Using the characters and their frequency from the string:

     this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.



",Python,"import heapq
 
class HuffmanTree(object):
    def __init__(self, freq):
        self.frequency = freq
 
    def __cmp__(self, other):
        return cmp(self.frequency, other.frequency)
 
class HuffmanLeaf(HuffmanTree):
    def __init__(self, freq, val):
        super(HuffmanLeaf, self).__init__(freq)
        self.value = val
 
class HuffmanNode(HuffmanTree):
    def __init__(self, left, right):
        super(HuffmanNode, self).__init__(left.frequency + right.frequency)
        self.left = left
        self.right = right
 
def build_tree(char_freqs):
    trees = []
    for i in range(len(char_freqs)):
        if char_freqs[i] > 0:
            trees.append(HuffmanLeaf(char_freqs[i], i))
 
    heapq.heapify(trees)
    assert len(trees) > 0
    while len(trees) > 1:
        a = heapq.heappop(trees)
        b = heapq.heappop(trees)
        heapq.heappush(trees, HuffmanNode(a, b))
    return heapq.heappop(trees)
 
def print_codes(tree, prefix):
    assert tree is not None
    if isinstance(tree, HuffmanLeaf):
        print tree.value, '\t', tree.frequency, '\t', prefix
    elif isinstance(tree, HuffmanNode):
        print_codes(tree.left, prefix + '0')
        print_codes(tree.right, prefix + '1')
 
def main():
    test = 'this is an example for huffman encoding'
 
    char_freqs = [0] * 256
    for c in test:
        char_freqs[ord(c)] += 1
 
    tree = build_tree(char_freqs)
    print 'SYMBOL\tWEIGHT\tHUFFMAN CODE'
    print_codes(tree, '')
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",Python,"class Doc(object):
   """"""
   This is a class docstring. Traditionally triple-quoted strings are used because
   they can span multiple lines and you can include quotation marks without escaping.
   """"""
   def method(self, num):
      """"""This is a method docstring.""""""
      pass",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",Python,"def bit_count(n):
    count = 0
    while n > 0:
        n >>= 1
        count += 1
    return count
 
def mod_pow(p, n):
    square = 1
    bits = bit_count(p)
    while bits > 0:
        square = square * square
        bits -= 1
        if (p & (1 << bits))!= 0:
            square <<= 1
        square %= n
    return square
 
def is_prime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    p = 5
    while p * p <= n:
        if n % p == 0:
            return False
        p += 2
        if n % p == 0:
            return False
        p += 4
    return True
 
def find_mersenne_factor(p):
    k = 0
    while True:
        k += 1
        q = 2 * k * p + 1
        if q % 8 == 1 or q % 8 == 7:
            if mod_pow(p, q) == 1 and is_prime(p):
                return q
 
print(find_mersenne_factor(929))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Averages/Arithmetic_mean,Averages/Arithmetic mean,"Task[edit]
Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"def mean(numbers):
    if len(numbers) == 0:
        return 0
    sum = 0
    for i in numbers:
        sum += i
    return sum / len(numbers)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Boolean_values,Boolean values,"Task

Show how to represent the boolean states ""true"" and ""false"" in a language.

If other objects represent ""true"" or ""false"" in conditionals, note it.



Related tasks

   Logical operations

",Python,">>> True
True
>>> not True
False
>>> # As numbers
>>> False + 0
0
>>> True + 0
1
>>> False + 0j
0j
>>> True * 3.141
3.141
>>> # Numbers as booleans
>>> not 0
True
>>> not not 0
False
>>> not 1234
False
>>> bool(0.0)
False
>>> bool(0j)
False
>>> bool(1+2j)
True
>>> # Collections as booleans
>>> bool([])
False
>>> bool([None])
True
>>> 'I contain something' if (None,) else 'I am empty'
'I contain something'
>>> bool({})
False
>>> bool("""")
False
>>> bool(""False"")
True",Human_written,Python_from_C
http://rosettacode.org/wiki/Animate_a_pendulum,Animate a pendulum,"
One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.

The classic such physical system is a simple gravity pendulum.



Task

Create a simple physical model of a pendulum and animate it.



",Python,"import pygame, sys
from pygame.locals import *
from math import sin, cos, radians
 
pygame.init()
 
WINDOWSIZE = 250
TIMETICK = 100
BOBSIZE = 15
 
window = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))
pygame.display.set_caption(""Pendulum"")
 
screen = pygame.display.get_surface()
screen.fill((255,255,255))
 
PIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)
SWINGLENGTH = PIVOT[1]*4
 
class BobMass(pygame.sprite.Sprite):
    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
        self.theta = 45
        self.dtheta = 0
        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),
                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),
                                1,1)
        self.draw()
 
    def recomputeAngle(self):
        scaling = 3000.0/(SWINGLENGTH**2)
 
        firstDDtheta = -sin(radians(self.theta))*scaling
        midDtheta = self.dtheta + firstDDtheta
        midtheta = self.theta + (self.dtheta + midDtheta)/2.0
 
        midDDtheta = -sin(radians(midtheta))*scaling
        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2
        midtheta = self.theta + (self.dtheta + midDtheta)/2
 
        midDDtheta = -sin(radians(midtheta)) * scaling
        lastDtheta = midDtheta + midDDtheta
        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0
 
        lastDDtheta = -sin(radians(lasttheta)) * scaling
        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0
        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0
 
        self.dtheta = lastDtheta
        self.theta = lasttheta
        self.rect = pygame.Rect(PIVOT[0]-
                                SWINGLENGTH*sin(radians(self.theta)), 
                                PIVOT[1]+
                                SWINGLENGTH*cos(radians(self.theta)),1,1)
 
 
    def draw(self):
        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)
        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)
        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)
        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))
 
    def update(self):
        self.recomputeAngle()
        screen.fill((255,255,255))
        self.draw()
 
bob = BobMass()
 
TICK = USEREVENT + 2
pygame.time.set_timer(TICK, TIMETICK)
 
def input(events):
    for event in events:
        if event.type == QUIT:
            sys.exit(0)
        elif event.type == TICK:
            bob.update()
 
while True:
    input(pygame.event.get())
    pygame.display.flip()",Human_written,Python_from_Java
http://rosettacode.org/wiki/URL_decoding,URL decoding,"This task   (the reverse of   URL encoding   and distinct from   URL parser)   is to provide a function
or mechanism to convert an URL-encoded string into its original unencoded form.



Test cases

   The encoded string   ""http%3A%2F%2Ffoo%20bar%2F""   should be reverted to the unencoded form   ""http://foo bar/"".
   The encoded string   ""google.com/search?q=%60Abdu%27l-Bah%C3%A1""   should revert to the unencoded form   ""google.com/search?q=`Abdu'l-Bahá"".

",Python,"import re
 
def ishex(x):
	return	(x >= '0' and x <= '9')	or
		(x >= 'a' and x <= 'f')	or
		(x >= 'A' and x <= 'F')
 
def decode(s, dec):
	o = 0
	end = len(s)
	for i in range(end):
		c = s[i]
		if c == '+': c =''
		elif c == '%' and (	not ishex(s[i+1])	or
					not ishex(s[i+2])	or
					not re.match(s[i+1:i+3], ""%2x"")):
			return -1
 
		if dec: dec[o] = c
		o += 1
 
	return o
 
if __name__ == '__main__':
	url = ""http%3A%2F%2ffoo+bar%2Fabcd""
	out = [0] * (len(url) + 1)
 
	print ""length: %d"" % decode(url, 0)
	print ""bad string"" if decode(url, out) < 0 else out",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Averages/Mean_angle,Averages/Mean angle,"When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.

If one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.

To calculate the mean angle of several angles:

 Assume all angles are on the unit circle and convert them to complex numbers expressed in real and imaginary form.
 Compute the mean of the complex numbers.
 Convert the complex mean to polar coordinates whereupon the phase of the complex mean is the required angular mean.


(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)

You can alternatively use this formula:

 Given the angles 




α

1


,
…
,

α

n




{\displaystyle \alpha _{1},\dots ,\alpha _{n}}

 the mean is computed by







α
¯



=
atan2
⁡

(


1
n


⋅

∑

j
=
1


n


sin
⁡

α

j


,


1
n


⋅

∑

j
=
1


n


cos
⁡

α

j


)



{\displaystyle {\bar {\alpha }}=\operatorname {atan2} \left({\frac {1}{n}}\cdot \sum _{j=1}^{n}\sin \alpha _{j},{\frac {1}{n}}\cdot \sum _{j=1}^{n}\cos \alpha _{j}\right)}


Task[edit]
 write a function/method/subroutine/... that given a list of angles in degrees returns their mean angle. 
 (You should use a built-in function if you have one that does this for degrees or radians). 
 Use the function to compute the means of these lists of angles (in degrees):
   [350, 10] 
   [90, 180, 270, 360] 
   [10, 20, 30]
 Show your output here.
See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"import cmath
import math
 
def deg2rad(d):
    return d * math.pi / 180
 
def rad2deg(r):
    return r * 180 / math.pi
 
def mean_angle(deg):
    return rad2deg(sum(cmath.rect(1, deg2rad(d)) for d in deg) / len(deg)).real
 
for angles in ([350, 10], [90, 180, 270, 360], [10, 20, 30]):
    print(""The mean angle of %r is: %f degrees"" % (angles, mean_angle(angles)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Harmonic_series,Harmonic series,"

 This page uses content from Wikipedia. The original article was at Harmonic number. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, the n-th harmonic number is the sum of the reciprocals of the first n natural numbers:

   Hn = 1 + 1/2 + 1/3 + ... + 1/n

The series of harmonic numbers thus obtained is often loosely referred to as the harmonic series.

Harmonic numbers are closely related to the Riemann zeta function, and roughly approximate the natural logarithm function; differing by γ (lowercase Gamma), the Euler–Mascheroni constant.

The harmonic series is divergent, albeit quite slowly, and grows toward infinity.



Task
 Write a function (routine, procedure, whatever it may be called in your language) to generate harmonic numbers.
 Use that procedure to show the values of the first 20 harmonic numbers.
 Find and show the position in the series of the first value greater than the integers 1 through 5


Stretch
 Find and show the position in the series of the first value greater than the integers 6 through 10


Related
 Egyptian fractions

",Python,"from  fractions import Fraction
 
def harmonic_series():
    n, h = Fraction(1), Fraction(1)
    while True:
        yield h
        h += 1 / (n + 1)
        n += 1
 
if __name__ == '__main__':
    from itertools import islice
    for n, d in (h.as_integer_ratio() for h in islice(harmonic_series(), 20)):
        print(n, '/', d)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",Python,"import numpy as np
 
def det_in(in_array, n, perm):
	if n == 1:
		return in_array[0][0]
 
	sum = 0
	m = [None] * (n - 1)
	for i in range(n - 1):
		m[i] = in_array[i + 1][1:]
 
	for i in range(n):
		sum += (-1)**i * (in_array[i][0] * det_in(m, n - 1, perm))
		if i == n - 1:
			break
 
		m[i] = in_array[i][1:]
		if not perm:
			sum *= -1
	return sum
 
def det(in_array, n, perm):
	m = [None] * n
	for i in range(n):
		m[i] = in_array[i * n:(i + 1) * n]
 
	return det_in(m, n, perm)
 
if __name__ == '__main__':
	x = np.arange(25).reshape(5, 5)
	print('det: ', det(x, 5, 0))
	print('perm: ', det(x, 5, 1))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Digital_root/Multiplicative_digital_root,Digital root/Multiplicative digital root,"The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, 



n


{\displaystyle n}

, is calculated rather like the Digital root except digits are multiplied instead of being added:

 Set 



m


{\displaystyle m}

 to 



n


{\displaystyle n}

 and 



i


{\displaystyle i}

 to 



0


{\displaystyle 0}

.
 While 



m


{\displaystyle m}

 has more than one digit:
 Find a replacement 



m


{\displaystyle m}

 as the multiplication of the digits of the current value of 



m


{\displaystyle m}

.
 Increment 



i


{\displaystyle i}

.
 Return 



i


{\displaystyle i}

 (= MP) and 



m


{\displaystyle m}

 (= MDR)


Task

 Tabulate the MP and MDR of the numbers 123321, 7739, 893, 899998
 Tabulate MDR versus the first five numbers having that MDR, something like:
MDR: [n0..n4]
===  ========
  0: [0, 10, 20, 25, 30]
  1: [1, 11, 111, 1111, 11111]
  2: [2, 12, 21, 26, 34]
  3: [3, 13, 31, 113, 131]
  4: [4, 14, 22, 27, 39]
  5: [5, 15, 35, 51, 53]
  6: [6, 16, 23, 28, 32]
  7: [7, 17, 71, 117, 171]
  8: [8, 18, 24, 29, 36]
  9: [9, 19, 33, 91, 119]

Show all output on this page.

Similar

The Product of decimal digits of n page was redirected here, and had the following description


Find the product of the decimal digits of a positive integer   n,   where n <= 100

The three existing entries for Phix, REXX, and Ring have been moved here, under ===Similar=== headings, feel free to match or ignore them.



References

 Multiplicative Digital Root on Wolfram Mathworld.
 Multiplicative digital root on The On-Line Encyclopedia of Integer Sequences.
 What's special about 277777788888899? - Numberphile video

",Python,"try:
    from functools import reduce
except:
    pass
 
def mdroot(n):
    'Multiplicative digital root'
    mdr = [n]
    while mdr[-1] > 9:
        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))
    return len(mdr) - 1, mdr[-1]
 
if __name__ == '__main__':
    print('Number: (MP, MDR)\n======  =========')
    for n in (123321, 7739, 893, 899998):
        print('%6i: %r' % (n, mdroot(n)))
 
    table, n = {i: [] for i in range(10)}, 0
    while min(len(row) for row in table.values()) < 5:
        mpersistence, mdr = mdroot(n)
        table[mdr].append(n)
        n += 1
    print('\nMP: [n0..n4]\n==  ========')
    for mp, val in sorted(table.items()):
        print('%2i: %r' % (mp, val[:5]))",Human_written,Python_from_C
http://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Vigenère cipher,"Task

Implement a   Vigenère cypher,   both encryption and decryption.

The program should handle keys and text of unequal length,
and should capitalize everything and discard non-alphabetic characters. 

(If your program handles non-alphabetic characters in another way,
make a note of it.)



Related tasks

   Caesar cipher
   Rot-13
   Substitution Cipher

",Python,"'''Vigenere encryption and decryption'''
 
from itertools import starmap, cycle
 
 
def encrypt(message, key):
    '''Vigenere encryption of message using key.'''
 
    # Converted to uppercase.
    # Non-alpha characters stripped out.
    message = filter(str.isalpha, message.upper())
 
    def enc(c, k):
        '''Single letter encryption.'''
 
        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))
 
    return ''.join(starmap(enc, zip(message, cycle(key))))
 
 
def decrypt(message, key):
    '''Vigenere decryption of message using key.'''
 
    def dec(c, k):
        '''Single letter decryption.'''
 
        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))
 
    return ''.join(starmap(dec, zip(message, cycle(key))))
 
 
def main():
    '''Demonstration'''
 
    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (
           'the claws that catch!'
    )
    key = 'VIGENERECIPHER'
 
    encr = encrypt(text, key)
    decr = decrypt(encr, key)
 
    print(text)
    print(encr)
    print(decr)
 
 
if __name__ == '__main__':
    main()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Priority_queue,Priority queue,"A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.



Task

Create a priority queue.   The queue must support at least two operations:

   Insertion.   An element is added to the queue with a priority (a numeric value).
   Top item removal.   Deletes the element or one of the elements with the current top priority and return it.


Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.



To test your implementation, insert a number of elements into the queue, each with some random priority.

Then dequeue them sequentially; now the elements should be sorted by priority.

You can use the following task/priority items as input data:

        Priority         Task
       ══════════   ════════════════
           3         Clear drains
           4         Feed cat
           5         Make tea
           1         Solve RC tasks
           2         Tax return



The implementation should try to be efficient.   A typical implementation has   O(log n)   insertion and extraction time,   where   n   is the number of items in the queue.

You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc.   If so, discuss the reasons behind it.



",Python,">>> import queue
>>> pq = queue.PriorityQueue()
>>> for item in ((3, ""Clear drains""), (4, ""Feed cat""), (5, ""Make tea""), (1, ""Solve RC tasks""), (2, ""Tax return"")):
  pq.put(item)
 
 
>>> while not pq.empty():
  print(pq.get_nowait())
 
 
(1, 'Solve RC tasks')
(2, 'Tax return')
(3, 'Clear drains')
(4, 'Feed cat')
(5, 'Make tea')
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Taxicab_numbers,Taxicab numbers,"
A   taxicab number   (the definition that is being used here)   is a positive integer that can be expressed as the sum of two positive cubes in more than one way.



The first taxicab number is   1729,   which is:

 13   +   123       and also
 93   +   103.


Taxicab numbers are also known as:

   taxi numbers
   taxi-cab numbers
   taxi cab numbers
   Hardy-Ramanujan numbers


Task

 Compute and display the lowest 25 taxicab numbers (in numeric order, and in a human-readable format).
 For each of the taxicab numbers, show the number as well as it's constituent cubes.


Extra credit
 Show the 2,000th taxicab number, and a half dozen more


See also

 A001235: taxicab numbers on The On-Line Encyclopedia of Integer Sequences.
 Hardy-Ramanujan Number on MathWorld.
 taxicab number on MathWorld.
 taxicab number on Wikipedia   (includes the story on how taxi-cab numbers came to be called).

",Python,"# version 1.0.6
 
from itertools import count
from heapq import heappush, heappop
 
class CubeSum:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.value = x * x * x + y * y * y
 
    def __str__(self):
        return f""{self.x}^3 + {self.y}^3""
 
    def __lt__(self, other):
        return self.value < other.value
 
class SumIterator:
    def __init__(self):
        self.pq = []
        self.n = 0
 
    def __iter__(self):
        return self
 
    def __next__(self):
        while len(self.pq) == 0 or self.pq[0].value >= self.n * self.n * self.n:
            heappush(self.pq, CubeSum(self.n, 1))
            self.n += 1
        s = heappop(self.pq)
        if s.x > s.y + 1:
            heappush(self.pq, CubeSum(s.x, s.y + 1))
        return s
 
class TaxiIterator:
    def __init__(self):
        self.sum_iterator = SumIterator()
        self.last = next(self.sum_iterator)
 
    def __iter__(self):
        return self
 
    def __next__(self):
        s = next(self.sum_iterator)
        train = []
        while s.value!= self.last.value:
            self.last = s
            s = next(self.sum_iterator)
        train.append(self.last)
        while s.value == self.last.value:
            train.append(s)
            s = next(self.sum_iterator)
        self.last = s
        return train
 
if __name__ == ""__main__"":
    taxi = TaxiIterator()
    for i in range(1, 2007):
        t = next(taxi)
        if i in range(26, 2000):
            continue
        print(f""{i:4d}: {t[0].value:10d}"", end="""")
        for s in t:
            print(f""  = {s}"", end="""")
        print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body,Loops/Increment loop index within loop body,"Sometimes, one may need   (or want)   a loop which
its   iterator   (the index
variable)   is modified within the

loop body    in addition to the normal incrementation by the   (do)   loop structure index.



Goal

Demonstrate the best way to accomplish this.



Task

Write a loop which:

   starts the index (variable) at   42
   (at iteration time)   increments the index by unity
   if the index is prime:
   displays the count of primes found (so far) and the prime   (to the terminal)
   increments the index such that the new index is now the (old) index plus that prime
   terminates the loop when   42   primes are shown


Extra credit:   because of the primes get rather large, use commas
within the displayed primes to ease comprehension.



Show all output here.



Note

Not all programming languages allow the modification of a
loop's index.   If that is the case, then use whatever method that
is appropriate or idiomatic for that language.   Please add a note
if the loop's index isn't modifiable.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"from locale import setlocale, LC_NUMERIC
from math import sqrt
 
LIMIT = 42
 
def is_prime(n):
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0:
            return False
        d += 2
        if n % d == 0:
            return False
        d += 4
    return True
 
setlocale(LC_NUMERIC, """")
for i, n in zip(range(LIMIT, LIMIT * 2), range(1, LIMIT + 1)):
    if is_prime(i):
        print(""n = %-2d  %'19d"" % (n, i))
        i += i - 1",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Longest_common_substring,Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",Python,"# version 1.1.2
 
def lcs(a, b):
    if len(a) > len(b):
        return lcs(b, a)
    res = """"
    for ai in range(0, len(a)):
        for len in range(len(a) - ai, 0, -1):
            for bi in range(0, len(b) - len):
                if a[ai:ai + len] == b[bi:bi + len] and len > len(res):
                    res = a[ai:ai + len]
    return res
 
print(lcs(""testing123testing"", ""thisisatest""))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"def eca(cells, rule):
    lencells = len(cells)
    c = ""0"" + cells + ""0""    # Zero pad the ends
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    yield c[1:-1]
    while True:
        c = ''.join(['0',
                     ''.join(neighbours2next[c[i-1:i+2]]
                             for i in range(1,lencells+1)),
                     '0'])
        yield c[1:-1]
 
if __name__ == '__main__':
    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)
    zipped = [range(lines)] + [eca(start, rule) for rule in rules]
    print('\n   Rules: %r' % (rules,))
    for data in zip(*zipped):
        i = data[0]
        cells = data[1:]
        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Substring/Top_and_tail,Substring/Top and tail,"The task is to demonstrate how to remove the first and last characters from a string.

The solution should demonstrate how to obtain the following results:

 String with first character removed
 String with last character removed
 String with both the first and last characters removed


If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it.

The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"print ""knight""[1:]     # strip first character
print ""socks""[:-1]     # strip last character
print ""brooms""[1:-1]   # strip both first and last characters",Human_written,Python_from_Go
http://rosettacode.org/wiki/Palindrome_dates,Palindrome dates,"Today   (2020-02-02,   at the time of this writing)   happens to be a palindrome,   without the hyphens,   not only for those countries which express their dates in the   yyyy-mm-dd   format but,   unusually,   also for countries which use the   dd-mm-yyyy   format.



Task
Write a program which calculates and shows the next 15 palindromic dates for those countries which express their dates in the   yyyy-mm-dd   format.



",Python,"'''Palindrome dates'''
 
from datetime import datetime
from itertools import chain
 
 
# palinDay :: Int -> [ISO Date]
def palinDay(y):
    '''A possibly empty list containing the palindromic
       date for the given year, if such a date exists.
    '''
    s = str(y)
    r = s[::-1]
    iso = '-'.join([s, r[0:2], r[2:]])
    try:
        datetime.strptime(iso, '%Y-%m-%d')
        return [iso]
    except ValueError:
        return []
 
 
# --------------------------TEST---------------------------
# main :: IO ()
def main():
    '''Count and samples of palindromic dates [2021..9999]
    '''
    palinDates = list(chain.from_iterable(
        map(palinDay, range(2021, 10000))
    ))
    for x in [
            'Count of palindromic dates [2021..9999]:',
            len(palinDates),
            '\nFirst 15:',
            '\n'.join(palinDates[0:15]),
            '\nLast 15:',
            '\n'.join(palinDates[-15:])
    ]:
        print(x)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_C
http://rosettacode.org/wiki/String_length,String length,"Task

Find the character and byte length of a string.

This means encodings like UTF-8 need to be handled properly, as there is not necessarily a one-to-one relationship between bytes and characters.

By character, we mean an individual Unicode code point, not a user-visible grapheme containing combining characters.

For example, the character length of ""møøse"" is 5 but the byte length is 7 in UTF-8 and 10 in UTF-16.

Non-BMP code points (those between 0x10000 and 0x10FFFF) must also be handled correctly: answers should produce actual character counts in code points, not in code unit counts.

Therefore a string like ""𝔘𝔫𝔦𝔠𝔬𝔡𝔢"" (consisting of the 7 Unicode characters U+1D518 U+1D52B U+1D526 U+1D520 U+1D52C U+1D521 U+1D522) is 7 characters long, not 14 UTF-16 code units; and it is 28 bytes long whether encoded in UTF-8 or in UTF-16.

Please mark your examples with ===Character Length=== or ===Byte Length===.

If your language is capable of providing the string length in graphemes, mark those examples with ===Grapheme Length===.

For example, the string ""J̲o̲s̲é̲"" (""J\x{332}o\x{332}s\x{332}e\x{301}\x{332}"") has 4 user-visible graphemes, 9 characters (code points), and 14 bytes when encoded in UTF-8.





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"print len('ascii')
# 5",Human_written,Python_from_C
http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",Python,">>> def flatten(lst):
	return sum( ([x] if not isinstance(x, list) else flatten(x)
		     for x in lst), [] )
 
>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
>>> flatten(lst)
[1, 2, 3, 4, 5, 6, 7, 8]",Human_written,Python_from_C#
http://rosettacode.org/wiki/Longest_common_subsequence,Longest common subsequence,"Introduction

Define a subsequence to be any output string obtained by deleting zero or more symbols from an input string.

The Longest Common Subsequence (LCS) is a subsequence of maximum length common to two or more strings.

Let A ≡ A[0]… A[m - 1] and B ≡ B[0]… B[n - 1], m < n be strings drawn from an alphabet Σ of size s, containing every distinct symbol in A + B.

An ordered pair (i, j) will be referred to as a match if A[i] = B[j], where 0 < i ≤ m and 0 < j ≤ n.

Define a non-strict product-order (≤) over ordered pairs, such that (i1, j1) ≤ (i2, j2) ⇔ i1 ≤ i2 and j1 ≤ j2. We define (≥) similarly.

We say m1, m2 are comparable if either m1 ≤ m2 or m1 ≥ m2 holds. If i1 < i2 and j2 < j1 (or i2 < i1 and j1 < j2) then neither m1 ≤ m2 nor m1 ≥ m2 are possible; and we say m1, m2 are incomparable.

We also define the strict product-order (<) over ordered pairs, such that (i1, j1) < (i2, j2) ⇔ i1 < i2 and j1 < j2. We define (>) similarly.

Given a set of matches M, a chain C is a subset of M consisting of at least one element m; and where either m1 < m2 or m1 > m2 for every pair of distinct elements m1 and m2. An antichain D is any subset of M in which every pair of distinct elements m1 and m2 are incomparable.

The set M represents a relation over match pairs: M[i, j] ⇔ (i, j) ∈ M. A chain C can be visualized as a curve which strictly increases as it passes through each match pair in the m*n coordinate space.

Finding an LCS can be restated as the problem of finding a chain of maximum cardinality p over the set of matches M.

According to [Dilworth 1950], this cardinality p equals the minimum number of disjoint antichains into which M can be decomposed. Note that such a decomposition into the minimal number p of disjoint antichains may not be unique.

Contours

Forward Contours FC[k] of class k are defined inductively, as follows:

FC[0] consists of those elements m1 for which there exists no element m2 such that m2 < m1.

FC[k] consists of those elements m1 for which there exists no element m2 such that m2 < m1; and where neither m1 nor m2 are contained in FC[l] for any class l < k.

Reverse Contours RC[k] of class k are defined similarly.

Members of the Meet (∧), or Infimum of a Forward Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 < m1.

Members of the Join (∨), or Supremum of a Reverse Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 > m1.

Where multiple Dominant Matches exist within a Meet (or within a Join, respectively) the Dominant Matches will be incomparable to each other.

Background

Where the number of symbols appearing in matches is small relative to the length of the input strings, reuse of the symbols increases; and the number of matches will tend towards quadratic, O(m*n) growth. This occurs, for example, in the Bioinformatics application of nucleotide and protein sequencing.

The divide-and-conquer approach of [Hirschberg 1975] limits the space required to O(n). However, this approach requires O(m*n) time even in the best case.

This quadratic time dependency may become prohibitive, given very long input strings. Thus, heuristics are often favored over optimal Dynamic Programming solutions.

In the application of comparing file revisions, records from the input files form a large symbol space; and the number of symbols approaches the length of the LCS. In this case the number of matches reduces to linear, O(n) growth.

A binary search optimization due to [Hunt and Szymanski 1977] can be applied to the basic Dynamic Programming approach, resulting in an expected performance of O(n log m). Performance can degrade to O(m*n log m) time in the worst case, as the number of matches grows to O(m*n).

Note

[Rick 2000] describes a linear-space algorithm with a time bound of O(n*s + p*min(m, n - p)).

Legend

A, B are input strings of lengths m, n respectively
p is the length of the LCS
M is the set of match pairs (i, j) such that A[i] = B[j]
r is the magnitude of M
s is the magnitude of the alphabet Σ of distinct symbols in A + B

References

[Dilworth 1950] ""A decomposition theorem for partially ordered sets""
by Robert P. Dilworth, published January 1950,
Annals of Mathematics [Volume 51, Number 1, pp. 161-166]

[Goeman and Clausen 2002] ""A New Practical Linear Space Algorithm for the Longest Common
Subsequence Problem"" by Heiko Goeman and Michael Clausen,
published 2002, Kybernetika [Volume 38, Issue 1, pp. 45-66]

[Hirschberg 1975] ""A linear space algorithm for computing maximal common subsequences""
by Daniel S. Hirschberg, published June 1975
Communications of the ACM [Volume 18, Number 6, pp. 341-343]

[Hunt and McIlroy 1976] ""An Algorithm for Differential File Comparison""
by James W. Hunt and M. Douglas McIlroy, June 1976
Computing Science Technical Report, Bell Laboratories 41

[Hunt and Szymanski 1977] ""A Fast Algorithm for Computing Longest Common Subsequences""
by James W. Hunt and Thomas G. Szymanski, published May 1977
Communications of the ACM [Volume 20, Number 5, pp. 350-353]

[Rick 2000] ""Simple and fast linear space computation of longest common subsequences""
by Claus Rick, received 17 March 2000, Information Processing Letters,
Elsevier Science [Volume 75, pp. 275–281]



Examples

The sequences ""1234"" and ""1224533324"" have an LCS of ""1234"":

1234
1224533324

For a string example, consider the sequences ""thisisatest"" and ""testing123testing"". An LCS would be ""tsitest"":

thisisatest
testing123testing

In this puzzle, your code only needs to deal with strings. Write a function which returns an LCS of two strings (case-sensitive). You don't need to show multiple LCS's.

For more information on this problem please see Wikipedia.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def lcs(a, b):
    aSub = a[0:len(a)-1]
    bSub = b[0:len(b)-1]

    if len(a) == 0 or len(b) == 0:
        return ''
    elif a[len(a)-1] == b[len(b)-1]:
        return lcs(aSub, bSub) + a[len(a)-1]
    else:
        x = lcs(a, bSub)
        y = lcs(aSub, b)
        if len(x) > len(y):
            return x
        else:
            return y",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes,Safe primes and unsafe primes,"Definitions

   A   safe prime   is a prime   p   and where   (p-1)/2   is also prime.
   The corresponding prime  (p-1)/2   is known as a   Sophie Germain   prime.
   An   unsafe prime   is a prime   p   and where   (p-1)/2   isn't   a prime.
   An   unsafe prime   is a prime that   isn't   a   safe   prime.


Task

   Find and display (on one line) the first   35   safe primes.
   Find and display the   count   of the safe primes below   1,000,000.
   Find and display the   count   of the safe primes below 10,000,000.
   Find and display (on one line) the first   40   unsafe primes.
   Find and display the   count   of the unsafe primes below   1,000,000.
   Find and display the   count   of the unsafe primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   strong and weak primes.


Also see

   The OEIS article:     safe   primes.
   The OEIS article:   unsafe primes.

",Python,"primes =[]
sp =[]
usp=[]
n = 10000000
if 2<n:
    primes.append(2)
for i in range(3,n+1,2):
    for j in primes:
        if(j>i/2) or (j==primes[-1]):
            primes.append(i)
            if((i-1)/2) in primes:
                sp.append(i)
                break
            else:
                usp.append(i)
                break
        if (i%j==0):
            break
 
print('First 35 safe primes are:\n' , sp[:35])
print('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')
print('There are '+str(len(sp))+' safe primes below 10,000,000')
print('First 40 unsafe primes:\n',usp[:40])
print('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')
print('There are '+str(len(usp))+' safe primes below 10,000,000')",Human_written,Python_from_Java
http://rosettacode.org/wiki/GUI/Maximum_window_dimensions,GUI/Maximum window dimensions,"The task is to determine the maximum height and width of a window that can fit within the physical display area of the screen without scrolling.

This is effectively the screen size (not the total desktop area, which could be bigger than the screen display area) in pixels minus any adjustments for window decorations and menubars.

The idea is to determine the physical display parameters for the maximum height and width of the usable display area in pixels (without scrolling).

The values calculated should represent the usable desktop area of a window maximized to fit the the screen.



Considerations

--- Multiple Monitors

For multiple monitors, the values calculated should represent the size of the usable display area on the monitor which is related to the task (i.e.:   the monitor which would display a window if such instructions were given).

--- Tiling Window Managers
For a tiling window manager, the values calculated should represent the maximum height and width of the display area of the maximum size a window can be created (without scrolling). This would typically be a full screen window (minus any areas occupied by desktop bars), unless the window manager has restrictions that prevents the creation of a full screen window, in which case the values represent the usable area of the desktop that occupies the maximum permissible window size (without scrolling).



",Python,"import clr
clr.AddReference(""System.Windows.Forms"")
from System.Windows.Forms import Screen
 
bounds = Screen.PrimaryScreen.Bounds
print(f""Primary screen bounds:  {bounds.Width}x{bounds.Height}"")
 
workingArea = Screen.PrimaryScreen.WorkingArea
print(f""Primary screen working area:  {workingArea.Width}x{workingArea.Height}"")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Pseudo-random_numbers/Middle-square_method,Pseudo-random numbers/Middle-square method,"Middle-square_method Generator 
 The Method

To generate a sequence of n-digit pseudorandom numbers, an n-digit starting value is created and squared, producing a 2n-digit number. If the result has fewer than 2n digits, leading zeroes are added to compensate. The middle n digits of the result would be the next number in the sequence and returned as the result. This process is then repeated to generate more numbers.

 Pseudo code

var seed = 675248
function random()
    var s = str(seed * seed) 'str: turn a number into string
    do while not len(s) = 12
        s = ""0"" + s          'add zeroes before the string
    end do
    seed = val(mid(s, 4, 6)) 'mid: string variable, start, length
                             'val: turn a string into number
    return seed
end function

 Middle-square method use

for i = 1 to 5
    print random()
end for

Task

 Generate a class/set of functions that generates pseudo-random
numbers (6 digits) as shown above.

 Show the first five integers generated with the seed 675248 as shown above.
 Show your output here, on this page.",Python,"seed = 675248
def random():
    global seed
    s = str(seed ** 2)
    while len(s) != 12:
        s = ""0"" + s
    seed = int(s[3:9])
    return seed
for i in range(0,5):
    print(random())",Human_written,Python_from_C
http://rosettacode.org/wiki/Associative_array/Iteration,Associative array/Iteration,"Show how to iterate over the key-value pairs of an associative array, and print each pair out.

Also show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"myhash = {} #a new, empty object
myhash[""hello""] = 3
myhash.world = 6 #obj.name is equivalent to obj[""name""] for certain values of name
myhash[""!""] = 9
 
#iterate using for..in loop
for key in myhash:
  #ensure key is in object and not in prototype
  if key in myhash:
    print ""Key is: "" + key + '. Value is:'+ myhash[key]
 
#iterate using ES5.1 Object.keys() and Array.prototype.Map()
keys = Object.keys() #get Array of object keys (doesn't get prototype keys)
keys.map(lambda key: print ""Key is: "" + key + '. Value is:'+ myhash[key])",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Horizontal_sundial_calculations,Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",Python,"from __future__ import print_function
import math
try: raw_input
except: raw_input = input
 
lat = float(raw_input(""Enter latitude       => ""))
lng = float(raw_input(""Enter longitude      => ""))
ref = float(raw_input(""Enter legal meridian => ""))
print()
 
slat = math.sin(math.radians(lat))
print(""    sine of latitude:   %.3f"" % slat)
print(""    diff longitude:     %.3f"" % (lng-ref))
print()
print(""Hour, sun hour angle, dial hour line angle from 6am to 6pm"")
 
for h in range(-6, 7):
  hra = 15 * h
  hra -= lng - ref
  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))
  print(""HR=%3d; HRA=%7.3f; HLA=%7.3f"" % (h, hra, hla))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Amicable_pairs,Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",Python,"h = {}
for n in range(1,20001):
    h[n] = sum(proper_divisors(n))
for key,val in h.items():
    if h[val] == key and key < val:
        print(key,val)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",Python,"# version 1.1.3
 
def identity_matrix(n):
    assert n >= 1
    ident = [[0.0] * n for _ in range(n)]
    for i in range(n):
        ident[i][i] = 1.0
    return ident
 
def matrix_pow(m, n):
    assert n >= 0 and len(m) == len(m[0])
    if n == 0:
        return identity_matrix(len(m))
    if n == 1:
        return m
    pow = identity_matrix(len(m))
    base = m
    e = n
    while e > 0:
        if (e & 1) == 1:
            pow = matrix_mul(pow, base)
        e = e >> 1
        base = matrix_mul(base, base)
    return pow
 
def matrix_mul(m1, m2):
    rows1 = len(m1)
    cols1 = len(m1[0])
    rows2 = len(m2)
    cols2 = len(m2[0])
    assert cols1 == rows2
    result = [[0.0] * cols2 for _ in range(rows1)]
    for i in range(rows1):
        for j in range(cols2):
            for k in range(rows2):
                result[i][j] += m1[i][k] * m2[k][j]
    return result
 
def print_matrix(m, n):
    print(""** Power of"", n, ""**"")
    for i in range(len(m)):
        print(m[i])
    print()
 
m = [[3.0, 2.0], [2.0, 1.0]]
for i in range(11):
    print_matrix(matrix_pow(m, i), i)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/File_size_distribution,File size distribution,"Task

Beginning from the current directory, or optionally from a directory specified as a command-line argument, determine how many files there are of various sizes in a directory hierarchy.



My suggestion is to sort by logarithmn of file size, since a few bytes here or there, or even a factor of two or three, may not be that significant.

Don't forget that empty files may exist, to serve as a marker.



Is your file system predominantly devoted to a large number of smaller files, or a smaller number of huge files?



",Python,"# version 1.2.10
 
import os
import math
 
def fileSizeDistribution(path):
    sizes = [0] * 12
    files = os.walk(path)
    accessible = 0
    notAccessible = 0
    totalSize = 0
    for root, dirs, files in files:
        for file in files:
            try:
                f = os.path.join(root, file)
                len = os.path.getsize(f)
                accessible += 1
                if len == 0:
                    sizes[0] += 1
                    continue
                totalSize += len
                logLen = math.log10(len)
                index = math.floor(logLen)
                sizes[index + 1] += 1
            except:
                notAccessible += 1
    print(""File size distribution for '%s' :-\n"" % path)
    for i in range(0, len(sizes)):
        print((""%s Files less than 10 ^ %2d bytes : %5d"" % (""  "" if i == 0 else ""+ "", i, sizes[i])))
    print(""                                  -----"")
    print(""= Number of accessible files    : %5d"" % accessible)
    print(""\n  Total size in bytes           : %d"" % totalSize)
    print(""\n  Number of inaccessible files  : %5d"" % notAccessible)
 
fileSizeDistribution(""./"")  # current directory",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Kronecker_product,Kronecker product,"Kronecker product

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Implement the   Kronecker product   of two matrices (arbitrary sized) resulting in a block matrix. 




Test cases

Show results for each of the following two samples:




Sample 1 (from Wikipedia):



          ┌   ┐     ┌   ┐     ┌           ┐
          │1 2│     │0 5│     │ 0  5  0 10│
          │3 4│  x  │6 7│  =  │ 6  7 12 14│
	  └   ┘     └   ┘     │ 0 15  0 20│
	                      │18 21 24 28│
                              └           ┘ 

Sample 2:

          ┌     ┐     ┌       ┐     ┌                       ┐       
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
          │1 1 1│  x  │1 0 0 1│  =  │0 0 0 0 1 0 0 1 0 0 0 0│
          │0 1 0│     │1 1 1 1│     │0 0 0 0 1 1 1 1 0 0 0 0│
	  └     ┘     └       ┘     │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │1 0 0 1 1 0 0 1 1 0 0 1│
                                    │1 1 1 1 1 1 1 1 1 1 1 1│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    │0 0 0 0 1 0 0 1 0 0 0 0│
                                    │0 0 0 0 1 1 1 1 0 0 0 0│
                                    └                       ┘



See implementations and results below in JavaScript and PARI/GP languages.



Related task

  Kronecker product based fractals. 

",Python,"#!/usr/bin/env python3
 
# Sample 1
a1 = [[1, 2], [3, 4]]
b1 = [[0, 5], [6, 7]]
 
# Sample 2
a2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]
b2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]
 
def kronecker(matrix1, matrix2):
    final_list = []
    sub_list = []
 
    count = len(matrix2)
 
    for elem1 in matrix1:
        counter = 0
        check = 0
        while check < count:
            for num1 in elem1:
                for num2 in matrix2[counter]:
                    sub_list.append(num1 * num2)
            counter += 1
            final_list.append(sub_list)
            sub_list = []
            check +=1
 
    return final_list
 
# Result 1
result1 = kronecker(a1, b1)
for elem in result1:
    print(elem)
 
print("""")
 
# Result 2
result2 = kronecker(a2, b2)
for elem in result2:
    print(elem)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sort_stability,Sort stability,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


When sorting records in a table by a particular column or field, a stable sort will always retain the relative order of records that have the same key.



Example

In this table of countries and cities, a stable sort on the second column, the cities, would keep the   US Birmingham   above the   UK Birmingham.

(Although an unstable sort might, in this case, place the   US Birmingham   above the   UK Birmingham,   a stable sort routine would guarantee it).

UK  London
US  New York
US  Birmingham
UK  Birmingham

Similarly, stable sorting on just the first column would generate UK London as the first item and US Birmingham as the last item   (since the order of the elements having the same first word –   UK or US   – would be maintained).



Task

   Examine the documentation on any in-built sort routines supplied by a language.
   Indicate if an in-built routine is supplied
   If supplied, indicate whether or not the in-built routine is stable.


(This Wikipedia table shows the stability of some common sort routines).



",Python,"# First, define a bernoulli sample, of length 26.
x <- sample(c(0, 1), 26, replace=T)
 
x
# [1] 1 1 1 1 0 1 1 0 1 0 1 1 1 0 1 1 0 1 0 1 0 1 1 0 1 0
 
# Give names to the entries. ""letters"" is a builtin value
names(x) <- letters
 
x
# a b c d e f g h i j k l m n o p q r s t u v w x y z
# 1 1 1 1 0 1 1 0 1 0 1 1 1 0 1 1 0 1 0 1 0 1 1 0 1 0
 
# The unstable one, see how ""a"" appears after ""l"" now
sort(x, method=""quick"")
# z h s u e q x n j r t v w y p o m l a i g f d c b k
# 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 
# The stable sort, letters are ordered in each section
sort(x, method=""shell"")
# e h j n q s u x z a b c d f g i k l m o p r t v w y
# 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",Human_written,Python_from_Java
http://rosettacode.org/wiki/Long_year,Long year,"Most years have 52 weeks, some have 53, according to ISO8601.



Task

Write a function which determines if a given year is long (53 weeks) or not, and demonstrate it.



",Python,"from math import floor
 
def p(year):
	return (year + floor(year/4) - floor(year/100) + floor(year/400)) % 7
 
def is_long_year(year):
	return p(year) == 4 or p(year - 1) == 3
 
def print_long_years(from_year, to_year):
	for year in range(from_year, to_year + 1):
		if is_long_year(year):
			print(year, end=' ')
 
print(""Long (53 week) years between 1800 and 2100\n\n"")
print_long_years(1800, 2100)
print()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Anti-primes,Anti-primes,"The anti-primes
(or highly composite numbers, sequence A002182 in the OEIS)
are the natural numbers with more factors than any smaller than itself.



Task

Generate and show here, the first twenty anti-primes.



Related tasks

   Factors of an integer
   Sieve of Eratosthenes

",Python,"from itertools import chain, count, cycle, islice, accumulate
 
def factors(n):
    def prime_powers(n):
        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):
            if c*c > n: break
            if n%c: continue
            d,p = (), c
            while not n%c:
                n,p,d = n//c, p*c, d+(p,)
            yield d
        if n > 1: yield n,
 
    r = [1]
    for e in prime_powers(n):
        r += [a*b for a in r for b in e]
    return r
 
def antiprimes():
    mx = 0
    yield 1
    for c in count(2,2):
        if c >= 58: break
        ln = len(factors(c))
        if ln > mx:
            yield c
            mx = ln
    for c in count(60,30):
        ln = len(factors(c))
        if ln > mx:
            yield c
            mx = ln  
 
if __name__ == '__main__':
    print(*islice(antiprimes(), 40)))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/FizzBuzz,FizzBuzz,"Task

Write a program that prints the integers from   1   to   100   (inclusive).



But:

   for multiples of three,   print   Fizz     (instead of the number)
   for multiples of five,   print   Buzz     (instead of the number)
   for multiples of both three and five,   print   FizzBuzz     (instead of the number) 


The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.



Also see

   (a blog)   dont-overthink-fizzbuzz
   (a blog)   fizzbuzz-the-programmers-stairway-to-heaven

",Python,"for i in xrange(1, 101):
    if i % 15 == 0:
        print ""FizzBuzz""
    elif i % 3 == 0:
        print ""Fizz""
    elif i % 5 == 0:
        print ""Buzz""
    else:
        print i",Human_written,Python_from_C#
http://rosettacode.org/wiki/Polyspiral,Polyspiral,"A Polyspiral is a spiral made of multiple line segments, whereby each segment is larger (or smaller) than the previous one by a given amount. Each segment also changes direction at a given angle.



Task
Animate a series of polyspirals, by drawing a complete spiral then incrementing the angle, and (after clearing the background) drawing the next, and so on. Every spiral will be a frame of the animation. The animation may stop as it goes full circle or continue indefinitely. The given input values may be varied.

If animation is not practical in your programming environment, you may show a single frame instead.



Pseudo code
    set incr to 0.0

    // animation loop
    WHILE true 

        incr = (incr + 0.05) MOD 360
        x = width / 2
        y = height / 2
        length = 5
        angle = incr

        // spiral loop
        FOR 1 TO 150
            drawline
            change direction by angle
            length = length + 3
            angle = (angle + incr) MOD 360
        ENDFOR
    


",Python,"from PIL import Image

im = Image.open(""polyspiral.gif"")
im.seek(0)

try:
    while 1:
        im.seek(im.tell()+1)
        im.save(""polyspiral2.gif"", save_all=True, append_images=[im])
except EOFError:
    pass",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Filter,Filter,"Task

Select certain elements from an Array into a new Array in a generic way.



To demonstrate, select all even numbers from an Array.

As an option, give a second solution which filters destructively,
by modifying the original Array rather than creating a new Array.



",Python,"values = range(10)
evens = [x for x in values if not x & 1]
ievens = (x for x in values if not x & 1) # lazy
# alternately but less idiomatic:
evens = filter(lambda x: not x & 1, values)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Apply_a_callback_to_an_array,Apply a callback to an array,"Task

Take a combined set of elements and apply a function to each element.



",Python,"def countWords(text):
    ret = {}
    words = text.split()
    for i in range(len(words)):
        word = words[i]
        if word not in ret:
            ret[word] = 1
        else:
            ret[word] += 1
    return ret

countWords(""one two three two one"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sequence_of_non-squares,Sequence of non-squares,"Task

Show that the following remarkable formula gives the sequence of non-square natural numbers:

            n + floor(1/2 + sqrt(n)) 

 Print out the values for    n    in the range   1   to   22
 Show that no squares occur for    n    less than one million


This is sequence   A000037   in the OEIS database.



",Python,"public class SeqNonSquares {
    public static int nonsqr(int n) {
        return n + (int)Math.round(Math.sqrt(n));
    }
 
    public static void main(String[] args) {
        // first 22 values (as a list) has no squares:
        for (int i = 1; i < 23; i++)
            System.out.print(nonsqr(i) + "" "");
        System.out.println();
 
        // The following check shows no squares up to one million:
        for (int i = 1; i < 1000000; i++) {
            double j = Math.sqrt(nonsqr(i));
            assert j!= Math.floor(j);
        }
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Fusc_sequence,Fusc sequence,"

Definitions

The   fusc   integer sequence is defined as:

   fusc(0) = 0
   fusc(1) = 1
   for n>1,   the   nth   term is defined as:
   if   n   is even;     fusc(n) = fusc(n/2)
   if   n   is   odd;     fusc(n) = fusc((n-1)/2)   +   fusc((n+1)/2)


Note that MathWorld's definition starts with unity, not zero.   This task will be using the OEIS' version   (above).



An observation

   fusc(A) = fusc(B)
where   A   is some non-negative integer expressed in binary,   and
where   B   is the binary value of   A   reversed.



Fusc numbers are also known as:

   fusc function   (named by Dijkstra, 1982)
   Stern's Diatomic series   (although it starts with unity, not zero)
   Stern-Brocot sequence   (although it starts with unity, not zero)


Task

   show the first   61   fusc numbers (starting at zero) in a horizontal format.
   show the fusc number (and its index) whose length is greater than any previous fusc number length.
   (the length is the number of decimal digits when the fusc number is expressed in base ten.)
   show all numbers with commas   (if appropriate).
   show all output here.


Related task

   RosettaCode Stern-Brocot sequence


Also see

   the MathWorld entry:   Stern's Diatomic Series.
   the OEIS entry:   A2487.

",Python,"from collections import deque
from itertools import islice, count
 
 
def fusc():
    q = deque([1])
    yield 0
    yield 1
 
    while True:
        x = q.popleft()
        q.append(x)
        yield x
 
        x += q[0]
        q.append(x)
        yield x
 
 
def longest_fusc():
    sofar = 0
    for i, f in zip(count(), fusc()):
        if f >= sofar:
            yield(i, f)
            sofar = 10 * sofar or 10
 
 
print('First 61:')
print(list(islice(fusc(), 61)))
 
print('\nLength records:')
for i, f in islice(longest_fusc(), 6):
    print(f'fusc({i}) = {f}')",Human_written,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort,Sorting algorithms/Selection sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of elements using the Selection sort algorithm.



It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.



Its asymptotic complexity is    O(n2)    making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.



References

   Rosetta Code:   O     (complexity).
   Wikipedia:   Selection sort.
   Wikipedia:   [Big O notation].

",Python,"def selection_sort(a):
    for i in range(len(a) - 1):
        k = i
        for j in range(i + 1, len(a)):
            if a[j] < a[k]:
                k = j
 
        if k!= i:
            a[i], a[k] = a[k], a[i]
 
if __name__ == '__main__':
    i = [4, 9, 3, -2, 0, 7, -5, 1, 6, 8]
    selection_sort(i)
    print(i)
 
    s = [-x for x in i]
    selection_sort(s)
    print(s)
 
    c = ['z', 'h', 'd', 'c', 'a']
    selection_sort(c)
    print(c)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/S-expressions,S-expressions,"S-Expressions   are one convenient way to parse and store data.



Task

Write a simple reader and writer for S-Expressions that handles quoted and unquoted strings, integers and floats.

The reader should read a single but nested S-Expression from a string and store it in a suitable datastructure (list, array, etc).

Newlines and other whitespace may be ignored unless contained within a quoted string.

“()”   inside quoted strings are not interpreted, but treated as part of the string.

Handling escaped quotes inside a string is optional;   thus “(foo""bar)” maybe treated as a string “foo""bar”, or as an error.

For this, the reader need not recognize “\” for escaping, but should, in addition, recognize numbers if the language has appropriate datatypes.

Languages that support it may treat unquoted strings as symbols.

Note that with the exception of “()""” (“\” if escaping is supported) and whitespace there are no special characters. Anything else is allowed without quotes.

The reader should be able to read the following input

((data ""quoted data"" 123 4.5)
 (data (!@# (4.5) ""(more"" ""data)"")))
and turn it into a native datastructure. (see the Pike, Python and Ruby implementations for examples of native data structures.)

The writer should be able to take the produced list and turn it into a new S-Expression.
Strings that don't contain whitespace or parentheses () don't need to be quoted in the resulting S-Expression, but as a simplification, any string may be quoted.



Extra Credit

Let the writer produce pretty printed output with indenting and line-breaks.



",Python,"import io
import re
import sys
import tokenize
 
class Token:
    def __init__(self, ttype, value):
        self.ttype = ttype
        self.value = value
 
class LispTokenizer:
    def __init__(self, src):
        self.src = src
        self.tokenizer = tokenize.generate_tokens(io.StringIO(src).readline)
        self.ioexn = None
 
    def peekToken(self):
        if self.ioexn is not None:
            return None
        try:
            token = next(self.tokenizer)
        except tokenize.TokenError as e:
            self.ioexn = e
            return None
        if token[0] == tokenize.ENDMARKER:
            return None
        return Token(token[0], token[1])
 
    def hasNext(self):
        if self.ioexn is not None:
            return False
        try:
            token = next(self.tokenizer)
        except tokenize.TokenError as e:
            self.ioexn = e
            return False
        if token[0] == tokenize.ENDMARKER:
            return False
        return True
 
    def getIOException(self):
        return self.ioexn
 
    def next(self):
        try:
            token = next(self.tokenizer)
        except tokenize.TokenError as e:
            self.ioexn = e
            return None
        return Token(token[0], token[1])
 
    def remove(self):
        pass",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Subtractive_generator,Subtractive generator,"A subtractive generator calculates a sequence of random numbers, where each number is congruent to the subtraction of two previous numbers from the sequence. 

The formula is

 




r

n


=

r

(
n
−
i
)


−

r

(
n
−
j
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-i)}-r_{(n-j)}{\pmod {m}}}


for some fixed values of 



i


{\displaystyle i}

, 



j


{\displaystyle j}

 and 



m


{\displaystyle m}

, all positive integers. Supposing that 



i
>
j


{\displaystyle i>j}

, then the state of this generator is the list of the previous numbers from 




r

n
−
i




{\displaystyle r_{n-i}}

 to 




r

n
−
1




{\displaystyle r_{n-1}}

. Many states generate uniform random integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

, but some states are bad. A state, filled with zeros, generates only zeros. If 



m


{\displaystyle m}

 is even, then a state, filled with even numbers, generates only even numbers. More generally, if 



f


{\displaystyle f}

 is a factor of 



m


{\displaystyle m}

, then a state, filled with multiples of 



f


{\displaystyle f}

, generates only multiples of 



f


{\displaystyle f}

.

All subtractive generators have some weaknesses. The formula correlates 




r

n




{\displaystyle r_{n}}

, 




r

(
n
−
i
)




{\displaystyle r_{(n-i)}}

 and 




r

(
n
−
j
)




{\displaystyle r_{(n-j)}}

; these three numbers are not independent, as true random numbers would be. Anyone who observes 



i


{\displaystyle i}

 consecutive numbers can predict the next numbers, so the generator is not cryptographically secure. The authors of Freeciv (utility/rand.c) and xpat2 (src/testit2.c) knew another problem: the low bits are less random than the high bits.

The subtractive generator has a better reputation than the linear congruential generator, perhaps because it holds more state. A subtractive generator might never multiply numbers: this helps where multiplication is slow. A subtractive generator might also avoid division: the value of 




r

(
n
−
i
)


−

r

(
n
−
j
)




{\displaystyle r_{(n-i)}-r_{(n-j)}}

 is always between 



−
m


{\displaystyle -m}

 and 



m


{\displaystyle m}

, so a program only needs to add 



m


{\displaystyle m}

 to negative numbers.

The choice of 



i


{\displaystyle i}

 and 



j


{\displaystyle j}

 affects the period of the generator. A popular choice is 



i
=
55


{\displaystyle i=55}

 and 



j
=
24


{\displaystyle j=24}

, so the formula is

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {m}}}


The subtractive generator from xpat2 uses

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod


10

9


)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {10^{9}}}}


The implementation is by J. Bentley and comes from program_tools/universal.c of the DIMACS (netflow) archive at Rutgers University. It credits Knuth, TAOCP, Volume 2, Section 3.2.2 (Algorithm A).

Bentley uses this clever algorithm to seed the generator.

 Start with a single 



s
e
e
d


{\displaystyle seed}

 in range 



0


{\displaystyle 0}

 to 




10

9


−
1


{\displaystyle 10^{9}-1}

.
 Set 




s

0


=
s
e
e
d


{\displaystyle s_{0}=seed}

 and 




s

1


=
1


{\displaystyle s_{1}=1}

. The inclusion of 




s

1


=
1


{\displaystyle s_{1}=1}

 avoids some bad states (like all zeros, or all multiples of 10).
 Compute 




s

2


,

s

3


,
.
.
.
,

s

54




{\displaystyle s_{2},s_{3},...,s_{54}}

 using the subtractive formula 




s

n


=

s

(
n
−
2
)


−

s

(
n
−
1
)




(
mod


10

9


)



{\displaystyle s_{n}=s_{(n-2)}-s_{(n-1)}{\pmod {10^{9}}}}

.
 Reorder these 55 values so 




r

0


=

s

34




{\displaystyle r_{0}=s_{34}}

, 




r

1


=

s

13




{\displaystyle r_{1}=s_{13}}

, 




r

2


=

s

47




{\displaystyle r_{2}=s_{47}}

, ..., 




r

n


=

s

(
34
∗
(
n
+
1
)


(
mod

55
)

)




{\displaystyle r_{n}=s_{(34*(n+1){\pmod {55}})}}

.
 This is the same order as 




s

0


=

r

54




{\displaystyle s_{0}=r_{54}}

, 




s

1


=

r

33




{\displaystyle s_{1}=r_{33}}

, 




s

2


=

r

12




{\displaystyle s_{2}=r_{12}}

, ..., 




s

n


=

r

(
(
34
∗
n
)
−
1


(
mod

55
)

)




{\displaystyle s_{n}=r_{((34*n)-1{\pmod {55}})}}

.
 This rearrangement exploits how 34 and 55 are relatively prime.
 Compute the next 165 values 




r

55




{\displaystyle r_{55}}

 to 




r

219




{\displaystyle r_{219}}

. Store the last 55 values.
This generator yields the sequence 




r

220




{\displaystyle r_{220}}

, 




r

221




{\displaystyle r_{221}}

, 




r

222




{\displaystyle r_{222}}

 and so on. For example, if the seed is 292929, then the sequence begins with 




r

220


=
467478574


{\displaystyle r_{220}=467478574}

, 




r

221


=
512932792


{\displaystyle r_{221}=512932792}

, 




r

222


=
539453717


{\displaystyle r_{222}=539453717}

. By starting at 




r

220




{\displaystyle r_{220}}

, this generator avoids a bias from the first numbers of the sequence. This generator must store the last 55 numbers of the sequence, so to compute the next 




r

n




{\displaystyle r_{n}}

. Any array or list would work; a ring buffer is ideal but not necessary.

Implement a subtractive generator that replicates the sequences from xpat2.



",Python,"# written for clarity not efficiency.
 
from collections import deque
 
class Subtractive_generator:
    param_i = 55
    param_j = 24
    initial_load = 219
    mod = 1e9
    def __init__(self, seed):
        self.r = deque(maxlen=Subtractive_generator.param_i)
        s = [0] * Subtractive_generator.param_i
        s[0] = seed
        s[1] = 1
        for n in range(2, Subtractive_generator.param_i):
            t = s[n-2]-s[n-1]
            if t < 0:
                t += Subtractive_generator.mod
            s[n] = t
 
        for n in range(Subtractive_generator.param_i):
            i = (34 * (n+1)) % Subtractive_generator.param_i
            self.r.append(s[i])
        for n in range(Subtractive_generator.param_i, Subtractive_generator.initial_load):
            self.next()
 
    def next(self):
        t = self.r[0]-self.r[31]
        if t < 0:
            t += Subtractive_generator.mod
        self.r.append(t)
        return self.r[Subtractive_generator.param_i-1]
 
    def __call__(self):
        return self.next()
 
rg = Subtractive_generator(292929)
 
print(""result = "", rg())
print(""result = "", rg())
print(""result = "", rg())
print(""result = "", rg())
print(""result = "", rg())
print(""result = "", rg())
print(""result = "", rg())",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Jewels_and_stones,Jewels and stones,"Jewels and stones

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.

Both strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.

The function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.



Note that:

 Only letters in the ISO basic Latin alphabet i.e. 'A to Z' or 'a to z' need be considered. 
 A lower case letter is considered to be different from its upper case equivalent for this purpose, i.e., 'a' != 'A'.
 The parameters do not need to have exactly the same names.
 Validating the arguments is unnecessary. 
So, for example, if passed ""aAAbbbb"" for 'stones' and ""aA"" for 'jewels', the function should return 3.

This task was inspired by this problem.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# canConstruct :: String -> String -> Bool
def canConstruct(ransomNote, magazine):
    r = list(ransomNote)
    m = list(magazine)
    return len([c for c in r if c in m]) == len(r)
 
# TEST -----------------------------------------------
print(list(map(lambda x: canConstruct(*x), [
            ['a', 'b'],
            ['aa', 'ab'],
            ['aa', 'aab']
        ])))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"from __future__ import print_function
import re
import os
import sys
import csv

# splitRegex :: Regex -> String -> [String]
def splitRegex(rgx, s):
    return s.split(rgx)

# lines :: String -> [String]
def lines(s):
    return s.splitlines()

# unlines :: [String] -> String
def unlines(xs):
    return '\n'.join(xs)

# readFile :: FilePath -> maybe String
def readFile(strPath):
    try:
        with open(strPath, 'r') as f:
            return f.read()
    except IOError as e:
        return e

# writeFile :: FilePath -> String -> IO ()
def writeFile(strPath, strText):
    with open(strPath, 'w') as f:
        f.write(strText)

# EXAMPLE - appending a SUM column

delimCSV = re.compile(r',\s*')

strSummed = unlines(
    [
        ','.join(
            xs + (
                [
                    # 'SUM' appended to first line, others summed.
                    sum(
                        [int(x) for x in xs]
                    )
                ] if i > 0 else ['SUM']
            )
        )
        for i, xs in enumerate(
            [splitRegex(delimCSV, x) for x in lines(readFile(os.path.expanduser('~/csvSample.txt')))]
        )
    ]
)

print(
    writeFile(os.path.expanduser('~/csvSampleSummed.txt'), strSummed),
    strSummed
)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes,Safe primes and unsafe primes,"Definitions

   A   safe prime   is a prime   p   and where   (p-1)/2   is also prime.
   The corresponding prime  (p-1)/2   is known as a   Sophie Germain   prime.
   An   unsafe prime   is a prime   p   and where   (p-1)/2   isn't   a prime.
   An   unsafe prime   is a prime that   isn't   a   safe   prime.


Task

   Find and display (on one line) the first   35   safe primes.
   Find and display the   count   of the safe primes below   1,000,000.
   Find and display the   count   of the safe primes below 10,000,000.
   Find and display (on one line) the first   40   unsafe primes.
   Find and display the   count   of the unsafe primes below   1,000,000.
   Find and display the   count   of the unsafe primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   strong and weak primes.


Also see

   The OEIS article:     safe   primes.
   The OEIS article:   unsafe primes.

",Python,"from itertools import islice, count
from math import sqrt
 
def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True
 
def is_safe_prime(n):
    if not is_prime(n):
        return False
    return is_prime((n - 1) // 2)
 
def format_parts(n):
    safes = len(list(islice(filter(is_safe_prime, count(1)), n)))
    unsafes = len(list(islice(filter(lambda x: not is_safe_prime(x), count(1)), n)))
    return ""There are %d safes and %d unsafes below %d."" % (safes, unsafes, n)
 
print(""First 35 safe-primes:"")
print(list(islice(filter(is_safe_prime, count(1)), 35)))
print(format_parts(1000000), ""\n"")
 
print(""First 40 unsafe-primes:"")
print(list(islice(filter(lambda x: not is_safe_prime(x), count(1)), 40)))
print(format_parts(10000000))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Anti-primes,Anti-primes,"The anti-primes
(or highly composite numbers, sequence A002182 in the OEIS)
are the natural numbers with more factors than any smaller than itself.



Task

Generate and show here, the first twenty anti-primes.



Related tasks

   Factors of an integer
   Sieve of Eratosthenes

",Python,"from __future__ import print_function
 
def countDivisors(n):
    count = 2 # 1 and n
    for i in range(2, n//2 + 1):
        if n%i == 0:
            count += 1
    return count
 
count = 0
maxDiv = 0
for n in range(1, 1000000000):
    d = countDivisors(n)
    if d > maxDiv:
        print(n, end=' ')
        maxDiv = d
        count += 1
    if count == 20:
        break
print()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Arithmetic_evaluation,Arithmetic evaluation,"Create a program which parses and evaluates arithmetic expressions.

Requirements

 An abstract-syntax tree (AST) for the expression must be created from parsing the input. 
 The AST must be used in evaluation, also, so the input may not be directly evaluated (e.g. by calling eval or a similar language feature.) 
 The expression will be a string or list of symbols like ""(1+3)*7"". 
 The four symbols + - * / must be supported as binary operators with conventional precedence rules. 
 Precedence-control parentheses must also be supported.


Note

For those who don't remember, mathematical precedence is as follows:

 Parentheses
 Multiplication/Division (left to right)
 Addition/Subtraction (left to right)


C.f
 
 24 game Player.
 Parsing/RPN calculator algorithm.
 Parsing/RPN to infix conversion.

",Python,"import operator
 
class AstNode(object):
   def __init__( self, opr, left, right ):
      self.opr = opr
      self.l = left
      self.r = right
 
   def eval(self):
      return self.opr(self.l.eval(), self.r.eval())
 
class LeafNode(object):
   def __init__( self, valStrg ):
      self.v = int(valStrg)
 
   def eval(self):
      return self.v
 
class Yaccer(object):
   def __init__(self):
      self.operstak = []
      self.nodestak =[]
      self.__dict__.update(self.state1)
 
   def v1( self, valStrg ):
      # Value String
      self.nodestak.append( LeafNode(valStrg))
      self.__dict__.update(self.state2)
      #print 'push', valStrg
 
   def o2( self, operchar ):
      # Operator character or open paren in state1
      def openParen(a,b):
         return 0		# function should not be called
 
      opDict= { '+': ( operator.add, 2, 2 ),
         '-': (operator.sub, 2, 2 ),
         '*': (operator.mul, 3, 3 ),
         '/': (operator.div, 3, 3 ),
         '^': ( pow,         4, 5 ),  # right associative exponentiation for grins
         '(': ( openParen,   0, 8 )
         }
      operPrecidence = opDict[operchar][2]
      self.redeuce(operPrecidence)
 
      self.operstak.append(opDict[operchar])
      self.__dict__.update(self.state1)
      # print 'pushop', operchar
 
   def syntaxErr(self, char ):
      # Open Parenthesis 
      print 'parse error - near operator ""%s""' %char
 
   def pc2( self,operchar ):
      # Close Parenthesis
      # reduce node until matching open paren found 
      self.redeuce( 1 )
      if len(self.operstak)>0:
         self.operstak.pop()		# pop off open parenthesis
      else:
         print 'Error - no open parenthesis matches close parens.'
      self.__dict__.update(self.state2)
 
   def end(self):
      self.redeuce(0)
      return self.nodestak.pop()
 
   def redeuce(self, precidence):
      while len(self.operstak)>0:
         tailOper = self.operstak[-1]
         if tailOper[1] < precidence: break
 
         tailOper = self.operstak.pop()
         vrgt = self.nodestak.pop()
         vlft= self.nodestak.pop()
         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))
         # print 'reduce'
 
   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }
   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }
 
 
def Lex( exprssn, p ):
   bgn = None
   cp = -1
   for c in exprssn:
      cp += 1
      if c in '+-/*^()':         # throw in exponentiation (^)for grins
         if bgn is not None:
            p.v(p, exprssn[bgn:cp])
            bgn = None
         if c=='(': p.po(p, c)
         elif c==')':p.pc(p, c)
         else: p.o(p, c)
      elif c in ' \t':
         if bgn is not None:
            p.v(p, exprssn[bgn:cp])
            bgn = None
      elif c in '0123456789':
         if bgn is None:
            bgn = cp
      else:
         print 'Invalid character in expression'
         if bgn is not None:
            p.v(p, exprssn[bgn:cp])
            bgn = None
 
   if bgn is not None:
      p.v(p, exprssn[bgn:cp+1])
      bgn = None
   return p.end()
 
 
expr = raw_input(""Expression:"")
astTree = Lex( expr, Yaccer())
print expr, '=',astTree.eval()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Polymorphic_copy,Polymorphic copy,"An object is polymorphic when its specific type may vary.
The types a specific value may take, is called class.

It is trivial to copy an object if its type is known:

int x;
int y = x;
Here x is not polymorphic, so y is declared of same type (int) as x.
But if the specific type of x were unknown, then y could not be declared of any specific type.

The task: let a polymorphic object contain an instance of some specific type S derived from a type T.
The type T is known.
The type S is possibly unknown until run time.
The objective is to create an exact copy of such polymorphic object (not to create a reference, nor a pointer to).
Let further the type T have a method overridden by S.
This method is to be called on the copy to demonstrate that the specific type of the copy is indeed S.
",Python,"class T(object):
    def name(self):
        return ""T""

    def copy(self):
        try:
            return super(T, self).clone()
        except AttributeError:
            return None

class S(T):
    def name(self):
        return ""S""

def copier(x):
    return x.copy()

if __name__ == ""__main__"":
    obj1 = T()
    obj2 = S()
    print(copier(obj1).name())
    print(copier(obj2).name())",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Fractran,Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",Python,"import sys
from fractions import Fraction
from math import log
 
def compile(src):
    s = src.split()
    r = [Fraction(s1) for s1 in s]
    return r
 
def exec(p, n, limit):
    for i in range(limit):
        print(n, end=' ')
        for j in range(len(p)):
            q, r = divmod(n, p[j].denominator)
            if r == 0:
                n = q * p[j].numerator
                break
        else:
            break
    print()
 
def usage():
    print('usage: ft <limit> <n> <prog>')
    sys.exit(1)
 
if len(sys.argv)!= 4:
    usage()
limit = int(sys.argv[1])
n = int(sys.argv[2])
p = compile(sys.argv[3])
exec(p, n, limit)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"games = ['12', '13', '14', '23', '24', '34']
results = '000000'
 
def next_result():
    global results
    if results == '222222':
        return False
    res = int(results, 3)
    results = '{:06}'.format(res + 1)
    return True
 
def main():
    points = [[0] * 10 for _ in range(4)]
    while True:
        records = [0] * 4
        for i in range(len(games)):
            if results[i] == '2':
                records[int(games[i][0]) - 1] += 3
            elif results[i] == '1':
                records[int(games[i][0]) - 1] += 1
                records[int(games[i][1]) - 1] += 1
            elif results[i] == '0':
                records[int(games[i][1]) - 1] += 3
        records.sort()
        for i in range(4):
            points[3 - i][records[i]] += 1
        if not next_result():
            break
    print('POINTS       0    1    2    3    4    5    6    7    8    9')
    print('-------------------------------------------------------------')
    places = ['1st', '2nd', '3rd', '4th']
    for i in range(4):
        print(places[i], 'place    ', end='')
        for j in range(10):
            print('{:5d}'.format(points[3 - i][j]), end='')
        print()
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Self-describing_numbers,Self-describing numbers,"Self-describing numbers

You are encouraged to solve this task according to the task description, using any language you may know.
There are several so-called ""self-describing"" or ""self-descriptive"" integers.

An integer is said to be ""self-describing"" if it has the property that, when digit positions are labeled 0 to N-1, the digit in each position is equal to the number of times that that digit appears in the number.

For example,   2020   is a four-digit self describing number:

   position   0   has value   2   and there are two 0s in the number;
   position   1   has value   0   and there are no 1s in the number;
   position   2   has value   2   and there are two 2s;
   position   3   has value   0   and there are zero 3s.


Self-describing numbers < 100.000.000  are:     1210,   2020,   21200,   3211000,   42101000.



Task Description
 Write a function/routine/method/... that will check whether a given positive integer is self-describing.
 As an optional stretch goal - generate and display the set of self-describing numbers.


Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-referential sequence
   Spelling of ordinal numbers

",Python,"# version 1.0.6
 
def selfDescribing(n):
    if n <= 0: return False
    ns = str(n)
    count = [0] * 10
    for i in range(len(ns)):
        count[int(ns[i])] += 1
    for i in range(len(ns)):
        if ns[i]!= str(count[i]): return False
    return True
 
print(""The self-describing numbers less than 100 million are:"")
for i in range(100000000):
    if selfDescribing(i): print(i, end="" "")
print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting algorithms/Quicksort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm.

The elements must have a   strict weak order   and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.



Quicksort, also known as   partition-exchange sort,   uses these steps.

   Choose any element of the array to be the pivot.
   Divide all other elements (except the pivot) into two partitions.
   All elements less than the pivot must be in the first partition.
   All elements greater than the pivot must be in the second partition.
   Use recursion to sort both partitions.
   Join the first sorted partition, the pivot, and the second sorted partition.


The best pivot creates partitions of equal length (or lengths differing by   1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.



This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

 ""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

 Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
 Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.


With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.



",Python,"def quicksort(A):
    if len(A) < 2:
        return A
    pivot = A[len(A) / 2]
    left = [x for x in A if x < pivot]
    middle = [x for x in A if x == pivot]
    right = [x for x in A if x > pivot]
    return quicksort(left) + middle + quicksort(right)

print quicksort([4, 65, 2, -31, 0, 99, 2, 83, 782, 1])",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",Python,"import re
import struct
 
class Cidr(object):
    def __init__(self, address, mask_length):
        self.address = address
        self.mask_length = mask_length
 
def cidr_parse(str):
    m = re.match(r'(\d+)\.(\d+)\.(\d+)\.(\d+)/(\d+)', str)
    if not m:
        return None
    a, b, c, d, m = map(int, m.groups())
    if m < 1 or m > 32 or a < 0 or a > 255 or b < 0 or b > 255 or c < 0 or c > 255 or d < 0 or d > 255:
        return None
    mask = ~((1 << (32 - m)) - 1)
    address = (a << 24) + (b << 16) + (c << 8) + d
    address &= mask
    return Cidr(address, m)
 
def cidr_format(cidr):
    address = cidr.address
    d = address & 0xff
    address >>= 8
    c = address & 0xff
    address >>= 8
    b = address & 0xff
    address >>= 8
    a = address & 0xff
    return '%d.%d.%d.%d/%d' % (a, b, c, d, cidr.mask_length)
 
def main():
    tests = [
        '87.70.141.1/22',
        '36.18.154.103/12',
        '62.62.197.11/29',
        '67.137.119.181/4',
        '161.214.74.21/24',
        '184.232.176.184/18'
    ]
    for test in tests:
        cidr = cidr_parse(test)
        if cidr:
            print '%-18s -> %s' % (test, cidr_format(cidr))
        else:
            print '%s: invalid CIDR' % test
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"import os
 
print(os.getenv(""HOME""))
print(os.getenv(""PATH""))
print(os.getenv(""USER""))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Host_introspection,Host introspection,"Print the word size and endianness of the host machine.

See also: Variable size/Get
",Python,"import sys
import os
import struct
import platform
 
def main():
	print(sys.version, platform.system(), platform.machine())
 
	# Inspect a uint32 variable to determine endianness.
	x = 0x01020304
	if struct.pack('I', x)[0] == 0x01:
		print(""big endian"")
	elif struct.pack('I', x)[0] == 0x04:
		print(""little endian"")
	else:
		print(""mixed endian?"")
 
	# Usually one cares about the size the executible was compiled for
	# rather than the actual underlying host's size.
 
	# There are several ways of determining the size of an int/uint.
	print(""         sys.maxsize ="", sys.maxsize)
	# That uses the following definition we can also be done by hand
	intSize = 32 << (1 if sys.maxsize > 2**32 else 0)
	print(""32 << (1 if sys.maxsize > 2**32 else 0) ="", intSize)
 
	# With Go 1.0, 64-bit architectures had 32-bit int and 64-bit
	# uintptr. This was changed in Go 1.1. In general it would
	# still be possible that int and uintptr (the type large enough
	# to hold the bit pattern of any pointer) are of different sizes.
	bitsPerByte = 8
	print(""  sizeof(int)     in bits:"", struct.calcsize('i')*bitsPerByte)
	print(""  sizeof(uintptr) in bits:"", struct.calcsize('P')*bitsPerByte)
	# If we really want to know the architecture size the executable was
	# compiled for and not the size of int it safest to take the max of those.
	archSize = struct.calcsize('i')
	if struct.calcsize('P') > archSize:
		archSize = struct.calcsize('P')
	print(""  compiled with word size:"", archSize*bitsPerByte)
 
	# There are some *very* unportable ways to attempt to get the actual
	# underlying hosts' word size.
	# Inspect cpuinfo to determine word size (some unix-like OS' only).
	with open('/proc/cpuinfo') as f:
		for l in f:
			if l.startswith('flags'):
				for f in l.split():
					if f == 'lm': # ""long mode""
						print(""64 bit word size"")
						return
				print(""32 bit word size"")
				return
 
if __name__ == '__main__':
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Window_creation,Window creation,"Display a GUI window. The window need not have any contents, but should respond to requests to be closed.
",Python,"import Tkinter
 
  w = Tkinter.Tk()
  w.mainloop()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Ternary_logic,Ternary logic,"

 This page uses content from Wikipedia. The original article was at Ternary logic. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In logic, a three-valued logic (also trivalent, ternary, or trinary logic, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value.

This is contrasted with the more commonly known bivalent logics (such as classical sentential or boolean logic) which provide only for true and false.

Conceptual form and basic ideas were initially created by Łukasiewicz, Lewis and Sulski.

These were then re-formulated by Grigore Moisil in an axiomatic algebraic form, and also extended to n-valued logics in 1945.


Example Ternary Logic Operators in Truth Tables:




not a


 ¬


 True 
 False


 Maybe 
 Maybe


 False 
 True




a and b


 ∧

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 False


 False 
 False 
 False 
 False




a or b


 ∨

 True 
 Maybe 
 False


 True 
 True 
 True 
 True


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 Maybe 
 False





if a then b


 ⊃

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 True 
 True




a is equivalent to b


 ≡

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 Maybe


 False 
 False 
 Maybe 
 True




Task

 Define a new type that emulates ternary logic by storing data trits.
 Given all the binary logic operators of the original programming language, reimplement these operators for the new Ternary logic type trit.
 Generate a sampling of results using trit variables.
 Kudos for actually thinking up a test case algorithm where ternary logic is intrinsically useful, optimises the test case algorithm and is preferable to binary logic.


Note:   Setun   (Сетунь) was a   balanced ternary   computer developed in 1958 at   Moscow State University.   The device was built under the lead of   Sergei Sobolev   and   Nikolay Brusentsov.   It was the only modern   ternary computer,   using three-valued ternary logic
",Python,"class Trit(int):
    def __new__(cls, value):
        if value == 'TRUE':
            value = 1
        elif value == 'FALSE':
            value = 0
        elif value == 'MAYBE':
            value = -1
        return super(Trit, cls).__new__(cls, value // (abs(value) or 1)) 
 
    def __repr__(self):
        if self > 0:
            return 'TRUE'
        elif self == 0:
            return 'FALSE'
        return 'MAYBE'
 
    def __str__(self):
        return repr(self)
 
    def __bool__(self):
        if self > 0:
            return True
        elif self == 0:
            return False
        else:
            raise ValueError(""invalid literal for bool(): '%s'"" % self)
 
    def __or__(self, other):
        if isinstance(other, Trit):
            return _ttable[(self, other)][1]
        else:
            try:
                return _ttable[(self, Trit(bool(other)))][1]
            except:
                return NotImplemented
 
    def __ror__(self, other):
        if isinstance(other, Trit):
            return _ttable[(self, other)][1]
        else:
            try:
                return _ttable[(self, Trit(bool(other)))][1]
            except:
                return NotImplemented
 
    def __and__(self, other):
        if isinstance(other, Trit):
            return _ttable[(self, other)][0]
        else:
            try:
                return _ttable[(self, Trit(bool(other)))][0]
            except:
                return NotImplemented
 
    def __rand__(self, other):
        if isinstance(other, Trit):
            return _ttable[(self, other)][0]
        else:
            try:
                return _ttable[(self, Trit(bool(other)))][0]
            except:
                return NotImplemented
 
    def __xor__(self, other):
        if isinstance(other, Trit):
            return _ttable[(self, other)][2]
        else:
            try:
                return _ttable[(self, Trit(bool(other)))][2]
            except:
                return NotImplemented
 
    def __rxor__(self, other):
        if isinstance(other, Trit):
            return _ttable[(self, other)][2]
        else:
            try:
                return _ttable[(self, Trit(bool(other)))][2]
            except:
                return NotImplemented
 
    def __invert__(self):
        return _ttable[self]
 
    def __getattr__(self, name):
        if name in ('_n', 'flip'):
            # So you can do x._n == x.flip; the inverse of x
            # In Python 'not' is strictly boolean so we can't write `not x`
            # Same applies to keywords 'and' and 'or'.
            return _ttable[self]
        else:
            raise AttributeError 
 
 
 
TRUE, FALSE, MAYBE = Trit(1), Trit(0), Trit(-1)
 
_ttable = {
    #    A: -> flip_A
         TRUE: FALSE,
        FALSE:  TRUE,
        MAYBE: MAYBE,
    #     (A, B): -> (A_and_B, A_or_B, A_xor_B)
        (MAYBE, MAYBE): (MAYBE, MAYBE, MAYBE),
        (MAYBE, FALSE): (FALSE, MAYBE, MAYBE),
        (MAYBE,  TRUE): (MAYBE,  TRUE, MAYBE),
        (FALSE, MAYBE): (FALSE, MAYBE, MAYBE),
        (FALSE, FALSE): (FALSE, FALSE, FALSE),
        (FALSE,  TRUE): (FALSE,  TRUE,  TRUE),
        ( TRUE, MAYBE): (MAYBE,  TRUE, MAYBE),
        ( TRUE, FALSE): (FALSE,  TRUE,  TRUE),
        ( TRUE,  TRUE): ( TRUE,  TRUE, FALSE),
    }
 
 
values = ('FALSE', 'TRUE ', 'MAYBE')
 
print(""\nTrit logical inverse, '~'"")
for a in values:
    expr = '~%s' % a
    print('  %s = %s' % (expr, eval(expr)))
 
for op, ophelp in (('&', 'and'), ('|', 'or'), ('^', 'exclusive-or')):
    print(""\nTrit logical %s, '%s'"" % (ophelp, op))
    for a in values:
        for b in values:
            expr = '%s %s %s' % (a, op, b)
            print('  %s = %s' % (expr, eval(expr)))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm,Parsing/RPN calculator algorithm,"Task

Create a stack-based evaluator for an expression in   reverse Polish notation (RPN)   that also shows the changes in the stack as each individual token is processed as a table.



 Assume an input of a correct, space separated, string of tokens of an RPN expression
 Test with the RPN expression generated from the   Parsing/Shunting-yard algorithm   task: 

         3 4 2 * 1 5 - 2 3 ^ ^ / + 

 Print or display the output here


Notes

    ^    means exponentiation in the expression above.
    /    means division.


See also

   Parsing/Shunting-yard algorithm for a method of generating an RPN from an infix expression.
   Several solutions to 24 game/Solve make use of RPN evaluators (although tracing how they work is not a part of that task).
   Parsing/RPN to infix conversion.
   Arithmetic evaluation.

",Python,"def rpn(text):
    tokens = text.split()
    stack = []
    print(""input operation stack"")
 
    for token in tokens:
        print(f""{token:^5}"", end="" "")
        try:
            num = float(token)
            stack.append(num)
            print(f""push      {stack}"")
        except ValueError:
            if token == ""+"":
                b = stack.pop()
                a = stack.pop()
                stack.append(a + b)
            elif token == ""-"":
                b = stack.pop()
                a = stack.pop()
                stack.append(a - b)
            elif token == ""*"":
                b = stack.pop()
                a = stack.pop()
                stack.append(a * b)
            elif token == ""/"":
                b = stack.pop()
                a = stack.pop()
                stack.append(a / b)
            elif token == ""^"":
                b = stack.pop()
                a = stack.pop()
                stack.append(a ** b)
            else:
                raise ValueError(f""unknown operator {token}"")
            print(f""calculate {stack}"")
 
    return stack.pop() if stack else 0.0
 
if __name__ == ""__main__"":
    text = ""3 4 2 * 1 5 - 2 3 ^ ^ / +""
 
    print(f""\nresult: {rpn(text)}"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort,Sorting algorithms/Cocktail sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The cocktail shaker sort is an improvement on the Bubble Sort.

The improvement is basically that values ""bubble"" both directions through the array, because on each iteration the cocktail shaker sort bubble sorts once forwards and once backwards. Pseudocode for the algorithm (from wikipedia):

function cocktailSort( A : list of sortable items )
 do
   swapped := false
   for each i in 0 to length( A ) - 2 do
     if A[ i ] > A[ i+1 ] then // test whether the two 
                               // elements are in the wrong 
                               // order
       swap( A[ i ], A[ i+1 ] ) // let the two elements
                                // change places
       swapped := true;
   if swapped = false then
     // we can exit the outer loop here if no swaps occurred.
     break do-while loop;
   swapped := false
   for each i in length( A ) - 2 down to 0 do
     if A[ i ] > A[ i+1 ] then
       swap( A[ i ], A[ i+1 ] )
       swapped := true;
 while swapped; // if no elements have been swapped, 
                // then the list is sorted

Related task

   cocktail sort with shifting bounds

",Python,"# Python 3.5.2 tested implementation
arr = [4, 9, 0, 3, 1, 5]
isSorted = True
while isSorted:
    for i in range(0, len(arr) - 1):
        if arr[i] > arr[i + 1]:
            temp = arr[i]
            arr[i] = arr[i + 1]
            arr[i + 1] = temp
            isSorted = True
    if not isSorted:
        break
    isSorted = False
    for j in range(len(arr) - 1, 0, -1):
        if arr[j - 1] > arr[j]:
            temp = arr[j]
            arr[j] = arr[j - 1]
            arr[j - 1] = temp
            isSorted = True
print(arr)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Rename_a_file,Rename a file,"Task

Rename:

   a file called     input.txt     into     output.txt     and 
   a directory called     docs     into     mydocs.


This should be done twice:  
once ""here"", i.e. in the current working directory and once in the filesystem root.

It can be assumed that the user has the rights to do so.

(In unix-type systems, only the user root would have
sufficient permissions in the filesystem root.)



",Python,"import os
 
os.rename(""input.txt"", ""output.txt"")
os.rename(""docs"", ""mydocs"")
 
os.rename(os.sep + ""input.txt"", os.sep + ""output.txt"")
os.rename(os.sep + ""docs"", os.sep + ""mydocs"")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Hough_transform,Hough transform,"Task

Implement the Hough transform, which is used as part of feature extraction with digital images.

It is a tool that makes it far easier to identify straight lines in the source image, whatever their orientation.

The transform maps each point in the target image, 



(
ρ
,
θ
)


{\displaystyle (\rho ,\theta )}

, to the average color of the pixels on the corresponding line of the source image (in 



(
x
,
y
)


{\displaystyle (x,y)}

-space, where the line corresponds to points of the form 



x
cos
⁡
θ
+
y
sin
⁡
θ
=
ρ


{\displaystyle x\cos \theta +y\sin \theta =\rho }

). The idea is that where there is a straight line in the original image, it corresponds to a bright (or dark, depending on the color of the background field) spot; by applying a suitable filter to the results of the transform, it is possible to extract the locations of the lines in the original image.

 Sample PNG image to use for the Hough transform.
The target space actually uses polar coordinates, but is conventionally plotted on rectangular coordinates for display. There's no specification of exactly how to map polar coordinates to a flat surface for display, but a convenient method is to use one axis for 



θ


{\displaystyle \theta }

 and the other for 



ρ


{\displaystyle \rho }

, with the center of the source image being the origin.

There is also a spherical Hough transform, which is more suited to identifying planes in 3D data.



",Python,"from math import hypot, pi, cos, sin
from PIL import Image
 
 
def hough(im, ntx=460, mry=360):
    ""Calculate Hough transform.""
    pim = im.load()
    nimx, mimy = im.size
    mry = int(mry/2)*2          #Make sure that this is even
    him = Image.new(""L"", (ntx, mry), 255)
    phim = him.load()
 
    rmax = hypot(nimx, mimy)
    dr = rmax / (mry/2)
    dth = pi / ntx
 
    for jx in xrange(nimx):
        for iy in xrange(mimy):
            col = pim[jx, iy]
            if col == 255: continue
            for jtx in xrange(ntx):
                th = dth * jtx
                r = jx*cos(th) + iy*sin(th)
                iry = mry/2 + int(r/dr+0.5)
                phim[jtx, iry] -= 1
    return him
 
 
def test():
    ""Test Hough transform with pentagon.""
    im = Image.open(""pentagon.png"").convert(""L"")
    him = hough(im)
    him.save(""ho5.bmp"")
 
 
if __name__ == ""__main__"": test()",Human_written,Python_from_C
http://rosettacode.org/wiki/Stack_traces,Stack traces,"Many programming languages allow for introspection of the current call stack environment. This can be for a variety of purposes such as enforcing security checks, debugging, or for getting access to the stack frame of callers.



Task

Print out (in a manner considered suitable for the platform) the current call stack.

The amount of information printed for each frame on the call stack is not constrained, but should include at least the name of the function or method at that level of the stack frame.

You may explicitly add a call to produce the stack trace to the (example) code being instrumented for examination.

The task should allow the program to continue after generating the stack trace.

The task report here must include the trace from a sample program.



",Python,"import traceback
 
def f(): return g()
def g(): traceback.print_stack()
 
f()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Generic_swap,Generic swap,"Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.

If your solution language is statically typed please describe the way your language provides genericity.

If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.
That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.

Generic swap is a task which brings together a few separate issues in programming language semantics.

Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.

Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.

Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).

Do your best!



",Python,"class Pair(object):
    def __init__(self, first, second):
        self.first = first
        self.second = second

def swap(p):
    temp = p.first
    p.first = p.second
    p.second = temp",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Memory_allocation,Memory allocation,"Task

Show how to explicitly allocate and deallocate blocks of memory in your language.

Show access to different types of memory (i.e., heap, stack, shared, foreign) if applicable.



",Python,">>> from array import array
>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \u2641'),
	('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]
>>> for typecode, initializer in argslist:
	a = array(typecode, initializer)
	print a
	del a
 
 
array('l')
array('c', 'hello world')
array('u', u'hello \u2641')
array('l', [1, 2, 3, 4, 5])
array('d', [1.0, 2.0, 3.1400000000000001])
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",Python,"#!/usr/bin/env python
 
import sys
 
def main():
    program = sys.argv[0]
    print(""Program: %s"" % program)
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Greyscale_bars/Display,Greyscale bars/Display,"The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.

For the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)

For the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).

Halfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.
",Python,"#!/usr/bin/env python
#four gray scaled stripes 8:16:32:64 in Python 2.7.1
 
from livewires import *
 
horiz=640; vert=480; pruh=vert/4; dpp=255.0
begin_graphics(width=horiz,height=vert,title=""Gray stripes"",background=Colour.black)
 
def ty_pruhy(each):
	hiy=each[0]*pruh; loy=hiy-pruh
	krok=horiz/each[1]; piecol=255.0/(each[1]-1)
	for x in xrange(0,each[1]):
		barva=Colour(piecol*x/dpp,piecol*x/dpp,piecol*x/dpp ); set_colour(barva)
		if each[2]:
			box(x*krok,hiy,x*krok+krok,loy,filled=1)
		else:
			box(horiz-x*krok,hiy,horiz-((x+1)*krok),loy,filled=1)
 
# main
source=[[4,8,True],[3,16,False],[2,32,True],[1,64,False]]
for each in source:
	ty_pruhy(each)
 
while keys_pressed() != [' ']: # press spacebar to close window
	pass",Human_written,Python_from_C#
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"# USING A LIST MONAD DIRECTLY, WITHOUT SPECIAL SYNTAX FOR LIST COMPREHENSIONS
 
def pythagorean_triples(n):
 
    return mb(r(1,     n), lambda x:  # x <- [1..n]
    mb(r(1 + x, n), lambda y:  # y <- [1+x..n]
    mb(r(1 + y, n), lambda z:  # z <- [1+y..n]
 
       [[x, y, z]] if x * x + y * y == z * z else []
 
    )))
 
    # LIBRARY FUNCTIONS
 
    # Monadic bind for lists
    def mb(xs, f):
        return [y for x in xs for y in f(x)]
 
    # Monadic return for lists is simply lambda x -> [x]
    # as in [[x, y, z]] : [] above
 
    # Integer range [m..n]
    def r(m, n):
        return range(m, n + 1)
 
print(pythagorean_triples(100))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Arithmetic_numbers,Arithmetic numbers,"Definition
A positive integer n is an arithmetic number if the average of its positive divisors is also an integer.

Clearly all odd primes p must be arithmetic numbers because their only divisors are 1 and p whose sum is even and hence their average must be an integer. However, the prime number 2 is not an arithmetic number because the average of its divisors is 1.5.

Example
30 is an arithmetic number because its 7 divisors are: [1, 2, 3, 5, 6, 10, 15, 30], their sum is 72 and average 9 which is an integer.

Task
Calculate and show here:

1. The first 100 arithmetic numbers.

2. The xth arithmetic number where x = 1,000 and x = 10,000.

3. How many of the first x arithmetic numbers are composite.

Note that, technically, the arithmetic number 1 is neither prime nor composite.

Stretch
Carry out the same exercise in 2. and 3. above for x = 100,000 and x = 1,000,000.

References
 Wikipedia: Arithmetic number
 OEIS:A003601 - Numbers n such that the average of the divisors of n is an integer



",Python,"def divisor_count_and_sum(n):
    divisor_count = 1
    divisor_sum = 1
    power = 2
    while n & 1 == 0:
        divisor_count += 1
        divisor_sum += power
        power <<= 1
        n >>= 1
    p = 3
    while p * p <= n:
        count = 1
        sum = 1
        power = p
        while n % p == 0:
            count += 1
            sum += power
            power *= p
            n //= p
        divisor_count *= count
        divisor_sum *= sum
        p += 2
    if n > 1:
        divisor_count *= 2
        divisor_sum *= n + 1
    return divisor_count, divisor_sum
 
arithmetic_count = 0
composite_count = 0
n = 1
while arithmetic_count <= 1000000:
    divisor_count, divisor_sum = divisor_count_and_sum(n)
    if divisor_sum % divisor_count!= 0:
        n += 1
        continue
    arithmetic_count += 1
    if divisor_count > 2:
        composite_count += 1
    if arithmetic_count <= 100:
        print(f""{n:3} "", end="""")
        if arithmetic_count % 10 == 0:
            print()
    if arithmetic_count in (1000, 10000, 100000, 1000000):
        print(f""\n{arithmetic_count}th arithmetic number is {n}"")
        print(f""Number of composite arithmetic numbers <= {n}: {composite_count}"")
    n += 1",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort,Sorting algorithms/Insertion sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Insertion sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



An O(n2) sorting algorithm which moves elements one at a time into the correct position.
The algorithm consists of inserting one element at a time into the previously sorted part of the array, moving higher ranked elements up as necessary.
To start off, the first (or smallest, or any arbitrary) element of the unsorted array is considered to be the sorted part.

Although insertion sort is an O(n2) algorithm, its simplicity, low overhead, good locality of reference and efficiency make it a good choice in two cases: 


   small   n, 

   as the final finishing-off algorithm for O(n logn) algorithms such as mergesort and quicksort.


The algorithm is as follows (from wikipedia):

function insertionSort(array A)
    for i from 1 to length[A]-1 do
        value := A[i] 
        j := i-1
        while j >= 0 and A[j] > value do
            A[j+1] := A[j]
            j := j-1
        done
        A[j+1] = value
    done

Writing the algorithm for integers will suffice.



",Python,"def insertionsort(array):
    for i in range(1, len(array)):
        value = array[i]
        j = i - 1
        while j >= 0 and array[j] > value:
            array[j+1] = array[j]
            j -= 1
        array[j+1] = value
    return array

ary = [7,6,5,9,8,4,3,1,2,0]
print(insertionsort(ary))
# => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Image_convolution,Image convolution,"One class of image digital filters is described by a rectangular matrix of real coefficients called kernel convoluted in a sliding window of image pixels. Usually the kernel is square 




K

k
l




{\displaystyle K_{kl}}

, where k, l are in the range -R,-R+1,..,R-1,R. W=2R+1 is the kernel width. The filter determines the new value of a monochromatic image pixel Pij as a convolution of the image pixels in the window centered in i, j and the kernel values:







P

i
j


=


∑

k
=
−
R


R



∑

l
=
−
R


R



P

i
+
k
 
j
+
l



K

k
l





{\displaystyle P_{ij}=\displaystyle \sum _{k=-R}^{R}\sum _{l=-R}^{R}P_{i+k\ j+l}K_{kl}}




Color images are usually split into the channels which are filtered independently. A color model can be changed as well, i.e. filtration is performed not necessarily in RGB. Common kernels sizes are 3x3 and 5x5. The complexity of filtrating grows quadratically (O(n2)) with the kernel width.

Task: Write a generic convolution 3x3 kernel filter. Optionally show some end user filters that use this generic one.

(You can use, to test the functions below, these input and output solutions.)
",Python,"import math
import numpy as np
from PIL import Image
 
# kf3 is a generic convolution 3x3 kernel filter that operatates on
# images of type image.Gray from the Go standard image library.
def kf3(k, src, dst):
    for y in range(src.shape[0]):
        for x in range(src.shape[1]):
            sum = 0
            i = 0
            for yo in range(y - 1, y + 2):
                for xo in range(x - 1, x + 2):
                    if (yo >= 0 and yo < src.shape[0] and xo >= 0 and xo < src.shape[1]):
                        sum += k[i] * src[yo, xo]
                    else:
                        sum += k[i] * src[y, x]
                    i += 1
            dst[y, x] = min(255, max(0, sum))
 
blur = [1. / 9, 1. / 9, 1. / 9, 1. / 9, 1. / 9, 1. / 9, 1. / 9, 1. / 9, 1. / 9]
 
# blurY example function applies blur kernel to Y channel
# of YCbCr image using generic kernel filter function kf3
def blurY(src):
    dst = src.copy()
 
    # catch zero-size image here
    if src.shape[0] == 0 or src.shape[1] == 0:
        return dst
 
    # pass Y channels as gray images
    srcGray = src[:, :, 0]
    dstGray = np.zeros(srcGray.shape)
    kf3(blur, srcGray, dstGray) # call generic convolution function
 
    # complete result
    dst[:, :, 0] = dstGray # convolution result
    dst[:, :, 1] = src[:, :, 1] # Cb, Cr are just copied
    dst[:, :, 2] = src[:, :, 2]
    return dst
 
# Example file used here is Lenna100.jpg from the task ""Percentage
# difference between images""
img = Image.open(""Lenna100.jpg"")
img = np.array(img)
img = blurY(img)
img = Image.fromarray(img)
img.save(""blur.jpg"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",Python,"def ffr(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return ffr.r[n]
    except IndexError:
        r, s = ffr.r, ffs.s
        ffr_n_1 = ffr(n-1)
        lastr = r[-1]
        # extend s up to, and one past, last r 
        s += list(range(s[-1] + 1, lastr))
        if s[-1] < lastr: s += [lastr + 1]
        # access s[n-1] temporarily extending s if necessary
        len_s = len(s)
        ffs_n_1 = s[n-1] if len_s > n else (n - len_s) + s[-1]
        ans = ffr_n_1 + ffs_n_1
        r.append(ans)
        return ans
ffr.r = [None, 1]
 
def ffs(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return ffs.s[n]
    except IndexError:
        r, s = ffr.r, ffs.s
        for i in range(len(r), n+2):
            ffr(i)
            if len(s) > n:
                return s[n]
        raise Exception(""Whoops!"")
ffs.s = [None, 2]
 
if __name__ == '__main__':
    first10 = [ffr(i) for i in range(1,11)]
    assert first10 == [1, 3, 7, 12, 18, 26, 35, 45, 56, 69], ""ffr() value error(s)""
    print(""ffr(n) for n = [1..10] is"", first10)
    #
    bin = [None] + [0]*1000
    for i in range(40, 0, -1):
        bin[ffr(i)] += 1
    for i in range(960, 0, -1):
        bin[ffs(i)] += 1
    if all(b == 1 for b in bin[1:1000]):
        print(""All Integers 1..1000 found OK"")
    else:
        print(""All Integers 1..1000 NOT found only once: ERROR"")",Human_written,Python_from_C#
http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# From the standard library:
from string import ascii_lowercase
 
# Generation:
lower = [chr(i) for i in range(ord('a'), ord('z') + 1)]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Stack_traces,Stack traces,"Many programming languages allow for introspection of the current call stack environment. This can be for a variety of purposes such as enforcing security checks, debugging, or for getting access to the stack frame of callers.



Task

Print out (in a manner considered suitable for the platform) the current call stack.

The amount of information printed for each frame on the call stack is not constrained, but should include at least the name of the function or method at that level of the stack frame.

You may explicitly add a call to produce the stack trace to the (example) code being instrumented for examination.

The task should allow the program to continue after generating the stack trace.

The task report here must include the trace from a sample program.



",Python,"import inspect

def print_stack_trace():
    elems = inspect.stack()
    print(""Stack trace:"")
    for i in range(len(elems)-1, 2, -1):
        print(""  "" + elems[i][1] + ""."" + elems[i][3])",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Formatted_numeric_output,Formatted numeric output,"Task

Express a number in decimal as a fixed-length string with leading zeros.



For example, the number   7.125   could be expressed as   00007.125.



",Python,"value = 7.125
print(f'{value:09.3f}')
print('{:09.3f}'.format(value))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Last_letter-first_letter,Last letter-first letter,"A certain children's game involves starting with a word in a particular category.   Each participant in turn says a word, but that word must begin with the final letter of the previous word.   Once a word has been given, it cannot be repeated.   If an opponent cannot give a word in the category, they fall out of the game.



For example, with   ""animals""   as the category,

Child 1: dog 
Child 2: goldfish
Child 1: hippopotamus
Child 2: snake
...



Task

Take the following selection of 70 English Pokemon names   (extracted from   Wikipedia's list of Pokemon)   and generate the/a sequence with the highest possible number of Pokemon names where the subsequent name starts with the final letter of the preceding name.

No Pokemon name is to be repeated.

audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask



Extra brownie points for dealing with the full list of   646   names.



",Python,"# derived from C
class LastLetterFirstLetter:
    maxPathLength = 0
    maxPathLengthCount = 0
    maxPathExample = """"
 
    names = [""audino"", ""bagon"", ""baltoy"", ""banette"",
        ""bidoof"", ""braviary"", ""bronzor"", ""carracosta"", ""charmeleon"",
        ""cresselia"", ""croagunk"", ""darmanitan"", ""deino"", ""emboar"",
        ""emolga"", ""exeggcute"", ""gabite"", ""girafarig"", ""gulpin"",
        ""haxorus"", ""heatmor"", ""heatran"", ""ivysaur"", ""jellicent"",
        ""jumpluff"", ""kangaskhan"", ""kricketune"", ""landorus"", ""ledyba"",
        ""loudred"", ""lumineon"", ""lunatone"", ""machamp"", ""magnezone"",
        ""mamoswine"", ""nosepass"", ""petilil"", ""pidgeotto"", ""pikachu"",
        ""pinsir"", ""poliwrath"", ""poochyena"", ""porygon2"", ""porygonz"",
        ""registeel"", ""relicanth"", ""remoraid"", ""rufflet"", ""sableye"",
        ""scolipede"", ""scrafty"", ""seaking"", ""sealeo"", ""silcoon"",
        ""simisear"", ""snivy"", ""snorlax"", ""spoink"", ""starly"", ""tirtouga"",
        ""trapinch"", ""treecko"", ""tyrogue"", ""vigoroth"", ""vulpix"",
        ""wailord"", ""wartortle"", ""whismur"", ""wingull"", ""yamask""]
 
    def recursive(self, part, offset):
        if offset > LastLetterFirstLetter.maxPathLength:
            LastLetterFirstLetter.maxPathLength = offset
            LastLetterFirstLetter.maxPathLengthCount = 1
        elif offset == LastLetterFirstLetter.maxPathLength:
            LastLetterFirstLetter.maxPathLengthCount += 1
            LastLetterFirstLetter.maxPathExample = """"
            for i in range(0, offset):
                if i % 5 == 0:
                    LastLetterFirstLetter.maxPathExample += ""\n  ""
                else:
                    LastLetterFirstLetter.maxPathExample += "" ""
                LastLetterFirstLetter.maxPathExample += part[i]
        lastChar = part[offset - 1][-1]
        for i in range(offset, len(part)):
            if part[i][0] == lastChar:
                tmp = self.names[offset]
                self.names[offset] = self.names[i]
                self.names[i] = tmp
                self.recursive(self.names, offset+1)
                self.names[i] = self.names[offset]
                self.names[offset] = tmp
 
    def main(self):
        for i in range(0, len(self.names)):
            tmp = self.names[0]
            self.names[0] = self.names[i]
            self.names[i] = tmp
            self.recursive(self.names, 1)
            self.names[i] = self.names[0]
            self.names[0] = tmp
        print(""maximum path length        : "" + str(LastLetterFirstLetter.maxPathLength))
        print(""paths of that length       : "" + str(LastLetterFirstLetter.maxPathLengthCount))
        print(""example path of that length:"" + LastLetterFirstLetter.maxPathExample)
 
if __name__ == ""__main__"":
    LastLetterFirstLetter().main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Dynamic_variable_names,Dynamic variable names,"Task

Create a variable with a user-defined name.

The variable name should not be written in the program text, but should be taken from the user dynamically.



See also
   Eval in environment is a similar task.

",Python,"def main():
    vars = {}
    vars[""Variable name""] = 3
    vars[""Next variable name""] = 5
    sc = input()
    vars[sc] = int(input())
    print(vars[""Variable name""])
    print(vars[sc])",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Palindromic_gapful_numbers,Palindromic gapful numbers,"Palindromic gapful numbers

You are encouraged to solve this task according to the task description, using any language you may know.
Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

1037   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    1037. 



A palindromic number is   (for this task, a positive integer expressed in base ten),   when the number is
reversed,   is the same as the original number.



Task

   Show   (nine sets)   the first   20   palindromic gapful numbers that   end   with:
   the digit   1
   the digit   2
   the digit   3
   the digit   4
   the digit   5
   the digit   6
   the digit   7
   the digit   8
   the digit   9
   Show   (nine sets, like above)   of palindromic gapful numbers:
   the last   15   palindromic gapful numbers   (out of      100)
   the last   10   palindromic gapful numbers   (out of   1,000)       {optional}


For other ways of expressing the (above) requirements, see the   discussion   page.



Note

All palindromic gapful numbers are divisible by eleven.



Related tasks

   palindrome detection.
   gapful numbers.


Also see

   The OEIS entry:   A108343 gapful numbers.

",Python,"from itertools import count
from pprint import pformat
import re
import heapq
 
 
def pal_part_gen(odd=True):
    for i in count(1):
        fwd = str(i)
        rev = fwd[::-1][1:] if odd else fwd[::-1]
        yield int(fwd + rev)
 
def pal_ordered_gen():
    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))
 
def is_gapful(x):
    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)
 
if __name__ == '__main__':
    start = 100
    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:
        print(f""\nLast {last} of the first {mx} binned-by-last digit "" 
              f""gapful numbers >= {start}"")
        bin = {i: [] for i in range(1, 10)}
        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))
        while any(len(val) < mx for val in bin.values()):
            g = next(gen)
            val = bin[g % 10]
            if len(val) < mx:
                val.append(g)
        b = {k:v[-last:] for k, v in bin.items()}
        txt = pformat(b, width=220)
        print('', re.sub(r""[{},\[\]]"", '', txt))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",Python,"def nonoblocks(cell, blocks):
    if cell < sum(blocks) + len(blocks) - 1:
        raise ValueError('Those blocks will not fit in those cells')
    return nblock(cell, blocks, '', [])
 
def nblock(cell, blocks, position, result):
    if cell <= 0:
        result.append(position[:cell])
    elif not blocks or not blocks[0]:
        result.append(position + '.' * cell)
    else:
        rest = cell - sum(blocks) - len(blocks) + 2
        bl, *brest = blocks
        for i in range(rest):
            nblock(cell-i-bl-1, brest, position + '.'*i + '#' * bl + '.', result)
    return result
 
conf = [[ 5, [2, 1]],
        [ 5, []],
        [10, [8]],
        [15, [2, 3, 2, 3]],
        [ 5, [2, 3]],      ]
for cell, blocks in conf:
    try:
        print(f'{cell} cells and {blocks} blocks')
        result = nonoblocks(cell, blocks)
        print(result, len(result), """")
    except ValueError as e:
        print(e)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice,Seven-sided dice from five-sided dice,"Task

(Given an equal-probability generator of one of the integers 1 to 5
as dice5),   create dice7 that generates a pseudo-random integer from
1 to 7 in equal probability using only dice5 as a source of random
numbers,   and check the distribution for at least one million calls using the function created in   Simple Random Distribution Checker.


Implementation suggestion:
dice7 might call dice5 twice, re-call if four of the 25
combinations are given, otherwise split the other 21 combinations
into 7 groups of three, and return the group index from the rolls.

(Task adapted from an answer here)
",Python,"import random
import math
import time
 
# ""given""
def dice5():
    return random.randint(1, 5)
 
# function specified by task ""Seven-sided dice from five-sided dice""
def dice7():
    while True:
        i = 5*dice5() + dice5()
        if i < 27:
            break
    return (i // 3) - 1
 
# function specified by task ""Verify distribution uniformity/Naive""
#
# Parameter ""f"" is expected to return a random integer in the range 1..n.
# (Values out of range will cause an unceremonious crash.)
# ""Max"" is returned as an ""indication of distribution achieved.""
# It is the maximum delta observed from the count representing a perfectly
# uniform distribution.
# Also returned is a boolean, true if ""max"" is less than threshold
# parameter ""delta.""
def distCheck(f, n, repeats, delta):
    count = [0] * n
    for i in range(repeats):
        count[f()-1] += 1
    expected = float(repeats) / float(n)
    max = 0
    for c in count:
        max = max(max, abs(float(c)-expected))
    return max, max < delta
 
# Driver, produces output satisfying both tasks.
random.seed(time.time())
calls = 1000000
max, flatEnough = distCheck(dice7, 7, calls, 500)
print(""Max delta:"", max, ""Flat enough:"", flatEnough)
max, flatEnough = distCheck(dice7, 7, calls, 500)
print(""Max delta:"", max, ""Flat enough:"", flatEnough)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",Python,"$ python -c 'print ""Hello""'
Hello",Human_written,Python_from_Java
http://rosettacode.org/wiki/Levenshtein_distance,Levenshtein distance,"

 This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.



Example

The Levenshtein distance between ""kitten"" and ""sitting"" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

   kitten   sitten   (substitution of 'k' with 's')
   sitten   sittin   (substitution of 'e' with 'i')
   sittin   sitting   (insert 'g' at the end).

The Levenshtein distance between   ""rosettacode"",   ""raisethysword""   is   8.

The distance between two strings is same as that when both strings are reversed.



Task

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between   ""kitten""   and   ""sitting"".



Related task

   Longest common subsequence



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def levenshteinDistance(str1, str2):
    m = len(str1)
    n = len(str2)
    d = [[i] for i in range(1, m + 1)]   # d matrix rows
    d.insert(0, list(range(0, n + 1)))   # d matrix columns
    for j in range(1, n + 1):
        for i in range(1, m + 1):
            if str1[i - 1] == str2[j - 1]:   # Python (string) is 0-based
                substitutionCost = 0
            else:
                substitutionCost = 1
            d[i].insert(j, min(d[i - 1][j] + 1,
                               d[i][j - 1] + 1,
                               d[i - 1][j - 1] + substitutionCost))
    return d[-1][-1]
 
print(levenshteinDistance(""kitten"",""sitting""))
print(levenshteinDistance(""rosettacode"",""raisethysword""))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Update_a_configuration_file,Update a configuration file,"We have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines begininning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# The first word on each non comment line is the configuration option.
# Remaining words or numbers on the line are configuration parameter
# data fields.

# Note that configuration option names are not case sensitive. However,
# configuration parameter data is case sensitive and the lettercase must
# be preserved.

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# How many bananas we have
NUMBEROFBANANAS 48

The task is to manipulate the configuration file as follows:

 Disable the needspeeling option (using a semicolon prefix)
 Enable the seedsremoved option by removing the semicolon and any leading whitespace
 Change the numberofbananas parameter to 1024
 Enable (or create if it does not exist in the file) a parameter for numberofstrawberries with a value of 62000


Note that configuration option names are not case sensitive. This means that changes should be effected, regardless of the case.

Options should always be disabled by prefixing them with a semicolon.

Lines beginning with hash symbols should not be manipulated and left unchanged in the revised file.

If a configuration option does not exist within the file (in either enabled or disabled form), it should be added during this update. Duplicate configuration option names in the file should be removed, leaving just the first entry.

For the purpose of this task, the revised file should contain appropriate entries, whether enabled or not for needspeeling,seedsremoved,numberofbananas and numberofstrawberries.)

The update should rewrite configuration option names in capital letters. However lines beginning with hashes and any parameter data must not be altered (eg the banana for favourite fruit must not become capitalized). The update process should also replace double semicolon prefixes with just a single semicolon (unless it is uncommenting the option, in which case it should remove all leading semicolons).

Any lines beginning with a semicolon or groups of semicolons, but no following option should be removed, as should any leading or trailing whitespace on the lines. Whitespace between the option and parameters should consist only of a single
space, and any non-ASCII extended characters, tabs characters, or control codes
(other than end of line markers), should also be removed.



Related tasks
 Read a configuration file

",Python,"#!/usr/bin/env python
 
#----------------------------------------------------------------------------
# STANDARD MODULES
#----------------------------------------------------------------------------
import re
import string
 
 
#----------------------------------------------------------------------------
# GLOBAL: VARIABLES
#----------------------------------------------------------------------------
DISABLED_PREFIX = ';'
 
 
#----------------------------------------------------------------------------
# CLASS Option
#----------------------------------------------------------------------------
class Option(object):
    """"""An option, characterized by its name and its (optional) value. and by
       its status, which can be enabled or disabled.
       If its value is None, it is regarded to as a boolean option with a
       value of true.
    """"""
 
    #------------------------------------------------------------------------
    def __init__(self, name, value=None, disabled=False,
                 disabled_prefix=DISABLED_PREFIX):
        """"""Create an Option instance, setting its name to 'name' (always
           converted to a string) and its value to 'value'. If 'disabled' is
           True, the option is considered disabled, otherwise enabled.
           The string 'disabled_prefix' is used as a prefix when generating the
           string representation of the option.
        """"""
        self.name = str(name)
        self.value = value
        self.disabled = bool(disabled)
        self.disabled_prefix = disabled_prefix
 
    #------------------------------------------------------------------------
    def __str__(self):
        """"""Return a string representation of the Option instance.
           This always includes the option name, followed by a space and the
           option value (if it is not None). If the option is disabled, the
           whole string is preprendend by the string stored in the instance
           attribute 'disabled_prefix' and a space.
        """"""
        disabled = ('', '%s ' % self.disabled_prefix)[self.disabled]
        value = (' %s' % self.value, '')[self.value is None]
        return ''.join((disabled, self.name, value))
 
    #------------------------------------------------------------------------
    def get(self):
        """"""Return the option value.
           If the stored value is None, the option is regarded to as a
           boolean one and its enabled status is returned. Othrwise its value
           is returned.
        """"""
        enabled = not bool(self.disabled)
        if self.value is None:
            value = enabled
        else:
            value = enabled and self.value
        return value
 
 
#----------------------------------------------------------------------------
# CLASS Config
#----------------------------------------------------------------------------
class Config(object):
    """"""A set of configuration options and comment strings.
    """"""
    # Regular expression matching a valid option line.
    reOPTION = r'^\s*(?P<disabled>%s*)\s*(?P<name>\w+)(?:\s+(?P<value>.+?))?\s*$'
 
    #------------------------------------------------------------------------
    def __init__(self, fname=None, disabled_prefix=DISABLED_PREFIX):
        """"""Initialize a Config instance, optionally reading the contents of
           the configuration file 'fname'.
           The string 'disabled_prefix' is used as a prefix when generating the
           string representation of the options.
        """"""
        self.disabled_prefix = disabled_prefix
        self.contents = []          # Sequence of strings and Option instances.
        self.options = {}           # Map an option name to an Option instance.
        self.creOPTION = re.compile(self.reOPTION % self.disabled_prefix)
        if fname:
            self.parse_file(fname)
 
    #------------------------------------------------------------------------
    def __str__(self):
        """"""Return a string representation of the Config instance.
           This is just the concatenation of all the items stored in the
           attribute 'contents'.
        """"""
        return '\n'.join(map(str, self.contents))
 
    #------------------------------------------------------------------------
    def parse_file(self, fname):
        """"""Parse all the lines of file 'fname' by applying the method
           'parser_lines' on the file contents.
        """"""
        with open(fname) as f:
            self.parse_lines(f)
        return self
 
    #------------------------------------------------------------------------
    def parse_lines(self, lines):
        """"""Parse all the lines of iterable 'lines' by invoking the method
           'parse_line' for each line in 'lines'.
        """"""
        for line in lines:
            self.parse_line(line)
        return self
 
    #------------------------------------------------------------------------
    def parse_line(self, line):
        """"""Parse the line 'line', looking for options.
           If an option line is found, spaces are stripped from the start and
           the end of 'line' and any non-printable character is removed as well.
           Only the first occurrence of an option is processed, all the other
           occurrences are ignored. A valid option is added to the instance
           attribute 'contents' (in order to preserve its position among the
           other lines). It is also added to the mapping stored in the instance
           attribute 'options'.
           Any non-option string is added the the instance attribute 'contents',
           except those lines starting with the string stored into the instance
           attribute 'disabled_prefix' which are not followed by any option
           name.
        """"""
        s = ''.join(c for c in line.strip() if c in string.printable) 
        moOPTION = self.creOPTION.match(s)
        if moOPTION:
            name = moOPTION.group('name').upper()
            if not name in self.options:
                self.add_option(name, moOPTION.group('value'),
                                moOPTION.group('disabled'))
        else:
            if not s.startswith(self.disabled_prefix):
                self.contents.append(line.rstrip())
        return self
 
    #------------------------------------------------------------------------
    def add_option(self, name, value=None, disabled=False):
        """"""Create a new Option instance, named 'name' (always converted to
           uppercase) with value 'value' and set its disabled status to
           'disabled'.
           The Option instance is added to the instance attribute 'contents'.
           It is also added to the mapping stored in the instance attribute
           'options'.
        """"""
        name = name.upper()
        opt = Option(name, value, disabled)
        self.options[name] = opt
        self.contents.append(opt)
        return opt
 
    #------------------------------------------------------------------------
    def set_option(self, name, value=None, disabled=False):
        """"""Look for an option named 'name' (always converted to
           uppercase) among the options stored in the instance
           attribute 'options'.
           If it is not found, a new Option instance is created.
           In any case its value is set to 'value' and its disabled
           status to 'disabled'.
        """"""
        name = name.upper()
        opt = self.options.get(name)
        if opt:
            opt.value = value
            opt.disabled = disabled
        else:
            opt = self.add_option(name, value, disabled)
        return opt
 
    #------------------------------------------------------------------------
    def enable_option(self, name, value=None):
        """"""Enable the option named 'name' (always converted to
           uppercase) and set its value to 'value'.
           If the option is not found, it is created and added to the
           end of the instance attribute 'contents'.
        """"""
        return self.set_option(name, value, False)
 
    #------------------------------------------------------------------------
    def disable_option(self, name, value=None):
        """"""Disable the option named 'name' (always converted to
           uppercase) and set its value to 'value'.
           If the option is not found, it is created and added to the
           end of the instance attribute 'contents'.
        """"""
        return self.set_option(name, value, True)
 
    #------------------------------------------------------------------------
    def get_option(self, name):
        """"""Return the value of the option named 'name' (always
           converted to uppercase).
           If the option is not found in the instance attribute
           'options', None is returned. If the stored value is None,
           it is regarded to as a boolean option and its enable status
           is returned. Otherwise its value is returned.
        """"""
        opt = self.options.get(name.upper())
        value = opt.get() if opt else None
        return value
 
 
#----------------------------------------------------------------------------
# MAIN
#----------------------------------------------------------------------------
if __name__ == '__main__':
    import sys
    cfg = Config(sys.argv[1] if len(sys.argv) > 1 else None)
    cfg.disable_option('needspeeling')
    cfg.enable_option('seedsremoved')
    cfg.enable_option('numberofbananas', 1024)
    cfg.enable_option('numberofstrawberries', 62000)
    print cfg",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Respond_to_an_unknown_method_call,Respond to an unknown method call,"Task

Demonstrate how to make the object respond (sensibly/usefully) to an invocation of a method on it that it does not support through its class definitions.

Note that this is not the same as just invoking a defined method whose name is given dynamically; the method named at the point of invocation must not be defined.

This task is intended only for object systems that use a dynamic dispatch mechanism without static checking.



Related task

   Send an unknown method call.

",Python,"from __future__ import print_function
import sys
from System import *
from System.Dynamic import *
 
class Example(DynamicObject):
    def TryInvokeMember(self, binder, args, result):
        result = None
 
        print(""This is {0}."".format(binder.Name))
        return True
 
class Program:
    @staticmethod
    def Main(args):
        ex = Example()
 
        ex.Foo()
        ex.Bar()
 
if __name__ == '__main__':
    import sys
    Program.Main(sys.argv)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",Python,"#include <iostream> # Only for cout to demonstrate
 
int main()
{
  std::cout <<
R""EOF(  A  raw  string  begins  with  R,  then a double-quote (""),  then an optional
identifier (here I've used ""EOF""),  then an opening parenthesis ('(').  If you
use  an  identifier,  it  cannot  be longer than 16 characters,  and it cannot
contain a space,  either opening or closing parentheses, a backslash, a tab, a
vertical tab, a form feed, or a newline.
 
  It  ends with a closing parenthesis (')'),  the identifer (if you used one),
and a double-quote.
 
  All  characters are okay in a raw string,  no escape sequences are necessary
or recognized, and all whitespace is preserved.
)EOF"";
}",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Pointers_and_references,Pointers and references,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


In this task, the goal is to demonstrate common operations on pointers and references. These examples show pointer operations on the stack, which can be dangerous and is rarely done. Pointers and references are commonly used along with Memory allocation on the heap.
",Python,"# Bind a literal string object to a name:
 a = ""foo""
 # Bind an empty list to another name:
 b = []
 # Classes are ""factories"" for creating new objects: invoke class name as a function:
 class Foo(object):
     pass
 c = Foo()
 # Again, but with optional initialization:
 class Bar(object):
     def __init__(self, initializer = None)
         # ""initializer is an arbitrary identifier, and ""None"" is an arbitrary default value
         if initializer is not None:
            self.value = initializer
 d = Bar(10)
 print d.value
 # Test if two names are references to the same object:
 if a is b: pass
 # Alternatively:
 if id(a) == id(b): pass
 # Re-bind a previous used name to a function:
 def a(fmt, *args):
     if fmt is None:
         fmt = ""%s""
      print fmt % (args)
 # Append reference to a list:
 b.append(a)
 # Unbind a reference:
 del(a)
 # Call (anymous function object) from inside a list
 b[0](""foo"")  # Note that the function object we original bound to the name ""a"" continues to exist
              # even if its name is unbound or rebound to some other object.",Human_written,Python_from_C++
http://rosettacode.org/wiki/Checkpoint_synchronization,Checkpoint synchronization,"The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.

The task

Implement checkpoint synchronization in your language.

Make sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.
",Python,"""""""
 
Based on https://pymotw.com/3/threading/
 
""""""
 
import threading
import time
import random
 
 
def worker(workernum, barrier):
    # task 1
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 1, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
    barrier.wait()
    # task 2
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 2, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
 
barrier = threading.Barrier(3)
 
w1 = threading.Thread(target=worker, args=((1,barrier)))
w2 = threading.Thread(target=worker, args=((2,barrier)))
w3 = threading.Thread(target=worker, args=((3,barrier)))
 
w1.start()
w2.start()
w3.start()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Tokenize_a_string_with_escaping,Tokenize a string with escaping,"Task[edit]
Write a function or program that can split a string at each non-escaped occurrence of a separator character.

It should accept three input parameters:

   The string
   The separator character
   The escape character


It should output a list of strings.

Details
Rules for splitting:

 The fields that were separated by the separators, become the elements of the output list.
 Empty fields should be preserved, even at the start and end.


Rules for escaping:

 ""Escaped"" means preceded by an occurrence of the escape character that is not already escaped itself.
 When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).
 Each occurrence of the escape character that was used to escape something, should not become part of the output.


Test case
Demonstrate that your function satisfies the following test-case:



 Input

 Output





 string:

 one^|uno||three^^^^|four^^^|^cuatro|


 separator character:

 |


 escape character:

 ^





 one|uno


 


 three^^


 four^|cuatro


 


(Print the output list in any format you like, as long as it is it easy to see what the fields are.)


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
STR_DEMO = ""one^|uno||three^^^^|four^^^|^cuatro|""
SEP = '|'
ESC = '^'
 
def tokenize(s, sep, esc):
    """"""
    Tokenize a string s according to the separator character sep and the escape
    character esc.
    """"""
    # Split the string into a list of tokens
    tokens = re.split(r'(?<!{0})({0})'.format(re.escape(sep)), s)
    # Remove the escape characters
    return [token.replace(esc, '') for token in tokens]
 
if __name__ == '__main__':
    print('Original string: {0}'.format(STR_DEMO))
    print('{0} tokens:'.format(len(tokenize(STR_DEMO, SEP, ESC))))
    for i, token in enumerate(tokenize(STR_DEMO, SEP, ESC), 1):
        print('{0}. {1}'.format(i, token))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Variable-length_quantity,Variable-length quantity,"Implement some operations on variable-length quantities, at least including conversions from a normal number in the language to the binary representation of the variable-length quantity for that number, and vice versa. Any variants are acceptable.



Task

With above operations,

convert these two numbers 0x200000 (2097152 in decimal) and 0x1fffff (2097151 in decimal) into sequences of octets (an eight-bit byte); 
display these sequences of octets;
convert these sequences of octets back to numbers, and check that they are equal to original numbers.

",Python,"def tobits(n, _group=8, _sep='_', _pad=False):
    'Express n as binary bits with separator'
    bits = '{0:b}'.format(n)[::-1]
    if _pad:
        bits = '{0:0{1}b}'.format(n,
                                  ((_group+len(bits)-1)//_group)*_group)[::-1]
        answer = _sep.join(bits[i:i+_group]
                                 for i in range(0, len(bits), _group))[::-1]
        answer = '0'*(len(_sep)-1) + answer
    else:
        answer = _sep.join(bits[i:i+_group]
                           for i in range(0, len(bits), _group))[::-1]
    return answer
 
def tovlq(n):
    return tobits(n, _group=7, _sep='1_', _pad=True)
 
def toint(vlq):
    return int(''.join(vlq.split('_1')), 2)    
 
def vlqsend(vlq):
    for i, byte in enumerate(vlq.split('_')[::-1]):
        print('Sent byte {0:3}: {1:#04x}'.format(i, int(byte,2)))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Find_the_intersection_of_two_lines,Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",Python,"def line_intersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):
    """""" returns a (x, y) tuple or None if there is no intersection """"""
    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)
    if d:
        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d
        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d
    else:
        return
    if not(0 <= uA <= 1 and 0 <= uB <= 1):
        return
    x = Ax1 + uA * (Ax2 - Ax1)
    y = Ay1 + uA * (Ay2 - Ay1)
 
    return x, y
 
if __name__ == '__main__':
    (a, b), (c, d) = (4, 0), (6, 10)  # try (4, 0), (6, 4)
    (e, f), (g, h) = (0, 3), (10, 7)  # for non intersecting test
    pt = line_intersect(a, b, c, d, e, f, g, h)
    print(pt)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Topswops,Topswops,"Topswops is a card game created by John Conway in the 1970's.



Assume you have a particular permutation of a set of   n   cards numbered   1..n   on both of their faces, for example the arrangement of four cards given by   [2, 4, 1, 3]   where the leftmost card is on top.

A round is composed of reversing the first   m   cards where   m   is the value of the topmost card.

Rounds are repeated until the topmost card is the number   1   and the number of swaps is recorded.



For our example the swaps produce:

    
    [2, 4, 1, 3]    # Initial shuffle
    [4, 2, 1, 3]
    [3, 1, 2, 4]
    [2, 1, 3, 4]
    [1, 2, 3, 4]

For a total of four swaps from the initial ordering to produce the terminating case where   1   is on top.



For a particular number    n    of cards,    topswops(n)    is the maximum swaps needed for any starting permutation of the   n   cards.



Task

The task is to generate and show here a table of    n    vs    topswops(n)    for    n    in the range   1..10   inclusive.



Note

Topswops   is also known as   Fannkuch   from the German word   Pfannkuchen   meaning   pancake.



Related tasks

   Number reversal game
   Sorting algorithms/Pancake sort

",Python,"from itertools import permutations
 
def topswops(n):
    max_steps = 0
    for list in permutations(range(1, n + 1)):
        temp_list = list
        for steps in range(1, n + 1):
            temp_list = temp_list[:temp_list[0]] + tuple(reversed(temp_list[:temp_list[0]]))
            if temp_list[0] == 1:
                if steps > max_steps:
                    max_steps = steps
                break
    return max_steps
 
for i in range(1, 11):
    print(i, topswops(i))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/First-class_functions,First-class functions,"A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

 Create new functions from preexisting functions at run-time
 Store functions in collections
 Use functions as arguments to other functions
 Use functions as return values of other functions


Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections ""A"" and ""B"". These names are only used in the preceding paragraph for clarity.)



Related task
 
First-class Numbers
",Python,">>> # Some built in functions and their inverses
>>> from math import sin, cos, acos, asin
>>> # Add a user defined function and its inverse
>>> cube = lambda x: x * x * x
>>> croot = lambda x: x ** (1/3.0)
>>> # First class functions allow run-time creation of functions from functions
>>> # return function compose(f,g)(x) == f(g(x))
>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )
>>> # first class functions should be able to be members of collection types
>>> funclist = [sin, cos, cube]
>>> funclisti = [asin, acos, croot]
>>> # Apply functions from lists as easily as integers
>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]
[0.5, 0.4999999999999999, 0.5]
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Man_or_boy_test,Man or boy test,"Man or boy test

You are encouraged to solve this task according to the task description, using any language you may know.

Background: The man or boy test was proposed by computer scientist Donald Knuth as a means of evaluating implementations of the ALGOL 60 programming language. The aim of the test was to distinguish compilers that correctly implemented ""recursion and non-local references"" from those that did not.


I have written the following simple routine, which may separate the 'man-compilers' from the 'boy-compilers'
 — Donald Knuth
Task: Imitate Knuth's example in Algol 60 in another language, as far as possible.

Details: Local variables of routines are often kept in activation records (also call frames). In many languages, these records are kept on a call stack. In Algol (and e.g. in Smalltalk), they are allocated on a heap instead. Hence it is possible to pass references to routines that still can use and update variables from their call environment, even if the routine where those variables are declared already returned. This difference in implementations is sometimes called the Funarg Problem.

In Knuth's example, each call to A allocates an activation record for the variable A. When B is called from A, any access to k now refers to this activation record. Now B in turn calls A, but passes itself as an argument. This argument remains bound to the activation record. This call to A also ""shifts"" the variables xi by one place, so eventually the argument B (still bound to its particular
activation record) will appear as x4 or x5 in a call to A. If this happens when the expression x4 + x5 is evaluated, then this will again call B, which in turn will update k in the activation record it was originally bound to. As this activation record is shared with other instances of calls to A and B, it will influence the whole computation.

So all the example does is to set up a convoluted calling structure, where updates to k can influence the behavior
in completely different parts of the call tree.

Knuth used this to test the correctness of the compiler, but one can of course also use it to test that other languages can emulate the Algol behavior correctly. If the handling of activation records is correct, the computed value will be −67.

Performance and Memory: Man or Boy is intense and can be pushed to challenge any machine. Memory (both stack and heap) not CPU time is the constraining resource as the recursion creates a proliferation activation records which will quickly exhaust memory and present itself through a stack error. Each language may have ways of adjusting the amount of memory or increasing the recursion depth. Optionally, show how you would make such adjustments.

The table below shows the result, call depths, and total calls for a range of k:



 k

 0

 1

 2

 3

 4

 5

 6

 7

 8

 9

 10

 11

 12

 13

 14

 15

 16

 17

 18

 19

 20

 21

 22

 23

 24

 25

 26

 27

 28

 29

 30


 A

 1

 0

 -2

 0

 1

 0

 1

 -1

 -10

 -30

 -67

 -138

 -291

 -642

 -1,446

 -3,250

 -7,244

 -16,065

 -35,601

 -78,985

 -175,416

 -389,695

 -865,609

 -1,922,362

 -4,268,854

 -9,479,595

 -21,051,458

 -46,750,171

 -103,821,058

 -230,560,902

 -512,016,658


 A called

 1

 2

 3

 4

 8

 18

 38

 80

 167

 347

 722

 1,509

 3,168

 6,673

 14,091

 29,825

 63,287

 134,652

 287,264

 614,442

 1,317,533

 2,831,900

 6,100,852

 13,172,239

 28,499,827

 61,786,266

 134,202,509

 292,011,464

 

 

 


 A depth

 1

 2

 3

 4

 8

 16

 32

 64

 128

 256

 512

 1,024

 2,048

 4,096

 8,192

 16,384

 32,768

 65,536

 131,072

 262,144

 524,288

 1,048,576

 2,097,152

 4,194,304

 8,388,608

 

 

 

 

 

 


 B called

 0

 1

 2

 3

 7

 17

 37

 79

 166

 346

 721

 1,508

 3,167

 6,672

 14,090

 29,824

 63,286

 134,651

 287,263

 614,441

 1,317,532

 2,831,899

 6,100,851

 13,172,238

 28,499,826

 

 

 

 

 

 


 B depth

 0

 1

 2

 3

 7

 15

 31

 63

 127

 255

 511

 1,023

 2,047

 4,095

 8,191

 16,383

 32,767

 65,535

 131,071

 262,143

 524,287

 1,048,575

 2,097,151

 4,194,303

 8,388,607

 

 

 

 

 

 



Related tasks

   Jensen's Device

",Python,"#!/usr/bin/env python
import sys
sys.setrecursionlimit(1025)
 
def a(in_k, x1, x2, x3, x4, x5):
    k = [in_k]
    def b():
        k[0] -= 1
        return a(k[0], b, x1, x2, x3, x4)
    return x4() + x5() if k[0] <= 0 else b()
 
x = lambda i: lambda: i
print(a(10, x(1), x(-1), x(-1), x(1), x(0)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sierpinski_arrowhead_curve,Sierpinski arrowhead curve,"Task
Produce a graphical or ASCII-art representation of a  Sierpinski arrowhead curve  of at least order  3.



",Python,"import matplotlib.pyplot as plt
import math
 
 
def nextPoint(x, y, angle):
    a = math.pi * angle / 180
    x2 = (int)(round(x + (1 * math.cos(a))))
    y2 = (int)(round(y + (1 * math.sin(a))))
    return x2, y2
 
 
def expand(axiom, rules, level):
    for l in range(0, level):
        a2 = """"
        for c in axiom:
            if c in rules:
                a2 += rules[c]
            else:
                a2 += c
        axiom = a2
    return axiom
 
 
def draw_lsystem(axiom, rules, angle, iterations):
    xp = [1]
    yp = [1]
    direction = 0
    for c in expand(axiom, rules, iterations):
        if c == ""F"":
            xn, yn = nextPoint(xp[-1], yp[-1], direction)
            xp.append(xn)
            yp.append(yn)
        elif c == ""-"":
            direction = direction - angle
            if direction < 0:
                direction = 360 + direction
        elif c == ""+"":
            direction = (direction + angle) % 360
 
    plt.plot(xp, yp)
    plt.show()
 
 
if __name__ == '__main__':
    # Sierpinski Arrowhead Curve L-System Definition
    s_axiom = ""XF""
    s_rules = {""X"": ""YF+XF+Y"",
               ""Y"": ""XF-YF-X""}
    s_angle = 60
 
    draw_lsystem(s_axiom, s_rules, s_angle, 7)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion,Parsing/RPN to infix conversion,"Parsing/RPN to infix conversion

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a program that takes an RPN representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in infix notation.

 Assume an input of a correct, space separated, string of tokens
 Generate a space separated output string representing the same expression in infix notation
 Show how the major datastructure of your algorithm changes with each new token parsed.
 Test with the following input RPN strings then print and display the output here.


 RPN input 
 sample output


 3 4 2 * 1 5 - 2 3 ^ ^ / +
 3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3


 1 2 + 3 4 + ^ 5 6 + ^
 ( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )

 Operator precedence and operator associativity is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



See also

   Parsing/Shunting-yard algorithm   for a method of generating an RPN from an infix expression.
   Parsing/RPN calculator algorithm   for a method of calculating a final value from this output RPN expression.
   Postfix to infix   from the RubyQuiz site.

",Python,"""""""
>>> # EXAMPLE USAGE
>>> result = rpn_to_infix('3 4 2 * 1 5 - 2 3 ^ ^ / +', VERBOSE=True)
TOKEN  STACK
3      ['3']
4      ['3', '4']
2      ['3', '4', '2']
*      ['3', Node('2','*','4')]
1      ['3', Node('2','*','4'), '1']
5      ['3', Node('2','*','4'), '1', '5']
-      ['3', Node('2','*','4'), Node('5','-','1')]
2      ['3', Node('2','*','4'), Node('5','-','1'), '2']
3      ['3', Node('2','*','4'), Node('5','-','1'), '2', '3']
^      ['3', Node('2','*','4'), Node('5','-','1'), Node('3','^','2')]
^      ['3', Node('2','*','4'), Node(Node('3','^','2'),'^',Node('5','-','1'))]
/      ['3', Node(Node(Node('3','^','2'),'^',Node('5','-','1')),'/',Node('2','*','4'))]
+      [Node(Node(Node(Node('3','^','2'),'^',Node('5','-','1')),'/',Node('2','*','4')),'+','3')]
""""""
 
prec_dict =  {'^':4, '*':3, '/':3, '+':2, '-':2}
assoc_dict = {'^':1, '*':0, '/':0, '+':0, '-':0}
 
class Node:
    def __init__(self,x,op,y=None):
        self.precedence = prec_dict[op]
        self.assocright = assoc_dict[op]
        self.op = op
        self.x,self.y = x,y
 
    def __str__(self):
        """"""
        Building an infix string that evaluates correctly is easy.
        Building an infix string that looks pretty and evaluates
        correctly requires more effort.
        """"""
        # easy case, Node is unary
        if self.y == None:
            return '%s(%s)'%(self.op,str(self.x))
 
        # determine left side string
        str_y = str(self.y)
        if  self.y < self or \
            (self.y == self and self.assocright) or \
            (str_y[0] is '-' and self.assocright):
 
            str_y = '(%s)'%str_y
        # determine right side string and operator
        str_x = str(self.x)
        str_op = self.op
        if self.op is '+' and not isinstance(self.x, Node) and str_x[0] is '-':
            str_x = str_x[1:]
            str_op = '-'
        elif self.op is '-' and not isinstance(self.x, Node) and str_x[0] is '-':
            str_x = str_x[1:]
            str_op = '+'
        elif self.x < self or \
             (self.x == self and not self.assocright and \
              getattr(self.x, 'op', 1) != getattr(self, 'op', 2)):
 
            str_x = '(%s)'%str_x
        return ' '.join([str_y, str_op, str_x])
 
    def __repr__(self):
        """"""
        >>> repr(Node('3','+','4')) == repr(eval(repr(Node('3','+','4'))))
        True
        """"""
        return 'Node(%s,%s,%s)'%(repr(self.x), repr(self.op), repr(self.y))
 
    def __lt__(self, other):
        if isinstance(other, Node):
            return self.precedence < other.precedence
        return self.precedence < prec_dict.get(other,9)
 
    def __gt__(self, other):
        if isinstance(other, Node):
            return self.precedence > other.precedence
        return self.precedence > prec_dict.get(other,9)
 
    def __eq__(self, other):
        if isinstance(other, Node):
            return self.precedence == other.precedence
        return self.precedence > prec_dict.get(other,9)
 
 
 
def rpn_to_infix(s, VERBOSE=False):
    """"""
 
    converts rpn notation to infix notation for string s
 
    """"""
    if VERBOSE : print('TOKEN  STACK')
 
    stack=[]
    for token in s.replace('^','^').split():
        if token in prec_dict:
            stack.append(Node(stack.pop(),token,stack.pop()))
        else:
            stack.append(token)
 
        # can't use \t in order to make global docstring pass doctest
        if VERBOSE : print(token+' '*(7-len(token))+repr(stack)) 
 
    return str(stack[0])
 
strTest = ""3 4 2 * 1 5 - 2 3 ^ ^ / +""
strResult = rpn_to_infix(strTest, VERBOSE=False)
print (""Input: "",strTest)
print (""Output:"",strResult)
 
print()
 
strTest = ""1 2 + 3 4 + ^ 5 6 + ^""
strResult = rpn_to_infix(strTest, VERBOSE=False)
print (""Input: "",strTest)
print (""Output:"",strResult)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Window_creation,Window creation,"Display a GUI window. The window need not have any contents, but should respond to requests to be closed.
",Python,"items = [""apple"", ""banana"", ""kiwifruit""]
for item in items:
    if item == ""banana"":
        continue
    print(item)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Element-wise_operations,Element-wise operations,"This task is similar to:

   Matrix multiplication
   Matrix transposition


Task

Implement basic element-wise matrix-matrix and scalar-matrix operations, which can be referred to in other, higher-order tasks.

Implement:

   addition
   subtraction
   multiplication
   division
   exponentiation


Extend the task if necessary to include additional basic operations, which should not require their own specialised task.



",Python,"import numpy as np
 
OPERATIONS = {
	""add"": lambda a, b: a + b,
	""sub"": lambda a, b: a - b,
	""mul"": lambda a, b: a * b,
	""div"": lambda a, b: a / b,
	""pow"": lambda a, b: a ** b,
	""mod"": lambda a, b: a % b
}
 
def scalar_op(op, matr, scalar):
	operation = OPERATIONS.get(op, lambda a, b: a)
	return np.array([[operation(a, scalar) for a in row] for row in matr])
 
def matr_op(op, matr, scalar):
	operation = OPERATIONS.get(op, lambda a, b: a)
	return np.array([[operation(a, scalar[i % len(scalar)][j % len(scalar[i % len(scalar)])]) for j, a in enumerate(row)] for i, row in enumerate(matr)])
 
def print_matrix(matr):
	print(matr)
 
if __name__ == ""__main__"":
	print_matrix(scalar_op(""mul"", np.array([
		[1.0, 2.0, 3.0],
		[4.0, 5.0, 6.0],
		[7.0, 8.0, 9.0]
	]), 3.0))
 
print_matrix(matr_op(""div"", np.array([
		[1.0, 2.0, 3.0],
		[4.0, 5.0, 6.0],
		[7.0, 8.0, 9.0]
	]), np.array([
		[1.0, 2.0],
		[3.0, 4.0]
	])))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
 
public class LetterFreq:
	def countLetters(filename):
		freqs = [0] * 26
		in = BufferedReader(FileReader(filename))
		line = in.readLine()
		while line!= None:
			line = line.upper()
			for ch in line:
				if ch.isLetter():
					freqs[ord(ch) - ord('A')] += 1
			line = in.readLine()
		in.close()
		return freqs
 
	def main():
		print(Arrays.toString(countLetters(""filename.txt"")))
 
if __name__ == '__main__':
	main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Draw_a_sphere,Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Python,"# Based on https://www.cairographics.org/samples/gradient/
 
from PyQt5.QtGui import QImage, QPainter, QColor, QLinearGradient, QRadialGradient, QBrush
from PyQt5.QtCore import Qt
 
def main():
    black = QColor(0, 0, 0)
    white = QColor(255, 255, 255)
 
    size = 300
    diameter = 0.6 * size
 
    image = QImage(size, size, QImage.Format_RGB32)
    painter = QPainter(image)
    painter.setRenderHint(QPainter.Antialiasing)
 
    linearGradient = QLinearGradient(0, 0, 0, size)
    linearGradient.setColorAt(0, white)
    linearGradient.setColorAt(1, black)
 
    brush = QBrush(linearGradient)
    painter.fillRect(0, 0, size, size, brush)
 
    point1 = (0.4 * size, 0.4 * size)
    point2 = (0.45 * size, 0.4 * size)
    radialGradient = QRadialGradient(point1, size * 0.5, point2, size * 0.1)
    radialGradient.setColorAt(0, white)
    radialGradient.setColorAt(1, black)
 
    brush2 = QBrush(radialGradient)
    painter.setPen(Qt.NoPen)
    painter.setBrush(brush2)
    painter.drawEllipse((size - diameter)/2, (size - diameter)/2, diameter, diameter)
 
    image.save(""sphere.png"")
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bitcoin/address_validation,Bitcoin/address validation,"Bitcoin/address validation

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Write a program that takes a bitcoin address as argument,
and checks whether or not this address is valid.

A bitcoin address uses a base58 encoding, which uses an alphabet of the characters 0 .. 9, A ..Z, a .. z, but without the four characters:

   0   zero
   O   uppercase oh
   I   uppercase eye
   l   lowercase ell


With this encoding, a bitcoin address encodes 25 bytes:

 the first byte is the version number, which will be zero for this task ;
 the next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this task: you can consider them a pure arbitrary data ;
 the last four bytes are a checksum check. They are the first four bytes of a double SHA-256 digest of the previous 21 bytes.


To check the bitcoin address, you must read the first twenty-one bytes, compute the checksum, and check that it corresponds to the last four bytes.

The program can either return a boolean value or throw an exception when not valid.

You can use a digest library for SHA-256.



Example of a bitcoin address



1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i



It doesn't belong to anyone and is part of the test suite of the bitcoin software.

You can change a few characters in this string and check that it'll fail the test.



",Python,"import hashlib
import unittest
 
def validate_bitcoin_address(address):
    if len(address) < 26 or len(address) > 35:
        raise Exception(""wrong length"")
    decoded = decode_base58(address)
    d1 = hash(decoded[:21])
    d2 = hash(d1)
    if decoded[21:25]!= d2[:4]:
        raise Exception(""bad digest"")
    return True
 
def decode_base58(input):
    output = [0] * 25
    for t in input:
        p = ""123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"".index(t)
        if p == -1:
            raise Exception(""invalid character found"")
        j = 24
        while j > 0:
            p += 58 * output[j]
            output[j] = p % 256
            p //= 256
            j -= 1
        if p!= 0:
            raise Exception(""address too long"")
    return output
 
def hash(bytes):
    return hashlib.sha256(bytes).digest()
 
class ValidateTest(unittest.TestCase):
    def test_validate_bitcoin_address(self):
        self.assertTrue(validate_bitcoin_address(""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"")) # VALID
        self.assertTrue(validate_bitcoin_address(""1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9"")) # VALID
        self.assertRaises(Exception, validate_bitcoin_address, ""1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X"") # checksum changed, original data
        self.assertRaises(Exception, validate_bitcoin_address, ""1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"") # data changed, original checksum
        self.assertRaises(Exception, validate_bitcoin_address, ""1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i"") # invalid chars
        self.assertRaises(Exception, validate_bitcoin_address, ""BZbvjr"") # checksum is fine, address too short
 
if __name__ == '__main__':
    unittest.main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",Python,"# version 1.1.0
 
def stoogeSort(a, i, j):
    if a[j] < a[i]:
        temp = a[j]
        a[j] = a[i]
        a[i] = temp
    if j - i > 1:
        t = (j - i + 1) // 3
        stoogeSort(a, i, j - t)
        stoogeSort(a, i + t, j)
        stoogeSort(a, i, j - t)
 
if __name__ == '__main__':
    a = [100, 2, 56, 200, -52, 3, 99, 33, 177, -199]
    print(""Original : {}"".format(a))
    stoogeSort(a, 0, len(a) - 1)
    print(""Sorted   : {}"".format(a))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Galton_box_animation,Galton box animation," Example of a Galton Box at the end of animation.


A   Galton device   Sir Francis Galton's device   is also known as a   bean machine,   a   Galton Board,   or a   quincunx.



Description of operation

In a Galton box, there are a set of pins arranged in a triangular pattern.   A number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin.   The ball continues to fall to the left or right of lower pins before arriving at one of the collection points between and to the sides of the bottom row of pins.

Eventually the balls are collected into bins at the bottom   (as shown in the image),   the ball column heights in the bins approximate a   bell curve.   Overlaying   Pascal's triangle   onto the pins shows the number of different paths that can be taken to get to each bin.



Task

Generate an animated simulation of a Galton device.



Task requirements

   The box should have at least 5 pins on the bottom row. 
   A solution can use graphics or ASCII animation. 
   Provide a sample of the output/display such as a screenshot.
   There can be one or more balls in flight at the same time. 
   If multiple balls are in flight, ensure they don't interfere with each other.
   A solution should allow users to specify the number of balls, or it should run until full or a preset limit. 
   Optionally,   display the number of balls.

",Python,"import random
import time
 
boxW = 41      # Galton box width
boxH = 37      # Galton box height.
pinsBaseW = 19 # Pins triangle base.
nMaxBalls = 55 # Number of balls.
 
centerH = pinsBaseW + (boxW-pinsBaseW*2+1)/2 - 1
 
empty  =''
ball   = 'o'
wall   = '|'
corner = '+'
floor  = '-'
pin    = '.'
 
class Ball:
    def __init__(self, x, y):
        if box[y][x]!= empty:
            raise Exception(""Tried to create a new ball in a non-empty cell. Program terminated."")
        self.x = x
        self.y = y
        box[y][x] = ball
 
    def doStep(self):
        if self.y <= 0:
            return # Reached the bottom of the box.
        cell = box[self.y-1][self.x]
        if cell == empty:
            box[self.y][self.x] = empty
            self.y -= 1
            box[self.y][self.x] = ball
        elif cell == pin:
            box[self.y][self.x] = empty
            self.y -= 1
            if box[self.y][self.x-1] == empty and box[self.y][self.x+1] == empty:
                self.x += random.randint(0, 1)*2 - 1
                box[self.y][self.x] = ball
                return
            elif box[self.y][self.x-1] == empty:
                self.x += 1
            else:
                self.x -= 1
            box[self.y][self.x] = ball
        else:
            # It's frozen - it always piles on other balls.
 
# Galton box. Will be printed upside down.
box = [[0 for i in range(boxW)] for j in range(boxH)]
 
def initializeBox():
    # Set ceiling and floor
    box[0][0] = corner
    box[0][boxW-1] = corner
    for i in range(1, boxW-1):
        box[0][i] = floor
    for i in range(0, boxW):
        box[boxH-1][i] = box[0][i]
 
    # Set walls
    for r in range(1, boxH-1):
        box[r][0] = wall
        box[r][boxW-1] = wall
 
    # Set rest to empty initially
    for i in range(1, boxH-1):
        for j in range(1, boxW-1):
            box[i][j] = empty
 
    # Set pins
    for nPins in range(1, pinsBaseW+1):
        for p in range(0, nPins):
            box[boxH-2-nPins][centerH+1-nPins+p*2] = pin
 
def drawBox():
    for r in range(boxH-1, -1, -1):
        for c in range(0, boxW):
            print(box[r][c], end='')
        print()
 
def main():
    random.seed(time.time())
    initializeBox()
    balls = []
    for i in range(0, nMaxBalls+boxH):
        print(""\nStep"", i, "":"")
        if i < nMaxBalls:
            balls.append(Ball(centerH, boxH-2)) # add ball
        drawBox()
 
        # Next step for the simulation.
        # Frozen balls are kept in balls slice for simplicity
        for b in balls:
            b.doStep()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sequence_of_primorial_primes,Sequence of primorial primes,"The sequence of primorial primes is given as the increasing values of n where primorial(n) ± 1 is prime.

Noting that the n'th primorial is defined as the multiplication of the smallest n primes, the sequence is of the number of primes, in order that when multiplied together is one-off being a prime number itself.



Task

Generate and show here the first ten values of the sequence.



Optional extended task

Show the first twenty members of the series.



Notes
 
 This task asks for the primorial indices that create the final primorial prime numbers, so there should be no ten-or-more digit numbers in the program output (although extended precision integers will be needed for intermediate results).
 There is some confusion in the references, but for the purposes of this task the sequence begins with n = 1.
 Probabilistic primality tests are allowed, as long as they are good enough such that the output shown is correct.


Related tasks

 Primorial numbers
 Factorial


See also

 Primorial prime Wikipedia.
 Primorial prime from The Prime Glossary.
 Sequence A088411 from The On-Line Encyclopedia of Integer Sequences

",Python,"import time
import math
import sympy
 
i, urutan, primorial_number = 1, 1, 1
start = time.time()
prime_array = sympy.primerange(1, 500)
 
while urutan <= 20:
  primorial_number *= prime_array[i-1] 
  if sympy.isprime(primorial_number - 1) or sympy.isprime(primorial_number + 1):
    print(time.time() - start, ""\tPrimorial prime"", urutan, "":"", i)
    urutan += 1
  i += 1",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Atomic_updates,Atomic updates,"

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

 get the current value of any bucket
 remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

 As often as possible, pick two buckets and make their values closer to equal.
 As often as possible, pick two buckets and arbitrarily redistribute their values.
 At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.


The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.


This task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.



",Python,"import random
import threading
import time
 
bucket_count = 15
 
def equalizer(buckets, bucket_mutex):
    while True:
        from_ = random.randint(0, bucket_count - 1)
        to = random.randint(0, bucket_count - 1)
        if from_!= to:
            bucket_mutex[min(from_, to)].acquire()
            bucket_mutex[max(from_, to)].acquire()
            diff = buckets[from_] - buckets[to]
            amount = abs(diff // 2)
            if diff < 0:
                from_, to = to, from_
            buckets[from_] -= amount
            buckets[to] += amount
            bucket_mutex[from_].release()
            bucket_mutex[to].release()
 
def randomizer(buckets, bucket_mutex):
    while True:
        from_ = random.randint(0, bucket_count - 1)
        to = random.randint(0, bucket_count - 1)
        if from_!= to:
            bucket_mutex[min(from_, to)].acquire()
            bucket_mutex[max(from_, to)].acquire()
            amount = random.randint(0, buckets[from_])
            buckets[from_] -= amount
            buckets[to] += amount
            bucket_mutex[from_].release()
            bucket_mutex[to].release()
 
def print_buckets(buckets):
    total = 0
    for bucket in buckets:
        total += bucket
        print(f""{bucket:3}"", end="" "")
    print(f""= {total:3}"")
 
buckets = [random.randint(0, 99) for _ in range(bucket_count)]
print_buckets(buckets)
 
bucket_mutex = [threading.Lock() for _ in range(bucket_count)]
t_eq = threading.Thread(target=equalizer, args=(buckets, bucket_mutex))
t_rd = threading.Thread(target=randomizer, args=(buckets, bucket_mutex))
t_eq.start()
t_rd.start()
 
while True:
    time.sleep(1)
    for mutex in bucket_mutex:
        mutex.acquire()
    print_buckets(buckets)
    for mutex in bucket_mutex:
        mutex.release()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/String_case,String case,"Task

Take the string     alphaBETA     and demonstrate how to convert it to:

   upper-case     and 
   lower-case


Use the default encoding of a string literal or plain ASCII if there is no string literal in your language.

Note: In some languages alphabets toLower and toUpper is not reversable.

Show any additional case conversion functions   (e.g. swapping case, capitalizing the first letter, etc.)   that may be included in the library of your language.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ""alphaBETA""
print s.upper() # => ""ALPHABETA""
print s.lower() # => ""alphabeta""
 
print s.swapcase() # => ""ALPHAbeta""
 
print ""fOo bAR"".capitalize() # => ""Foo bar""
print ""fOo bAR"".title() # => ""Foo Bar""
 
import string
print string.capwords(""fOo bAR"") # => ""Foo Bar""",Human_written,Python_from_C++
http://rosettacode.org/wiki/Variable_size/Get,Variable size/Get,"Demonstrate how to get the size of a variable.

See also: Host introspection
",Python,"import ctypes
intsize = ctypes.sizeof(ctypes.c_int)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",Python,"#!/usr/bin/env python3
 
import tkinter as tk
 
class MyForm(tk.Frame):
 
    def __init__(self, master=None):
        tk.Frame.__init__(self, master)
        self.pack(expand=True, fill=""both"", padx=10, pady=10)
        self.master.title(""Controls"")
        self.setupUI()
 
    def setupUI(self):
        self.value_entry = tk.Entry(self, justify=tk.CENTER)
        self.value_entry.grid(row=0, column=0, columnspan=2,
                              padx=5, pady=5, sticky=""nesw"")
        self.value_entry.insert('end', '0')
        self.value_entry.bind(""<KeyPress-Return>"", self.eventHandler)
 
        self.decre_btn = tk.Button(self, text=""Decrement"", state=tk.DISABLED)
        self.decre_btn.grid(row=1, column=0, padx=5, pady=5)
        self.decre_btn.bind(""<Button-1>"", self.eventHandler)
 
        self.incre_btn = tk.Button(self, text=""Increment"")
        self.incre_btn.grid(row=1, column=1, padx=5, pady=5)
        self.incre_btn.bind(""<Button-1>"", self.eventHandler)
 
    def eventHandler(self, event):
        value = int(self.value_entry.get())
        if event.widget == self.value_entry:
            if value > 10:
                self.value_entry.delete(""0"", ""end"")
                self.value_entry.insert(""end"", ""0"")
            elif value == 10:
                self.value_entry.config(state=tk.DISABLED)
                self.incre_btn.config(state=tk.DISABLED)
                self.decre_btn.config(state=tk.NORMAL)
            elif value == 0:
                self.value_entry.config(state=tk.NORMAL)
                self.incre_btn.config(state=tk.NORMAL)
                self.decre_btn.config(state=tk.DISABLED)
            elif (value > 0) and (value < 10):
                self.value_entry.config(state=tk.DISABLED)
                self.incre_btn.config(state=tk.NORMAL)
                self.decre_btn.config(state=tk.NORMAL)
        else:
            if event.widget == self.incre_btn:
                if (value >= 0) and (value < 10):
                    value += 1
                    self.value_entry.config(state=tk.NORMAL)
                    self.value_entry.delete(""0"", ""end"")
                    self.value_entry.insert(""end"", str(value))
                if value > 0:
                    self.decre_btn.config(state=tk.NORMAL)
                    self.value_entry.config(state=tk.DISABLED)
                if value == 10:
                    self.incre_btn.config(state=tk.DISABLED)
            elif event.widget == self.decre_btn:
                if (value > 0) and (value <= 10):
                    value -= 1
                    self.value_entry.config(state=tk.NORMAL)
                    self.value_entry.delete(""0"", ""end"")
                    self.value_entry.insert(""end"", str(value))
                    self.value_entry.config(state=tk.DISABLED)
                if (value) < 10:
                    self.incre_btn.config(state=tk.NORMAL)
                if (value) == 0:
                    self.decre_btn.config(state=tk.DISABLED)
                    self.value_entry.config(state=tk.NORMAL)
 
def main():
    app = MyForm()
    app.mainloop()
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Text_processing/2,Text processing/2,"The following task concerns data that came from a pollution monitoring station with twenty-four instruments monitoring twenty-four aspects of pollution in the air. Periodically a record is added to the file, each record being a line of 49 fields separated by white-space, which can be one or more space or tab characters.

The fields (from the left) are:

 DATESTAMP [ VALUEn FLAGn ] * 24

i.e. a datestamp followed by twenty-four repetitions of a floating-point instrument value and that instrument's associated integer flag. Flag values are >= 1 if the instrument is working and < 1 if there is some problem with it, in which case that instrument's value should be ignored.

A sample from the full data file readings.txt, which is also used in the Text processing/1 task, follows:

Data is no longer available at that link. Zipped mirror available here

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Task

 Confirm the general field format of the file.
 Identify any DATESTAMPs that are duplicated.
 Report the number of records that have good readings for all instruments.

",Python,"import re
import sys

e = re.compile(r""\s+"")

def main():
    infile = open(sys.argv[1])
    duplicates = []
    datestamps = set()
    all_ok = 0
    pattern_ok = 0
    for line in infile:
        fields = e.split(line)
        if len(fields) == 49:
            pattern_ok += 1
        else:
            print(""Format not ok!"")
        if datestamps.add(fields[0]) is None:
            howoften = (len(fields) - 1) // 2
            for n in range(1, howoften):
                if fields[2 * n] >= 1:
                    if n == howoften:
                        all_ok += 1
                        break
    infile.close()
    print(""The following %d datestamps were duplicated:"" % len(duplicates))
    for datestamp in duplicates:
        print(datestamp)
    print(""%d records were complete and ok!"" % all_ok)

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Hamming_numbers,Hamming numbers,"Hamming numbers are numbers of the form  

    H = 2i × 3j × 5k
           where 
     i,  j,  k  ≥  0 

Hamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).



Task

Generate the sequence of Hamming numbers, in increasing order.   In particular:

 Show the   first twenty   Hamming numbers.
 Show the   1691st   Hamming number (the last one below   231).
 Show the   one millionth   Hamming number (if the language – or a convenient library – supports arbitrary-precision integers).


Related tasks

 Humble numbers
 N-smooth numbers


References

 Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
 Wikipedia entry:   Smooth number
 OEIS entry:   A051037   5-smooth   or   Hamming numbers
 Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

",Python,"from itertools import islice
 
def hamming2():
    '''\
    This version is based on a snippet from:
        https://web.archive.org/web/20081219014725/http://dobbscodetalk.com:80
                         /index.php?option=com_content&task=view&id=913&Itemid=85
        http://www.drdobbs.com/architecture-and-design/hamming-problem/228700538
        Hamming problem
        Written by Will Ness
        December 07, 2008
 
        When expressed in some imaginary pseudo-C with automatic
        unlimited storage allocation and BIGNUM arithmetics, it can be
        expressed as:
            hamming = h where
              array h;
              n=0; h[0]=1; i=0; j=0; k=0;
              x2=2*h[ i ]; x3=3*h[j]; x5=5*h[k];
              repeat:
                h[++n] = min(x2,x3,x5);
                if (x2==h[n]) { x2=2*h[++i]; }
                if (x3==h[n]) { x3=3*h[++j]; }
                if (x5==h[n]) { x5=5*h[++k]; } 
    '''
    h = 1
    _h=[h]    # memoized
    multipliers  = (2, 3, 5)
    multindeces  = [0 for i in multipliers] # index into _h for multipliers
    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]
    yield h
    while True:
        h = min(multvalues)
        _h.append(h)
        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):
            if v == h:
                i += 1
                multindeces[n] = i
                multvalues[n]  = x * _h[i]
        # cap the memoization
        mini = min(multindeces)
        if mini >= 1000:
            del _h[:mini]
            multindeces = [i - mini for i in multindeces]
        #
        yield h",Human_written,Python_from_Go
http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",Python,"csvtxt = '''\
Character,Speech
The multitude,The messiah! Show us the messiah!
Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
The multitude,Who are you?
Brians mother,I'm his mother; that's who!
The multitude,Behold his mother! Behold his mother!\
'''
 
from cgi import escape
 
def _row2tr(row, attr=None):
    cols = escape(row).split(',')
    return ('<TR>'
            + ''.join('<TD>%s</TD>' % data for data in cols)
            + '</TR>')
 
def csv2html(txt):
    htmltxt = '<TABLE summary=""csv2html program output"">\n'
    for rownum, row in enumerate(txt.split('\n')):
        htmlrow = _row2tr(row)
        htmlrow = '  <TBODY>%s</TBODY>\n' % htmlrow
        htmltxt += htmlrow
    htmltxt += '</TABLE>\n'
    return htmltxt
 
htmltxt = csv2html(csvtxt)
print(htmltxt)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Repeat,Repeat,"Task

Write a procedure which accepts as arguments another procedure and a positive integer.

The latter procedure is executed a number of times equal to the accepted integer.



",Python,"def repeat(n, f):
  for i in range(n):
    f()
 
def fn():
  print(""Example"")
 
repeat(4, fn)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Casting_out_nines,Casting out nines,"Task   (in three parts)



Part 1
Write a procedure (say 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

) which implements Casting Out Nines as described by returning the checksum for 



x


{\displaystyle x}

. Demonstrate the procedure using the examples given there, or others you may consider lucky.

Part 2
Notwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:

 Consider the statement ""318682 is 101558 + 217124 and squared is 101558217124"" (see: Kaprekar numbers#Casting Out Nines (fast)).
 note that 



318682


{\displaystyle 318682}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

);
 note that 



101558217124


{\displaystyle 101558217124}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

) because for a Kaprekar they are made up of the same digits (sometimes with extra zeroes);
 note that this implies that for Kaprekar numbers the checksum of 



k


{\displaystyle k}

 equals the checksum of 




k

2




{\displaystyle k^{2}}

.
Demonstrate that your procedure can be used to generate or filter a range of numbers with the property 





c
o
9


(
k
)
=


c
o
9


(

k

2


)


{\displaystyle {\mathit {co9}}(k)={\mathit {co9}}(k^{2})}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.

Part 3
Considering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:

 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

 is the residual of 



x


{\displaystyle x}

 mod 



9


{\displaystyle 9}

;
 the procedure can be extended to bases other than 9.
Demonstrate your algorithm by generating or filtering a range of numbers with the property 



k
%
(


B
a
s
e


−
1
)
==
(

k

2


)
%
(


B
a
s
e


−
1
)


{\displaystyle k\%({\mathit {Base}}-1)==(k^{2})\%({\mathit {Base}}-1)}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.



related tasks
 First perfect square in base N with N unique digits
 Kaprekar numbers

",Python,"def compare_co9_efficiency(base, upto):
    naive_candidates = range(1, upto)
    co9_candidates = [x for x in naive_candidates if x % (base - 1) == (x * x) % (base - 1)]
    print(co9_candidates)
    print(""Trying {} numbers instead of {} saves {:.2}%"".format(
        len(co9_candidates),
        len(naive_candidates),
        100.0 - 100.0 * (len(co9_candidates) / len(naive_candidates))
    ))
 
compare_co9_efficiency(10, 100)
compare_co9_efficiency(16, 256)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Use_another_language_to_call_a_function,Use another language to call a function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
This task is inverse to the task Call foreign language function. Consider the following C program:

#include <stdio.h>
 
extern int Query (char * Data, size_t * Length);
 
int main (int argc, char * argv [])
{
   char     Buffer [1024];
   size_t   Size = sizeof (Buffer);
 
   if (0 == Query (Buffer, &Size))
   {
      printf (""failed to call Query\n"");
   }
   else
   {
      char * Ptr = Buffer;
      while (Size-- > 0) putchar (*Ptr++);
      putchar ('\n');
   }
}
Implement the missing Query function in your language, and let this C program call it. The function should place the string Here am I into the buffer which is passed to it as the parameter Data. The buffer size in bytes is passed as the parameter Length. When there is no room in the buffer, Query shall return 0. Otherwise it overwrites the beginning of Buffer, sets the number of overwritten bytes into Length and returns 1.
",Python,"# query.py
import ctypes
 
# Look for a C variable named QueryPointer.
# Raise an error if it is missing.
c_var = ctypes.CDLL(None).QueryPointer
 
# Implement the C function
#   int Query(void *data, size_t *length)
# in Python code.  Store it in a global constant in Python (named Query)
# to protect it from Python's garbage collector.
#
def Query(data, length):
  message = ""Here am I""
 
  # We got data and length as ctypes.c_void_p objects.
  # Read length, assuming sizeof(size_t) == sizeof(void *).
  length = length.value
 
  # Does the message fit in length bytes?
  if length < len(message):
    0  # failure
  else:
    length = len(message)
    ctypes.string_at(data, length)  # Copy the message.
    length = ctypes.c_size_t(length)  # Update the length.
    1  # success
 
# Set the C variable to our Query.
c_var.value = Query",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Rosetta_Code/Count_examples,Rosetta Code/Count examples,"task
Essentially, count the number of occurrences of =={{header| on each task page.

Output:

100 doors: 20 examples.
99 Bottles of Beer: 29 examples.
Abstract type: 10 examples.

Total: X examples.
For a full output, updated periodically, see Rosetta Code/Count examples/Full list.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",Python,"import urllib
import urllib2
import xml.etree.ElementTree as ET
 
URL_ROOT = ""http://rosettacode.org/mw""
 
def get_url(page, query):
    pstr = urllib.quote(page)
    qstr = urllib.urlencode(query)
    url = ""%s/%s?%s"" % (URL_ROOT, pstr, qstr)
    print url
    return url
 
def get_api_url(query):
    return get_url(""api.php"", query)
 
def category_members(category):
    query = {
        ""action"": ""query"",
        ""list"": ""categorymembers"",
        ""cmtitle"": ""Category:%s"" % category,
        ""format"": ""xml"",
        ""cmlimit"": 500,
    }
    while True:
        url = get_api_url(query)
        doc = ET.parse(urllib2.urlopen(url))
 
        for task in doc.findall("".//cm""):
            yield task.attrib[""title""]
 
        continue_elem = doc.find("".//query-continue"")
        if continue_elem is None:
            break
        cm = continue_elem.find(""categorymembers"")
        query[""cmcontinue""] = cm.attrib[""cmcontinue""]
 
if __name__ == ""__main__"":
    for task in category_members(""Category:Programming Tasks""):
        print task",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",Python,"import math
def yinyang(n=3):
	radii   = [i * n for i in (1, 3, 6)]
	ranges  = [list(range(-r, r+1)) for r in radii]
	squares = [[ (x,y) for x in rnge for y in rnge]
		   for rnge in ranges]
	circles = [[ (x,y) for x,y in sqrpoints
		     if math.hypot(x,y) <= radius ]
		   for sqrpoints, radius in zip(squares, radii)]
	m = {(x,y):' ' for x,y in squares[-1]}
	for x,y in circles[-1]:
		m[x,y] = '*'
	for x,y in circles[-1]:
		if x>0: m[(x,y)] = '·'
	for x,y in circles[-2]:
		m[(x,y+3*n)] = '*'
		m[(x,y-3*n)] = '·'
	for x,y in circles[-3]:
		m[(x,y+3*n)] = '·'
		m[(x,y-3*n)] = '*'
	return '\n'.join(''.join(m[(x,y)] for x in reversed(ranges[-1])) for y in ranges[-1])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",Python,"def hanoi(ndisks, startPeg=1, endPeg=3):
    if ndisks:
        hanoi(ndisks-1, startPeg, 6-startPeg-endPeg)
        print ""Move disk %d from peg %d to peg %d"" % (ndisks, startPeg, endPeg)
        hanoi(ndisks-1, 6-startPeg-endPeg, endPeg)
 
hanoi(ndisks=4)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Totient_function,Totient function,"The   totient   function is also known as:

   Euler's totient function
   Euler's phi totient function
   phi totient function
    Φ    function   (uppercase Greek phi)
    φ     function   (lowercase Greek phi)


Definitions   (as per number theory)

The totient function:

   counts the integers up to a given positive integer   n   that are relatively prime to   n
   counts the integers   k   in the range   1 ≤ k ≤ n   for which the greatest common divisor   gcd(n,k)   is equal to   1
   counts numbers   ≤ n   and   prime to   n


If the totient number   (for N)   is one less than   N,   then   N   is prime.



Task

Create a   totient   function and:

   Find and display   (1 per line)   for the 1st   25   integers:
   the integer   (the index)
   the totient number for that integer
   indicate if that integer is prime
   Find and display the   count   of the primes up to          100
   Find and display the   count   of the primes up to       1,000
   Find and display the   count   of the primes up to     10,000
   Find and display the   count   of the primes up to   100,000     (optional)
Show all output here.



Related task

   Perfect totient numbers


Also see

   Wikipedia: Euler's totient function.
   MathWorld: totient function.
   OEIS: Euler totient function phi(n).

",Python,"from math import gcd
 
def  φ(n):
    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)
 
if __name__ == '__main__':
    def is_prime(n):
        return φ(n) == n - 1
 
    for n in range(1, 26):
        print(f"" φ({n}) == {φ(n)}{', is prime' if is_prime(n)  else ''}"")
    count = 0
    for n in range(1, 10_000 + 1):
        count += is_prime(n)
        if n in {100, 1000, 10_000}:
            print(f""Primes up to {n}: {count}"")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Rep-string,Rep-string,"Given a series of ones and zeroes in a string, define a repeated string or rep-string as a string which is created by repeating a substring of the first N characters of the string truncated on the right to the length of the input string, and in which the substring appears repeated at least twice in the original.

For example, the string 10011001100 is a rep-string as the leftmost four characters of 1001 are repeated three times and truncated on the right to give the original string.

Note that the requirement for having the repeat occur two or more times means that the repeating unit is never longer than half the length of the input string.



Task

 Write a function/subroutine/method/... that takes a string and returns an indication of if it is a rep-string and the repeated string.   (Either the string that is repeated, or the number of repeated characters would suffice). 
 There may be multiple sub-strings that make a string a rep-string - in that case an indication of all, or the longest, or the shortest would suffice.
 Use the function to indicate the repeating substring if any, in the following:

1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1


 Show your output on this page.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_repeated(text):
    'check if the first part of the string is repeated throughout the string'
    for x in range(len(text)//2, 0, -1):
        if text.startswith(text[x:]): return x
    return 0
 
matchstr = """"""\
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
""""""
for line in matchstr.split():
    ln = is_repeated(line)
    print('%r has a repetition length of %i i.e. %s' 
           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Guess_the_number,Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",Python,"import random
t,g=random.randint(1,10),0
g=int(input(""Guess a number that's between 1 and 10: ""))
while t!=g:g=int(input(""Guess again! ""))
print(""That's right!"")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"lp = open(""/dev/lp0"")
lp.write(""Hello World!\n"")
lp.close()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"import random
import numpy as np
from PIL import Image
 
max_iterations = 50000
img_side = 800
tri_size = 400
 
# Create a new ImgBuf
imgbuf = Image.new('L', (img_side, img_side))
 
# Create triangle vertices
vertices = np.zeros((3, 2))
for i in range(vertices.shape[0]):
    vertices[i, 0] = img_side / 2 + tri_size / 2 * np.cos(np.pi * i * 2 / 3)
    vertices[i, 1] = img_side / 2 + tri_size / 2 * np.sin(np.pi * i * 2 / 3)
 
# Iterate chaos game
x = img_side / 2
y = img_side / 2
for _ in range(max_iterations):
    choice = random.randint(0, vertices.shape[0] - 1)
    x = (x + vertices[choice, 0]) / 2
    y = (y + vertices[choice, 1]) / 2
 
    imgbuf.putpixel((int(x), int(y)), 255)
 
# Save image
imgbuf.save('fractal.png')",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/SHA-256,SHA-256,"SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string ""Rosetta code"" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
",Python,">>> import hashlib
>>> hashlib.sha256( ""Rosetta code"".encode() ).hexdigest()
'764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf'
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Random_numbers,Random numbers,"Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers
with a mean of   1.0   and a   standard deviation   of   0.5



Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.



Related task

   Standard deviation

",Python,"import numpy as np
from numpy.random import normal

rands = np.zeros(1000)
for i in range(1000):
    rands[i] = normal(1.0, 0.5)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/24_game,24 game,"The 24 Game tests one's mental arithmetic.



Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

 Only the following operators/functions are allowed: multiplication, division, addition, subtraction
 Division should use floating point or rational arithmetic, etc, to preserve remainders.
 Brackets are allowed, if using an infix expression evaluator.
 Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
 The order of the digits when given does not have to be preserved.


Notes
 The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
 The task is not for the program to generate the expression, or test whether an expression is even possible.


Related tasks
 24 game/Solve


Reference
 The 24 Game on h2g2.

",Python,"import re
 
def twentyfour(numbers, input):
    invalidChars = re.compile(r'[^\d\+\*\/\s-\(\)]')
 
    def validNums(str):
        mnums = numbers[:]
        mnums.sort()
 
        return re.sub(r'[^\d\s]','', str).strip().split() \
           .map(lambda n: int(n)) \
           .sort() \
           .every(lambda v, i: v == mnums[i])
 
    def validEval(input):
        try:
            return eval(input)
        except Exception as e:
            return {'error': e.toString()}
 
    if input.strip() == """":
        return ""You must enter a value.""
    if input.match(invalidChars):
        return ""Invalid chars used, try again. Use only:\n + - * / ( )""
    if not validNums(input):
        return ""Wrong numbers used, try again.""
    calc = validEval(input)
    if type(calc)!= int:
        return ""That is not a valid input; please try again.""
    if calc!= 24:
        return ""Wrong answer: "" + str(calc) + ""; please try again.""
    return input + "" == 24.  Congratulations!""
 
# I/O below.
 
while True:
    numbers = [1, 2, 3, 4].map(lambda: random.randint(1, 8))
 
    input = raw_input(
        ""Your numbers are:\n"" + numbers.join("" "") +
        ""\nEnter expression. (use only + - * / and parens).\n"", +""'x' to exit."", """")
 
    if input == 'x':
        break
    print twentyfour(numbers, input)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Digital_root/Multiplicative_digital_root,Digital root/Multiplicative digital root,"The multiplicative digital root (MDR) and multiplicative persistence (MP) of a number, 



n


{\displaystyle n}

, is calculated rather like the Digital root except digits are multiplied instead of being added:

 Set 



m


{\displaystyle m}

 to 



n


{\displaystyle n}

 and 



i


{\displaystyle i}

 to 



0


{\displaystyle 0}

.
 While 



m


{\displaystyle m}

 has more than one digit:
 Find a replacement 



m


{\displaystyle m}

 as the multiplication of the digits of the current value of 



m


{\displaystyle m}

.
 Increment 



i


{\displaystyle i}

.
 Return 



i


{\displaystyle i}

 (= MP) and 



m


{\displaystyle m}

 (= MDR)


Task

 Tabulate the MP and MDR of the numbers 123321, 7739, 893, 899998
 Tabulate MDR versus the first five numbers having that MDR, something like:
MDR: [n0..n4]
===  ========
  0: [0, 10, 20, 25, 30]
  1: [1, 11, 111, 1111, 11111]
  2: [2, 12, 21, 26, 34]
  3: [3, 13, 31, 113, 131]
  4: [4, 14, 22, 27, 39]
  5: [5, 15, 35, 51, 53]
  6: [6, 16, 23, 28, 32]
  7: [7, 17, 71, 117, 171]
  8: [8, 18, 24, 29, 36]
  9: [9, 19, 33, 91, 119]

Show all output on this page.

Similar

The Product of decimal digits of n page was redirected here, and had the following description


Find the product of the decimal digits of a positive integer   n,   where n <= 100

The three existing entries for Phix, REXX, and Ring have been moved here, under ===Similar=== headings, feel free to match or ignore them.



References

 Multiplicative Digital Root on Wolfram Mathworld.
 Multiplicative digital root on The On-Line Encyclopedia of Integer Sequences.
 What's special about 277777788888899? - Numberphile video

",Python,"import math
 
def mult(n, base):
	mult = 1
	while mult > 0 and n > 0:
		mult *= n % base
		n //= base
	return mult
 
def mult_digital_root(n, base):
	mp = 0
	while n >= base:
		n = mult(n, base)
		mp += 1
	return mp, n
 
def main():
	base = 10
	size = 5
	test_fmt = ""%20v %3v %3v\n""
	print(test_fmt % (""Number"", ""MDR"", ""MP""))
	for n in (123321, 7739, 893, 899998, 18446743999999999999, 3778888999, 277777788888899):
		mp, mdr = mult_digital_root(n, base)
		print(test_fmt % (n, mdr, mp))
	print()
	list = [[] for _ in range(base)]
	for i in range(base):
		list[i] = []
	for cnt, n in zip(range(size*base), range(size*base)):
		_, mdr = mult_digital_root(n, base)
		if len(list[mdr]) < size:
			list[mdr].append(n)
			cnt -= 1
	table_fmt = ""%3v: %v\n""
	print(table_fmt % (""MDR"", ""First""))
	for i, l in enumerate(list):
		print(table_fmt % (i, l))
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Haversine_formula,Haversine formula,"

 This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".



Task

Implement a great-circle distance function, or use a library function,
to show the great-circle distance between:

 Nashville International Airport (BNA)   in Nashville, TN, USA,   which is: 
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

 Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius. However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased). When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km. This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.





",Python,"from math import radians, sin, cos, sqrt, asin
 
 
def haversine(lat1, lon1, lat2, lon2):
    R = 6372.8  # Earth radius in kilometers
 
    dLat = radians(lat2 - lat1)
    dLon = radians(lon2 - lon1)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
 
    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2
    c = 2 * asin(sqrt(a))
 
    return R * c
 
>>> haversine(36.12, -86.67, 33.94, -118.40)
2887.2599506071106
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",Python,"def sierpinski(n):
    d = [""*""]
    for i in xrange(n):
        sp = "" "" * (2 ** i)
        d = [sp+x+sp for x in d] + [x+"" ""+x for x in d]
    return d
 
print ""\n"".join(sierpinski(4))",Human_written,Python_from_JavaScript
"http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem","Sailors, coconuts and a monkey problem","Five sailors are shipwrecked on an island and collect a large pile of coconuts during the day.

That night the first sailor wakes up and decides to take his first share early so tries to divide the pile of coconuts equally into five piles but finds that there is one coconut left over, so he tosses it to a monkey and then hides ""his"" one of the five equally sized piles of coconuts and pushes the other four piles together to form a single visible pile of coconuts again and goes to bed.

To cut a long story short, each of the sailors in turn gets up once during the night and performs the same actions of dividing the coconut pile into five, finding that one coconut is left over and giving that single remainder coconut to the monkey.

In the morning (after the surreptitious and separate action of each of the five sailors during the night), the remaining coconuts are divided into five equal piles for each of the sailors, whereupon it is found that the pile of coconuts divides equally amongst the sailors with no remainder. (Nothing for the monkey in the morning.)



The task

 Calculate the minimum possible size of the initial pile of coconuts collected during the first day.
 Use a method that assumes an answer is possible, and then applies the constraints of the tale to see if it is correct. (I.e. no applying some formula that generates the correct answer without integer divisions and remainders and tests on remainders; but constraint solvers are allowed.)
 Calculate the size of the initial pile of coconuts if six sailors were marooned and went through a similar process (but split into six piles instead of five of course).
 Show your answers here.


Extra credit (optional)

 Give some indication of the number of coconuts each sailor hides during the night.


Note

 Of course the tale is told in a world where the collection of any amount of coconuts in a day and multiple divisions of the pile, etc can occur in time fitting the story line, so as not to affect the mathematics.
 The tale is also told in a version where the monkey also gets a coconut in the morning. This is not that tale!


C.f

 Monkeys and Coconuts - Numberphile (Video) Analytical solution.
 A002021: Pile of coconuts problem The On-Line Encyclopedia of Integer Sequences. (Although some of its references may use the alternate form of the tale).

",Python,"import math
 
def valid(n, nuts):
    for k in range(n, 0, -1):
        nuts -= 1 + math.floor(nuts / n)
        if nuts % n!= 1:
            return False
    return nuts!= 0 and nuts % n == 0
 
x = 0
for n in range(2, 10):
    while not valid(n, x):
        x += 1
    print(n, "": "", x, sep="""")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,"#The function anynacci determines the n-arity of the sequence from the number of seed elements. 0 ended arrays are used since C does not have a way of determining the length of dynamic and function-passed integer arrays.
 
def anynacci(seedArray, howMany):
    result = [0] * howMany
    i = 0
    while seedArray[i]!= 0:
        i += 1
    initialCardinality = i
    for i in range(initialCardinality):
        result[i] = seedArray[i]
    for i in range(initialCardinality, howMany):
        result[i] = 0
        for j in range(i - initialCardinality, i):
            result[i] += result[j]
    return result
 
fibo = [1, 1, 0]
tribo = [1, 1, 2, 0]
tetra = [1, 1, 2, 4, 0]
luca = [2, 1, 0]
fibonacci = anynacci(fibo, 10)
tribonacci = anynacci(tribo, 10)
tetranacci = anynacci(tetra, 10)
lucas = anynacci(luca, 10)
 
print ""\nFibonacci\tTribonacci\tTetranacci\tLucas\n""
for i in range(10):
    print ""%d\t\t%d\t\t%d\t\t%d"" % (fibonacci[i], tribonacci[i], tetranacci[i], lucas[i])",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",Python,"example = {}
example['foo'] = lambda x: 42 + x

name = 'foo'
example[name](5)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sum_of_squares,Sum of squares,"Task

Write a program to find the sum of squares of a numeric vector.

The program should work on a zero-length vector (with an answer of   0).



Related task

   Mean

",Python,"sum([x*x for x in [3,1,4,1,5,9]])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Greyscale_bars/Display,Greyscale bars/Display,"The task is to display a series of vertical greyscale bars (contrast bars) with a sufficient number of bars to span the entire width of the display.

For the top quarter of the display, the left hand bar should be black, and we then incrementally step through six shades of grey until we have a white bar on the right hand side of the display. (This gives a total of 8 bars)

For the second quarter down, we start with white and step down through 14 shades of gray, getting darker until we have black on the right hand side of the display. (This gives a total of 16 bars).

Halfway down the display, we start with black, and produce 32 bars, ending in white, and for the last quarter, we start with white and step through 62 shades of grey, before finally arriving at black in the bottom right hand corner, producing a total of 64 bars for the bottom quarter.
",Python,"import gtk
import cairo
def gsplot(cr,x,y,s):
    cr.set_source_rgb(s,s,s)
    cr.move_to(x+0.5,y)
    cr.rel_line_to(0,1)
    cr.stroke()
def expose_event(widget,event,data=None):
    cr = widget.window.cairo_create()
    cr.scale(5,50)
    cr.set_line_width(1)
    for r in range(4):
        c = (r&1)*64-(r%2)
        while c!= (!(r%2))*64-(r%2):
            gsplot(cr,x%64,r,c/(1<<(3-r))/(8*(1<<r)-1.0))
            x+=1
            c+=2*!(r%2)-1
    return False
def main():
    window = gtk.Window()
    window.connect(""expose-event"",expose_event)
    window.connect(""delete-event"",gtk.main_quit)
    window.set_default_size(320,200)
    window.set_app_paintable(True)
    window.show_all()
    gtk.main()
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Pernicious_numbers,Pernicious numbers,"A   pernicious number   is a positive integer whose   population count   is a prime.

The   population count   is the number of   ones   in the binary representation of a non-negative integer.



Example
22   (which is   10110   in binary)   has a population count of   3,   which is prime,   and therefore

22   is a pernicious number.



Task
 display the first   25   pernicious numbers   (in decimal).
 display all pernicious numbers between   888,888,877   and   888,888,888   (inclusive).
 display each list of integers on one line   (which may or may not include a title).


See also
 Sequence   A052294 pernicious numbers on The On-Line Encyclopedia of Integer Sequences.
 Rosetta Code entry   population count, evil numbers, odious numbers.

",Python,">>> def popcount(n): return bin(n).count(""1"")
 
>>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}
>>> p, i = [], 0
>>> while len(p) < 25:
        if popcount(i) in primes: p.append(i)
        i += 1
 
 
>>> p
[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]
>>> p, i = [], 888888877
>>> while i <= 888888888:
        if popcount(i) in primes: p.append(i)
        i += 1
 
 
>>> p
[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",Python,"print(""""""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
"""""")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/HTTP,HTTP,"Task

Access and print a URL's content (the located resource) to the console.

There is a separate task for HTTPS Requests.



",Python,"import urllib.request
print(urllib.request.urlopen(""http://rosettacode.org"").read())",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort,Sorting algorithms/Selection sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of elements using the Selection sort algorithm.



It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.



Its asymptotic complexity is    O(n2)    making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.



References

   Rosetta Code:   O     (complexity).
   Wikipedia:   Selection sort.
   Wikipedia:   [Big O notation].

",Python,"def selection_sort(lst):
    for i, e in enumerate(lst):
        mn = min(range(i,len(lst)), key=lst.__getitem__)
        lst[i], lst[mn] = lst[mn], e
    return lst",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_palindrome(s):
  return s == s[::-1]",Human_written,Python_from_C++
http://rosettacode.org/wiki/Substring/Top_and_tail,Substring/Top and tail,"The task is to demonstrate how to remove the first and last characters from a string.

The solution should demonstrate how to obtain the following results:

 String with first character removed
 String with last character removed
 String with both the first and last characters removed


If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it.

The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.0.6
def main(args):
    s = ""Rosetta""
    print(s[1:])
    print(s[:-1])
    print(s[1:-1])

if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",Python,"array = []
 
array.append(1)
array.append(3)
 
array[0] = 2
 
print array[0]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"def eca(cells, rule):
    lencells = len(cells)
    c = ""0"" + cells + ""0""    # Zero pad the ends
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    yield c[1:-1]
    while True:
        c = ''.join(['0',
                     ''.join(neighbours2next[c[i-1:i+2]]
                             for i in range(1,lencells+1)),
                     '0'])
        yield c[1:-1]
 
if __name__ == '__main__':
    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)
    zipped = [range(lines)] + [eca(start, rule) for rule in rules]
    print('\n   Rules: %r' % (rules,))
    for data in zip(*zipped):
        i = data[0]
        cells = data[1:]
        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Quickselect_algorithm,Quickselect algorithm,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Use the quickselect algorithm on the vector

 [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
To show the first, second, third, ... up to the tenth largest member of the vector, in order, here on this page.

 Note: Quicksort has a separate task. 

",Python,"import random
 
def partition(vector, left, right, pivotIndex):
    pivotValue = vector[pivotIndex]
    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  # Move pivot to end
    storeIndex = left
    for i in range(left, right):
        if vector[i] < pivotValue:
            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]
            storeIndex += 1
    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  # Move pivot to its final place
    return storeIndex
 
def _select(vector, left, right, k):
    ""Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.""
    while True:
        pivotIndex = random.randint(left, right)     # select pivotIndex between left and right
        pivotNewIndex = partition(vector, left, right, pivotIndex)
        pivotDist = pivotNewIndex - left
        if pivotDist == k:
            return vector[pivotNewIndex]
        elif k < pivotDist:
            right = pivotNewIndex - 1
        else:
            k -= pivotDist + 1
            left = pivotNewIndex + 1
 
def select(vector, k, left=None, right=None):
    """"""\
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    """"""
    if left is None:
        left = 0
    lv1 = len(vector) - 1
    if right is None:
        right = lv1
    assert vector and k >= 0, ""Either null vector or k < 0 ""
    assert 0 <= left <= lv1, ""left is out of range""
    assert left <= right <= lv1, ""right is out of range""
    return _select(vector, left, right, k)
 
if __name__ == '__main__':
    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
    print([select(v, i) for i in range(10)])",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Superpermutation_minimisation,Superpermutation minimisation,"A superpermutation of N different characters is a string consisting of an arrangement of multiple copies of those N different characters in which every permutation of those characters can be found as a substring.

For example, representing the characters as A..Z, using N=2 we choose to use the first two characters 'AB'. 

The permutations of 'AB' are the two, (i.e. two-factorial), strings: 'AB' and 'BA'.

A too obvious method of generating a superpermutation is to just join all the permutations together forming 'ABBA'.

A little thought will produce the shorter (in fact the shortest) superpermutation of 'ABA' - it contains 'AB' at the beginning and contains 'BA' from the middle to the end.

The ""too obvious"" method of creation generates a string of length N!*N. Using this as a yardstick, the task is to investigate other methods of generating superpermutations of N from 1-to-7 characters, that never generate larger superpermutations.

Show descriptions and comparisons of algorithms used here, and select the ""Best"" algorithm as being the one generating shorter superpermutations.

The problem of generating the shortest superpermutation for each N might be NP complete, although the minimal strings for small values of N have been found by brute -force searches.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Reference

 The Minimal Superpermutation Problem. by Nathaniel Johnston.
 oeis A180632 gives 0-5 as 0, 1, 3, 9, 33, 153. 6 is thought to be 872.
 Superpermutations - Numberphile. A video
 Superpermutations: the maths problem solved by 4chan - Standupmaths. A video of recent (2018) mathematical progress.
 New Superpermutations Discovered! Standupmaths & Numberphile.

",Python,"""Generate a short Superpermutation of n characters A... as a string using various algorithms.""
 
 
from __future__ import print_function, division
 
from itertools import permutations
from math import factorial
import string
import datetime
import gc
 
 
 
MAXN = 7
 
 
def s_perm0(n):
    """"""
    Uses greedy algorithm of adding another char (or two, or three, ...)
    until an unseen perm is formed in the last n chars
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in permutations(allchars)]
    sp, tofind = allperms[0], set(allperms[1:])
    while tofind:
        for skip in range(1, n):
            for trial_add in (''.join(p) for p in permutations(sp[-n:][:skip])):
                #print(sp, skip, trial_add)
                trial_perm = (sp + trial_add)[-n:]
                if trial_perm in tofind:
                    #print(sp, skip, trial_add)
                    sp += trial_add
                    tofind.discard(trial_perm)
                    trial_add = None    # Sentinel
                    break
            if trial_add is None:
                break
    assert all(perm in sp for perm in allperms) # Check it is a superpermutation
    return sp
 
def s_perm1(n):
    """"""
    Uses algorithm of concatenating all perms in order if not already part
    of concatenation.
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in sorted(permutations(allchars))]
    perms, sp = allperms[::], ''
    while perms:
        nxt = perms.pop()
        if nxt not in sp:
            sp += nxt
    assert all(perm in sp for perm in allperms)
    return sp
 
def s_perm2(n):
    """"""
    Uses algorithm of concatenating all perms in order first-last-nextfirst-
    nextlast... if not already part of concatenation.
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in sorted(permutations(allchars))]
    perms, sp = allperms[::], ''
    while perms:
        nxt = perms.pop(0)
        if nxt not in sp:
            sp += nxt
        if perms:
            nxt = perms.pop(-1)
            if nxt not in sp:
                sp += nxt
    assert all(perm in sp for perm in allperms)
    return sp
 
def _s_perm3(n, cmp):
    """"""
    Uses algorithm of concatenating all perms in order first,
    next_with_LEASTorMOST_chars_in_same_position_as_last_n_chars, ...
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in sorted(permutations(allchars))]
    perms, sp = allperms[::], ''
    while perms:
        lastn = sp[-n:]
        nxt = cmp(perms,
                  key=lambda pm:
                    sum((ch1 == ch2) for ch1, ch2 in zip(pm, lastn)))
        perms.remove(nxt)
        if nxt not in sp:
            sp += nxt
    assert all(perm in sp for perm in allperms)
    return sp
 
def s_perm3_max(n):
    """"""
    Uses algorithm of concatenating all perms in order first,
    next_with_MOST_chars_in_same_position_as_last_n_chars, ...
    """"""
    return _s_perm3(n, max)
 
def s_perm3_min(n):
    """"""
    Uses algorithm of concatenating all perms in order first,
    next_with_LEAST_chars_in_same_position_as_last_n_chars, ...
    """"""
    return _s_perm3(n, min)
 
 
longest = [factorial(n) * n for n in range(MAXN + 1)]
weight, runtime = {}, {}
print(__doc__)
for algo in [s_perm0, s_perm1, s_perm2, s_perm3_max, s_perm3_min]:
    print('\n###\n### %s\n###' % algo.__name__)
    print(algo.__doc__)
    weight[algo.__name__], runtime[algo.__name__] = 1, datetime.timedelta(0)
    for n in range(1, MAXN + 1):
        gc.collect()
        gc.disable()
        t = datetime.datetime.now()
        sp = algo(n)
        t = datetime.datetime.now() - t
        gc.enable()
        runtime[algo.__name__] += t
        lensp = len(sp)
        wt = (lensp / longest[n]) ** 2
        print('  For N=%i: SP length %5i Max: %5i Weight: %5.2f'
              % (n, lensp, longest[n], wt))
        weight[algo.__name__] *= wt
    weight[algo.__name__] **= 1 / n  # Geometric mean
    weight[algo.__name__] = 1 / weight[algo.__name__]
    print('%*s Overall Weight: %5.2f in %.1f seconds.'
          % (29, '', weight[algo.__name__], runtime[algo.__name__].total_seconds()))
 
print('\n###\n### Algorithms ordered by shortest superpermutations first\n###')
print('\n'.join('%12s (%.3f)' % kv for kv in
                sorted(weight.items(), key=lambda keyvalue: -keyvalue[1])))
 
print('\n###\n### Algorithms ordered by shortest runtime first\n###')
print('\n'.join('%12s (%.3f)' % (k, v.total_seconds()) for k, v in
                sorted(runtime.items(), key=lambda keyvalue: keyvalue[1])))",Human_written,Python_from_C
http://rosettacode.org/wiki/Execute_Brain****,Execute Brain****,"Execute Brain**** is an implementation of Brainf***.
Other implementations of Brainf***.
RCBF is a set of Brainf*** compilers and interpreters written for Rosetta Code in a variety of languages.

Below are links to each of the versions of RCBF.

An implementation need only properly implement the following instructions:



Command

Description


 > 
 Move the pointer to the right


 < 
 Move the pointer to the left


 + 
 Increment the memory cell under the pointer


 - 
 Decrement the memory cell under the pointer


 . 
 Output the character signified by the cell at the pointer


 , 
 Input a character and store it in the cell at the pointer


 [ 
 Jump past the matching ] if the cell under the pointer is 0


 ] 
 Jump back to the matching [ if the cell under the pointer is nonzero

Any cell size is allowed,   EOF   (End-O-File)   support is optional, as is whether you have bounded or unbounded memory.



",Python,"class Data(object):
    def __init__(self, ptr, cells):
        self.ptr = ptr
        self.cells = cells
 
def inc_ptr(next_cmd):
    def _inc_ptr(data):
        return next_cmd(Data(data.ptr + 1, data.cells))
    return _inc_ptr
 
def dec_ptr(next_cmd):
    def _dec_ptr(data):
        return next_cmd(Data(data.ptr - 1, data.cells))
    return _dec_ptr
 
def inc_cell(next_cmd):
    def _inc_cell(data):
        return next_cmd(Data(data.ptr, data.cells.set(data.ptr, data.cells.get(data.ptr, 0) + 1)))
    return _inc_cell
 
def dec_cell(next_cmd):
    def _dec_cell(data):
        return next_cmd(Data(data.ptr, data.cells.set(data.ptr, data.cells.get(data.ptr, 0) - 1)))
    return _dec_cell
 
def output_cell(next_cmd):
    def _output_cell(data):
        global output
        output.append(data.cells.get(data.ptr, 0))
        return next_cmd(data)
    return _output_cell
 
def input_cell(next_cmd):
    def _input_cell(data):
        global input
        return next_cmd(Data(data.ptr, data.cells.set(data.ptr, input[0])))
    return _input_cell
 
def if_loop(next_cmd, loop_cmd):
    def _if_loop(data):
        if data.cells.get(data.ptr, 0) == 0:
            return data
        else:
            return _if_loop(loop_cmd(data))
    return _if_loop
 
def terminate(data):
    return data
 
def split_cmds(cmds):
    def _split(cmds, loop_cmds):
        if len(cmds) == 0:
            raise Exception(""invalid commands: missing ]"")
        cmd = cmds[0]
        if cmd == '[':
            c, l = _split(cmds[1:], """")
            return _split(c, loop_cmds + ""["" + l + ""]"")
        elif cmd == ']':
            return cmds[1:], loop_cmds
        else:
            return _split(cmds[1:], loop_cmds + cmd)
    return _split(cmds, """")
 
def compile_cmds(cmds):
    if len(cmds) == 0:
        return terminate
    cmd = cmds[0]
    if cmd == '>':
        return inc_ptr(compile_cmds(cmds[1:]))
    elif cmd == '<':
        return dec_ptr(compile_cmds(cmds[1:]))
    elif cmd == '+':
        return inc_cell(compile_cmds(cmds[1:]))
    elif cmd == '-':
        return dec_cell(compile_cmds(cmds[1:]))
    elif cmd == '.':
        return output_cell(compile_cmds(cmds[1:]))
    elif cmd == ',':
        return input_cell(compile_cmds(cmds[1:]))
    elif cmd == '[':
        cmds, loop_cmds = split_cmds(cmds[1:])
        return if_loop(compile_cmds(cmds), compile_cmds(loop_cmds))
    elif cmd == ']':
        raise Exception(""invalid commands: missing ["")
    else:
        return compile_cmds(cmds[1:])
 
def compile_and_run(cmds, input):
    global output
    output = []
    compiled_cmds = compile_cmds(cmds)
    print(compiled_cmds(Data(0, {})))
    print(output)
    print(''.join(map(chr, output)))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/RPG_attributes_generator,RPG attributes generator,"RPG   =   Role Playing Game.



You're running a tabletop RPG, and your players are creating characters.

Each character has six core attributes: strength, dexterity, constitution, intelligence, wisdom, and charisma.

One way of generating values for these attributes is to roll four, 6-sided dice (d6) and sum the three highest rolls, discarding the lowest roll.

Some players like to assign values to their attributes in the order they're rolled.

To ensure generated characters don't put players at a disadvantage, the following requirements must be satisfied:

 The total of all character attributes must be at least 75.
 At least two of the attributes must be at least 15.

However, this can require a lot of manual dice rolling. A programatic solution would be much faster.



Task

Write a program that:

 Generates 4 random, whole values between 1 and 6.
 Saves the sum of the 3 largest values.
 Generates a total of 6 values this way.
 Displays the total, and all 6 values once finished.

 The order in which each value was generated must be preserved.
 The total of all 6 values must be at least 75.
 At least 2 of the values must be 15 or more.
",Python,"import random
random.seed()
attributes_total = 0
count = 0
 
while attributes_total < 75 or count < 2:
    attributes = []
 
    for attribute in range(0, 6):
        rolls = []
 
        for roll in range(0, 4):
            result = random.randint(1, 6)
            rolls.append(result)
 
        sorted_rolls = sorted(rolls)
        largest_3 = sorted_rolls[1:]
        rolls_total = sum(largest_3)
 
        if rolls_total >= 15:
            count += 1
 
        attributes.append(rolls_total)
 
    attributes_total = sum(attributes)
 
print(attributes_total, attributes)",Human_written,Python_from_JavaScript
"http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem","Sailors, coconuts and a monkey problem","Five sailors are shipwrecked on an island and collect a large pile of coconuts during the day.

That night the first sailor wakes up and decides to take his first share early so tries to divide the pile of coconuts equally into five piles but finds that there is one coconut left over, so he tosses it to a monkey and then hides ""his"" one of the five equally sized piles of coconuts and pushes the other four piles together to form a single visible pile of coconuts again and goes to bed.

To cut a long story short, each of the sailors in turn gets up once during the night and performs the same actions of dividing the coconut pile into five, finding that one coconut is left over and giving that single remainder coconut to the monkey.

In the morning (after the surreptitious and separate action of each of the five sailors during the night), the remaining coconuts are divided into five equal piles for each of the sailors, whereupon it is found that the pile of coconuts divides equally amongst the sailors with no remainder. (Nothing for the monkey in the morning.)



The task

 Calculate the minimum possible size of the initial pile of coconuts collected during the first day.
 Use a method that assumes an answer is possible, and then applies the constraints of the tale to see if it is correct. (I.e. no applying some formula that generates the correct answer without integer divisions and remainders and tests on remainders; but constraint solvers are allowed.)
 Calculate the size of the initial pile of coconuts if six sailors were marooned and went through a similar process (but split into six piles instead of five of course).
 Show your answers here.


Extra credit (optional)

 Give some indication of the number of coconuts each sailor hides during the night.


Note

 Of course the tale is told in a world where the collection of any amount of coconuts in a day and multiple divisions of the pile, etc can occur in time fitting the story line, so as not to affect the mathematics.
 The tale is also told in a version where the monkey also gets a coconut in the morning. This is not that tale!


C.f

 Monkeys and Coconuts - Numberphile (Video) Analytical solution.
 A002021: Pile of coconuts problem The On-Line Encyclopedia of Integer Sequences. (Although some of its references may use the alternate form of the tale).

",Python,"def valid(sailor, nuts):
    for i in range(sailor):
        if (nuts % sailor)!= 1:
            return False
        nuts -= 1 + nuts / sailor
    return nuts > 0 and nuts % sailor == 0

for sailor in [5, 6]:
    n = sailor
    while not valid(sailor, n):
        n += 1
    print(""\n{} sailors => {} coconuts"".format(sailor, n))
    for i in range(sailor + 1):
        div, mod = divmod(n, sailor)
        print(""  {} {} {}"".format(n, div, mod))
        n -= 1 + div",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Department_numbers,Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",Python,"# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f, xs):
    return [y for x in xs for y in f(x)]

print('(Police, Sanitation, Fire)\n' +
      '\n'.join(map(str, concatMap(lambda x: concatMap(lambda y: concatMap(lambda z: [z] if z!= y and 1 <= z <= 7 else [], [12 - (x + y)]), [1, 2, 3, 4, 5, 6, 7]), [2, 4, 6]))))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Set_puzzle,Set puzzle,"Set Puzzles are created with a deck of cards from the Set Game™. The object of the puzzle is to find sets of 3 cards in a rectangle of cards that have been dealt face up. 


There are 81 cards in a deck.
Each card contains a unique variation of the following four features: color, symbol, number and shading.

 there are three colors:
    red, green, purple

 there are three symbols:
    oval, squiggle, diamond

 there is a number of symbols on the card:
    one, two, three

 there are three shadings:
    solid, open, striped

Three cards form a set if each feature is either the same on each card, or is different on each card. For instance: all 3 cards are red, all 3 cards have a different symbol, all 3 cards have a different number of symbols, all 3 cards are striped.

There are two degrees of difficulty: basic and advanced. The basic mode deals 9 cards, that contain exactly 4 sets; the advanced mode deals 12 cards that contain exactly 6 sets.

When creating sets you may use the same card more than once.




Task
Write code that deals the cards (9 or 12, depending on selected mode) from a shuffled deck in which the total number of sets that could be found is 4 (or 6, respectively); and print the contents of the cards and the sets.

For instance:



DEALT 9 CARDS:

green, one, oval, striped
green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid
purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open
red, three, oval, open
red, three, diamond, solid

CONTAINING 4 SETS:

green, one, oval, striped
purple, two, squiggle, open
red, three, diamond, solid


green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid


green, one, diamond, open
purple, two, squiggle, open
red, three, oval, open


purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open

",Python,"# version 1.1.3
 
from enum import Enum
from random import shuffle
 
class Color(Enum):
    RED = 0
    GREEN = 1
    PURPLE = 2
 
class Symbol(Enum):
    OVAL = 0
    SQUIGGLE = 1
    DIAMOND = 2
 
class Number(Enum):
    ONE = 0
    TWO = 1
    THREE = 2
 
class Shading(Enum):
    SOLID = 0
    OPEN = 1
    STRIPED = 2
 
class Degree(Enum):
    BASIC = 0
    ADVANCED = 1
 
class Card:
 
    def __init__(self, color, symbol, number, shading):
        self.color = color
        self.symbol = symbol
        self.number = number
        self.shading = shading
        self.value = (
            color.value * 27 + symbol.value * 9 + number.value * 3 + shading.value
        )
 
    def __lt__(self, other):
        return self.value < other.value
 
    def __str__(self):
        return (
            self.color.name.ljust(8) +
            self.symbol.name.ljust(10) +
            self.number.name.ljust(7) +
            self.shading.name.ljust(7)
        ).lower()
 
    @staticmethod
    def zero():
        return Card(Color.RED, Symbol.OVAL, Number.ONE, Shading.SOLID)
 
def create_deck():
    return [
        Card(color, symbol, number, shading)
        for color in Color
        for symbol in Symbol
        for number in Number
        for shading in Shading
    ]
 
def play_game(degree):
    deck = create_deck()
    n_cards = 9 if degree == Degree.BASIC else 12
    n_sets = n_cards // 2
    sets = [ [Card.zero() for _ in range(3)] for _ in range(n_sets) ]
    while True:
        shuffle(deck)
        hand = deck[:n_cards]
        count = 0
        for i in range(len(hand) - 2):
            for j in range(i + 1, len(hand) - 1):
                for k in range(j + 1, len(hand)):
                    trio = [hand[i], hand[j], hand[k]]
                    if is_set(trio):
                        sets[count] = trio
                        count += 1
                        if count == n_sets:
                            break
        else:
            continue
        break
    hand.sort()
    print(f'DEALT {n_cards} CARDS:\n')
    print('\n'.join(str(card) for card in hand))
    print(f'\nCONTAINING {n_sets} SETS:\n')
    for s in sets:
        s.sort()
        print('\n'.join(str(card) for card in s))
        print()
 
def is_set(trio):
    r1 = sum(card.color.value for card in trio) % 3
    r2 = sum(card.symbol.value for card in trio) % 3
    r3 = sum(card.number.value for card in trio) % 3
    r4 = sum(card.shading.value for card in trio) % 3
    return (r1 + r2 + r3 + r4) == 0
 
if __name__ == '__main__':
    play_game(Degree.BASIC)
    print()
    play_game(Degree.ADVANCED)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Text_processing/2,Text processing/2,"The following task concerns data that came from a pollution monitoring station with twenty-four instruments monitoring twenty-four aspects of pollution in the air. Periodically a record is added to the file, each record being a line of 49 fields separated by white-space, which can be one or more space or tab characters.

The fields (from the left) are:

 DATESTAMP [ VALUEn FLAGn ] * 24

i.e. a datestamp followed by twenty-four repetitions of a floating-point instrument value and that instrument's associated integer flag. Flag values are >= 1 if the instrument is working and < 1 if there is some problem with it, in which case that instrument's value should be ignored.

A sample from the full data file readings.txt, which is also used in the Text processing/1 task, follows:

Data is no longer available at that link. Zipped mirror available here

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Task

 Confirm the general field format of the file.
 Identify any DATESTAMPs that are duplicated.
 Report the number of records that have good readings for all instruments.

",Python,"import datetime
import sys
 
filename = ""readings.txt""
readings = 24  # per line
fields = readings*2 + 1  # per line
dateFormat = ""%Y-%m-%d""
 
def main():
    with open(filename) as file:
        allGood = 0
        uniqueGood = 0
        m = {}
        for line in file:
            f = line.split()
            if len(f)!= fields:
                sys.exit(""unexpected format, {} fields."".format(len(f)))
            ts = datetime.datetime.strptime(f[0], dateFormat).date()
            good = True
            for i in range(1, fields, 2):
                flag = int(f[i+1])
                if flag > 0:  # value is good
                    try:
                        float(f[i])
                    except ValueError:
                        sys.exit(""bad value: {}"".format(f[i]))
                else:  # value is bad
                    good = False
            if good:
                allGood += 1
            previouslyGood = m.get(ts, False)
            m[ts] = previouslyGood or good
            if not previouslyGood and good:
                uniqueGood += 1
        print(""\nData format valid."")
        print(""{} records with good readings for all instruments."".format(allGood))
        print(""{} unique dates with good readings for all instruments."".format(uniqueGood))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sum_of_squares,Sum of squares,"Task

Write a program to find the sum of squares of a numeric vector.

The program should work on a zero-length vector (with an answer of   0).



Related task

   Mean

",Python,"import numpy as np
 
def add_square(prev_sum, new_val):
  return prev_sum + new_val*new_val
 
def vec_add_squares(v):
  return np.sum(v)
 
# first, show that for empty vectors we indeed get 0
v = np.array([]) # empty
print(vec_add_squares(v))
 
# now, use some values
v = np.array([0, 1, 3, 1.5, 42, 0.1, -4])
print(vec_add_squares(v))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Horizontal_sundial_calculations,Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",Python,"from __future__ import print_function
import math
try: raw_input
except: raw_input = input
 
lat = float(raw_input(""Enter latitude       => ""))
lng = float(raw_input(""Enter longitude      => ""))
ref = float(raw_input(""Enter legal meridian => ""))
print()
 
slat = math.sin(math.radians(lat))
print(""    sine of latitude:   %.3f"" % slat)
print(""    diff longitude:     %.3f"" % (lng-ref))
print()
print(""Hour, sun hour angle, dial hour line angle from 6am to 6pm"")
 
for h in range(-6, 7):
  hra = 15 * h
  hra -= lng - ref
  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))
  print(""HR=%3d; HRA=%7.3f; HLA=%7.3f"" % (h, hra, hla))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Intersecting_number_wheels,Intersecting number wheels,"A number wheel has:

 A name which is an uppercase letter.
 A set of ordered values which are either numbers or names.

A number is generated/yielded from a named wheel by:

1. Starting at the first value of the named wheel and advancing through subsequent values and wrapping around to the first value to form a ""wheel"":
1.a If the value is a number, yield it.
1.b If the value is a name, yield the next value from the named wheel
1.c Advance the position of this wheel.
Given the wheel

 A: 1 2 3
the number 1 is first generated, then 2, then 3, 1, 2, 3, 1, ...

Note: When more than one wheel is defined as a set of intersecting wheels then the
first named wheel is assumed to be the one that values are generated from.

Examples

Given the wheels:

   A: 1 B 2
   B: 3 4

The series of numbers generated starts:

   1, 3, 2, 1, 4, 2, 1, 3, 2, 1, 4, 2, 1, 3, 2...

The intersections of number wheels can be more complex, (and might loop forever),
and wheels may be multiply connected. 


Note: If a named wheel is referenced more than
once by one or many other wheels, then there is only one position of the wheel
that is advanced by each and all references to it.

E.g.

 A:  1 D D
 D:  6 7 8
 Generates:
   1 6 7 1 8 6 1 7 8 1 6 7 1 8 6 1 7 8 1 6 ...    

Task

Generate and show the first twenty terms of the sequence of numbers generated
from these groups:

   Intersecting Number Wheel group:
     A:  1 2 3
   
   Intersecting Number Wheel group:
     A:  1 B 2
     B:  3 4
   
   Intersecting Number Wheel group:
     A:  1 D D
     D:  6 7 8
   
   Intersecting Number Wheel group:
     A:  1 B C
     B:  3 4
     C:  5 B

Show your output here, on this page.


",Python,"from typing import List, Dict, Tuple
import itertools
 
Wheel = Tuple[int, List[str]]
WheelMap = Dict[str, Wheel]
 
def generate(wheels: WheelMap, start: str, max_count: int) -> None:
    count = 0
    w = wheels[start]
    while True:
        s = w[1][w[0]]
        w = (w[0] + 1) % len(w[1]), w[1]
        wheels[start] = w
        try:
            v = int(s)
            print(v, end="" "")
            count += 1
            if count == max_count:
                print(""..."")
                return
        except ValueError:
            while True:
                w2 = wheels[s]
                ss = s
                s = w2[1][w2[0]]
                w2 = (w2[0] + 1) % len(w2[1]), w2[1]
                wheels[ss] = w2
                try:
                    v = int(s)
                    print(v, end="" "")
                    count += 1
                    if count == max_count:
                        print(""..."")
                        return
                    break
                except ValueError:
                    pass
 
def print_wheels(wheels: WheelMap) -> None:
    names = sorted(wheels.keys())
    print(""Intersecting Number Wheel group:"")
    for name in names:
        print(f""  {name}: {wheels[name][1]}"")
    print(""  Generates:"")
    print(""    "", end="""")
 
if __name__ == ""__main__"":
    wheel_maps = [
        {""A"": (0, [""1"", ""2"", ""3""])},
        {""A"": (0, [""1"", ""B"", ""2""]), ""B"": (0, [""3"", ""4""])},
        {""A"": (0, [""1"", ""D"", ""D""]), ""D"": (0, [""6"", ""7"", ""8""])},
        {""A"": (0, [""1"", ""B"", ""C""]), ""B"": (0, [""3"", ""4""]), ""C"": (0, [""5"", ""B""])},
    ]
    for wheels in wheel_maps:
        print_wheels(wheels)
        generate(wheels, ""A"", 20)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",Python,"a, b = input(""enter two integers: "").split()
a = int(a)
b = int(b)
print(a, ""+"", b, ""="", a+b)
print(a, ""-"", b, ""="", a-b)
print(a, ""*"", b, ""="", a*b)
print(a, ""/"", b, ""="", a//b)
print(a, ""%"", b, ""="", a%b)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Greatest_subsequential_sum,Greatest subsequential sum,"Task

Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.



An empty subsequence is considered to have the sum of   0;   thus if all elements are negative, the result must be the empty sequence.



",Python,"nums = [1,2,39,34,20, -20, -16, 35, 0]

max = 0
boundaries = (0,0)

for length in range(len(nums)):
    for start in range(len(nums)-length):
        sum = sum(nums[start:start+length])
        if sum > max:
            max = sum
            boundaries = (start, start+length)

print(""Max subsequence sum: {} for {}"".format(max, nums[boundaries[0]:boundaries[1]]))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",Python,"# Python version 3.6.1
 
class C:
    def foo(self):
        print(""foo called"")
 
def main(args):
    c = C()
    f = ""c.foo""
    js(f)()  # invokes c.foo dynamically",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Anonymous_recursion,Anonymous recursion,"While implementing a recursive function, it often happens that we must resort to a separate   helper function   to handle the actual recursion.

This is usually the case when directly calling the current function would waste too many resources (stack space, execution time), causing unwanted side-effects,   and/or the function doesn't have the right arguments and/or return values.

So we end up inventing some silly name like   foo2   or   foo_helper.   I have always found it painful to come up with a proper name, and see some disadvantages:

   You have to think up a name, which then pollutes the namespace
   Function is created which is called from nowhere else
   The program flow in the source code is interrupted
Some languages allow you to embed recursion directly in-place.   This might work via a label, a local gosub instruction, or some special keyword.

Anonymous recursion can also be accomplished using the   Y combinator.



Task

If possible, demonstrate this by writing the recursive version of the fibonacci function   (see Fibonacci sequence)   which checks for a negative argument before doing the actual recursion.



",Python,">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))
>>> [ Y(fib)(i) for i in range(-2, 10) ]
[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",Python,"def add(a, b):
    """"""
    Perform addition on a and b.

    :param a: One of the numbers to be added.
    :param b: Another number to be added.
    :return: The sum of a and b.
    :code:
        sum = add(1, 2)
    """"""
    return a + b",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Luhn test of credit card numbers,"The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

 Reverse the order of the digits in the number.
 Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
 Taking the second, fourth ... and every other even digit in the reversed digits:
 Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
 Sum the partial sums of the even digits to form s2
 If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.


For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and

use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



Related tasks

   SEDOL
   ISIN

",Python,"# version 1.0
 
def checkLuhn(number):
    isOdd = True
    sum = 0
 
    for index in range(len(number) - 1, -1, -1):
        digit = int(number[index])
        sum += digit if isOdd else (digit * 2) // 10 + (digit * 2) % 10
        isOdd = not isOdd
 
    return (sum % 10) == 0
 
numbers = [""49927398716"", ""49927398717"", ""1234567812345678"", ""1234567812345670""]
for number in numbers:
    print(f""{number.rjust(16)} is {'valid' if checkLuhn(number) else 'invalid'}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Multiplication_tables,Multiplication tables,"Task

Produce a formatted   12×12   multiplication table of the kind memorized by rote when in primary (or elementary) school.



Only print the top half triangle of products.



",Python,"from browser import document, html

def multiplication_table(n, target):
    table = html.TABLE()

    row = html.TR()
    cell = html.TH('x')
    row <= cell
    for x in range(1, n+1):
        cell = html.TH(x)
        row <= cell
    table <= row

    for x in range(1, n+1):
        row = html.TR()
        cell = html.TH(x)
        row <= cell
        y = 1
        while y < x:
            cell = html.TD('\u00a0')
            row <= cell
            y += 1
        while y <= n:
            cell = html.TD(x*y)
            row <= cell
            y += 1
        table <= row
    target <= table

multiplication_table(12, document['target'])",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Multiplication_tables,Multiplication tables,"Task

Produce a formatted   12×12   multiplication table of the kind memorized by rote when in primary (or elementary) school.



Only print the top half triangle of products.



",Python,">>> size = 12
>>> width = len(str(size**2))
>>> for row in range(-1,size+1):
	if row==0:
		print(""─""*width + ""┼""+""─""*((width+1)*size-1))
	else:
		print("""".join(""%*s%1s"" % ((width,) + ((""x"",""│"")      if row==-1 and col==0
					              else (row,""│"") if row>0   and col==0
					              else (col,"""")  if row==-1
					              else ("""","""")   if row>col
					              else (row*col,"""")))
			       for col in range(size+1)))
 
 
  x│  1   2   3   4   5   6   7   8   9  10  11  12 
───┼───────────────────────────────────────────────
  1│  1   2   3   4   5   6   7   8   9  10  11  12 
  2│      4   6   8  10  12  14  16  18  20  22  24 
  3│          9  12  15  18  21  24  27  30  33  36 
  4│             16  20  24  28  32  36  40  44  48 
  5│                 25  30  35  40  45  50  55  60 
  6│                     36  42  48  54  60  66  72 
  7│                         49  56  63  70  77  84 
  8│                             64  72  80  88  96 
  9│                                 81  90  99 108 
 10│                                    100 110 120 
 11│                                        121 132 
 12│                                            144 
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Hello_world/Newbie,Hello world/Newbie,"Task

Guide a new user of a language through the steps necessary
to install the programming language and selection of a text editor if needed,
to run the languages' example in the Hello world/Text task.

 Assume the language-newbie is a programmer in another language.
 Assume the language-newbie is competent in installing software for the platform.
 Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor).
 Refer to, (and link to), already existing documentation as much as possible (but provide a summary here).
 Remember to state where to view the output.
 If particular IDE's or editors are required that are not standard, then point to/explain their installation too.


Note:
 If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated.
 You may use sub-headings if giving instructions for multiple platforms.

",Python,>>> print('hello world'),Human_written,Python_from_Rust
http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",Python,"def r2cf(n1,n2):
  while n2:
    n1, (t1, n2) = n2, divmod(n1, n2)
    yield t1
 
print(list(r2cf(1,2)))    # => [0, 2]
print(list(r2cf(3,1)))    # => [3]
print(list(r2cf(23,8)))    # => [2, 1, 7]
print(list(r2cf(13,11)))    # => [1, 5, 2]
print(list(r2cf(22,7)))    # => [3, 7]
print(list(r2cf(14142,10000)))    # => [1, 2, 2, 2, 2, 2, 1, 1, 29]
print(list(r2cf(141421,100000)))    # => [1, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1, 7, 2]
print(list(r2cf(1414214,1000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 3, 6, 1, 2, 1, 12]
print(list(r2cf(14142136,10000000)))    # => [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Modular_arithmetic,Modular arithmetic,"Modular arithmetic is a form of arithmetic (a calculation technique involving the concepts of addition and multiplication) which is done on numbers with a defined equivalence relation called congruence.

For any positive integer 



p


{\displaystyle p}

 called the congruence modulus,
two numbers 



a


{\displaystyle a}

 and 



b


{\displaystyle b}

 are said to be congruent modulo p whenever there exists an integer 



k


{\displaystyle k}

 such that:





a
=
b
+
k

p


{\displaystyle a=b+k\,p}


The corresponding set of equivalence classes forms a ring denoted 






Z


p

Z






{\displaystyle {\frac {\mathbb {Z} }{p\mathbb {Z} }}}

.

Addition and multiplication on this ring have the same algebraic structure as in usual arithmetics, so that a function such as a polynomial expression could receive a ring element as argument and give a consistent result.

The purpose of this task is to show, if your programming language allows it,
how to redefine operators so that they can be used transparently on modular integers.
You can do it either by using a dedicated library, or by implementing your own class.

You will use the following function for demonstration:





f
(
x
)
=

x

100


+
x
+
1


{\displaystyle f(x)=x^{100}+x+1}


You will use 



13


{\displaystyle 13}

 as the congruence modulus and you will compute 



f
(
10
)


{\displaystyle f(10)}

.

It is important that the function 



f


{\displaystyle f}

 is agnostic about whether or not its argument is modular; it should behave the same way with normal and modular integers.
In other words, the function is an algebraic expression that could be used with any ring, not just integers.



",Python,"import operator
import functools
 
@functools.total_ordering
class Mod:
    __slots__ = ['val','mod']
 
    def __init__(self, val, mod):
        if not isinstance(val, int):
            raise ValueError('Value must be integer')
        if not isinstance(mod, int) or mod<=0:
            raise ValueError('Modulo must be positive integer')
        self.val = val % mod
        self.mod = mod
 
    def __repr__(self):
        return 'Mod({}, {})'.format(self.val, self.mod)
 
    def __int__(self):
        return self.val
 
    def __eq__(self, other):
        if isinstance(other, Mod):
            if self.mod == other.mod:
                return self.val==other.val
            else:
                return NotImplemented
        elif isinstance(other, int):
            return self.val == other
        else:
            return NotImplemented
 
    def __lt__(self, other):
        if isinstance(other, Mod):
            if self.mod == other.mod:
                return self.val<other.val
            else:
                return NotImplemented
        elif isinstance(other, int):
            return self.val < other
        else:
            return NotImplemented
 
    def _check_operand(self, other):
        if not isinstance(other, (int, Mod)):
            raise TypeError('Only integer and Mod operands are supported')
        if isinstance(other, Mod) and self.mod != other.mod:
            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))
 
    def __pow__(self, other):
        self._check_operand(other)
        # We use the built-in modular exponentiation function, this way we can avoid working with huge numbers.
        return Mod(pow(self.val, int(other), self.mod), self.mod)
 
    def __neg__(self):
        return Mod(self.mod - self.val, self.mod)
 
    def __pos__(self):
        return self # The unary plus operator does nothing.
 
    def __abs__(self):
        return self # The value is always kept non-negative, so the abs function should do nothing.
 
# Helper functions to build common operands based on a template.
# They need to be implemented as functions for the closures to work properly.
def _make_op(opname):
    op_fun = getattr(operator, opname)  # Fetch the operator by name from the operator module
    def op(self, other):
        self._check_operand(other)
        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)
    return op
 
def _make_reflected_op(opname):
    op_fun = getattr(operator, opname)
    def op(self, other):
        self._check_operand(other)
        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)
    return op
 
# Build the actual operator overload methods based on the template.
for opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:
    setattr(Mod, opname, _make_op(opname))
    setattr(Mod, reflected_opname, _make_reflected_op(opname))
 
def f(x):
    return x**100+x+1
 
print(f(Mod(10,13)))
# Output: Mod(1, 13)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Additive_primes,Additive primes,"Definitions
In mathematics, additive primes are prime numbers for which the sum of their decimal digits are also primes.



Task
Write a program to determine (and show here) all additive primes less than 500.

Optionally, show the number of additive primes.



Also see

   the OEIS entry:   A046704 additive primes.
   the prime-numbers entry:   additive primes.
   the geeks for geeks entry: additive prime number.
   the prime-numbers fandom: additive primes.

",Python,"from itertools import islice, count
from math import sqrt
 
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True
 
def additive_primes(n):
    for i in count(2):
        if is_prime(i) and is_prime(sum(int(j) for j in str(i))):
            yield i
            if i > n:
                break
 
print("" "".join(str(i) for i in islice(additive_primes(500), 500)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Summarize_and_say_sequence,Summarize and say sequence,"There are several ways to generate a self-referential sequence. One very common one (the Look-and-say sequence) is to start with a positive integer, then generate the next term by concatenating enumerated groups of adjacent alike digits:

       0, 10, 1110, 3110, 132110, 1113122110, 311311222110 ...

The terms generated grow in length geometrically and never converge.

Another way to generate a self-referential sequence is to summarize the previous term.

Count how many of each alike digit there is, then concatenate the sum and digit for each of the sorted enumerated digits. Note that the first five terms are the same as for the previous sequence.

       0, 10, 1110, 3110, 132110, 13123110, 23124110 ... 

Sort the digits largest to smallest. Do not include counts of digits that do not appear in the previous term.

Depending on the seed value, series generated this way always either converge to a stable value or to a short cyclical pattern. (For our purposes, I'll use converge to mean an element matches a previously seen element.) The sequence shown, with a seed value of 0, converges to a stable value of 1433223110 after 11 iterations. The seed value that converges most quickly is 22. It goes stable after the first element. (The next element is 22, which has been seen before.)



Task

Find all the positive integer seed values under 1000000, for the above convergent self-referential sequence, that takes the largest number of iterations before converging. Then print out the number of iterations and the sequence they return. Note that different permutations of the digits of the seed will yield the same sequence. For this task, assume leading zeros are not permitted.

Seed Value(s): 9009 9090 9900

Iterations: 21 

Sequence: (same for all three seeds except for first element)
9009
2920
192210
19222110
19323110
1923123110
1923224110
191413323110
191433125110
19151423125110
19251413226110
1916151413325110
1916251423127110
191716151413326110
191726151423128110
19181716151413327110
19182716151423129110
29181716151413328110
19281716151423228110
19281716151413427110
19182716152413228110

Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Spelling of ordinal numbers



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Also see

   The On-Line Encyclopedia of Integer Sequences.

",Python,"_map = {}
_result = []
longest = 0
 
def make_sequence( n ):
    global _map
    global _result
    global longest
    _map = {}
    for i in n:
        if i in _map:
            _map[i] += 1
        else:
            _map[i] = 1
 
    z = """"
    for i in reversed( sorted( _map.keys() ) ):
        z += str( _map[i] )
        z += i
 
    if longest <= len( z ):
        longest = len( z )
        if z not in _result:
            _result.append( z )
            make_sequence( z )
 
tests = [ ""9900"", ""9090"", ""9009"" ]
for i in tests:
    make_sequence( i )
    print( ""["" + i + ""] Iterations: "" + str( len( _result ) + 1 ) )
    for j in _result:
        print( j )
    print( ""\n\n"" )",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Integer_sequence,Integer sequence,"Task

Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.



An example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.



",Python,"import sys
i = 0
while i < sys.maxsize:
    print(i)
    i += 1",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII,Write language name in 3D ASCII,"Task

Write/display a language's name in 3D ASCII.



(We can leave the definition of ""3D ASCII"" fuzzy,
so long as the result is interesting or amusing,
not a cheap hack to satisfy the task.)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 draw a Deathstar

",Python,"py = '''\
 #####    #   #   #####  #    #   ####   #    #
 #    #    # #      #    #    #  #    #  ##   #
 #    #     #       #    ######  #    #  # #  #
 #####      #       #    #    #  #    #  #  # #
 #          #       #    #    #  #    #  #   ##
 #          #       #    #    #   ####   #    #
'''
 
lines = py.replace('#', '<<<').replace(' ','X').replace('X', '   ').replace('\n', ' Y').replace('< ', '<>').split('Y')
for i, l in enumerate(lines): 
    print( '   ' * (len(lines) - i) + l)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",Python,"def ycomb(f):
    def y(g):
        return f(lambda *args: g(g)(*args))
    return y(y)

def fact(f):
    return lambda n: 1 if n == 0 else n * f(n-1)

fact = ycomb(fact)

print(fact(5))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Character_codes,Character codes,"

Task

Given a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).



Example

The character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.



",Python,"print(ord('a')) # prints ""97""
print(chr(97)) # prints ""a""",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Accumulator_factory,Accumulator factory,"A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).



Rules

The detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).

Before you submit an example, make sure the function
 Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i).
Although these exact function and parameter names need not be used
 Works for any numeric type-- i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) (i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that)
 Generates functions that return the sum of every number ever passed to them, not just the most recent. (This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.)
 Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. (Follow your language's conventions here.)
 Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. (No global variables or other such things.)
 E.g. if after the example, you added the following code (in a made-up language) where the factory function is called foo:
 x = foo(1); 
x(5); 
foo(3);
print x(2.3);
 It should print 8.3. (There is no need to print the form of the accumulator function returned by foo(3); it's not part of the task at all.)


Task

Create a function that implements the described rules.



It need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.

Where it is not possible to hold exactly to the constraints above, describe the deviations.



",Python,"def makeCounter():
    count = 0
    def inner():
        nonlocal count
        count += 1
        return count
    return inner
counter = makeCounter()
print(counter())
print(counter())
print(counter())",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Color_of_a_screen_pixel,Color of a screen pixel,"Task

Get color information from an arbitrary pixel on the screen, such as the current location of the mouse cursor.

The mouse cursor may or may not have to be active in a GUI created by your program. These functions are OS related.



",Python,"import robotgo
 
# get position of mouse cursor
x, y = robotgo.getMousePos()
 
# get color of pixel at that position
color = robotgo.getPixelColor(x, y)
print(""Color of pixel at (%d, %d) is 0x%s"" % (x, y, color))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sierpinski_pentagon,Sierpinski pentagon,"Produce a graphical or ASCII-art representation of a Sierpinski pentagon (aka a Pentaflake) of order 5. Your code should also be able to correctly generate representations of lower orders: 1 to 4.





See also
 Sierpinski pentagon

",Python,"# version 1.1.2
 
import java.awt.*
import java.awt.geom.Path2D
import java.util.Random
import javax.swing.*
 
class SierpinskiPentagon : JPanel() {
    // exterior angle
    private val degrees072 = Math.toRadians(72.0)
 
    /* After scaling we'll have 2 sides plus a gap occupying the length
       of a side before scaling. The gap is the base of an isosceles triangle
       with a base angle of 72 degrees. */
    private val scaleFactor = 1.0 / (2.0 + Math.cos(degrees072) * 2.0)
 
    private val margin = 20
    private var limit = 0
    private val r = Random()
 
    init {
        preferredSize = Dimension(640, 640)
        background = Color.white
        Timer(3000) {
            limit++
            if (limit >= 5) limit = 0
            repaint()
        }.start()
    }
 
    private fun drawPentagon(g: Graphics2D, x: Double, y: Double, s: Double, depth: Int) {
        var angle = 3.0 * degrees072  // starting angle
        var xx = x
        var yy = y
        var side = s
        if (depth == 0) {
            val p = Path2D.Double()
            p.moveTo(xx, yy)
 
            // draw from the top
            for (i in 0 until 5) {
                xx += Math.cos(angle) * side
                yy -= Math.sin(angle) * side
                p.lineTo(xx, yy)
                angle += degrees072
            }
 
            g.color = RandomHue.next()
            g.fill(p)
        }
        else {
            side *= scaleFactor
            /* Starting at the top of the highest pentagon, calculate
               the top vertices of the other pentagons by taking the
               length of the scaled side plus the length of the gap. */
            val distance = side + side * Math.cos(degrees072) * 2.0
 
            /* The top positions form a virtual pentagon of their own,
               so simply move from one to the other by changing direction. */
            for (i in 0 until 5) {
                xx += Math.cos(angle) * distance
                yy -= Math.sin(angle) * distance
                drawPentagon(g, xx, yy, side, depth - 1)
                angle += degrees072
            }
        }
    }
 
    override fun paintComponent(gg: Graphics) {
        super.paintComponent(gg)
        val g = gg as Graphics2D
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)
        val hw = width / 2
        val radius = hw - 2.0 * margin
        val side = radius * Math.sin(Math.PI / 5.0) * 2.0
        drawPentagon(g, hw.toDouble(), 3.0 * margin, side, limit)
    }
 
    private class RandomHue {
        /* Try to avoid random color values clumping together */
        companion object {
            val goldenRatioConjugate = (Math.sqrt(5.0) - 1.0) / 2.0
            var hue = Math.random()
 
            fun next(): Color {
                hue = (hue + goldenRatioConjugate) % 1
                return Color.getHSBColor(hue.toFloat(), 1.0f, 1.0f)
            }
        }
    }
}
 
fun main(args: Array<String>) {
    SwingUtilities.invokeLater {
        val f = JFrame()
        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE
        f.title = ""Sierpinski Pentagon""
        f.isResizable = true
        f.add(SierpinskiPentagon(), BorderLayout.CENTER)
        f.pack()
        f.setLocationRelativeTo(null)
        f.isVisible = true
    }
}",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Colour_pinstripe/Display,Colour pinstripe/Display,"The task is to create 1 pixel wide coloured vertical pinstripes with a sufficient number of pinstripes to span the entire width of the graphics display.



The pinstripes should either follow the system palette sequence,   or a sequence that includes:

black,   red,   green,   blue,   magenta,   cyan,   yellow,   and   white:

   after filling the top quarter, switch to a wider 2 pixel wide vertical pinstripe pattern,
   halfway down the display, switch to 3 pixel wide vertical pinstripe,
   finally to a 4 pixels wide vertical pinstripe for the last quarter of the display.


See also

   display black and white 
   print colour

",Python,"from turtle import *
 
colors = [""black"", ""red"", ""green"", ""blue"", ""magenta"", ""cyan"", ""yellow"", ""white""]
 
# Middle of screen is 0,0
 
screen = getscreen()
 
left_edge = -screen.window_width()//2
 
right_edge = screen.window_width()//2
 
quarter_height = screen.window_height()//4
 
half_height = quarter_height * 2
 
speed(""fastest"")
 
for quarter in range(4):
    pensize(quarter+1)
    colornum = 0
 
    min_y = half_height - ((quarter + 1) * quarter_height)
    max_y = half_height - ((quarter) * quarter_height)
 
    for x in range(left_edge,right_edge,quarter+1):
        penup()
        pencolor(colors[colornum])
        colornum = (colornum + 1) % len(colors)
        setposition(x,min_y)
        pendown()
        setposition(x,max_y)
 
notused = input(""Hit enter to continue: "")",Human_written,Python_from_Java
http://rosettacode.org/wiki/Eertree,Eertree,"An eertree is a data structure designed for efficient processing of certain palindrome tasks, for instance counting the number of sub-palindromes in an input string.

The data structure has commonalities to both tries and suffix trees.
  See links below.



Task

Construct an eertree for the string ""eertree"", then output all sub-palindromes by traversing the tree.



See also

   Wikipedia entry:   trie.
   Wikipedia entry:   suffix tree 
   Cornell University Library, Computer Science, Data Structures and Algorithms ───► EERTREE: An Efficient Data Structure for Processing Palindromes in Strings.

",Python,"#!/bin/python
from __future__ import print_function
 
class Node(object):
	def __init__(self):
		self.edges = {} # edges (or forward links)
		self.link = None # suffix link (backward links)
		self.len = 0 # the length of the node
 
class Eertree(object):
	def __init__(self):
		self.nodes = []
		# two initial root nodes
		self.rto = Node() #odd length root node, or node -1
		self.rte = Node() #even length root node, or node 0
 
		# Initialize empty tree
		self.rto.link = self.rte.link = self.rto;
		self.rto.len = -1
		self.rte.len = 0
		self.S = [0] # accumulated input string, T=S[1..i]
		self.maxSufT = self.rte # maximum suffix of tree T
 
	def get_max_suffix_pal(self, startNode, a):
		# We traverse the suffix-palindromes of T in the order of decreasing length.
		# For each palindrome we read its length k and compare T[i-k] against a
		# until we get an equality or arrive at the -1 node.
		u = startNode
		i = len(self.S)
		k = u.len
		while id(u) != id(self.rto) and self.S[i - k - 1] != a:
			assert id(u) != id(u.link) #Prevent infinte loop
			u = u.link
			k = u.len
 
		return u
 
	def add(self, a):
 
		# We need to find the maximum suffix-palindrome P of Ta
		# Start by finding maximum suffix-palindrome Q of T.
		# To do this, we traverse the suffix-palindromes of T
		# in the order of decreasing length, starting with maxSuf(T)
		Q = self.get_max_suffix_pal(self.maxSufT, a)
 
		# We check Q to see whether it has an outgoing edge labeled by a.
		createANewNode = not a in Q.edges
 
		if createANewNode:
			# We create the node P of length Q+2
			P = Node()
			self.nodes.append(P)
			P.len = Q.len + 2
			if P.len == 1:
				# if P = a, create the suffix link (P,0)
				P.link = self.rte
			else:
				# It remains to create the suffix link from P if |P|>1. Just
				# continue traversing suffix-palindromes of T starting with the suffix 
				# link of Q.
				P.link = self.get_max_suffix_pal(Q.link, a).edges[a]
 
			# create the edge (Q,P)
			Q.edges[a] = P
 
		#P becomes the new maxSufT
		self.maxSufT = Q.edges[a]
 
		#Store accumulated input string
		self.S.append(a)
 
		return createANewNode
 
	def get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):
		#Each node represents a palindrome, which can be reconstructed
		#by the path from the root node to each non-root node.
 
		#Traverse all edges, since they represent other palindromes
		for lnkName in nd.edges:
			nd2 = nd.edges[lnkName] #The lnkName is the character used for this edge
			self.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)
 
		#Reconstruct based on charsToHere characters.
		if id(nd) != id(self.rto) and id(nd) != id(self.rte): #Don't print for root nodes
			tmp = """".join(charsToHere)
			if id(nodesToHere[0]) == id(self.rte): #Even string
				assembled = tmp[::-1] + tmp
			else: #Odd string
				assembled = tmp[::-1] + tmp[1:]
			result.append(assembled)
 
if __name__==""__main__"":
	st = ""eertree""
	print (""Processing string"", st)
	eertree = Eertree()
	for ch in st:
		eertree.add(ch)
 
	print (""Number of sub-palindromes:"", len(eertree.nodes))
 
	#Traverse tree to find sub-palindromes
	result = []
	eertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) #Odd length words
	eertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) #Even length words
	print (""Sub-palindromes:"", result)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort,Sorting algorithms/Bead sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of positive integers using the Bead Sort Algorithm.

A   bead sort   is also known as a   gravity sort.



Algorithm has   O(S),   where   S   is the sum of the integers in the input set:   Each bead is moved individually.

This is the case when bead sort is implemented without a mechanism to assist in finding empty spaces below the beads, such as in software implementations.



",Python,"#this algorithm only works with positive, whole numbers.
#O(2n) time complexity where n is the summation of the whole list to be sorted. 
#O(3n) space complexity.
 
def distribute(dist, List):
	#beads go down into different buckets using gravity (addition).
    if dist > len(List) :
        List.resize(dist) #resize if too big for current vector
 
    for i in range(dist):
        List[i] += 1
 
def beadSort(myints):
    list = []
    list2 = []
    fifth = myints
 
    print(""#1 Beads falling down: "")
    for i in range(len(fifth)):
        distribute (fifth[i], list)
    print('\n')
 
    print(""\nBeads on their sides: "")
    for i in range(len(list)):
        print("" "" + str(list[i]))
    print('\n')
 
    #second part
 
    print(""#2 Beads right side up: "")
    for i in range(len(list)):
        distribute (list[i], list2)
    print('\n')
 
    return list2
 
myints = [734,3,1,24,324,324,32,432,42,3,4,1,1]
sorted = beadSort(myints)
print(""Sorted list/array: "")
for i in range(len(sorted)):
	print(str(sorted[i]) +'')",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"def pow(base, exp):
    if exp == 0:
        return 1
    while exp & 1 == 0:
        base = base * base
        exp >>= 1
    if exp == 1:
        return base
    acc = base
    while exp > 1:
        exp >>= 1
        base = base * base
        if exp & 1 == 1:
            acc = acc * base
    return acc",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,">>> def sort_disjoint_sublist(data, indices):
	indices = sorted(indices)
	values  = sorted(data[i] for i in indices)
	for index, value in zip(indices, values):
		data[index] = value
 
 
>>> d = [7, 6, 5, 4, 3, 2, 1, 0]
>>> i = set([6, 1, 7])
>>> sort_disjoint_sublist(d, i)
>>> d
[7, 0, 5, 4, 3, 2, 1, 6]
>>> # Which could be more cryptically written as:
>>> def sort_disjoint_sublist(data, indices):
	for index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value
 
 
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Parallel_calculations,Parallel calculations,"Many programming languages allow you to specify computations to be run in parallel.
While Concurrent computing is focused on concurrency,
the purpose of this task is to distribute time-consuming calculations
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one
with the largest minimal prime factor
(that is, the one that contains relatively large factors).
To speed up the search, the factorization should be done
in parallel using separate threads or processes,
to take advantage of multi-core CPUs.

Show how this can be formulated in your language.
Parallelize the factorization of those numbers,
then search the returned list of numbers and factors
for the largest minimal factor,
and return that number and its prime factors.

For the prime number decomposition
you may use the solution of the Prime decomposition task.
",Python,"# version 1.1.51
 
import math
from itertools import count
 
def prime_factor_info(n):
    if n <= 1:
        raise ValueError(""Number must be more than one"")
    if is_prime(n):
        return (n, n, [n])
    factors = []
    factor = 2
    nn = n
    while True:
        if nn % factor == 0:
            factors.append(factor)
            nn //= factor
            if nn == 1:
                return (n, min(factors), factors)
            if is_prime(nn):
                factor = nn
        else:
            if factor >= 3:
                factor += 2
            else:
                factor = 3
 
def is_prime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0:
            return False
        d += 2
        if n % d == 0:
            return False
        d += 4
    return True
 
def main():
    numbers = [12757923, 12878611, 12878893, 12757923, 15808973, 15780709, 197622519]
    info = [prime_factor_info(n) for n in numbers]
    max_factor = max(info, key=lambda x: x[1])[1]
    results = [result for result in info if result[1] == max_factor]
    print(""The following number(s) have the largest minimal prime factor of {}:"".format(max_factor))
    for result in results:
        print(""  {} whose prime factors are {}"".format(result[0], result[2]))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Least_common_multiple,Least common multiple,"Least common multiple

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Compute the   least common multiple   (LCM)   of two integers.

Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.



Example

The least common multiple of   12   and   18   is   36,       because:

   12   is a factor     (12 × 3 = 36),     and 
   18   is a factor     (18 × 2 = 36),     and 
   there is no positive integer less than   36   that has both factors. 


As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.



One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.

If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.



 



lcm
⁡
(
m
,
n
)
=




|

m
×
n

|



gcd
⁡
(
m
,
n
)





{\displaystyle \operatorname {lcm} (m,n)={\frac {|m\times n|}{\operatorname {gcd} (m,n)}}}




One can also find   lcm   by merging the prime decompositions of both   m   and   n.



Related task
   greatest common divisor.


See also

   MathWorld entry:   Least Common Multiple.
   Wikipedia entry:   Least common multiple.

",Python,"def main(args):
    def gcd(a, b):
        return a if b == 0 else gcd(b, a % b)
    def lcm(a, b):
        return a / gcd(a, b) * b
    print(lcm(15, 9))
 
if __name__ == '__main__':
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Farey_sequence,Farey sequence,"The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.

The   Farey sequence   is sometimes incorrectly called a   Farey series.



Each Farey sequence:

   starts with the value   0   (zero),   denoted by the fraction     





0
1




{\displaystyle {\frac {0}{1}}}


   ends with the value   1   (unity),   denoted by the fraction   





1
1




{\displaystyle {\frac {1}{1}}}

.


The Farey sequences of orders   1   to   5   are:

 







F




1


=


0
1


,


1
1




{\displaystyle {\bf {\it {F}}}_{1}={\frac {0}{1}},{\frac {1}{1}}}



 







F




2


=


0
1


,


1
2


,


1
1




{\displaystyle {\bf {\it {F}}}_{2}={\frac {0}{1}},{\frac {1}{2}},{\frac {1}{1}}}



 







F




3


=


0
1


,


1
3


,


1
2


,


2
3


,


1
1




{\displaystyle {\bf {\it {F}}}_{3}={\frac {0}{1}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {1}{1}}}



 







F




4


=


0
1


,


1
4


,


1
3


,


1
2


,


2
3


,


3
4


,


1
1




{\displaystyle {\bf {\it {F}}}_{4}={\frac {0}{1}},{\frac {1}{4}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {3}{4}},{\frac {1}{1}}}



 







F




5


=


0
1


,


1
5


,


1
4


,


1
3


,


2
5


,


1
2


,


3
5


,


2
3


,


3
4


,


4
5


,


1
1




{\displaystyle {\bf {\it {F}}}_{5}={\frac {0}{1}},{\frac {1}{5}},{\frac {1}{4}},{\frac {1}{3}},{\frac {2}{5}},{\frac {1}{2}},{\frac {3}{5}},{\frac {2}{3}},{\frac {3}{4}},{\frac {4}{5}},{\frac {1}{1}}}


Task
   Compute and show the Farey sequence for orders   1   through   11   (inclusive).
   Compute and display the   number   of fractions in the Farey sequence for order   100   through   1,000   (inclusive)   by hundreds.
   Show the fractions as    n/d    (using the solidus [or slash] to separate the numerator from the denominator). 


The length   (the number of fractions)   of a Farey sequence asymptotically approaches:

  3 × n2   ÷   



π


{\displaystyle \pi }

2 
See also

   OEIS sequence   A006842 numerators of Farey series of order 1, 2, ··· 
   OEIS sequence   A006843 denominators of Farey series of order 1, 2, ··· 
   OEIS sequence   A005728 number of fractions in Farey series of order n 
   MathWorld entry   Farey sequence
   Wikipedia   entry   Farey sequence

",Python,"from fractions import Fraction
 
 
class Fr(Fraction):
    def __repr__(self):
        return '(%s/%s)' % (self.numerator, self.denominator)
 
 
def farey(n, length=False):
    if not length:
        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})
    else:
        #return 1         +    len({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})
        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))
 
if __name__ == '__main__':
    print('Farey sequence for order 1 through 11 (inclusive):')
    for n in range(1, 12): 
        print(farey(n))
    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')
    print([farey(i, length=True) for i in range(100, 1001, 100)])",Human_written,Python_from_C#
http://rosettacode.org/wiki/Test_a_function,Test a function,"

Task

Using a well-known testing-specific library/module/suite for your language, write some tests for your language's entry in Palindrome.

If your language does not have a testing specific library well known to the language's community then state this or omit the language.


",Python,"import unittest
from palindrome import check

class TestPalindrome(unittest.TestCase):
    def test_check(self):
        self.assertTrue(check('racecar'))
        self.assertTrue(check('abcba'))
        self.assertTrue(check('aa'))
        self.assertTrue(check('a'))
        self.assertTrue(check(''))
        self.assertFalse(check('alice'))
        self.assertFalse(check('ab'))
        self.assertFalse(check('abcdba'))

if __name__ == '__main__':
    unittest.main()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Continued_fraction,Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",Python,"from fractions import Fraction
import itertools
try: zip = itertools.izip
except: pass
 
# The Continued Fraction
def CF(a, b, t):
  terms = list(itertools.islice(zip(a, b), t))
  z = Fraction(1,1)
  for a, b in reversed(terms):
    z = a + b / z
  return z
 
# Approximates a fraction to a string
def pRes(x, d):
  q, x = divmod(x, 1)
  res = str(q)
  res += "".""
  for i in range(d):
    x *= 10
    q, x = divmod(x, 1)
    res += str(q)
  return res
 
# Test the Continued Fraction for sqrt2
def sqrt2_a():
  yield 1
  for x in itertools.repeat(2):
    yield x
 
def sqrt2_b():
  for x in itertools.repeat(1):
    yield x
 
cf = CF(sqrt2_a(), sqrt2_b(), 950)
print(pRes(cf, 200))
#1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147
 
 
# Test the Continued Fraction for Napier's Constant
def Napier_a():
  yield 2
  for x in itertools.count(1):
    yield x
 
def Napier_b():
  yield 1
  for x in itertools.count(1):
    yield x
 
cf = CF(Napier_a(), Napier_b(), 950)
print(pRes(cf, 200))
#2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901
 
# Test the Continued Fraction for Pi
def Pi_a():
  yield 3
  for x in itertools.repeat(6):
    yield x
 
def Pi_b():
  for x in itertools.count(1,2):
    yield x*x
 
cf = CF(Pi_a(), Pi_b(), 950)
print(pRes(cf, 10))
#3.1415926532",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Checkpoint_synchronization,Checkpoint synchronization,"The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.

The task

Implement checkpoint synchronization in your language.

Make sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.
",Python,"import java.util.Scanner;
import java.util.Random;
 
public class CheckpointSync{
	public static void main(String[] args){
		System.out.print(""Enter number of workers to use: "");
		Scanner in = new Scanner(System.in);
		Worker.nWorkers = in.nextInt();
		System.out.print(""Enter number of tasks to complete:"");
		runTasks(in.nextInt());
	}
 
	/*
	 * Informs that workers started working on the task and
	 * starts running threads. Prior to proceeding with next
	 * task syncs using static Worker.checkpoint() method.
	 */
	private static void runTasks(int nTasks){
		for(int i = 0; i < nTasks; i++){
			System.out.println(""Starting task number "" + (i+1) + ""."");
			runThreads();
			Worker.checkpoint();
		}
	}
 
	/*
	 * Creates a thread for each worker and runs it.
	 */
	private static void runThreads(){
		for(int i = 0; i < Worker.nWorkers; i ++){
			new Thread(new Worker(i+1)).start();
		}
	}
 
	/*
	 * Worker inner static class.
	 */
	public static class Worker implements Runnable{
		public Worker(int threadID){
			this.threadID = threadID;
		}
		public void run(){
			work();
		}
 
		/*
		 *  Notifies that thread started running for 100 to 1000 msec.
		 *  Once finished increments static counter 'nFinished'
		 *  that counts number of workers finished their work.
		 */
		private synchronized void work(){
			try {
				int workTime = rgen.nextInt(900) + 100;
				System.out.println(""Worker "" + threadID + "" will work for "" + workTime + "" msec."");
				Thread.sleep(workTime); //work for 'workTime'
				nFinished++; //increases work finished counter
				System.out.println(""Worker "" + threadID + "" is ready"");
			} catch (InterruptedException e) {
				System.err.println(""Error: thread execution interrupted"");
				e.printStackTrace();
			}
		}
 
		/*
		 * Used to synchronize Worker threads using 'nFinished' static integer.
		 * Waits (with step of 10 msec) until 'nFinished' equals to 'nWorkers'.
		 * Once they are equal resets 'nFinished' counter.
		 */
		public static synchronized void checkpoint(){
			while(nFinished!= nWorkers){
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {
					System.err.println(""Error: thread execution interrupted"");
					e.printStackTrace();
				}
			}
			nFinished = 0;
		}
 
		/* inner class instance variables */
		private int threadID;
 
		/* static variables */
		private static Random rgen = new Random();
		private static int nFinished = 0;
		public static int nWorkers = 0;
	}
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Roman_numerals/Decode,Roman numerals/Decode,"Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately,

starting with the leftmost decimal digit and skipping any 0s   (zeroes).

1990 is rendered as   MCMXC     (1000 = M,   900 = CM,   90 = XC)     and

2008 is rendered as   MMVIII       (2000 = MM,   8 = VIII).

The Roman numeral for 1666,   MDCLXVI,   uses each letter in descending order.



",Python,"_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))
 
def decode( roman ):
    result = 0
    for r, r1 in zip(roman, roman[1:]):
        rd, rd1 = _rdecode[r], _rdecode[r1]
        result += -rd if rd < rd1 else rd
    return result + _rdecode[roman[-1]]
 
if __name__ == '__main__':
    for r in 'MCMXC MMVIII MDCLXVI'.split():
        print( r, decode(r) )",Human_written,Python_from_Go
http://rosettacode.org/wiki/Maze_solving,Maze solving,"Task

For a maze generated by this task, write a function
that finds (and displays) the shortest path between two cells.



Note that because these mazes are generated by the Depth-first search algorithm, they contain no circular paths,
and a simple depth-first tree search can be used.



",Python,"# python 3
 
def Dijkstra(Graph, source):
    '''
        +   +---+---+
        | 0   1   2 |
        +---+   +   +
        | 3   4 | 5  
        +---+---+---+
 
        >>> graph = (        # or ones on the diagonal
        ...     (0,1,0,0,0,0,),
        ...     (1,0,1,0,1,0,),
        ...     (0,1,0,0,0,1,),
        ...     (0,0,0,0,1,0,),
        ...     (0,1,0,1,0,0,),
        ...     (0,0,1,0,0,0,),
        ... )
        ...
        >>> Dijkstra(graph, 0)
        ([0, 1, 2, 3, 2, 3], [1e+140, 0, 1, 4, 1, 2])
        >>> display_solution([1e+140, 0, 1, 4, 1, 2])
        5<2<1<0
    '''
    # Graph[u][v] is the weight from u to v (however 0 means infinity)
    infinity = float('infinity')
    n = len(graph)
    dist = [infinity]*n   # Unknown distance function from source to v
    previous = [infinity]*n # Previous node in optimal path from source
    dist[source] = 0        # Distance from source to source
    Q = list(range(n)) # All nodes in the graph are unoptimized - thus are in Q
    while Q:           # The main loop
        u = min(Q, key=lambda n:dist[n])                 # vertex in Q with smallest dist[]
        Q.remove(u)
        if dist[u] == infinity:
            break # all remaining vertices are inaccessible from source
        for v in range(n):               # each neighbor v of u
            if Graph[u][v] and (v in Q): # where v has not yet been visited
                alt = dist[u] + Graph[u][v]
                if alt < dist[v]:       # Relax (u,v,a)
                    dist[v] = alt
                    previous[v] = u
    return dist,previous
 
def display_solution(predecessor):
    cell = len(predecessor)-1
    while cell:
        print(cell,end='<')
        cell = predecessor[cell]
    print(0)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"import random
import time
 
def main():
    list = [31, 41, 59, 26, 53, 58, 97, 93, 23, 84]
    print(""unsorted:"", list)
    temp = list[:]
    random.seed(time.time())
    while not sorted(temp) == temp:
        temp = [list[i] for i in random.sample(range(len(list)), len(list))]
    print(""sorted!  "", temp)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Draw_a_clock,Draw a clock,"Task

Draw a clock.



More specific:

 Draw a time keeping device. It can be a stopwatch, hourglass, sundial, a mouth counting ""one thousand and one"", anything. Only showing the seconds is required, e.g.: a watch with just a second hand will suffice. However, it must clearly change every second, and the change must cycle every so often (one minute, 30 seconds, etc.) It must be drawn; printing a string of numbers to your terminal doesn't qualify. Both text-based and graphical drawing are OK.
 The clock is unlikely to be used to control space flights, so it needs not be hyper-accurate, but it should be usable, meaning if one can read the seconds off the clock, it must agree with the system clock.
 A clock is rarely (never?) a major application: don't be a CPU hog and poll the system timer every microsecond, use a proper timer/signal/event from your system or language instead. For a bad example, many OpenGL programs update the frame-buffer in a busy loop even if no redraw is needed, which is very undesirable for this task.
 A clock is rarely (never?) a major application: try to keep your code simple and to the point. Don't write something too elaborate or convoluted, instead do whatever is natural, concise and clear in your language.


Key points
 animate simple object
 timed event 
 polling system resources 
 code clarity

",Python,"from shoes import *

def draw_ray(width, start, stop, ratio):
    angle = math.pi * 2 * ratio - math.pi/2
    strokewidth(width)
    cos = math.cos(angle)
    sin = math.sin(angle)
    line(101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop)

def update():
    t = time.time()
    @time.text = t.strftime(""%H:%M:%S"")
    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f
    s += t.to_f - t.to_i  # add the fractional seconds

    @hands.clear()
    draw_ray(3, 0, 70, (h + m/60)/12)
    draw_ray(2, 0, 90, (m + s/60)/60)
    draw_ray(1, 0, 95, s/60)

# a place for the text display
@time = para(align=""center"", family=""monospace"")

# draw the clock face
stack(width=203, height=203) do
    strokewidth(1)
    fill(gradient(deepskyblue, aqua))
    oval(1, 1, 200)
    fill(black)
    oval(98, 98, 6)
    # draw the minute indicators
    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}
end.move(0,23)

# the drawing area for the hands
@hands = stack(width=203, height=203) {}.move(0,23)

animate(5) {update()}",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Bitwise_IO,Bitwise IO,"The aim of this task is to write functions (or create a class if your
language is Object Oriented and you prefer) for reading and writing sequences of
bits, most significant bit first. While the output of a asciiprint ""STRING"" is the ASCII byte sequence
""S"", ""T"", ""R"", ""I"", ""N"", ""G"", the output of a ""print"" of the bits sequence
0101011101010 (13 bits) must be 0101011101010; real I/O is performed always
quantized by byte (avoiding endianness issues and relying on underlying
buffering for performance), therefore you must obtain as output the bytes
0101 0111 0101 0000 (bold bits are padding bits), i.e. in hexadecimal 57 50.

As test, you can implement a rough (e.g. don't care about error handling or
other issues) compression/decompression program for ASCII sequences
of bytes, i.e. bytes for which the most significant bit is always unused, so that you can write
seven bits instead of eight (each 8 bytes of input, we write 7 bytes of output).

These bit oriented I/O functions can be used to implement compressors and
decompressors; e.g. Dynamic and Static Huffman encodings use variable length
bits sequences, while LZW (see LZW compression) use fixed or variable words
nine (or more) bits long.

 Limits in the maximum number of bits that can be written/read in a single read/write operation are allowed.
 Errors handling is not mandatory

",Python,"# version 1.2.31
 
import io
 
class BitFilter:
 
    def __init__(self, f, accu=0, bits=0):
        self.f = f
        self.accu = accu
        self.bits = bits
        self.bw = f.bufferedWriter()
        self.br = f.bufferedReader()
 
    def write(self, buf, start, nBits, shift):
        while nBits!= 0 or self.bits >= 8:
            while self.bits >= 8:
                self.bits -= 8
                self.bw.write(self.accu >> self.bits)
                self.accu = self.accu & ((1 << self.bits) - 1)
            while self.bits < 8 and nBits!= 0:
                b = buf[index]
                self.accu = (self.accu << 1) | (((128 >> shift) & b) >> (7 - shift))
                nBits -= 1
                self.bits += 1
                if shift += 1 == 8:
                    shift = 0
                    index += 1
 
    def read(self, buf, start, nBits, shift):
        while nBits!= 0:
            while self.bits!= 0 and nBits!= 0:
                mask = 128 >> shift
                if (self.accu & (1 << (self.bits - 1)))!= 0:
                    buf[index] = buf[index] | mask
                else:
                    buf[index] = buf[index] & mask.inv()
                nBits -= 1
                self.bits -= 1
                if shift += 1 == 8:
                    shift = 0
                    index += 1
            if nBits == 0:
                break
            self.accu = (self.accu << 8) | self.br.read()
            self.bits += 8
 
    def closeWriter(self):
        if self.bits!= 0:
            self.accu = (self.accu << (8 - self.bits))
            self.bw.write(self.accu)
        self.bw.close()
        self.accu = 0
        self.bits = 0
 
    def closeReader(self):
        self.br.close()
        self.accu = 0
        self.bits = 0
 
def main():
    s = ""abcdefghijk"".encode(""utf-8"")
    f = io.File(""test.bin"")
    bf = BitFilter(f)
 
    # for each byte in s, write 7 bits skipping 1
    for i in range(len(s)):
        bf.write(s, i, 7, 1)
    bf.closeWriter()
 
    # read 7 bits and expand to each byte of s2 skipping 1 bit
    s2 = bytearray(len(s))
    for i in range(len(s2)):
        bf.read(s2, i, 7, 1)
    bf.closeReader()
    print(s2.decode(""utf-8""))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Palindromic_gapful_numbers,Palindromic gapful numbers,"Palindromic gapful numbers

You are encouraged to solve this task according to the task description, using any language you may know.
Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

1037   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    1037. 



A palindromic number is   (for this task, a positive integer expressed in base ten),   when the number is
reversed,   is the same as the original number.



Task

   Show   (nine sets)   the first   20   palindromic gapful numbers that   end   with:
   the digit   1
   the digit   2
   the digit   3
   the digit   4
   the digit   5
   the digit   6
   the digit   7
   the digit   8
   the digit   9
   Show   (nine sets, like above)   of palindromic gapful numbers:
   the last   15   palindromic gapful numbers   (out of      100)
   the last   10   palindromic gapful numbers   (out of   1,000)       {optional}


For other ways of expressing the (above) requirements, see the   discussion   page.



Note

All palindromic gapful numbers are divisible by eleven.



Related tasks

   palindrome detection.
   gapful numbers.


Also see

   The OEIS entry:   A108343 gapful numbers.

",Python,"import math
 
def reverse(s):
    e = 0
    while s > 0:
        e = e*10 + (s % 10)
        s //= 10
    return e
 
def commatize(n):
    s = str(n)
    le = len(s)
    for i in range(le - 3, 0, -3):
        s = s[0:i] + "","" + s[i:]
    return s
 
def ord(n):
    suffix = """"
    if n > 10 and ((n-11)%100 == 0 or (n-12)%100 == 0 or (n-13)%100 == 0):
        suffix = ""th""
    else:
        if n % 10 == 1:
            suffix = ""st""
        elif n % 10 == 2:
            suffix = ""nd""
        elif n % 10 == 3:
            suffix = ""rd""
        else:
            suffix = ""th""
    return f""{commatize(n)}{suffix}""
 
def main():
    max = 10_000_000
    data = [[1, 20, 7], [86, 100, 8], [991, 1000, 10], [9995, 10000, 12], [1e5, 1e5, 14],
        [1e6, 1e6, 16], [1e7, 1e7, 18]]
    results = {}
    for d in data:
        for i in range(d[0], d[1]+1):
            results[i] = [0] * 9
    p = 0
    for d in range(1, 10):
        count = 0
        pow = 1
        fl = d * 11
        for nd in range(3, 20):
            slim = (d + 1) * pow
            for s in range(d * pow, slim):
                e = reverse(s)
                mlim = 1
                if nd % 2 == 1:
                    mlim = 10
                for m in range(mlim):
                    if nd % 2 == 0:
                        p = s*pow*10 + e
                    else:
                        p = s*pow*100 + m*pow*10 + e
                    if p % fl == 0:
                        count += 1
                        if count in results:
                            results[count][d-1] = p
                        if count == max:
                            break
            if nd % 2 == 1:
                pow *= 10
    for d in data:
        if d[0]!= d[1]:
            print(f""{ord(d[0])} to {ord(d[1])} palindromic gapful numbers (> 100) ending with:"")
        else:
            print(f""{ord(d[0])} palindromic gapful number (> 100) ending with:"")
        for i in range(1, 10):
            print(f""{i}: "", end="""")
            for j in range(d[0], d[1]+1):
                print(f""{results[j][i-1]:>{d[2]}} "", end="""")
            print()
        print()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Special_characters,Special characters,"Special characters are symbols (single characters or sequences of characters) that have a ""special"" built-in meaning in the language and typically cannot be used in identifiers.

Escape sequences are methods that the language uses to remove the special meaning from the symbol, enabling it to be used as a normal character, or sequence of characters when this can be done.



Task

List the special characters and show escape sequences in the language.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"$   Item
    @	Positional
    %	Associative
    &	Callable",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Happy_numbers,Happy numbers,"From Wikipedia, the free encyclopedia:

 A happy number is defined by the following process:
 Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals   1   (where it will stay),   or it loops endlessly in a cycle which does not include   1.   


 Those numbers for which this process end in   1   are       happy   numbers,   
 while   those numbers   that   do   not   end in   1   are   unhappy   numbers. 


Task

Find and print the first   8   happy numbers.

Display an example of your output here on this page.



See also

   The OEIS entry:   The     happy numbers:   A007770
   The OEIS entry:   The unhappy numbers;   A031177

",Python,"from sets import Set
 
seen_numbers = Set()
happy_numbers = Set()
 
def happy(n):
  if n == 1:
    return True
  if n in seen_numbers:
    return n in happy_numbers
 
  seen_numbers.add(n)
  digit_squared_sum = sum(int(c)**2 for c in str(n))
 
  if happy(digit_squared_sum):
    happy_numbers.add(n)
    return True
  else:
    return False",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Tokenize_a_string,Tokenize a string,"Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word.

Display the words to the 'user', in the simplest manner possible, separated by a period.

To simplify, you may display a trailing period.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"input = ""Hello,How,Are,You,Today""
print('.'.join(input.split(',')))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Zero_to_the_zero_power,Zero to the zero power,"Some computer programming languages are not exactly consistent   (with other computer programming languages)  

when   raising zero to the zeroth power:     00



Task

Show the results of raising   zero   to the   zeroth   power.



If your computer language objects to      0**0      or      0^0      at compile time,   you may also try something like:

           x = 0
           y = 0
           z = x**y
           say  'z='  z


Show the result here.

And of course use any symbols or notation that is supported in your computer programming language for exponentiation.



See also

 The Wiki entry: Zero to the power of zero. 
 The Wiki entry: History of differing points of view.
 The MathWorld™ entry: exponent laws.
 Also, in the above MathWorld™ entry, see formula (9): 




x

0


=
1


{\displaystyle x^{0}=1}

.
 The OEIS entry: The special case of zero to the zeroth power

",Python,"from decimal import Decimal
from fractions import Fraction
from itertools import product
 
zeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]
for i, j in product(zeroes, repeat=2):
    try:
        ans = i**j
    except:
        ans = '<Exception raised>'
    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",Python,"a = 2988348162058574136915891421498819466320163312926952423791023078876139
b = 2351399303373464486466122544523690094744975233415544072992656881240319
m = 10 ** 40
print(pow(a, b, m))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"#!/usr/bin/env python
a = input('Enter value of a: ')
b = input('Enter value of b: ')
 
if a < b:
    print 'a is less than b'
elif a > b:
    print 'a is greater than b'
elif a == b:
    print 'a is equal to b'",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/N-queens_problem,N-queens problem,"

Solve the eight queens puzzle.



You can extend the problem to solve the puzzle with a board of size   NxN.

For the number of solutions for small values of   N,   see   OEIS: A000170.



Related tasks

 A* search algorithm
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Knight's tour
 Peaceful chess queen armies
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"from itertools import permutations
 
n = 8
cols = range(n)
for vec in permutations(cols):
    if n == len(set(vec[i]+i for i in cols)) \
         == len(set(vec[i]-i for i in cols)):
        print ( vec )",Human_written,Python_from_C#
http://rosettacode.org/wiki/Formatted_numeric_output,Formatted numeric output,"Task

Express a number in decimal as a fixed-length string with leading zeros.



For example, the number   7.125   could be expressed as   00007.125.



",Python,"n = 123
str = (""00000"" + str(n)).slice(-5)
print(str)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Hello_world/Standard_error,Hello world/Standard error,"Hello world/Standard error is part of Short Circuit's Console Program Basics selection.
A common practice in computing is to send error messages
to a different output stream than normal text console messages.

The normal messages print to what is called ""standard output"" or ""standard out"".

The error messages print to ""standard error"".

This separation can be used to redirect error messages to a different place than normal messages.



Task

Show how to print a message to standard error by printing     Goodbye, World!     on that stream.



",Python,"print(""Goodbye, World!"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Character_codes,Character codes,"

Task

Given a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).



Example

The character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.



",Python,"c = 'a'
i = ord(c)
print(c, ""<->"", i)
i += 2
c = chr(i)
print(i, ""<->"", c)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Host_introspection,Host introspection,"Print the word size and endianness of the host machine.

See also: Variable size/Get
",Python,">>> import platform, sys, socket
>>> platform.architecture()
('64bit', 'ELF')
>>> platform.machine()
'x86_64'
>>> platform.node()
'yourhostname'
>>> platform.system()
'Linux'
>>> sys.byteorder
little
>>> socket.gethostname()
'yourhostname'
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",Python,"#############################
# Create a passwd text file
#############################
# note that UID & gid are of type ""text""
passwd_list=[
  dict(account='jsmith', password='x', UID=1001, GID=1000, # UID and GID are type int
       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',
                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),
                  directory='/home/jsmith', shell='/bin/bash'),
  dict(account='jdoe', password='x', UID=1002, GID=1000,
       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',
                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),
       directory='/home/jdoe', shell='/bin/bash')
]
 
passwd_fields=""account password UID GID GECOS directory shell"".split()
GECOS_fields=""fullname office extension homephone email"".split()
 
def passwd_text_repr(passwd_rec):
# convert individual fields to string type
  passwd_rec[""GECOS""]="","".join([ passwd_rec[""GECOS""][field] for field in GECOS_fields])
  for field in passwd_rec: # convert ""int"" fields
    if not isinstance(passwd_rec[field], str):
      passwd_rec[field]=`passwd_rec[field]`
  return "":"".join([ passwd_rec[field] for field in passwd_fields ])
 
passwd_text=open(""passwd.txt"",""w"")
for passwd_rec in passwd_list:
  print >> passwd_text,passwd_text_repr(passwd_rec)
passwd_text.close()
 
#################################
# Load text ready for appending
#################################
passwd_text=open(""passwd.txt"",""a+"")
new_rec=dict(account='xyz', password='x', UID=1003, GID=1000,
             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',
                        homephone='(234)555-0033', email='xyz@rosettacode.org'),
             directory='/home/xyz', shell='/bin/bash')
print >> passwd_text,  passwd_text_repr(new_rec)
passwd_text.close()
 
##############################################
# Finally reopen and check record was appended
##############################################
passwd_list=list(open(""passwd.txt"",""r""))
if ""xyz"" in passwd_list[-1]:
  print ""Appended record:"",passwd_list[-1][:-1]",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Synchronous_concurrency,Synchronous concurrency,"The goal of this task is to create two concurrent activities (""Threads"" or ""Tasks"", not processes.) that share data synchronously. Your language may provide syntax or libraries to perform concurrency. Different languages provide different implementations of concurrency, often with different names. Some languages use the term threads, others use the term tasks, while others use co-processes. This task should not be implemented using fork, spawn, or the Linux/UNIX/Win32 pipe command, as communication should be between threads, not processes.

One of the concurrent units will read from a file named ""input.txt"" and send the contents of that file, one line at a time, to the other concurrent unit, which will print the line it receives to standard output. The printing unit must count the number of lines it prints. After the concurrent unit reading the file sends its last line to the printing unit, the reading unit will request the number of lines printed by the printing unit. The reading unit will then print the number of lines printed by the printing unit.

This task requires two-way communication between the concurrent units. All concurrent units must cleanly terminate at the end of the program.
",Python,"import sys
from Queue import Queue
from threading import Thread
 
lines = Queue(1)
count = Queue(1)
 
def read(file):
    try:
        for line in file:
            lines.put(line)
    finally:
        lines.put(None)
    print count.get()
 
def write(file):
    n = 0
    while 1:
        line = lines.get()
        if line is None:
            break
        file.write(line)
        n += 1
    count.put(n)
 
reader = Thread(target=read, args=(open('input.txt'),))
writer = Thread(target=write, args=(sys.stdout,))
reader.start()
writer.start()
reader.join()
writer.join()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sum_to_100,Sum to 100,"Task

Find solutions to the    sum to one hundred    puzzle.



Add (insert) the mathematical
operators      +    or    -      (plus
or minus)   before any of the digits in the

decimal numeric string    123456789    such that the
resulting mathematical expression adds up to a

particular sum   (in this iconic case,   100).



Example:

             123 + 4 - 5 + 67 - 89   =   100     

Show all output here.



   Show all solutions that sum to    100 
   Show the sum that has the maximum   number   of solutions   (from zero to infinity‡)
   Show the lowest positive sum that   can't   be expressed   (has no solutions),   using the rules for this task
   Show the ten highest numbers that can be expressed using the rules for this task   (extra credit)


‡   (where   infinity   would be a relatively small   123,456,789)



An example of a sum that can't be expressed   (within the rules of this task)   is:   5074

(which,   of course,   isn't the lowest positive sum that can't be expressed).



",Python,"from itertools import product, islice
 
 
def expr(p):
    return ""{}1{}2{}3{}4{}5{}6{}7{}8{}9"".format(*p)
 
 
def gen_expr():
    op = ['+', '-', '']
    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']
 
 
def all_exprs():
    values = {}
    for expr in gen_expr():
        val = eval(expr)
        if val not in values:
            values[val] = 1
        else:
            values[val] += 1
    return values
 
 
def sum_to(val):
    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):
        print(s)
 
 
def max_solve():
    print(""Sum {} has the maximum number of solutions: {}"".
          format(*max(all_exprs().items(), key=lambda x: x[1])))
 
 
def min_solve():
    values = all_exprs()
    for i in range(123456789):
        if i not in values:
            print(""Lowest positive sum that can't be expressed: {}"".format(i))
            return
 
 
def highest_sums(n=10):
    sums = map(lambda x: x[0],
               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))
    print(""Highest Sums: {}"".format(list(sums)))
 
 
sum_to(100)
max_solve()
min_solve()
highest_sums()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def remove_comments(line, sep):
    for s in sep:
        i = line.find(s)
        if i >= 0:
            line = line[:i]
    return line.strip()
 
# test
print remove_comments('apples ; pears # and bananas', ';#')
print remove_comments('apples ; pears # and bananas', '!')",Human_written,Python_from_Go
http://rosettacode.org/wiki/AVL_tree,AVL tree,"

 This page uses content from Wikipedia. The original article was at AVL tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations. Note the tree of nodes comprise a set, so duplicate node keys are not allowed.

AVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.



Task

Implement an AVL tree in the language of choice, and provide at least basic operations.



",Python,"# Module: calculus.py
 
import enum
 
class entry_not_found(Exception):
   """"""Raised when an entry is not found in a collection""""""
   pass
 
class entry_already_exists(Exception):
   """"""Raised when an entry already exists in a collection""""""
   pass
 
class state(enum.Enum):
   header = 0
   left_high = 1
   right_high = 2
   balanced = 3
 
class direction(enum.Enum):
   from_left = 0
   from_right = 1
 
from abc import ABC, abstractmethod
 
class comparer(ABC):
 
    @abstractmethod
    def compare(self,t):
        pass
 
class node(comparer):
 
    def __init__(self):
        self.parent = None
        self.left = self
        self.right = self
        self.balance = state.header
 
    def compare(self,t):
        if self.key < t:
             return -1
        elif t < self.key:
             return 1
        else:
             return 0
 
    def is_header(self):
        return self.balance == state.header
 
    def length(self):
        if self != None:
           if self.left != None:
              left = self.left.length()
           else:
              left = 0
           if self.right != None:   
              right = self.right.length()
           else:
              right = 0
 
           return left + right + 1
        else:
           return 0
 
    def rotate_left(self):
         _parent = self.parent
         x = self.right
         self.parent = x
         x.parent = _parent
         if x.left is not None:
             x.left.parent = self
         self.right = x.left
         x.left = self
         return x
 
 
    def rotate_right(self):
        _parent = self.parent
        x = self.left
        self.parent = x
        x.parent = _parent;
        if x.right is not None:
            x.right.parent = self
        self.left = x.right
        x.right = self
        return x
 
    def balance_left(self):
 
       _left = self.left
 
       if _left is None:
          return self;
 
       if _left.balance == state.left_high:
                self.balance = state.balanced
                _left.balance = state.balanced
                self = self.rotate_right()
       elif _left.balance == state.right_high: 
                subright = _left.right
                if subright.balance == state.balanced:
                        self.balance = state.balanced
                        _left.balance = state.balanced
                elif subright.balance == state.right_high:
                        self.balance = state.balanced
                        _left.balance = state.left_high
                elif subright.balance == left_high:
                        root.balance = state.right_high
                        _left.balance = state.balanced
                subright.balance = state.balanced
                _left = _left.rotate_left()
                self.left = _left
                self = self.rotate_right()
       elif _left.balance == state.balanced:
               self.balance = state.left_high
               _left.balance = state.right_high
               self = self.rotate_right()
       return self;
 
    def balance_right(self):
 
       _right = self.right
 
       if _right is None:
          return self;
 
       if _right.balance == state.right_high:
                self.balance = state.balanced
                _right.balance = state.balanced
                self = self.rotate_left()
       elif _right.balance == state.left_high:
                subleft = _right.left;
                if subleft.balance == state.balanced:
                        self.balance = state.balanced
                        _right.balance = state.balanced
                elif subleft.balance == state.left_high:
                        self.balance = state.balanced
                        _right.balance = state.right_high
                elif subleft.balance == state.right_high:
                        self.balance = state.left_high
                        _right.balance = state.balanced
                subleft.balance = state.balanced
                _right = _right.rotate_right()
                self.right = _right
                self = self.rotate_left()
       elif _right.balance == state.balanced:
                self.balance = state.right_high
                _right.balance = state.left_high
                self = self.rotate_left()
       return self
 
 
    def balance_tree(self, direct):
        taller = True
        while taller:
            _parent = self.parent;
            if _parent.left == self:
                next_from =  direction.from_left
            else:
                next_from = direction.from_right;
 
            if direct == direction.from_left:
                if self.balance == state.left_high:
                        if _parent.is_header():
                            _parent.parent = _parent.parent.balance_left()
                        elif _parent.left == self:
                            _parent.left = _parent.left.balance_left()
                        else:
                            _parent.right = _parent.right.balance_left()
                        taller = False
 
                elif self.balance == state.balanced:
                        self.balance = state.left_high
                        taller = True
 
                elif self.balance == state.right_high:
                        self.balance = state.balanced
                        taller = False
            else:
              if self.balance == state.left_high:
                        self.balance = state.balanced
                        taller = False
 
              elif self.balance ==  state.balanced:
                        self.balance = state.right_high
                        taller = True
 
              elif self.balance ==  state.right_high:
                        if _parent.is_header():
                            _parent.parent = _parent.parent.balance_right()
                        elif _parent.left == self:
                            _parent.left = _parent.left.balance_right()
                        else:
                            _parent.right = _parent.right.balance_right()
                        taller = False
 
            if taller:
                if _parent.is_header():
                    taller = False
                else:
                    self = _parent
                    direct = next_from
 
    def balance_tree_remove(self, _from):
 
        if self.is_header():
            return;
 
        shorter = True;
 
        while shorter:
            _parent = self.parent;
            if _parent.left == self:
                next_from = direction.from_left
            else:
                next_from = direction.from_right
 
            if _from == direction.from_left:
                if self.balance == state.left_high:
                        shorter = True
 
                elif self.balance == state.balanced:
                        self.balance = state.right_high;
                        shorter = False
 
                elif self.balance == state.right_high:
                        if self.right is not None:
                            if self.right.balance == state.balanced:
                                shorter = False
                            else:
                                shorter = True
                        else:
                            shorter = False;
 
                        if _parent.is_header():
                            _parent.parent = _parent.parent.balance_right()
                        elif _parent.left == self:
                            _parent.left = _parent.left.balance_right();
                        else:
                            _parent.right = _parent.right.balance_right()
 
            else:
                if self.balance == state.right_high:
                        self.balance = state.balanced
                        shorter = True
 
                elif self.balance == state.balanced:
                        self.balance = state.left_high
                        shorter = False
 
                elif self.balance == state.left_high:
 
                        if self.left is not None:
                            if self.left.balance == state.balanced:
                                shorter = False
                            else:
                                shorter = True
                        else:
                           short = False;
 
                        if _parent.is_header():
                            _parent.parent = _parent.parent.balance_left();
                        elif _parent.left == self:
                            _parent.left = _parent.left.balance_left();
                        else:
                            _parent.right = _parent.right.balance_left();
 
            if shorter:
               if _parent.is_header():
                    shorter = False
               else: 
                    _from = next_from
                    self = _parent
 
    def previous(self):
        if self.is_header():
            return self.right
 
        if self.left is not None:
            y = self.left
            while y.right is not None:
                y = y.right
            return y
 
        else: 
            y = self.parent;
            if y.is_header():
                return y
 
            x = self
            while x == y.left:
                x = y
                y = y.parent
 
            return y
 
    def next(self):
        if self.is_header():
            return self.left
 
        if self.right is not None:
            y = self.right
            while y.left is not None:
                y = y.left
            return y;
 
        else:
            y = self.parent
            if y.is_header():
                return y
 
            x = self;         
            while x == y.right:
                x = y
                y = y.parent;
 
            return y
 
    def swap_nodes(a, b):
 
        if b == a.left:
            if b.left is not None:
                b.left.parent = a
 
            if b.right is not None:
                b.right.parent = a
 
            if a.right is not None:
                a.right.parent = b
 
            if not a.parent.is_header():
                if a.parent.left == a:
                    a.parent.left = b
                else:
                    a.parent.right = b;
            else:
                a.parent.parent = b
 
            b.parent = a.parent
            a.parent = b
 
            a.left = b.left
            b.left = a
 
            temp = a.right
            a.right = b.right
            b.right = temp
        elif b == a.right:
            if b.right is not None:
                b.right.parent = a
 
            if b.left is not None:
               b.left.parent = a
 
            if a.left is not None:
               a.left.parent = b
 
            if not a.parent.is_header(): 
                if a.parent.left == a:
                    a.parent.left = b
                else:
                    a.parent.right = b
            else:
               a.parent.parent = b
 
            b.parent = a.parent
            a.parent = b
 
            a.right = b.right
            b.right = a
 
            temp = a.left
            a.left = b.left
            b.left = temp
        elif a == b.left:
            if a.left is not None:
                a.left.parent = b
 
            if a.right is not None:
                a.right.parent = b
 
            if b.right is not None:
                b.right.parent = a
 
            if not parent.is_header(): 
                if b.parent.left == b:
                    b.parent.left = a
                else:
                    b.parent.right = a
            else:
                b.parent.parent = a
 
            a.parent = b.parent
            b.parent = a
 
            b.left = a.left
            a.left = b
 
            temp = a.right
            a.right = b.right
            b.right = temp
        elif a == b.right:
            if a.right is not None:
                a.right.parent = b
            if a.left is not None:
               a.left.parent = b
 
            if b.left is not None:
               b.left.parent = a
 
            if not b.parent.is_header():
                if b.parent.left == b:
                    b.parent.left = a
                else:
                    b.parent.right = a
            else:
                b.parent.parent = a
 
            a.parent = b.parent
            b.parent = a
 
            b.right = a.right
            a.right = b
 
            temp = a.left
            a.left = b.left
            b.left = temp
        else:
            if a.parent == b.parent:
                temp = a.parent.left
                a.parent.left = a.parent.right
                a.parent.right = temp
            else:
                if not a.parent.is_header():
                    if a.parent.left == a:
                        a.parent.left = b
                    else:
                        a.parent.right = b
                else:
                    a.parent.parent = b
 
                if not b.parent.is_header():
                    if b.parent.left == b:
                        b.parent.left = a
                    else:
                        b.parent.right = a
                else:
                    b.parent.parent = a
 
            if b.left is not None:
                b.left.parent = a
 
            if b.right is not None:
                b.right.parent = a
 
            if a.left is not None:
                a.left.parent = b
 
            if a.right is not None:
                a.right.parent = b
 
            temp1 = a.left
            a.left = b.left
            b.left = temp1
 
            temp2 = a.right
            a.right = b.right
            b.right = temp2
 
            temp3 = a.parent
            a.parent = b.parent
            b.parent = temp3
 
        balance = a.balance
        a.balance = b.balance
        b.balance = balance
 
class parent_node(node):
 
    def __init__(self, parent):
        self.parent = parent
        self.left = None
        self.right = None
        self.balance = state.balanced
 
class set_node(node):
 
    def __init__(self, parent, key):
        self.parent = parent
        self.left = None
        self.right = None
        self.balance = state.balanced
        self.key = key
 
class ordered_set:
 
    def __init__(self):
        self.header = node()
 
    def __iter__(self):
        self.node = self.header
        return self
 
    def __next__(self):
        self.node = self.node.next()
        if self.node.is_header():
            raise StopIteration
        return self.node.key
 
    def __delitem__(self, key):
          self.remove(key)
 
    def __lt__(self, other):
        first1 = self.header.left
        last1 = self.header
        first2 = other.header.left
        last2 = other.header
 
        while (first1 != last1) and (first2 != last2):
           l =  first1.key < first2.key
           if not l: 
              first1 = first1.next();
              first2 = first2.next();
           else:
              return True;
 
        a = self.__len__()
        b = other.__len__()
        return a < b
 
    def __hash__(self):
        h = 0
        for i in self:
            h = h + i.__hash__()
        return h    
 
    def __eq__(self, other):
       if self < other:
          return False
       if other < self:
          return False
       return True
 
    def __ne__(self, other):
       if self < other:
          return True
       if other < self:
          return True
       return False
 
    def __len__(self):
        return self.header.parent.length()
 
    def __getitem__(self, key):
          return self.contains(key)
 
    def __str__(self):
       l = self.header.right
       s = ""{""
       i = self.header.left
       h = self.header
       while i != h:
           s = s + i.key.__str__()
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + ""}""
       return s
 
    def __or__(self, other):
       r = ordered_set()
 
       first1 = self.header.left
       last1 = self.header
       first2 = other.header.left
       last2 = other.header
 
       while first1 != last1 and first2 != last2:
          les = first1.key < first2.key
          graater = first2.key < first1.key
 
          if les:
             r.add(first1.key)
             first1 = first1.next()
          elif graater:
             r.add(first2.key)
             first2 = first2.next()
          else:
             r.add(first1.key)
             first1 = first1.next()
             first2 = first2.next()
 
       while first1 != last1:
          r.add(first1.key)
          first1 = first1.next()
 
       while first2 != last2:
          r.add(first2.key)
          first2 = first2.next()
 
       return r
 
    def __and__(self, other):
       r = ordered_set()
 
       first1 = self.header.left
       last1 = self.header
       first2 = other.header.left
       last2 = other.header
 
       while first1 != last1 and first2 != last2:
          les = first1.key < first2.key
          graater = first2.key < first1.key
 
          if les:
             first1 = first1.next()
          elif graater:
             first2 = first2.next()
          else:
             r.add(first1.key)
             first1 = first1.next()
             first2 = first2.next()
 
       return r
 
    def __xor__(self, other):
       r = ordered_set()
 
       first1 = self.header.left
       last1 = self.header
       first2 = other.header.left
       last2 = other.header
 
       while first1 != last1 and first2 != last2:
          les = first1.key < first2.key
          graater = first2.key < first1.key
 
          if les:
             r.add(first1.key)
             first1 = first1.next()
          elif graater:
             r.add(first2.key)
             first2 = first2.next()
          else:
             first1 = first1.next()
             first2 = first2.next()
 
       while first1 != last1:
          r.add(first1.key)
          first1 = first1.next()
 
       while first2 != last2:
          r.add(first2.key)
          first2 = first2.next()
 
       return r
 
 
    def __sub__(self, other):
       r = ordered_set()
 
       first1 = self.header.left
       last1 = self.header
       first2 = other.header.left
       last2 = other.header
 
       while first1 != last1 and first2 != last2:
          les = first1.key < first2.key
          graater = first2.key < first1.key
 
          if les:
             r.add(first1.key)
             first1 = first1.next()
          elif graater:
             r.add(first2.key)
             first2 = first2.next()
          else:
             first1 = first1.next()
             first2 = first2.next()
 
       while first1 != last1:
          r.add(first1.key)
          first1 = first1.next()
 
       return r
 
    def __lshift__(self, data):
       self.add(data)
       return self
 
    def __rshift__(self, data):
       self.remove(data)
       return self
 
    def is_subset(self, other):
       first1 = self.header.left
       last1 = self.header
       first2 = other.header.left
       last2 = other.header
 
       is_subet = True
 
       while first1 != last1 and first2 != last2:
          if first1.key < first2.key:
              is_subset = False
              break
          elif first2.key < first1.key:
             first2 = first2.next()
          else:
             first1 = first1.next()
             first2 = first2.next()
 
          if is_subet:
             if first1 != last1:
                is_subet = False
 
       return is_subet
 
    def is_superset(self,other):
       return other.is_subset(self)
 
    def add(self, data):
            if self.header.parent is None:
                self.header.parent = set_node(self.header,data)
                self.header.left = self.header.parent
                self.header.right = self.header.parent
            else:
 
                root = self.header.parent
 
                while True:
                    c = root.compare(data)
                    if c >= 0:
                        if root.left is not None:
                            root = root.left
                        else:
                            new_node = set_node(root,data)
                            root.left = new_node
 
                            if self.header.left == root:
                                 self.header.left = new_node
                            root.balance_tree(direction.from_left)
                            return
 
                    else:
                        if root.right is not None:
                            root = root.right
                        else:
                            new_node = set_node(root, data)
                            root.right = new_node
                            if self.header.right == root:
                                  self.header.right = new_node
                            root.balance_tree(direction.from_right)
                            return
 
    def remove(self,data):
        root = self.header.parent;
 
        while True:
            if root is None:
                raise entry_not_found(""Entry not found in collection"")
 
            c  = root.compare(data)
 
            if c < 0:
               root = root.left;
 
            elif c > 0:
               root = root.right;
 
            else:
 
                 if root.left is not None:
                     if root.right is not None: 
                         replace = root.left
                         while replace.right is not None:
                             replace = replace.right
                         root.swap_nodes(replace)
 
                 _parent = root.parent
 
                 if _parent.left == root:
                     _from = direction.from_left
                 else:
                     _from = direction.from_right
 
                 if self.header.left == root:
 
                     n = root.next();
 
                     if n.is_header():
                         self.header.left = self.header
                         self.header.right = self.header
                     else:
                        self.header.left = n
                 elif self.header.right == root: 
 
                     p = root.previous();
 
                     if p.is_header():
                          self.header.left = self.header
                          self.header.right = self.header
                     else:
                          self.header.right = p
 
                 if root.left is None:
                     if _parent == self.header:
                         self.header.parent = root.right
                     elif _parent.left == root:
                         _parent.left = root.right
                     else:
                         _parent.right = root.right
 
                     if root.right is not None:
                          root.right.parent = _parent
 
                 else:
                     if _parent == self.header:
                          self.header.parent = root.left
                     elif _parent.left == root:
                         _parent.left = root.left
                     else:
                         _parent.right = root.left
 
                     if root.left is not None:
                         root.left.parent = _parent;
 
 
                 _parent.balance_tree_remove(_from)
                 return   
 
    def contains(self,data):
        root = self.header.parent;
 
        while True:
            if root == None:
                return False
 
            c  = root.compare(data);
 
            if c > 0:
               root = root.left;
 
            elif c < 0:
               root = root.right;
 
            else:
 
                 return True  
 
 
    def find(self,data):
        root = self.header.parent;
 
        while True:
            if root == None:
                raise entry_not_found(""An entry is not found in a collection"")
 
            c  = root.compare(data);
 
            if c > 0:
               root = root.left;
 
            elif c < 0:
               root = root.right;
 
            else:
 
                 return root.key;  
 
class key_value(comparer):
 
    def __init__(self, key, value):
        self.key = key
        self.value = value
 
    def compare(self,kv):
        if self.key < kv.key:
             return -1
        elif kv.key < self.key:
             return 1
        else:
             return 0
 
    def __lt__(self, other):
        return self.key < other.key
 
    def __str__(self):
        return '(' + self.key.__str__() + ',' + self.value.__str__() + ')'
 
    def __eq__(self, other):
       return self.key == other.key
 
    def __hash__(self):
        return hash(self.key)
 
 
class dictionary:
 
    def __init__(self):
        self.set = ordered_set()
        return None
 
    def __lt__(self, other):
       if self.keys() < other.keys():
          return true
 
       if other.keys() < self.keys():
          return false
 
       first1 = self.set.header.left
       last1 = self.set.header
       first2 = other.set.header.left
       last2 = other.set.header
 
       while (first1 != last1) and (first2 != last2):
          l =  first1.key.value < first2.key.value
          if not l: 
             first1 = first1.next();
             first2 = first2.next();
          else:
             return True;
 
       a = self.__len__()
       b = other.__len__()
       return a < b
 
 
    def add(self, key, value):
       try:
           self.set.remove(key_value(key,None))
       except entry_not_found:
            pass  
       self.set.add(key_value(key,value))
       return
 
    def remove(self, key):
       self.set.remove(key_value(key,None))
       return
 
    def clear(self):
       self.set.header = node()
 
    def sort(self):
 
      sort_bag = bag()
      for e in self:
        sort_bag.add(e.value)
      keys_set = self.keys()
      self.clear()
      i = sort_bag.__iter__()
      i = sort_bag.__next__()
      try:
        for e in keys_set:
          self.add(e,i)
          i = sort_bag.__next__()
      except:
         return        
 
    def keys(self):
         keys_set = ordered_set()
         for e in self:
             keys_set.add(e.key)
         return keys_set  
 
    def __len__(self):
        return self.set.header.parent.length()
 
    def __str__(self):
       l = self.set.header.right;
       s = ""{""
       i = self.set.header.left;
       h = self.set.header;
       while i != h:
           s = s + ""(""
           s = s + i.key.key.__str__()
           s = s + "",""
           s = s + i.key.value.__str__()
           s = s + "")""
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + ""}""
       return s;
 
    def __iter__(self):
 
        self.set.node = self.set.header
        return self
 
    def __next__(self):
        self.set.node = self.set.node.next()
        if self.set.node.is_header():
            raise StopIteration
        return key_value(self.set.node.key.key,self.set.node.key.value)
 
    def __getitem__(self, key):
          kv = self.set.find(key_value(key,None))
          return kv.value
 
    def __setitem__(self, key, value):
          self.add(key,value)
          return
 
    def __delitem__(self, key):
          self.set.remove(key_value(key,None))
 
 
class array:
 
    def __init__(self):
        self.dictionary = dictionary()
        return None
 
    def __len__(self):
        return self.dictionary.__len__()
 
    def push(self, value):
       k = self.dictionary.set.header.right
       if k == self.dictionary.set.header:
           self.dictionary.add(0,value)
       else:
           self.dictionary.add(k.key.key+1,value)
       return
 
    def pop(self):
       if self.dictionary.set.header.parent != None:
          data = self.dictionary.set.header.right.key.value
          self.remove(self.dictionary.set.header.right.key.key)
          return data
 
    def add(self, key, value):
       try:
          self.dictionary.remove(key)
       except entry_not_found:
          pass
       self.dictionary.add(key,value)          
       return
 
    def remove(self, key):
       self.dictionary.remove(key)
       return
 
    def sort(self):
       self.dictionary.sort()
 
    def clear(self):
      self.dictionary.header = node();
 
 
    def __iter__(self):
        self.dictionary.node = self.dictionary.set.header
        return self
 
    def __next__(self):
        self.dictionary.node = self.dictionary.node.next()
        if self.dictionary.node.is_header():
            raise StopIteration
        return self.dictionary.node.key.value
 
    def __getitem__(self, key):
          kv = self.dictionary.set.find(key_value(key,None))
          return kv.value
 
    def __setitem__(self, key, value):
          self.add(key,value)
          return
 
    def __delitem__(self, key):
          self.dictionary.remove(key)
 
    def __lshift__(self, data):
         self.push(data)
         return self
 
    def __lt__(self, other):
       return self.dictionary < other.dictionary
 
    def __str__(self):
       l = self.dictionary.set.header.right;
       s = ""{""
       i = self.dictionary.set.header.left;
       h = self.dictionary.set.header;
       while i != h:
           s = s + i.key.value.__str__()
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + ""}""
       return s;
 
 
class bag:
 
    def __init__(self):
        self.header = node()
 
    def __iter__(self):
        self.node = self.header
        return self
 
    def __delitem__(self, key):
          self.remove(key)
 
    def __next__(self):
        self.node = self.node.next()
        if self.node.is_header():
            raise StopIteration
        return self.node.key
 
    def __str__(self):
       l = self.header.right;
       s = ""(""
       i = self.header.left;
       h = self.header;
       while i != h:
           s = s + i.key.__str__()
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + "")""
       return s;
 
    def __len__(self):
        return self.header.parent.length()
 
    def __lshift__(self, data):
       self.add(data)
       return self
 
    def add(self, data):
            if self.header.parent is None:
                self.header.parent = set_node(self.header,data)
                self.header.left = self.header.parent
                self.header.right = self.header.parent
            else:
 
                root = self.header.parent
 
                while True:
                    c = root.compare(data)
                    if c >= 0:
                        if root.left is not None:
                            root = root.left
                        else:
                            new_node = set_node(root,data)
                            root.left = new_node
 
                            if self.header.left == root:
                                 self.header.left = new_node
 
                            root.balance_tree(direction.from_left)
                            return
 
                    else:
                        if root.right is not None:
                            root = root.right
                        else:
                            new_node = set_node(root, data)
                            root.right = new_node
 
                            if self.header.right == root:
                                  self.header.right = new_node
 
                            root.balance_tree(direction.from_right)
                            return
 
    def remove_first(self,data):
 
        root = self.header.parent;
 
        while True:
            if root is None:
                return False;
 
            c  = root.compare(data);
 
            if c > 0:
               root = root.left;
 
            elif c < 0:
               root = root.right;
 
            else:
 
                 if root.left is not None:
                     if root.right is not None: 
                         replace = root.left;
                         while replace.right is not None:
                             replace = replace.right;
                         root.swap_nodes(replace);
 
                 _parent = root.parent
 
                 if _parent.left == root:
                     _from = direction.from_left
                 else:
                     _from = direction.from_right
 
                 if self.header.left == root:
 
                     n = root.next();
 
                     if n.is_header():
                         self.header.left = self.header
                         self.header.right = self.header
                     else:
                        self.header.left = n;
                 elif self.header.right == root: 
 
                     p = root.previous();
 
                     if p.is_header():
                          self.header.left = self.header
                          self.header.right = self.header
                     else:
                          self.header.right = p
 
                 if root.left is None:
                     if _parent == self.header:
                         self.header.parent = root.right
                     elif _parent.left == root:
                         _parent.left = root.right
                     else:
                         _parent.right = root.right
 
                     if root.right is not None:
                          root.right.parent = _parent
 
                 else:
                     if _parent == self.header:
                          self.header.parent = root.left
                     elif _parent.left == root:
                         _parent.left = root.left
                     else:
                         _parent.right = root.left
 
                     if root.left is not None:
                         root.left.parent = _parent;
 
 
                 _parent.balance_tree_remove(_from)
                 return True;
 
    def remove(self,data):
       success = self.remove_first(data)
       while success:
          success = self.remove_first(data)
 
    def remove_node(self, root):
 
        if root.left != None and root.right != None:
            replace = root.left
            while replace.right != None:
               replace = replace.right
            root.swap_nodes(replace)
 
        parent = root.parent;
 
        if parent.left == root:
           next_from = direction.from_left
        else:
           next_from = direction.from_right
 
        if self.header.left == root:
            n = root.next()
 
            if n.is_header():
                self.header.left = self.header;
                self.header.right = self.header
            else:
                self.header.left = n
        elif self.header.right == root:
             p = root.previous()
 
             if p.is_header(): 
                root.header.left = root.header
                root.header.right = header
             else:
                self.header.right = p
 
        if root.left == None:
            if parent == self.header:
                self.header.parent = root.right
            elif parent.left == root:
                parent.left = root.right
            else:
                parent.right = root.right
 
            if root.right != None:
               root.right.parent = parent
        else:
            if parent == self.header:
                self.header.parent = root.left
            elif parent.left == root:
                parent.left = root.left
            else:
                parent.right = root.left
 
            if root.left != None:
               root.left.parent = parent;
 
        parent.balance_tree_remove(next_from)
 
    def remove_at(self, data, ophset):
 
            p = self.search(data);
 
            if p == None:
                return
            else:
                lower = p
                after = after(data)
 
            s = 0
            while True:
                if ophset == s:
                    remove_node(lower);
                    return;
                lower = lower.next_node()
                if after == lower:
                   break
                s = s+1
 
            return
 
    def search(self, key):
        s = before(key)
        s.next()
        if s.is_header():
           return None
        c = s.compare(s.key)
        if c != 0:
           return None
        return s
 
 
    def before(self, data):
        y = self.header;
        x = self.header.parent;
 
        while x != None:
            if x.compare(data) >= 0:
                x = x.left;
            else:
                y = x;
                x = x.right;
        return y
 
    def after(self, data):
        y = self.header;
        x = self.header.parent;
 
        while x != None:
            if x.compare(data) > 0:
                y = x
                x = x.left
            else:
                x = x.right
 
        return y;
 
 
    def find(self,data):
        root = self.header.parent;
 
        results = array()
 
        while True:
            if root is None:
                break;
 
            p = self.before(data)
            p = p.next()
            if not p.is_header():
               i = p
               l = self.after(data)
               while i != l:
                  results.push(i.key)
                  i = i.next()
 
               return results
            else:
               break;
 
        return results
 
class bag_dictionary:
 
    def __init__(self):
        self.bag = bag()
        return None
 
    def add(self, key, value):
       self.bag.add(key_value(key,value))
       return
 
    def remove(self, key):
       self.bag.remove(key_value(key,None))
       return
 
    def remove_at(self, key, index):
       self.bag.remove_at(key_value(key,None), index)
       return
 
    def clear(self):
       self.bag.header = node()
 
    def __len__(self):
        return self.bag.header.parent.length()
 
    def __str__(self):
       l = self.bag.header.right;
       s = ""{""
       i = self.bag.header.left;
       h = self.bag.header;
       while i != h:
           s = s + ""(""
           s = s + i.key.key.__str__()
           s = s + "",""
           s = s + i.key.value.__str__()
           s = s + "")""
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + ""}""
       return s;
 
    def __iter__(self):
 
        self.bag.node = self.bag.header
        return self
 
    def __next__(self):
        self.bag.node = self.bag.node.next()
        if self.bag.node.is_header():
            raise StopIteration
        return key_value(self.bag.node.key.key,self.bag.node.key.value)
 
    def __getitem__(self, key):
          kv_array = self.bag.find(key_value(key,None))
          return kv_array
 
    def __setitem__(self, key, value):
          self.add(key,value)
          return
 
    def __delitem__(self, key):
          self.bag.remove(key_value(key,None))
 
class unordered_set:
 
    def __init__(self):
        self.bag_dictionary = bag_dictionary()
 
    def __len__(self):
        return self.bag_dictionary.__len__()
 
    def __hash__(self):
        h = 0
        for i in self:
            h = h + i.__hash__()
        return h    
 
    def __eq__(self, other):
        for t in self:
           if not other.contains(t):
              return False
        for u in other:
           if self.contains(u):
              return False
        return true;
 
    def __ne__(self, other):
        return not self == other
 
    def __or__(self, other):
       r = unordered_set()
 
       for t in self:
          r.add(t);
 
       for u in other:
          if not self.contains(u):
             r.add(u);
 
       return r
 
    def __and__(self, other):
       r = unordered_set()
 
       for t in self:
          if other.contains(t):
              r.add(t)
 
       for u in other:
              if self.contains(u) and not r.contains(u):
                  r.add(u);
 
       return r
 
    def __xor__(self, other):
       r = unordered_set()
 
       for t in self:
          if not other.contains(t):
             r.add(t)
 
       for u in other:
          if not self.contains(u) and not r.contains(u):
             r.add(u)
 
       return r
 
 
    def __sub__(self, other):
       r = ordered_set()
 
       for t in self:
          if not other.contains(t):
             r.add(t);
 
       return r
 
    def __lshift__(self, data):
       self.add(data)
       return self
 
    def __rshift__(self, data):
       self.remove(data)
       return self
 
    def __getitem__(self, key):
          return self.contains(key)
 
    def is_subset(self, other):
 
       is_subet = True
 
       for t in self:
          if not other.contains(t):
             subset = False
             break
 
       return is_subet
 
    def is_superset(self,other):
       return other.is_subset(self)
 
 
    def add(self, value):
       if not self.contains(value):
           self.bag_dictionary.add(hash(value),value)
       else:
          raise entry_already_exists(""Entry already exists in the unordered set"")
 
    def contains(self, data):
            if self.bag_dictionary.bag.header.parent == None:
                return False;
            else:
                index = hash(data);
 
                _search = self.bag_dictionary.bag.header.parent;
 
                search_index =  _search.key.key;
 
                if index < search_index:
                   _search = _search.left
 
                elif index > search_index:
                   _search = _search.right
 
                if _search == None:
                    return False
 
                while _search != None:
                    search_index =  _search.key.key;
 
                    if index < search_index:
                       _search = _search.left
 
                    elif index > search_index:
                       _search = _search.right
 
                    else:
                       break
 
                if _search == None:
                   return False
 
                return self.contains_node(data, _search)
 
    def contains_node(self,data,_node):
 
        previous = _node.previous()
        save = _node
 
        while not previous.is_header() and previous.key.key == _node.key.key:
            save = previous;
            previous = previous.previous()
 
        c = _node.key.value
        _node = save
        if c == data:
           return True
 
        next = _node.next()
        while not next.is_header() and next.key.key == _node.key.key:
            _node = next
            c = _node.key.value
            if c == data:
               return True;
            next = _node.next()
 
        return False;
 
    def find(self,data,_node):
 
        previous = _node.previous()
        save = _node
 
        while not previous.is_header() and previous.key.key == _node.key.key:
            save = previous;
            previous = previous.previous();
 
        _node = save;
        c = _node.key.value
        if c == data:
           return _node
 
        next = _node.next()
        while not next.is_header() and next.key.key == _node.key.key:
            _node = next
            c = _node.data.value
            if c == data:
               return _node
            next = _node.next()
 
        return None
 
    def search(self, data):
        if self.bag_dictionary.bag.header.parent == None:
            return None
        else:
            index = hash(data)
 
            _search = self.bag_dictionary.bag.header.parent
 
            c = _search.key.key
 
            if index < c:
               _search = _search.left;
 
            elif index > c:
               _search = _search.right;
 
            while _search != None:
 
                if index != c:
                   break
 
                c = _search.key.key
 
                if index < c:
                   _search = _search.left;
 
                elif index > c:
                   _search = _search.right;
 
                else:
                   break
 
            if _search == None:
               return None
 
            return self.find(data, _search)
 
    def remove(self,data):
       found = self.search(data);
       if found != None:
          self.bag_dictionary.bag.remove_node(found);
       else:
          raise entry_not_found(""Entry not found in the unordered set"")
 
    def clear(self):
       self.bag_dictionary.bag.header = node()
 
    def __str__(self):
       l = self.bag_dictionary.bag.header.right;
       s = ""{""
       i = self.bag_dictionary.bag.header.left;
       h = self.bag_dictionary.bag.header;
       while i != h:
           s = s + i.key.value.__str__()
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + ""}""
       return s;
 
    def __iter__(self):
 
        self.bag_dictionary.bag.node = self.bag_dictionary.bag.header
        return self
 
    def __next__(self):
        self.bag_dictionary.bag.node = self.bag_dictionary.bag.node.next()
        if self.bag_dictionary.bag.node.is_header():
            raise StopIteration
        return self.bag_dictionary.bag.node.key.value
 
 
class map:
 
    def __init__(self):
        self.set = unordered_set()
        return None
 
    def __len__(self):
        return self.set.__len__()
 
    def add(self, key, value):
       try:
           self.set.remove(key_value(key,None))
       except entry_not_found:
            pass  
       self.set.add(key_value(key,value))
       return
 
    def remove(self, key):
       self.set.remove(key_value(key,None))
       return
 
    def clear(self):
       self.set.clear()
 
    def __str__(self):
       l = self.set.bag_dictionary.bag.header.right;
       s = ""{""
       i = self.set.bag_dictionary.bag.header.left;
       h = self.set.bag_dictionary.bag.header;
       while i != h:
           s = s + ""(""
           s = s + i.key.value.key.__str__()
           s = s + "",""
           s = s + i.key.value.value.__str__()
           s = s + "")""
           if i != l:
               s = s + "",""
           i = i.next()
 
       s = s + ""}""
       return s;
 
    def __iter__(self):
 
        self.set.node = self.set.bag_dictionary.bag.header
        return self
 
    def __next__(self):
        self.set.node = self.set.node.next()
        if self.set.node.is_header():
            raise StopIteration
        return key_value(self.set.node.key.key,self.set.node.key.value)
 
    def __getitem__(self, key):
          kv = self.set.find(key_value(key,None))
          return kv.value
 
    def __setitem__(self, key, value):
          self.add(key,value)
          return
 
    def __delitem__(self, key):
          self.remove(key)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Pragmatic_directives,Pragmatic directives,"Pragmatic directives cause the language to operate in a specific manner,   allowing support for operational variances within the program code   (possibly by the loading of specific or alternative modules).



Task

List any pragmatic directives supported by the language,   and demonstrate how to activate and deactivate the pragmatic directives and to describe or demonstrate the scope of effect that the pragmatic directives have within a program.



",Python,"# version 1.0.6
 
def main(args):
    s = ""To be suppressed""",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Topswops,Topswops,"Topswops is a card game created by John Conway in the 1970's.



Assume you have a particular permutation of a set of   n   cards numbered   1..n   on both of their faces, for example the arrangement of four cards given by   [2, 4, 1, 3]   where the leftmost card is on top.

A round is composed of reversing the first   m   cards where   m   is the value of the topmost card.

Rounds are repeated until the topmost card is the number   1   and the number of swaps is recorded.



For our example the swaps produce:

    
    [2, 4, 1, 3]    # Initial shuffle
    [4, 2, 1, 3]
    [3, 1, 2, 4]
    [2, 1, 3, 4]
    [1, 2, 3, 4]

For a total of four swaps from the initial ordering to produce the terminating case where   1   is on top.



For a particular number    n    of cards,    topswops(n)    is the maximum swaps needed for any starting permutation of the   n   cards.



Task

The task is to generate and show here a table of    n    vs    topswops(n)    for    n    in the range   1..10   inclusive.



Note

Topswops   is also known as   Fannkuch   from the German word   Pfannkuchen   meaning   pancake.



Related tasks

   Number reversal game
   Sorting algorithms/Pancake sort

",Python,">>> from itertools import permutations
>>> def f1(p):
	i = 0
	while True:
		p0  = p[0]
		if p0 == 1: break
		p[:p0] = p[:p0][::-1]
		i  += 1
	return i
 
>>> def fannkuch(n):
	return max(f1(list(p)) for p in permutations(range(1, n+1)))
 
>>> for n in range(1, 11): print(n,fannkuch(n))
 
1 0
2 1
3 2
4 4
5 7
6 10
7 16
8 22
9 30
10 38
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Priority_queue,Priority queue,"A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.



Task

Create a priority queue.   The queue must support at least two operations:

   Insertion.   An element is added to the queue with a priority (a numeric value).
   Top item removal.   Deletes the element or one of the elements with the current top priority and return it.


Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.



To test your implementation, insert a number of elements into the queue, each with some random priority.

Then dequeue them sequentially; now the elements should be sorted by priority.

You can use the following task/priority items as input data:

        Priority         Task
       ══════════   ════════════════
           3         Clear drains
           4         Feed cat
           5         Make tea
           1         Solve RC tasks
           2         Tax return



The implementation should try to be efficient.   A typical implementation has   O(log n)   insertion and extraction time,   where   n   is the number of items in the queue.

You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc.   If so, discuss the reasons behind it.



",Python,">>> import queue
>>> pq = queue.PriorityQueue()
>>> for item in ((3, ""Clear drains""), (4, ""Feed cat""), (5, ""Make tea""), (1, ""Solve RC tasks""), (2, ""Tax return"")):
  pq.put(item)
 
 
>>> while not pq.empty():
  print(pq.get_nowait())
 
 
(1, 'Solve RC tasks')
(2, 'Tax return')
(3, 'Clear drains')
(4, 'Feed cat')
(5, 'Make tea')
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Kernighans_large_earthquake_problem,Kernighans large earthquake problem,"Brian Kernighan, in a lecture at the University of Nottingham, described a problem on which this task is based.

Problem

You are given a a data file of thousands of lines; each of three `whitespace` separated fields: a date, a one word name and the magnitude of the event.

Example lines from the file would be lines like:

8/27/1883    Krakatoa            8.8
5/18/1980    MountStHelens       7.6
3/13/2009    CostaRica           5.1
Task

 Create a program or script invocation to find all the events with magnitude greater than 6
 Assuming an appropriate name e.g. ""data.txt"" for the file:
 Either: Show how your program is invoked to process a data file of that name.
 Or: Incorporate the file name into the program, (as it is assumed that the program is single use).

",Python,"# Version 1.2.40
 
import re
 
with open(""data.txt"") as f:
    data = f.readlines()
max = max(float(re.split(r""\s+"", line)[2]) for line in data)
print(""The maximum magnitude is"", max)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",Python,"# Go doesn't have generics, but sometimes a type definition helps
# readability and maintainability.   This example is written to
# the following function type, which uses float64.
ffType = Callable[[float], float]
 
# compose function requested by task
def compose(f: ffType, g: ffType) -> ffType:
    return lambda x: f(g(x))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"# python-deps: pygobject
import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
 
def delete_event(widget, event, data=None):
    Gtk.main_quit()
    return False
 
window = Gtk.Window()
window.set_title(""Goodbye, World!"")
window.set_border_width(10)
window.set_position(Gtk.WindowPosition.CENTER)
window.set_default_size(350, 70)
window.connect(""delete-event"", delete_event)
 
window.show_all()
Gtk.main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",Python,"import time
 
seconds = float(raw_input())
print ""Sleeping...""
time.sleep(seconds) # number is in seconds ... but accepts fractions
print ""Awake!""",Human_written,Python_from_Java
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]",Human_written,Python_from_C
http://rosettacode.org/wiki/Quaternion_type,Quaternion type,"Quaternions   are an extension of the idea of   complex numbers.

A complex number has a real and complex part,   sometimes written as     a + bi,  

where     a     and     b     stand for real numbers, and     i     stands for the square root of minus 1.

An example of a complex number might be     -3 + 2i,    

where the real part,     a     is     -3.0     and the complex part,     b     is     +2.0.  

A quaternion has one real part and three imaginary parts,     i,       j,     and     k.  

A quaternion might be written as     a + bi + cj + dk.  

In the quaternion numbering system:

     i∙i = j∙j = k∙k = i∙j∙k = -1,         or more simply,
     ii  = jj  = kk  = ijk   = -1.  
The order of multiplication is important, as, in general, for two quaternions:

     q1     and     q2:         q1q2 ≠ q2q1.  
An example of a quaternion might be     1 +2i +3j +4k  

There is a list form of notation where just the numbers are shown and the imaginary multipliers    i,       j,     and     k     are assumed by position.

So the example above would be written as     (1, 2, 3, 4)  



Task

Given the three quaternions and their components: 

   q  = (1, 2, 3, 4) = (a,  b,  c,  d)
   q1 = (2, 3, 4, 5) = (a1, b1, c1, d1)
   q2 = (3, 4, 5, 6) = (a2, b2, c2, d2) 

And a wholly real number     r = 7.  



Create functions   (or classes)   to perform simple maths with quaternions including computing:

 The norm of a quaternion: 




=



a

2


+

b

2


+

c

2


+

d

2






{\displaystyle ={\sqrt {a^{2}+b^{2}+c^{2}+d^{2}}}}

 
 The negative of a quaternion: 
   = (-a, -b, -c, -d)  
 The conjugate of a quaternion: 
   = ( a, -b, -c, -d)  
 Addition of a real number     r     and a quaternion     q:  
  r + q = q + r = (a+r, b, c, d)  
 Addition of two quaternions: 
   q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2)  
 Multiplication of a real number and a quaternion: 
   qr = rq = (ar, br, cr, dr)  
 Multiplication of two quaternions     q1     and   q2     is given by: 
   ( a1a2 − b1b2 − c1c2 − d1d2, 
   a1b2 + b1a2 + c1d2 − d1c2, 
   a1c2 − b1d2 + c1a2 + d1b2, 
   a1d2 + b1c2 − c1b2 + d1a2 )  
 Show that, for the two quaternions     q1     and     q2: 
 q1q2 ≠ q2q1  


If a language has built-in support for quaternions, then use it.



C.f.

   Vector products
   On Quaternions;   or on a new System of Imaginaries in Algebra.   By Sir William Rowan Hamilton LL.D, P.R.I.A., F.R.A.S., Hon. M. R. Soc. Ed. and Dub., Hon. or Corr. M. of the Royal or Imperial Academies of St. Petersburgh, Berlin, Turin and Paris, Member of the American Academy of Arts and Sciences, and of other Scientific Societies at Home and Abroad, Andrews' Prof. of Astronomy in the University of Dublin, and Royal Astronomer of Ireland.

",Python,"from collections import namedtuple
import math
 
class Q(namedtuple('Quaternion', 'real, i, j, k')):
    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' 
 
    __slots__ = () 
 
    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):
        'Defaults all parts of quaternion to zero'
        return super().__new__(_cls, float(real), float(i), float(j), float(k))
 
    def conjugate(self):
        return Q(self.real, -self.i, -self.j, -self.k)
 
    def _norm2(self):
        return sum( x*x for x in self)
 
    def norm(self):
        return math.sqrt(self._norm2())
 
    def reciprocal(self):
        n2 = self._norm2()
        return Q(*(x / n2 for x in self.conjugate())) 
 
    def __str__(self):
        'Shorter form of Quaternion as string'
        return 'Q(%g, %g, %g, %g)' % self
 
    def __neg__(self):
        return Q(-self.real, -self.i, -self.j, -self.k)
 
    def __add__(self, other):
        if type(other) == Q:
            return Q( *(s+o for s,o in zip(self, other)) )
        try:
            f = float(other)
        except:
            return NotImplemented
        return Q(self.real + f, self.i, self.j, self.k)
 
    def __radd__(self, other):
        return Q.__add__(self, other)
 
    def __mul__(self, other):
        if type(other) == Q:
            a1,b1,c1,d1 = self
            a2,b2,c2,d2 = other
            return Q(
                 a1*a2 - b1*b2 - c1*c2 - d1*d2,
                 a1*b2 + b1*a2 + c1*d2 - d1*c2,
                 a1*c2 - b1*d2 + c1*a2 + d1*b2,
                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )
        try:
            f = float(other)
        except:
            return NotImplemented
        return Q(self.real * f, self.i * f, self.j * f, self.k * f)
 
    def __rmul__(self, other):
        return Q.__mul__(self, other)
 
    def __truediv__(self, other):
        if type(other) == Q:
            return self.__mul__(other.reciprocal())
        try:
            f = float(other)
        except:
            return NotImplemented
        return Q(self.real / f, self.i / f, self.j / f, self.k / f)
 
    def __rtruediv__(self, other):
        return other * self.reciprocal()
 
    __div__, __rdiv__ = __truediv__, __rtruediv__
 
Quaternion = Q       
 
q  = Q(1, 2, 3, 4)
q1 = Q(2, 3, 4, 5)
q2 = Q(3, 4, 5, 6)
r  = 7",Human_written,Python_from_C#
http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas,The Twelve Days of Christmas,"Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas.
The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"gifts = ""A partridge in a pear tree\nTwo turtle doves and\nThree french hens\nFour calling birds\nFive golden rings\nSix geese a-laying\nSeven swans a-swimming\nEight maids a-milking\nNine ladies dancing\nTen lords a-leaping\nEleven pipers piping\nTwelve drummers drumming"".split(""\n"")

days = [""first"", ""second"", ""third"", ""fourth"", ""fifth"", ""sixth"", ""seventh"", ""eighth"", ""ninth"", ""tenth"", ""eleventh"", ""twelfth""]

for i, day in enumerate(days):
    print(""On the {} day of Christmas"".format(day))
    print(""My true love gave to me:"")
    for j in range(i, -1, -1):
        print(gifts[j])
    print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Set_of_real_numbers,Set of real numbers,"All real numbers form the uncountable set ℝ. Among its subsets, relatively simple are the convex sets, each expressed as a range between two real numbers a and b where a ≤ b. There are actually four cases for the meaning of ""between"", depending on open or closed boundary:

 [a, b]: {x | a ≤ x and x ≤ b }
 (a, b): {x | a < x and x < b }
 [a, b): {x | a ≤ x and x < b }
 (a, b]: {x | a < x and x ≤ b }
Note that if a = b, of the four only [a, a] would be non-empty.

Task

 Devise a way to represent any set of real numbers, for the definition of 'any' in the implementation notes below.
 Provide methods for these common set operations (x is a real number; A and B are sets):
 x ∈ A: determine if x is an element of A
 example: 1 is in [1, 2), while 2, 3, ... are not.
 A ∪ B: union of A and B, i.e. {x | x ∈ A or x ∈ B}
 example: [0, 2) ∪ (1, 3) = [0, 3); [0, 1) ∪ (2, 3] = well, [0, 1) ∪ (2, 3]
 A ∩ B: intersection of A and B, i.e. {x | x ∈ A and x ∈ B}
 example: [0, 2) ∩ (1, 3) = (1, 2); [0, 1) ∩ (2, 3] = empty set
 A - B: difference between A and B, also written as A \ B, i.e. {x | x ∈ A and x ∉ B}
 example: [0, 2) − (1, 3) = [0, 1]
 Test your implementation by checking if numbers 0, 1, and 2 are in any of the following sets:
 (0, 1] ∪ [0, 2)
 [0, 2) ∩ (1, 2]
 [0, 3) − (0, 1)
 [0, 3) − [0, 1]
Implementation notes

 'Any' real set means 'sets that can be expressed as the union of a finite number of convex real sets'. Cantor's set needs not apply.
 Infinities should be handled gracefully; indeterminate numbers (NaN) can be ignored.
 You can use your machine's native real number representation, which is probably IEEE floating point, and assume it's good enough (it usually is).
Optional work

 Create a function to determine if a given set is empty (contains no element).
 Define A = {x | 0 < x < 10 and |sin(π x²)| > 1/2 }, B = {x | 0 < x < 10 and |sin(π x)| > 1/2}, calculate the length of the real axis covered by the set A − B. Note that 
|sin(π x)| > 1/2 is the same as n + 1/6 < x < n + 5/6 for all integers n; your program does not need to derive this by itself.
",Python,"def realSet(set1, set2, op, values):
    def makeSet(set0):
        res = []
        if set0.rangeType == 0:
            for i in range(set0.low, set0.high + 1):
                res.append(i)
        elif set0.rangeType == 1:
            for i in range(set0.low + 1, set0.high):
                res.append(i)
        elif set0.rangeType == 2:
            for i in range(set0.low + 1, set0.high + 1):
                res.append(i)
        else:
            for i in range(set0.low, set0.high):
                res.append(i)
        return res
    res = []
    finalSet = []
    set1 = makeSet(set1)
    set2 = makeSet(set2)
    if op == ""union"":
        finalSet = list(set(set1 + set2))
    elif op == ""intersect"":
        for i in range(len(set1)):
            if set1[i] in set2:
                finalSet.append(set2[i])
    else:
        for i in range(len(set2)):
            if set2[i] not in set1:
                finalSet.append(set2[i])
        for i in range(len(set1)):
            if set1[i] not in set2:
                finalSet.append(set1[i])
    for i in range(len(values)):
        if values[i] in finalSet:
            res.append(True)
        else:
            res.append(False)
    return res",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Mouse_position,Mouse position,"Task

Get the current location of the mouse cursor relative to the active window.

Please specify if the window may be externally created.



",Python,"import Tkinter as tk
 
def showxy(event):
    xm, ym = event.x, event.y
    str1 = ""mouse at x=%d  y=%d"" % (xm, ym)
    # show cordinates in title
    root.title(str1)
    # switch color to red if mouse enters a set location range
    x,y, delta = 100, 100, 10
    frame.config(bg='red'
                 if abs(xm - x) < delta and abs(ym - y) < delta
                 else 'yellow')
 
root = tk.Tk()
frame = tk.Frame(root, bg= 'yellow', width=300, height=200)
frame.bind(""<Motion>"", showxy)
frame.pack()
 
root.mainloop()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Bitmap,Bitmap,"Show a basic storage type to handle a simple RGB raster graphics image,
and some primitive associated functions.

If possible provide a function to allocate an uninitialised image,
given its width and height, and provide 3 additional functions:

   one to fill an image with a plain RGB color,
   one to set a given pixel with a color,
   one to get the color of a pixel.


(If there are specificities about the storage or the allocation, explain those.)

These functions are used as a base for the articles in the category raster graphics operations, 
and a basic output function to check the results
is available in the article write ppm file.



",Python,"#  See the class definitions and constructors with, e.g. 
getClass(""pixmapIndexed"", package=pixmap)
pixmapIndexed
 
# Image with all one colour
plot(p1 <- pixmapIndexed(matrix(0, nrow=3, ncol=4), col=""red""))
 
# Image with one pixel specified
cols <- rep(""blue"", 12); cols[7] <- ""red""
plot(p2 <- pixmapIndexed(matrix(1:12, nrow=3, ncol=4), col=cols))
 
# Retrieve colour of a pixel
getcol <- function(pm, i, j)
{
   pmcol <- pm@col
   dim(pmcol) <- dim(pm@index)
   pmcol[i,j]   
}
getcol(p2, 3, 4)  #red",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Permutations,Permutations,"Task

Write a program that generates all   permutations   of   n   different objects.   (Practically numerals!)



Related tasks
 
   Find the missing permutation
   Permutations/Derangements



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"import itertools
for values in itertools.permutations([1,2,3]):
    print (values)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",Python,">>> import bisect
>>> _cin  = [.06, .11, .16, .21, .26, .31, .36, .41, .46, .51, .56, .61, .66, .71, .76, .81, .86, .91, .96, 1.01]
>>> _cout = [.10, .18, .26, .32, .38, .44, .50, .54, .58, .62, .66, .70, .74, .78, .82, .86, .90, .94, .98, 1.00]
>>> def pricerounder(pricein):
	return _cout[ bisect.bisect_right(_cin, pricein) ]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",Python,"T = [[""79"", ""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""],
     ["""",   ""H"", ""O"", ""L"", """",  ""M"", ""E"", ""S"", """",  ""R"", ""T""],
     [""3"",  ""A"", ""B"", ""C"", ""D"", ""F"", ""G"", ""I"", ""J"", ""K"", ""N""],
     [""7"",  ""P"", ""Q"", ""U"", ""V"", ""W"", ""X"", ""Y"", ""Z"", ""."", ""/""]]
 
def straddle(s):
    return """".join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L)
 
def unstraddle(s):
    s = iter(s)
    for c in s:
        if c in [T[2][0], T[3][0]]:
            i = [T[2][0], T[3][0]].index(c)
            n = T[2 + i][T[0].index(s.next())]
            yield s.next() if n == ""/"" else n
        else:
            yield T[1][T[0].index(c)]
 
O = ""One night-it was on the twentieth of March, 1888-I was returning""
print ""Encoded:"", straddle(O)
print ""Decoded:"", """".join(unstraddle(straddle(O)))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks,Rosetta Code/Find unimplemented tasks,"Task

Given the name of a language on Rosetta Code, find all tasks which are not implemented in that language.



Note: Implementations should allow for fetching more data than can be returned in one request to Rosetta Code.

You'll need to use the Media Wiki API, which you can find out about locally, here, or in Media Wiki's API documentation at, API:Query
",Python,"""""""
Given the name of a language on Rosetta Code,
finds all tasks which are not implemented in that language.
""""""
from operator import attrgetter
from typing import Iterator
 
import mwclient
 
URL = 'www.rosettacode.org'
API_PATH = '/mw/'
 
 
def unimplemented_tasks(language: str,
                        *,
                        url: str,
                        api_path: str) -> Iterator[str]:
    """"""Yields all unimplemented tasks for a specified language""""""
    site = mwclient.Site(url, path=api_path)
    all_tasks = site.categories['Programming Tasks']
    language_tasks = site.categories[language]
    name = attrgetter('name')
    all_tasks_names = map(name, all_tasks)
    language_tasks_names = set(map(name, language_tasks))
    for task in all_tasks_names:
        if task not in language_tasks_names:
            yield task
 
 
if __name__ == '__main__':
    tasks = unimplemented_tasks('Python', url=URL, api_path=API_PATH)
    print(*tasks, sep='\n')",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Parallel_brute_force,Parallel brute force,"Task

Find, through brute force, the five-letter passwords corresponding with the following SHA-256 hashes:

1. 1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad
2. 3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b
3. 74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f

Your program should naively iterate through all possible passwords consisting only of five lower-case ASCII English letters. It should use concurrent or parallel processing, if your language supports that feature. You may calculate SHA-256 hashes by calling a library or through a custom implementation. Print each matching password, along with its SHA-256 hash.

Related task: SHA-256
",Python,"# version 1.1.51
 
import hashlib
 
def stringHashToByteHash(hash):
    ba = bytearray(32)
    for i in range(0, 64, 2):
        ba[i // 2] = int(hash[i:i + 2], 16)
    return ba
 
def matches(ba1, ba2):
    for i in range(32):
        if ba1[i]!= ba2[i]:
            return False
    return True
 
def main():
    stringHashes = [
        ""1115dd800feaacefdf481f1f9070374a2a81e27880f187396db67958b207cbad"",
        ""3a7bd3e2360a3d29eea436fcfb7e44c735d117c42d1c1835420b6b9942dd4f1b"",
        ""74e1bb62f8dabb8125a58852b63bdf6eaef667cb56ac7f7cdba6d7305c50a22f""
    ]
    byteHashes = [stringHashToByteHash(stringHashes[i]) for i in range(3)]
    letters = [chr(97 + i) for i in range(26)]
 
    for i0 in letters:
        md = hashlib.sha256()
        range = range(97, 123)
        pwd = bytearray(5)
        pwd[0] = ord(i0)
        for i1 in range:
            pwd[1] = i1
            for i2 in range:
                pwd[2] = i2
                for i3 in range:
                    pwd[3] = i3
                    for i4 in range:
                        pwd[4] = i4
                        ba = md.digest(pwd)
                        for j in range(3):
                            if matches(ba, byteHashes[j]):
                                password = pwd.decode(""ascii"")
                                print(f""{password} => {stringHashes[j]}"")
                                break
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Phrase_reversals,Phrase reversals,"Task

Given a string of space separated words containing the following phrase:

 rosetta code phrase reversal

 Reverse the characters of the string.
 Reverse the characters of each individual word in the string, maintaining original word order within the string.
 Reverse the order of each word of the string, maintaining the order of characters in each word.


Show your output here.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"str = ""rosetta code phrase reversal""

print(str[::-1])                          # Reversed string.
print("" "".join(str.split()[::-1]))        # Words reversed.
print("" "".join(str.split()[::-1]))        # Word order reversed.",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Five_weekends,Five weekends,"The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.



Task

 Write a program to show all months that have this same characteristic of five full weekends from the year 1900 through 2100 (Gregorian calendar). 
 Show the number of months with this property (there should be 201).
 Show at least the first and last five dates, in order.

Algorithm suggestions

 Count the number of Fridays, Saturdays, and Sundays in every month.
 Find all of the 31-day months that begin on Friday.

Extra credit

Count and/or show all of the years which do not have at least one five-weekend month (there should be 29).



Related tasks
 Day of the week
 Last Friday of each month
 Find last sunday of each month

",Python,"import datetime

months = [""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""]
long_months = [0, 2, 4, 6, 7, 9, 11]

n = 0
for y in range(1900, 2101):
    for i in range(7):
        m = long_months[i]
        try:
            t = datetime.datetime(y, m+1, 1)
        except ValueError:
            print(""Error: {} {}"".format(y, months[m]))
            continue
        if t.weekday() == 4:
            print(""  {} {}"".format(y, months[m]))
            n += 1

print(""{} total"".format(n))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Undefined_values,Undefined values,"
",Python,"# Check to see whether a name is defined
try: name
except NameError: print ""name is undefined at first check""
 
# Create a name, giving it a string value
name = ""Chocolate""
 
# Check to see whether the name is defined now.
try: name
except NameError: print ""name is undefined at second check""
 
# Remove the definition of the name.
del name
 
# Check to see whether it is defined after the explicit removal.
try: name
except NameError: print ""name is undefined at third check""
 
# Recreate the name, giving it a value of 42
name = 42
 
# Check to see whether the name is defined now.
try: name
except NameError: print ""name is undefined at fourth check""
 
# Because most of the output is conditional, this serves as
# a clear indicator that the program has run to completion.
print ""Done""",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Equilibrium_index,Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",Python,"def equlibrium_indices(sequence):
    #find total sum
    totalSum = 0
    for n in sequence:
        totalSum += n
    #compare running sum to remaining sum to find equlibrium indices
    runningSum = 0
    for i in range(len(sequence)):
        n = sequence[i]
        if totalSum - runningSum - n == runningSum:
            print(i)
        runningSum += n
 
sequence = [-7, 1, 5, 2, -4, 3, 0]
equlibrium_indices(sequence)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Bitwise_operations,Bitwise operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.



",Python,"def bitwise(a, b):
    print(""a and b is {0}"".format(a & b))
    print(""a or b is {0}"".format(a | b))
    print(""a xor b is {0}"".format(a ^ b))
    print(""not a is {0}"".format(~a))
    print(""a lshift b is {0}"".format(a << b))
    print(""a arshift b is {0}"".format(a >> b)) # When the left operand of the >> operator is of a signed integral type, 
                                                # the operator performs an arithmetic shift right
    c = a
    print(""c rshift b is {0}"".format(c >> b)) # When the left operand of the >> operator is of an unsigned integral type, 
                                              # the operator performs a logical shift right
    # there are no rotation operators in C#",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Padovan_n-step_number_sequences,Padovan n-step number sequences,"As the Fibonacci sequence expands to the Fibonacci n-step number sequences; We similarly expand the Padovan sequence to form these Padovan n-step number sequences.

The Fibonacci-like sequences can be defined like this:

   For n == 2:
       start:      1, 1
       Recurrence: R(n, x) = R(n, x-1) + R(n, x-2); for n == 2
   For n == N:
       start:      First N terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-1) + R(N, x-2) + ... R(N, x-N))

For this task we similarly define terms of the first 2..n-step Padovan sequences as:

   For n == 2:
       start:      1, 1, 1
       Recurrence: R(n, x) = R(n, x-2) + R(n, x-3); for n == 2
   For n == N:
       start:      First N + 1 terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-2) + R(N, x-3) + ... R(N, x-N-1))

The initial values of the sequences are:


 Padovan 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Values 
 OEIS Entry


 2 
 1,1,1,2,2,3,4,5,7,9,12,16,21,28,37, ... 
 A134816: 'Padovan's spiral numbers'


 3 
 1,1,1,2,3,4,6,9,13,19,28,41,60,88,129, ... 
 A000930: 'Narayana's cows sequence'


 4 
 1,1,1,2,3,5,7,11,17,26,40,61,94,144,221, ... 
 A072465: 'A Fibonacci-like model in which each pair of rabbits dies after the birth of their 4th litter'


 5 
 1,1,1,2,3,5,8,12,19,30,47,74,116,182,286, ... 
 A060961: 'Number of compositions (ordered partitions) of n into 1's, 3's and 5's'


 6 
 1,1,1,2,3,5,8,13,20,32,51,81,129,205,326, ... 
 <not found>


 7 
 1,1,1,2,3,5,8,13,21,33,53,85,136,218,349, ... 
 A117760: 'Expansion of 1/(1 - x - x^3 - x^5 - x^7)'


 8 
 1,1,1,2,3,5,8,13,21,34,54,87,140,225,362, ... 
 <not found>




Task

 Write a function to generate the first 



t


{\displaystyle t}

 terms, of the first 2..max_n Padovan 



n


{\displaystyle n}

-step number sequences as defined above.
 Use this to print and show here at least the first t=15 values of the first 2..8 



n


{\displaystyle n}

-step sequences.
 (The OEIS column in the table above should be omitted).

",Python,"def padovan(n, x):
    if n < 2:
        return 0
    if n == 2 and x <= n + 1:
        return 1
    if n == 2:
        return padovan(n, x - 2) + padovan(n, x - 3)
    if x <= n + 1:
        return padovan(n - 1, x)
    return sum(padovan(n, i) for i in range(x - n - 1, x))
 
for n in range(2, 9):
    print(f""\nN={n}: "", end="""")
    for x in range(1, 16):
        print(f""{padovan(n, x)},"", end="""")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Jewels_and_stones,Jewels and stones,"Jewels and stones

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.

Both strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.

The function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.



Note that:

 Only letters in the ISO basic Latin alphabet i.e. 'A to Z' or 'a to z' need be considered. 
 A lower case letter is considered to be different from its upper case equivalent for this purpose, i.e., 'a' != 'A'.
 The parameters do not need to have exactly the same names.
 Validating the arguments is unnecessary. 
So, for example, if passed ""aAAbbbb"" for 'stones' and ""aA"" for 'jewels', the function should return 3.

This task was inspired by this problem.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def count_jewels(stones, jewels):
    count = 0
    for cur_char in stones:
        if cur_char in jewels:
            count += 1
    return count
 
print(count_jewels(""aAAbbbb"", ""aA""))
print(count_jewels(""ZZ"", ""z""))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Arrays,Arrays,"This task is about arrays.

For hashes or associative arrays, please see Creating an Associative Array.

For a definition and in-depth discussion of what an array is, see Array.



Task

Show basic array syntax in your language.

Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).

Please discuss at Village Pump:   Arrays.

Please merge code in from these obsolete tasks:

   Creating an Array
   Assigning Values to an Array
   Retrieving an Element of an Array


Related tasks

   Collections
   Creating an Associative Array
   Two-dimensional array (runtime)

",Python,"array = []
 
array.append(1)
array.append(3)
 
array[0] = 2
 
print array[0]",Human_written,Python_from_C++
http://rosettacode.org/wiki/File_extension_is_in_extensions_list,File extension is in extensions list,"File extension is in extensions list

You are encouraged to solve this task according to the task description, using any language you may know.
Filename extensions are a rudimentary but commonly used way of identifying files types.



Task

Given an arbitrary filename and a list of extensions, tell whether the filename has one of those extensions.



Notes:

 The check should be case insensitive.
 The extension must occur at the very end of the filename, and be immediately preceded by a dot (.).
 You may assume that none of the given extensions are the empty string, and none of them contain a dot. Other than that they may be arbitrary strings.


Extra credit:
 Allow extensions to contain dots. This way, users of your function/program have full control over what they consider as the extension in cases like:
  archive.tar.gz

 Please state clearly whether or not your solution does this.
Test cases
The following test cases all assume this list of extensions:   zip, rar, 7z, gz, archive, A##



 Filename

 Result


 MyData.a## 
 true


 MyData.tar.Gz 
 true


 MyData.gzip 
 false


 MyData.7z.backup 
 false


 MyData... 
 false


 MyData 
 false

If your solution does the extra credit requirement, add tar.bz2 to the list of extensions, and check the following additional test cases:



 Filename

 Result


 MyData_v1.0.tar.bz2 
 true


 MyData_v1.0.bz2 
 false

Motivation
Checking if a file is in a certain category of file formats with known extensions (e.g. archive files, or image files) is a common problem in practice, and may be approached differently from extracting and outputting an arbitrary extension (see e.g. FileNameExtensionFilter in Java).

It also requires less assumptions about the format of an extension, because the calling code can decide what extensions are valid.

For these reasons, this task exists in addition to the Extract file extension task.



Related tasks
 
 Extract file extension
 String matching

",Python,"import re
import os
 
def extIsIn(test, exts):
	lastSlash = max(test.rfind('/'), test.rfind('\\')) #whichever one they decide to use today
	filename = test[lastSlash + 1:] #+1 to get rid of the slash or move to index 0 if there's no slash
 
	#end of the name if no dot, last dot index otherwise
	lastDot = filename.rfind('.') if filename.rfind('.')!= -1 else len(filename)
	ext = filename[lastDot:] #everything at the last dot and after is the extension
 
	exts.sort() #sort for the binary search
 
	return ext.lower() in exts #binarySearch returns negative numbers when it's not found
 
tests = [""text.txt"", ""text.TXT"", ""test.tar.gz"", ""test/test2.exe"", ""test\\test2.exe"", ""test"", ""a/b/c\\d/foo""]
exts = ["".txt"","".gz"","""","".bat""]
 
print(""Extensions: "" + str(exts) + ""\n"")
 
for test in tests:
	print(test +"": "" + str(extIsIn(test, exts)))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",Python,">>> def flatten(lst):
	return sum( ([x] if not isinstance(x, list) else flatten(x)
		     for x in lst), [] )
 
>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
>>> flatten(lst)
[1, 2, 3, 4, 5, 6, 7, 8]",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Concurrent_computing,Concurrent computing,"Task

Using either native language concurrency syntax or freely available libraries, write a program to display the strings ""Enjoy"" ""Rosetta"" ""Code"", one string per line, in random order.

Concurrency syntax must use threads, tasks, co-routines, or whatever concurrency is called in your language.



",Python,"import random
import threading
import time
 
tRand = random.Random()
 
def WriteText(p):
	time.sleep(tRand.randint(1, 4))
	print(p)
 
t = threading.Thread(target=WriteText, args=(""Enjoy"",))
t.start()
 
t = threading.Thread(target=WriteText, args=(""Rosetta"",))
t.start()
 
t = threading.Thread(target=WriteText, args=(""Code"",))
t.start()
 
input()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Primorial_numbers,Primorial numbers,"Primorial numbers are those formed by multiplying successive prime numbers.



The primorial number series is:

   primorial(0) =         1       (by definition)
   primorial(1) =         2       (2)
   primorial(2) =         6       (2×3)
   primorial(3) =       30       (2×3×5)
   primorial(4) =     210       (2×3×5×7)
   primorial(5) =   2310       (2×3×5×7×11)
   primorial(6) = 30030       (2×3×5×7×11×13)
         ∙ ∙ ∙
To express this mathematically,   primorialn   is  
the product of the first   n   (successive) primes:



   



p
r
i
m
o
r
i
a

l

n


=

∏

k
=
1


n


p
r
i
m

e

k




{\displaystyle primorial_{n}=\prod _{k=1}^{n}prime_{k}}




 ─── where   



p
r
i
m

e

k




{\displaystyle prime_{k}}

   is the   kth   prime number.




In some sense, generating primorial numbers is similar to factorials.

As with factorials, primorial numbers get large quickly.



Task

   Show the first ten primorial numbers   (0 ──► 9,   inclusive).
   Show the length of primorial numbers whose index is:   10   100   1,000   10,000   and   100,000.
   Show the length of the one millionth primorial number   (optional). 
   Use exact integers, not approximations. 


By   length   (above), it is meant the number of decimal digits in the numbers. 




Related tasks

   Sequence of primorial primes
   Factorial
   Fortunate_numbers


See also

   the MathWorld webpage:   primorial
   the Wikipedia   webpage:   primorial.
   the   OEIS   webpage:   A002110.

",Python,"from pyprimes import nprimes
from functools import reduce
 
 
primelist = list(nprimes(1000001))    # [2, 3, 5, ...]
 
def primorial(n):
    return reduce(int.__mul__, primelist[:n], 1)
 
if __name__ == '__main__':
    print('First ten primorals:', [primorial(n) for n in range(10)])
    for e in range(7):
        n = 10**e
        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",Python,"#############################
# Create a passwd text file
#############################
# note that UID & gid are of type ""text""
passwd_list=[
  dict(account='jsmith', password='x', UID=1001, GID=1000, # UID and GID are type int
       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',
                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),
                  directory='/home/jsmith', shell='/bin/bash'),
  dict(account='jdoe', password='x', UID=1002, GID=1000,
       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',
                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),
       directory='/home/jdoe', shell='/bin/bash')
]
 
passwd_fields=""account password UID GID GECOS directory shell"".split()
GECOS_fields=""fullname office extension homephone email"".split()
 
def passwd_text_repr(passwd_rec):
# convert individual fields to string type
  passwd_rec[""GECOS""]="","".join([ passwd_rec[""GECOS""][field] for field in GECOS_fields])
  for field in passwd_rec: # convert ""int"" fields
    if not isinstance(passwd_rec[field], str):
      passwd_rec[field]=`passwd_rec[field]`
  return "":"".join([ passwd_rec[field] for field in passwd_fields ])
 
passwd_text=open(""passwd.txt"",""w"")
for passwd_rec in passwd_list:
  print >> passwd_text,passwd_text_repr(passwd_rec)
passwd_text.close()
 
#################################
# Load text ready for appending
#################################
passwd_text=open(""passwd.txt"",""a+"")
new_rec=dict(account='xyz', password='x', UID=1003, GID=1000,
             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',
                        homephone='(234)555-0033', email='xyz@rosettacode.org'),
             directory='/home/xyz', shell='/bin/bash')
print >> passwd_text,  passwd_text_repr(new_rec)
passwd_text.close()
 
##############################################
# Finally reopen and check record was appended
##############################################
passwd_list=list(open(""passwd.txt"",""r""))
if ""xyz"" in passwd_list[-1]:
  print ""Appended record:"",passwd_list[-1][:-1]",Human_written,Python_from_Go
http://rosettacode.org/wiki/Ulam_spiral_(for_primes),Ulam spiral (for primes),"An Ulam spiral (of primes) is a method of visualizing primes when expressed in a (normally counter-clockwise) outward spiral (usually starting at 1),   constructed on a square grid, starting at the ""center"".

An Ulam spiral is also known as a   prime spiral.

The first grid (green) is shown with sequential integers,   starting at   1.

In an Ulam spiral of primes, only the primes are shown (usually indicated by some glyph such as a dot or asterisk),   and all non-primes as shown as a blank   (or some other whitespace).

Of course, the grid and border are not to be displayed (but they are displayed here when using these Wiki HTML tables).

Normally, the spiral starts in the ""center"",   and the   2nd   number is to the viewer's right and the number spiral starts from there in a counter-clockwise direction.

There are other geometric shapes that are used as well, including clock-wise spirals.

Also, some spirals (for the   2nd   number)   is viewed upwards from the   1st   number instead of to the right, but that is just a matter of orientation.

Sometimes, the starting number can be specified to show more visual striking patterns (of prime densities).

[A larger than necessary grid (numbers wise) is shown here to illustrate the pattern of numbers on the diagonals   (which may be used by the method to orientate the direction of spiral-construction algorithm within the example computer programs)].

Then, in the next phase in the transformation of the Ulam prime spiral,   the non-primes are translated to blanks.

In the orange grid below,   the primes are left intact,   and all non-primes are changed to blanks.

Then, in the final transformation of the Ulam spiral (the yellow grid),   translate the primes to a glyph such as a    •    or some other suitable glyph.





 65 
 64 
 63 
 62 
 61 
 60 
 59 
 58 
 57


 66 
 37 
 36 
 35 
 34 
 33 
 32 
 31 
 56


 67 
 38 
 17 
 16 
 15 
 14 
 13 
 30 
 55


 68 
 39 
 18 
  5 
  4 
  3 
 12 
 29 
 54


 69 
 40 
 19 
  6 
  1 
  2 
 11 
 28 
 53


 70 
 41 
 20 
  7 
  8 
  9 
 10 
 27 
 52


 71 
 42 
 21 
 22 
 23 
 24 
 25 
 26 
 51


 72 
 43 
 44 
 45 
 46 
 47 
 48 
 49 
 50


 73 
 74 
 75 
 76 
 77 
 78 
 79 
 80 
 81



   
   
   
   
 61 
   
 59 
   
  


   
 37 
   
   
   
   
   
 31 
  


 67 
   
 17 
   
   
   
 13 
   
  


   
   
   
  5 
   
  3 
   
 29 
  


   
   
 19 
   
   
  2 
 11 
   
 53


   
 41 
   
  7 
   
   
   
   
  


 71 
   
   
   
 23 
   
   
   
  


   
 43 
   
   
   
 47 
   
   
  


 73 
   
   
   
   
   
 79 
   
  



   
   
   
   
  • 
   
  • 
   
  


   
  • 
   
   
   
   
   
  • 
  


  • 
   
  • 
   
   
   
  • 
   
  


   
   
   
  • 
   
  • 
   
  • 
  


   
   
  • 
   
   
  • 
  • 
   
  •


   
  • 
   
  • 
   
   
   
   
  


  • 
   
   
   
  • 
   
   
   
  


   
  • 
   
   
   
  • 
   
   
  


  • 
   
   
   
   
   
  • 
   
  



The Ulam spiral becomes more visually obvious as the grid increases in size.



Task
For any sized   N × N   grid,   construct and show an Ulam spiral (counter-clockwise) of primes starting at some specified initial number   (the default would be 1),   with some suitably   dotty   (glyph) representation to indicate primes,   and the absence of dots to indicate non-primes.

You should demonstrate the generator by showing at Ulam prime spiral large enough to (almost) fill your terminal screen.



Related tasks

   Spiral matrix
   Zig-zag matrix
   Identity matrix 
   Sequence of primes by Trial Division


See also
 Wikipedia entry:   Ulam spiral 
 MathWorld™ entry:   Prime Spiral

",Python,"# coding=UTF-8
from __future__ import print_function, division
from math import sqrt
 
def cell(n, x, y, start=1):
    d, y, x = 0, y - n//2, x - (n - 1)//2
    l = 2*max(abs(x), abs(y))
    d = (l*3 + x + y) if y >= x else (l - x - y)
    return (l - 1)**2 + d + start - 1
 
def show_spiral(n, symbol='# ', start=1, space=None):
    top = start + n*n + 1
    is_prime = [False,False,True] + [True,False]*(top//2)
    for x in range(3, 1 + int(sqrt(top))):
        if not is_prime[x]: continue
        for i in range(x*x, top, x*2):
            is_prime[i] = False
 
    cell_str = lambda x: f(x) if is_prime[x] else space
    f = lambda _: symbol # how to show prime cells
 
    if space == None: space = ' '*len(symbol)
 
    if not len(symbol): # print numbers instead
        max_str = len(str(n*n + start - 1))
        if space == None: space = '.'*max_str + ' '
        f = lambda x: ('%' + str(max_str) + 'd ')%x
 
    for y in range(n):
        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))
    print()
 
show_spiral(10, symbol=u'♞', space=u'♘') # black are the primes
show_spiral(9, symbol='', space=' - ')
# for filling giant terminals
#show_spiral(1001, symbol='*', start=42)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Active_object,Active object,"In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.

A typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.

The task

Implement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.

In order to test the object:

 set its input to sin (2π f t), where the frequency f=0.5Hz. The phase is irrelevant.
 wait 2s
 set the input to constant 0
 wait 0.5s
Verify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.
",Python,"from threading import Thread
from time import sleep
from math import sin, pi
 
class Integrator:
 
    def __init__(self, func):
        self.start = time.time()
        self.set_func(func)
        self.running = True
        self.thread = Thread(target=self.integrate)
        self.thread.start()
 
    def set_func(self, func):
        self.func = func
        self.v0 = func(0.0)
        self.t0 = 0
 
    def get_output(self):
        return self.sum
 
    def stop(self):
        self.running = False
 
    def integrate(self):
        while self.running:
            sleep(0.001)
            self.update()
 
    def update(self):
        t1 = time.time() - self.start
        v1 = self.func(t1)
        rect = (t1 - self.t0) * (self.v0 + v1) / 2
        self.sum += rect
        self.t0 = t1
        self.v0 = v1
 
if __name__ == '__main__':
    integrator = Integrator(lambda t: sin(pi * t))
    sleep(2)
 
    integrator.set_func(lambda t: 0.0)
    sleep(0.5)
 
    integrator.stop()
    print(integrator.get_output())",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",Python,"def gcd(a, b):
    leftover = 1
    dividend = a if a > b else b
    divisor = a if a > b else b
    while leftover!= 0:
        leftover = dividend % divisor
        if leftover > 0:
            dividend = divisor
            divisor = leftover
    return divisor

def heronArea(a, b, c):
    s = (a + b + c) / 2
    return (s * (s - a) * (s - b) * (s - c)) ** 0.5

def isHeron(h):
    return h % 1 == 0 and h > 0

list = []
j = 0
for c in range(1, 201):
    for b in range(1, c + 1):
        for a in range(1, b + 1):
            if gcd(gcd(a, b), c) == 1 and isHeron(heronArea(a, b, c)):
                list.append([a, b, c, a + b + c, heronArea(a, b, c)])

def sort(list):
    swapped = True
    temp = []
    while swapped:
        swapped = False
        for i in range(1, len(list)):
            if list[i][4] < list[i - 1][4] or list[i][4] == list[i - 1][4] and list[i][3] < list[i - 1][3]:
                temp = list[i]
                list[i] = list[i - 1]
                list[i - 1] = temp
                swapped = True

sort(list)
print(""<h2>Primitive Heronian triangles with sides up to 200: "" + str(len(list)) + ""</h2><h3>First ten when ordered by increasing area, then perimeter:</h3><table><tr><th>Sides</th><th>Perimeter</th><th>Area</th><tr>"")
for i in range(0, 10):
    print(""<tr><td>"" + str(list[i][0]) + "" x "" + str(list[i][1]) + "" x "" + str(list[i][2]) + ""</td><td>"" + str(list[i][3]) + ""</td><td>"" + str(list[i][4]) + ""</td></tr>"")
print(""</table><h3>Area = 210</h3><table><tr><th>Sides</th><th>Perimeter</th><th>Area</th><tr>"")
for i in range(0, len(list)):
    if list[i][4] == 210:
        print(""<tr><td>"" + str(list[i][0]) + "" x "" + str(list[i][1]) + "" x "" + str(list[i][2]) + ""</td><td>"" + str(list[i][3]) + ""</td><td>"" + str(list[i][4]) + ""</td></tr>"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Y_combinator,Y combinator,"In strict functional programming and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions.

This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.

The   Y combinator   is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function.

The Y combinator is the simplest of the class of such functions, called fixed-point combinators.



Task

Define the stateless   Y combinator   and use it to compute factorials and Fibonacci numbers from other stateless functions or lambda expressions.



Cf

 Jim Weirich: Adventures in Functional Programming

",Python,">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))
>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))
>>> [ Y(fac)(i) for i in range(10) ]
[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]
>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))
>>> [ Y(fib)(i) for i in range(10) ]
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;
 
class ColoredPoint extends Point:
    def __init__(self, x, y, idx):
        super().__init__(x, y)
        self.colorIndex = idx
 
class ChaosGame(JPanel):
    def __init__(self):
        self.stack = []
        self.points = []
        self.colors = [Color.red, Color.green, Color.blue]
        self.r = Random()
 
        dim = Dimension(640, 640)
        self.setPreferredSize(dim)
        self.setBackground(Color.white)
 
        margin = 60
        size = dim.width - 2 * margin
 
        self.points.append(Point(dim.width / 2, margin))
        self.points.append(Point(margin, size))
        self.points.append(Point(margin + size, size))
 
        self.stack.append(ColoredPoint(-1, -1, 0))
 
        Timer(10, self.addPoint).start()
 
    def addPoint(self, e):
        if len(self.stack) < 50_000:
            for i in range(1000):
                self.addPoint()
            self.repaint()
 
    def drawPoints(self, g):
        for p in self.stack:
            g.setColor(self.colors[p.colorIndex])
            g.fillOval(p.x, p.y, 1, 1)
 
    def halfwayPoint(self, a, b, idx):
        return ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx)
 
    def paintComponent(self, gg):
        super().paintComponent(gg)
        g = gg
 
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON)
 
        self.drawPoints(g)
 
    def main():
        SwingUtilities.invokeLater(lambda:
            f = JFrame()
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
            f.setTitle(""Chaos Game"")
            f.setResizable(False)
            f.add(ChaosGame(), BorderLayout.CENTER)
            f.pack()
            f.setLocationRelativeTo(None)
            f.setVisible(True)
        )
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",Python,"R = [None, 1]
S = [None, 2]

def extend_sequences(n):
    current = max(R[len(R)-1], S[len(S)-1])
    i = 0
    while len(R) <= n or len(S) <= n:
        i = min(len(R), len(S)) - 1
        current += 1
        if current == R[i] + S[i]:
            R.append(current)
        else:
            S.append(current)

def ffr(n):
    extend_sequences(n)
    return R[n]

def ffs(n):
    extend_sequences(n)
    return S[n]

for i in range(1, 11):
    print('R('+ str(i) +') ='+ str(ffr(i)))

int_array = []

for i in range(1, 41):
    int_array.append(ffr(i))
for i in range(1, 961):
    int_array.append(ffs(i))

int_array.sort()

for i in range(1, 1001):
    if int_array[i-1]!= i:
        raise Exception(""Something's wrong!"")
    else:
        print(""1000 integer check ok."")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Filter,Filter,"Task

Select certain elements from an Array into a new Array in a generic way.



To demonstrate, select all even numbers from an Array.

As an option, give a second solution which filters destructively,
by modifying the original Array rather than creating a new Array.



",Python,"# Enumerable#all? returns true if all elements satisfy the condition.
ary = [1, 2, 3, 4, 5, 6]
print(all(elem.even? for elem in ary)) # => False
 
# Enumerable#all? also works with Range.
range = range(1, 7)
print(all(elem.even? for elem in range)) # => False",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/One_of_n_lines_in_a_file,One of n lines in a file,"A method of choosing a line randomly from a file:

 Without reading the file more than once
 When substantial parts of the file cannot be held in memory
 Without knowing how many lines are in the file
Is to:

 keep the first line of the file as a possible choice, then
 Read the second line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/2.
 Read the third line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/3.
 ...
 Read the Nth line of the file if possible and make it the possible choice if a uniform random value between zero and one is less than 1/N
 Return the computed possible choice when no further lines exist in the file.


Task

 Create a function/method/routine called one_of_n that given n, the number of actual lines in a file, follows the algorithm above to return an integer - the line number of the line chosen from the file. 
The number returned can vary, randomly, in each run.
 Use one_of_n in a simulation to find what woud be the chosen line of a 10 line file simulated 1,000,000 times.
 Print and show how many times each of the 10 lines is chosen as a rough measure of how well the algorithm works.


Note: You may choose a smaller number of repetitions if necessary, but mention this up-front.

Note: This is a specific version of a Reservoir Sampling algorithm: https://en.wikipedia.org/wiki/Reservoir_sampling
",Python,"from random import randrange
try:
    range = xrange
except: pass
 
def one_of_n(lines): # lines is any iterable
    choice = None
    for i, line in enumerate(lines):
        if randrange(i+1) == 0:
            choice = line
    return choice
 
def one_of_n_test(n=10, trials=1000000):
    bins = [0] * n
    if n:
        for i in range(trials):
            bins[one_of_n(range(n))] += 1
    return bins
 
print(one_of_n_test())",Human_written,Python_from_C#
http://rosettacode.org/wiki/Terminal_control/Inverse_video,Terminal control/Inverse video,"Task

Display a word in inverse video   (or reverse video)   followed by a word in normal video.



",Python,"#!/usr/bin/env python
 
print ""\033[7mReversed\033[m Normal""",Human_written,Python_from_Go
http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",Python,">>> def strcat(sequence):
    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1]
 
>>> for seq in ([], [""ABC""], [""ABC"", ""DEF""], [""ABC"", ""DEF"", ""G"", ""H""]):
    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))
 
 
Input: []                       -> Output: '{}'
Input: ['ABC']                  -> Output: '{ABC}'
Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'
Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"from browser import document, html, window
import math
import random
 
def chaosGame():
    canv = document['sierpinski'].getContext('2d')
    x = random.random() * 400
    y = random.random() * 346
    for i in range(30000):
        vertex = math.floor(random.random() * 3)
        if vertex == 0:
            x = x / 2
            y = y / 2
            canv.fillStyle = 'green'
        elif vertex == 1:
            x = 200 + (200 - x) / 2
            y = 346 - (346 - y) / 2
            canv.fillStyle ='red'
        else:
            x = 400 - (400 - x) / 2
            y = y / 2
            canv.fillStyle = 'blue'
        canv.fillRect(x,y, 1,1)
 
document['sierpinski'].width = 400
document['sierpinski'].height = 346
 
chaosGame()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sort_using_a_custom_comparator,Sort using a custom comparator,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of strings in order of descending length, and in ascending lexicographic order for strings of equal length.

Use a sorting facility provided by the language/library, combined with your own callback comparison function.


Note:   Lexicographic order is case-insensitive.



",Python,"strings = ""here are Some sample strings to be sorted"".split()
 
def mykey(x):
    return -len(x), x.upper()
 
print sorted(strings, key=mykey)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",Python,"class rangeBounds:
    def __init__(self, b1, b2):
        self.b1 = b1
        self.b2 = b2
 
def mapRange(x, y, n):
    return y.b1 + (n - x.b1) * (y.b2 - y.b1) / (x.b2 - x.b1)
 
r1 = rangeBounds(0, 10)
r2 = rangeBounds(-1, 0)
for n in range(0, 11, 2):
    print(n, ""maps to"", mapRange(r1, r2, n))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,"import bisect
import itertools
import operator
 
def sortDisjoint(values, indices):
    temp = [values[i] for i in indices]
    indices.sort()
    temp.sort()
    for i, j in itertools.izip(indices, temp):
        values[i] = j
 
values = [7, 6, 5, 4, 3, 2, 1, 0]
indices = [6, 1, 7]
sortDisjoint(values, indices)
print values",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Last_letter-first_letter,Last letter-first letter,"A certain children's game involves starting with a word in a particular category.   Each participant in turn says a word, but that word must begin with the final letter of the previous word.   Once a word has been given, it cannot be repeated.   If an opponent cannot give a word in the category, they fall out of the game.



For example, with   ""animals""   as the category,

Child 1: dog 
Child 2: goldfish
Child 1: hippopotamus
Child 2: snake
...



Task

Take the following selection of 70 English Pokemon names   (extracted from   Wikipedia's list of Pokemon)   and generate the/a sequence with the highest possible number of Pokemon names where the subsequent name starts with the final letter of the preceding name.

No Pokemon name is to be repeated.

audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon
cresselia croagunk darmanitan deino emboar emolga exeggcute gabite
girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan
kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine
nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2
porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking
sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko
tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask



Extra brownie points for dealing with the full list of   646   names.



",Python,"import sys
 
def swap(s1, s2):
    tmp = s1
    s1 = s2
    s2 = tmp
 
def Search(pokemon, longest_chain, len):
    if len > len(longest_chain):
        longest_chain.clear()
        for i in range(len):
            longest_chain.append(pokemon[i])
 
    lastchar = pokemon[len - 1][len(pokemon[len - 1]) - 1]
    for i in range(len, len(pokemon)):
        if pokemon[i][0] == lastchar:
            swap(pokemon[i], pokemon[len])
            Search(pokemon, longest_chain, len + 1)
            swap(pokemon[i], pokemon[len])
 
def main():
    pokemon_names = ""audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon\ncresselia croagunk darmanitan deino emboar emolga exeggcute gabite\ngirafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan\nkricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine\nnosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2\nporygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking\nsealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko\ntyrogue vigoroth vulpix wailord wartortle whismur wingull yamask""
 
    pokemon = pokemon_names.split()
    longest_chain = []
 
    for i in range(len(pokemon)):
        swap(pokemon[0], pokemon[i])
        Search(pokemon, longest_chain, 1)
        swap(pokemon[0], pokemon[i])
 
    for s in longest_chain:
        print(s)
 
if __name__ == ""__main__"":
    sys.exit(main())",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Python,"def maxcat(a):
    a.sort(key=lambda x: str(x)[::-1], reverse=True)
    print(''.join(map(str, a)))
 
maxcat([1, 34, 3, 98, 9, 76, 45, 4])
maxcat([54, 546, 548, 60])",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sort_an_array_of_composite_structures,Sort an array of composite structures,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of composite structures by a key.



For example, if you define a composite structure that presents a name-value pair (in pseudo-code):

Define structure pair such that: 
   name as a string
   value as a string

and an array of such pairs:

   x: array of pairs

then define a sort routine that sorts the array x by the key name.

This task can always be accomplished with Sorting Using a Custom Comparator.

If your language is not listed here, please see the other article.



",Python,"def sort(a):
    for i in range(len(a)):
        for j in range(i+1, len(a)):
            if a[i] > a[j]:
                a[i], a[j] = a[j], a[i]",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sorting_algorithms/Patience_sort,Sorting algorithms/Patience sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of numbers (of any convenient size) into ascending order using   Patience sorting.



Related task

   Longest increasing subsequence

",Python,"from functools import total_ordering
from bisect import bisect_left
from heapq import merge
 
@total_ordering
class Pile(list):
    def __lt__(self, other): return self[-1] < other[-1]
    def __eq__(self, other): return self[-1] == other[-1]
 
def patience_sort(n):
    piles = []
    # sort into piles
    for x in n:
        new_pile = Pile([x])
        i = bisect_left(piles, new_pile)
        if i != len(piles):
            piles[i].append(x)
        else:
            piles.append(new_pile)
 
    # use a heap-based merge to merge piles efficiently
    n[:] = merge(*[reversed(pile) for pile in piles])
 
if __name__ == ""__main__"":
    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]
    patience_sort(a)
    print a",Human_written,Python_from_C++
http://rosettacode.org/wiki/Variadic_function,Variadic function,"Task

Create a function which takes in a variable number of arguments and prints each one on its own line.

Also show, if possible in your language, how to call the function on a list of arguments constructed at runtime.



Functions of this type are also known as Variadic Functions.



Related task

   Call a function

",Python,"def print_all(*things):
    for x in things:
        print x",Human_written,Python_from_C#
http://rosettacode.org/wiki/A%2BB,A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",Python,"try: raw_input
except: raw_input = input
 
print(sum(map(int, raw_input().split())))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",Python,"def ffr(n):
    return get(n, 0)[n - 1]
 
def ffs(n):
    return get(0, n)[n - 1]
 
def get(rSize, sSize):
    rlist = [1, 3, 7]
    slist = [2, 4, 5, 6]
    list = rlist if rSize > 0 else slist
    targetSize = rSize if rSize > 0 else sSize
 
    while len(list) > targetSize:
        list.pop()
    while len(list) < targetSize:
        lastIndex = len(rlist) - 1
        lastr = rlist[lastIndex]
        r = lastr + slist[lastIndex]
        rlist.append(r)
        s = lastr + 1
        while s < r and len(list) < targetSize:
            slist.append(s)
            s += 1
    return list
 
if __name__ == ""__main__"":
    print(""R():"", end="" "")
    for i in range(1, 11):
        print(ffr(i), end="" "")
    print()
 
    first40R = [ffr(i) for i in range(1, 41)]
    first960S = [ffs(i) for i in range(1, 961)]
    indices = [i for i in range(1, 1001) if (i in first40R) == (i in first960S)]
    for i in indices:
        print(""Integer"", i, ""either in both or neither set"")
    print(""Done"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/FizzBuzz,FizzBuzz,"Task

Write a program that prints the integers from   1   to   100   (inclusive).



But:

   for multiples of three,   print   Fizz     (instead of the number)
   for multiples of five,   print   Buzz     (instead of the number)
   for multiples of both three and five,   print   FizzBuzz     (instead of the number) 


The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.



Also see

   (a blog)   dont-overthink-fizzbuzz
   (a blog)   fizzbuzz-the-programmers-stairway-to-heaven

",Python,"for i in xrange(1, 101):
    if i % 15 == 0:
        print ""FizzBuzz""
    elif i % 3 == 0:
        print ""Fizz""
    elif i % 5 == 0:
        print ""Buzz""
    else:
        print i",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Dragon_curve,Dragon curve,"

Create and display a dragon curve fractal.

(You may either display the curve directly or write it to an image file.)



Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

 Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle. And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
 The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
 The curl direction right or left can be a parameter instead of two separate routines.
 Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
 This can be seen in the SVG example. This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
 Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
 Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side. If the segment is an even position then on the left. The process is then repeated on the new doubled list of segments. This constructs a full set of line segments before any drawing.
 The effect of the splitting is a kind of bottom-up version of the recursions. See the Asymptote example for code doing this.
 Iteratively the curve always turns 90-degrees left or right at each point. The direction of the turn is given by the bit above the lowest 1-bit of n. Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
 The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
 If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead. This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
 Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
 If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
 Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
 This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
 Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate. This is done in the gnuplot code. This might suit things similar to Gnuplot which want to calculate each point independently.
 Predicate test for whether a given X,Y point or segment is on the curve can be done. This might suit line-by-line output rather than building an entire image before printing. See M4 for an example of this.
 A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient. Why it works is slightly subtle but the calculation is not difficult. (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1. Check vertex by whether the segment either East or West is on the curve.)
 The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points. The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
 As a Lindenmayer system of expansions. The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above. Read more at for instance Joel Castellanos' L-system page.

Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.

The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 


",Python,"import math
import numpy as np
import matplotlib.pyplot as plt

# separation of the the two endpoints
# make this a power of 2 for prettiest output
sep = 512
# depth of recursion.  adjust as desired for different visual effects.
depth = 14

s = math.sqrt(2) / 2
sin = [0, s, 1, s, 0, -s, -1, -s]
cos = [1, s, 0, -s, -1, -s, 0, s]
p = [64, 192, 96, 255]

def dragon(n, a, t, d, x, y):
    if n <= 1:
        # Go packages used here do not have line drawing functions
        # so we implement a very simple line drawing algorithm here.
        # We take advantage of knowledge that we are always drawing
        # 45 degree diagonal lines.
        x1 = int(x + 0.5)
        y1 = int(y + 0.5)
        x2 = int(x + d*cos[a] + 0.5)
        y2 = int(y + d*sin[a] + 0.5)
        xInc = 1
        if x1 > x2:
            xInc = -1
        yInc = 1
        if y1 > y2:
            yInc = -1
        for x, y in zip(range(x1, x2, xInc), range(y1, y2, yInc)):
            b[x, y] = p
        return
    d *= s
    a1 = (a - t) & 7
    a2 = (a + t) & 7
    dragon(n-1, a1, 1, d, x, y)
    dragon(n-1, a2, -1, d, x+d*cos[a1], y+d*sin[a1])

width = sep * 11 // 6
height = sep * 4 // 3
b = np.zeros((width, height, 4), dtype=np.uint8)
b[:, :] = 255
dragon(depth, 0, 1, sep, sep/2, sep*5//6)
plt.imshow(b)
plt.show()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Munchausen_numbers,Munchausen numbers,"A Munchausen number is a natural number n the sum of whose digits (in base 10), each raised to the power of itself, equals n.

(Munchausen is also spelled: Münchhausen.)

For instance:    3435 = 33 + 44 + 33 + 55 



Task
Find all Munchausen numbers between   1   and   5000.



Also see

 The OEIS entry:  A046253
 The Wikipedia entry:  Perfect digit-to-digit invariant, redirected from Munchausen Number

",Python,"import math
 
powers = [0] * 10
 
def isMunchausen(n):
    if n < 0: return False
    n64 = n
    nn  = n
    sum = 0
    while nn > 0:
        sum += powers[nn % 10]
        if sum > n64: return False
        nn //= 10
    return sum == n64
 
# cache n ^ n for n in 0..9, defining 0 ^ 0 = 0 for this purpose
for i in range(1, 10):
    d = i
    powers[i] = int(math.pow(d, d))
 
# check numbers 0 to 500 million
print(""The Munchausen numbers between 0 and 500 million are:"")
for i in range(500000001):
    if isMunchausen(i): print(i, end="" "")
print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",Python,"import math
 
math.e          # e
math.pi         # pi
math.sqrt(x)    # square root  (Also commonly seen as x ** 0.5 to obviate importing the math module)
math.log(x)     # natural logarithm
math.log10(x)   # base 10 logarithm
math.exp(x)     # e raised to the power of x
abs(x)          # absolute value
math.floor(x)   # floor
math.ceil(x)    # ceiling
x ** y          # exponentiation 
pow(x, y[, n])  # exponentiation [, modulo n (useful in certain encryption/decryption algorithms)]
 
# The math module constants and functions can, of course, be imported directly by:
#   from math import e, pi, sqrt, log, log10, exp, floor, ceil",Human_written,Python_from_Go
http://rosettacode.org/wiki/Count_in_factors,Count in factors,"Task

Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.

For the purpose of this task,   1   (unity)   may be shown as itself.



Example

      2   is prime,   so it would be shown as itself.

      6   is not prime;   it would be shown as   



2
×
3


{\displaystyle 2\times 3}

.
2144   is not prime;   it would be shown as   



2
×
2
×
2
×
2
×
2
×
67


{\displaystyle 2\times 2\times 2\times 2\times 2\times 67}

.



Related tasks

   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Python,"import math
 
def factorize(n):
	l = []
	if n == 1:
		l.append(1)
	else:
		k = 2
		while n > 1:
			while n % k == 0:
				l.append(k)
				n /= k
			k += 1
	return l
 
for i in range(1, 23):
	f = factorize(i)
	print(str(i) + "":  "" + str(f[0]), end="""")
	for j in range(1, len(f)):
		print("" * "" + str(f[j]), end="""")
	print()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Number_reversal_game,Number reversal game,"Task

Given a jumbled list of the numbers   1   to   9   that are definitely   not   in
ascending order.

Show the list,   and then ask the player how many digits from the
left to reverse.

Reverse those digits,   then ask again,   until all the digits end up in ascending order.



The score is the count of the reversals needed to attain the ascending order.



Note: Assume the player's input does not need extra validation.



Related tasks

   Sorting algorithms/Pancake sort
   Pancake sorting.
   Topswops

",Python,"'''
number reversal game
    Given a jumbled list of the numbers 1 to 9
    Show the list.
    Ask the player how many digits from the left to reverse.
    Reverse those digits then ask again.
    until all the digits end up in ascending order.
 
'''
 
import random
 
print(__doc__)
data, trials = list('123456789'), 0
while data == sorted(data):
    random.shuffle(data)
while data != sorted(data):
    trials += 1
    flip = int(input('#%2i: LIST: %r Flip how many?: ' % (trials, ' '.join(data))))
    data[:flip] = reversed(data[:flip])
 
print('\nYou took %2i attempts to put the digits in order!' % trials)",Human_written,Python_from_C
http://rosettacode.org/wiki/Factorions,Factorions,"

Definition

A factorion is a natural number that equals the sum of the factorials of its digits.



Example
 
145   is a factorion in base 10 because:


          1! + 4! + 5!   =   1 + 24 + 120   =   145 





It can be shown (see talk page) that no factorion in base 10 can exceed   1,499,999.



Task

Write a program in your language to demonstrate, by calculating and printing out the factorions, that:

   There are   3   factorions in base   9
   There are   4   factorions in base 10
   There are   5   factorions in base 11 
   There are   2   factorions in base 12     (up to the same upper bound as for base 10)


See also

 Wikipedia article
 OEIS:A014080 - Factorions in base 10
 OEIS:A193163 - Factorions in base n

",Python,"#include <iostream>
 
class factorion_t {
public:
    factorion_t() {
        f[0] = 1u;
        for (uint n = 1u; n < 12u; n++)
            f[n] = f[n - 1] * n;
    }
 
    bool operator()(uint i, uint b) const {
        uint sum = 0;
        for (uint j = i; j > 0u; j /= b)
            sum += f[j % b];
        return sum == i;
    }
 
private:
    ulong f[12];  //< cache factorials from 0 to 11
};
 
int main() {
    factorion_t factorion;
    for (uint b = 9u; b <= 12u; ++b) {
        std::cout << ""factorions for base "" << b << ':';
        for (uint i = 1u; i < 1500000u; ++i)
            if (factorion(i, b))
                std::cout <<'' << i;
        std::cout << std::endl;
    }
    return 0;
}",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bitwise_IO,Bitwise IO,"The aim of this task is to write functions (or create a class if your
language is Object Oriented and you prefer) for reading and writing sequences of
bits, most significant bit first. While the output of a asciiprint ""STRING"" is the ASCII byte sequence
""S"", ""T"", ""R"", ""I"", ""N"", ""G"", the output of a ""print"" of the bits sequence
0101011101010 (13 bits) must be 0101011101010; real I/O is performed always
quantized by byte (avoiding endianness issues and relying on underlying
buffering for performance), therefore you must obtain as output the bytes
0101 0111 0101 0000 (bold bits are padding bits), i.e. in hexadecimal 57 50.

As test, you can implement a rough (e.g. don't care about error handling or
other issues) compression/decompression program for ASCII sequences
of bytes, i.e. bytes for which the most significant bit is always unused, so that you can write
seven bits instead of eight (each 8 bytes of input, we write 7 bytes of output).

These bit oriented I/O functions can be used to implement compressors and
decompressors; e.g. Dynamic and Static Huffman encodings use variable length
bits sequences, while LZW (see LZW compression) use fixed or variable words
nine (or more) bits long.

 Limits in the maximum number of bits that can be written/read in a single read/write operation are allowed.
 Errors handling is not mandatory

",Python,"class BitWriter(object):
    def __init__(self, f):
        self.accumulator = 0
        self.bcount = 0
        self.out = f
 
    def __enter__(self):
        return self
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.flush()
 
    def __del__(self):
        try:
            self.flush()
        except ValueError:   # I/O operation on closed file.
            pass
 
    def _writebit(self, bit):
        if self.bcount == 8:
            self.flush()
        if bit > 0:
            self.accumulator |= 1 << 7-self.bcount
        self.bcount += 1
 
    def writebits(self, bits, n):
        while n > 0:
            self._writebit(bits & 1 << n-1)
            n -= 1
 
    def flush(self):
        self.out.write(bytearray([self.accumulator]))
        self.accumulator = 0
        self.bcount = 0
 
 
class BitReader(object):
    def __init__(self, f):
        self.input = f
        self.accumulator = 0
        self.bcount = 0
        self.read = 0
 
    def __enter__(self):
        return self
 
    def __exit__(self, exc_type, exc_val, exc_tb):
        pass
 
    def _readbit(self):
        if not self.bcount:
            a = self.input.read(1)
            if a:
                self.accumulator = ord(a)
            self.bcount = 8
            self.read = len(a)
        rv = (self.accumulator & (1 << self.bcount-1)) >> self.bcount-1
        self.bcount -= 1
        return rv
 
    def readbits(self, n):
        v = 0
        while n > 0:
            v = (v << 1) | self._readbit()
            n -= 1
        return v
 
if __name__ == '__main__':
    import os
    import sys
    # Determine this module's name from it's file name and import it.
    module_name = os.path.splitext(os.path.basename(__file__))[0]
    bitio = __import__(module_name)
 
    with open('bitio_test.dat', 'wb') as outfile:
        with bitio.BitWriter(outfile) as writer:
            chars = '12345abcde'
            for ch in chars:
                writer.writebits(ord(ch), 7)
 
    with open('bitio_test.dat', 'rb') as infile:
        with bitio.BitReader(infile) as reader:
            chars = []
            while True:
                x = reader.readbits(7)
                if not reader.read:  # End-of-file?
                    break
                chars.append(chr(x))
            print(''.join(chars))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Word_wrap,Word wrap,"Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column.



Basic task

The basic task is to wrap a paragraph of text in a simple way in your language.

If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.

Show your routine working on a sample of text at two different wrap columns.



Extra credit

Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you must reference documentation indicating that the algorithm
is something better than a simple minimum length algorithm.

If you have both basic and extra credit solutions, show an example where
the two algorithms give different results.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> import textwrap
>>> help(textwrap.fill)
Help on function fill in module textwrap:
 
fill(text, width=70, **kwargs)
    Fill a single paragraph of text, returning a new string.
 
    Reformat the single paragraph in 'text' to fit in lines of no more
    than 'width' columns, and return a new string containing the entire
    wrapped paragraph.  As with wrap(), tabs are expanded and other
    whitespace characters converted to space.  See TextWrapper class for
    available keyword args to customize wrapping behaviour.
 
>>> txt = '''\
Reformat the single paragraph in 'text' to fit in lines of no more
than 'width' columns, and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are expanded and other
whitespace characters converted to space.  See TextWrapper class for
available keyword args to customize wrapping behaviour.'''
>>> print(textwrap.fill(txt, width=75))
Reformat the single paragraph in 'text' to fit in lines of no more than
'width' columns, and return a new string containing the entire wrapped
paragraph.  As with wrap(), tabs are expanded and other whitespace
characters converted to space.  See TextWrapper class for available keyword
args to customize wrapping behaviour.
>>> print(textwrap.fill(txt, width=45))
Reformat the single paragraph in 'text' to
fit in lines of no more than 'width' columns,
and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are
expanded and other whitespace characters
converted to space.  See TextWrapper class
for available keyword args to customize
wrapping behaviour.
>>> print(textwrap.fill(txt, width=85))
Reformat the single paragraph in 'text' to fit in lines of no more than 'width'
columns, and return a new string containing the entire wrapped paragraph.  As with
wrap(), tabs are expanded and other whitespace characters converted to space.  See
TextWrapper class for available keyword args to customize wrapping behaviour.
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",Python,"def yesno():
    try:
        import msvcrt
        str = msvcrt.getch()
    except ImportError:
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            str = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    if str == ""Y"":
        return True
    elif str == ""N"":
        return False
    else:
        raise ""Invalid character.""",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",Python,"def mersenne_factor(p):
    limit = (2**p - 1)**0.5
    k = 1
    while (2*k*p - 1) < limit:
        q = 2*k*p + 1
        if isPrime(q) and (q % 8 == 1 or q % 8 == 7) and trial_factor(2,p,q):
            return q # q is a factor of 2**p-1
        k += 1
    return None
 
def isPrime(value):
    for i in range(2, value):
        if value % i == 0:
            return False
    return True
 
def trial_factor(base, exp, mod):
    square = 1
    bits = bin(exp)[2:]
    for i in range(len(bits)):
        square = (square**2 * (base if bits[i] == '1' else 1)) % mod
    return square == 1
 
def check_mersenne(p):
    print(""M""+str(p)+"" = 2^""+str(p)+""-1 is "")
    f = mersenne_factor(p)
    print(""prime"" if f == None else ""composite with factor ""+str(f))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Resistor_mesh,Resistor mesh,"
Task

Given    10×10    grid nodes   (as shown in the image)   interconnected by    1Ω    resistors as shown,

find the resistance between points   A   and   B.



See also

   (humor, nerd sniping)   xkcd.com cartoon

",Python,"DIFF_THRESHOLD = 1e-40
 
class Fixed:
    FREE = 0
    A = 1
    B = 2
 
class Node:
    __slots__ = [""voltage"", ""fixed""]
    def __init__(self, v=0.0, f=Fixed.FREE):
        self.voltage = v
        self.fixed = f
 
def set_boundary(m):
    m[1][1] = Node( 1.0, Fixed.A)
    m[6][7] = Node(-1.0, Fixed.B)
 
def calc_difference(m, d):
    h = len(m)
    w = len(m[0])
    total = 0.0
 
    for i in xrange(h):
        for j in xrange(w):
            v = 0.0
            n = 0
            if i != 0:  v += m[i-1][j].voltage; n += 1
            if j != 0:  v += m[i][j-1].voltage; n += 1
            if i < h-1: v += m[i+1][j].voltage; n += 1
            if j < w-1: v += m[i][j+1].voltage; n += 1
            v = m[i][j].voltage - v / n
 
            d[i][j].voltage = v
            if m[i][j].fixed == Fixed.FREE:
                total += v ** 2
    return total
 
def iter(m):
    h = len(m)
    w = len(m[0])
    difference = [[Node() for j in xrange(w)] for i in xrange(h)]
 
    while True:
        set_boundary(m) # Enforce boundary conditions.
        if calc_difference(m, difference) < DIFF_THRESHOLD:
            break
        for i, di in enumerate(difference):
            for j, dij in enumerate(di):
                m[i][j].voltage -= dij.voltage
 
    cur = [0.0] * 3
    for i, di in enumerate(difference):
        for j, dij in enumerate(di):
            cur[m[i][j].fixed] += (dij.voltage *
                (bool(i) + bool(j) + (i < h-1) + (j < w-1)))
 
    return (cur[Fixed.A] - cur[Fixed.B]) / 2.0
 
def main():
    w = h = 10
    mesh = [[Node() for j in xrange(w)] for i in xrange(h)]
    print ""R = %.16f"" % (2 / iter(mesh))
 
main()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sudoku,Sudoku,"Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format.

references

 Algorithmics of Sudoku   may help implement this.
 Python Sudoku Solver Computerphile video.

",Python,"def initiate():
    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])
    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])
    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])
    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])
    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])
    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])
    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])
    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])
    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])
    for i in range(0, 81, 9):
        row.append(range(i, i+9))
    for i in range(9):
        column.append(range(i, 80+i, 9))
 
def valid(n, pos):
    current_row = pos/9
    current_col = pos%9
    current_box = (current_row/3)*3 + (current_col/3)
    for i in row[current_row]:
        if (grid[i] == n):
            return False
    for i in column[current_col]:
        if (grid[i] == n):
            return False
    for i in box[current_box]:
        if (grid[i] == n):
            return False
    return True
 
def solve():
    i = 0
    proceed = 1
    while(i < 81):
        if given[i]:
            if proceed:
                    i += 1
            else:
                i -= 1
        else:
            n = grid[i]
            prev = grid[i]
            while(n < 9):
              if (n < 9):
                  n += 1
              if valid(n, i):
                  grid[i] = n
                  proceed = 1
                  break
            if (grid[i] == prev):
               grid[i] = 0
               proceed = 0
            if proceed:
               i += 1
            else:
               i -=1
 
def inputs():
    nextt = 'T'
    number = 0
    pos = 0
    while(not(nextt == 'N' or nextt == 'n')):
        print ""Enter the position:"",
        pos = int(raw_input())
        given[pos - 1] = True
        print ""Enter the numerical:"",
        number = int(raw_input())
        grid[pos - 1] = number
        print ""Do you want to enter another given?(Y, for yes: N, for no)""
        nextt = raw_input()
 
 
grid = [0]*81
given = [False]*81
box = []
row = []
column = []
initiate()
inputs()
solve()
for i in range(9):
    print grid[i*9:i*9+9]
raw_input()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Exponentiation_order,Exponentiation order,"This task will demonstrate the order of exponentiation   (xy)    when there are multiple exponents.

(Many programming languages,   especially those with extended─precision integer arithmetic,   usually support one of  **, ^, ↑  or some such for exponentiation.)



Task requirements
Show the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



Using whatever operator or syntax your language supports (if any), show the results in three lines (with identification):


   5**3**2 
   (5**3)**2
   5**(3**2)




If there are other methods (or formats) of multiple exponentiations, show them as well.



See also

 MathWorld entry:   exponentiation


Related tasks

   exponentiation operator
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,">>> 5**3**2
1953125
>>> (5**3)**2
15625
>>> 5**(3**2)
1953125
>>> # The following is not normally done
>>> try: from functools import reduce # Py3K
except: pass
 
>>> reduce(pow, (5, 3, 2))
15625
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Evaluate_binomial_coefficients,Evaluate binomial coefficients,"This programming task, is to calculate ANY binomial coefficient.

However, it has to be able to output   






(


5
3


)





{\displaystyle {\binom {5}{3}}}

,   which is   10.

This formula is recommended:


 






(


n
k


)



=



n
!


(
n
−
k
)
!
k
!



=



n
(
n
−
1
)
(
n
−
2
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
(
k
−
2
)
…
1





{\displaystyle {\binom {n}{k}}={\frac {n!}{(n-k)!k!}}={\frac {n(n-1)(n-2)\ldots (n-k+1)}{k(k-1)(k-2)\ldots 1}}}





See Also:

 Combinations and permutations
 Pascal's triangle

 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"class Integer:
    def choose(self, k):
        pTop = reduce(lambda x, y: x*y, range(self-k+1, self+1))
        pBottom = reduce(lambda x, y: x*y, range(2, k+1))
        return pTop / pBottom
 
print 5.choose(3)
print 60.choose(30)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Fractal_tree,Fractal tree,"Generate and draw a fractal tree.

 Draw the trunk
 At the end of the trunk, split by some angle and draw two branches
 Repeat at the end of each branch until a sufficient level of branching is reached


Related tasks
 Pythagoras Tree

",Python,"# version 1.1.2
 
import java.awt.Color
import java.awt.Graphics
import javax.swing.JFrame
 
class FractalTree(JFrame):
    def __init__(self):
        super().__init__(""Fractal Tree"")
        self.background = Color.black
        self.setBounds(100, 100, 800, 600)
        self.isResizable = False
        self.defaultCloseOperation = EXIT_ON_CLOSE
 
    def drawTree(self, g, x1, y1, angle, depth):
        if depth == 0:
            return
        x2 = x1 + (math.cos(math.toRadians(angle)) * depth * 10.0).toInt()
        y2 = y1 + (math.sin(math.toRadians(angle)) * depth * 10.0).toInt()
        g.drawLine(x1, y1, x2, y2)
        self.drawTree(g, x2, y2, angle - 20, depth - 1)
        self.drawTree(g, x2, y2, angle + 20, depth - 1)
 
    def paint(self, g):
        g.color = Color.white
        self.drawTree(g, 400, 500, -90.0, 9)
 
def main(args):
    FractalTree().isVisible = True
 
if __name__ == '__main__':
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",Python,"import math
 
def isPrime(n):
	if n % 2 == 0:
		return n == 2
	if n % 3 == 0:
		return n == 3
	d = 5
	while d*d <= n:
		if n % d == 0:
			return False
		d += 2
		if n % d == 0:
			return False
		d += 4
	return True
 
q = 929
if not isPrime(q):
	return
r = q
while r > 0:
	r <<= 1
d = 2 * q + 1
while True:
	i = 1
	for p in range(r):
		i = (i*i) % d
		if p < 0:
			i *= 2
		if i > d:
			i -= d
	if i!= 1:
		d += 2 * q
	else:
		break
 
print(""2^""+str(q)+""-1 = 0 (mod ""+str(d)+"")"")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",Python,"import math
def yinyang(n=3):
	radii   = [i * n for i in (1, 3, 6)]
	ranges  = [list(range(-r, r+1)) for r in radii]
	squares = [[ (x,y) for x in rnge for y in rnge]
		   for rnge in ranges]
	circles = [[ (x,y) for x,y in sqrpoints
		     if math.hypot(x,y) <= radius ]
		   for sqrpoints, radius in zip(squares, radii)]
	m = {(x,y):' ' for x,y in squares[-1]}
	for x,y in circles[-1]:
		m[x,y] = '*'
	for x,y in circles[-1]:
		if x>0: m[(x,y)] = '·'
	for x,y in circles[-2]:
		m[(x,y+3*n)] = '*'
		m[(x,y-3*n)] = '·'
	for x,y in circles[-3]:
		m[(x,y+3*n)] = '·'
		m[(x,y-3*n)] = '*'
	return '\n'.join(''.join(m[(x,y)] for x in reversed(ranges[-1])) for y in ranges[-1])",Human_written,Python_from_C#
http://rosettacode.org/wiki/Shortest_common_supersequence,Shortest common supersequence,"The   shortest common supersequence   is a problem closely related to the   longest common subsequence,   which you can use as an external function for this task.



Task

Given two strings 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

, find the shortest possible sequence 



s


{\displaystyle s}

, which is the shortest common super-sequence of 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 where both 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 are a subsequence of 



s


{\displaystyle s}

. Defined as such, 



s


{\displaystyle s}

 is not necessarily unique.

Demonstrate this by printing 



s


{\displaystyle s}

 where 



u
=


{\displaystyle u=}

“abcbdab” and 



v
=


{\displaystyle v=}

“bdcaba”.



Also see

 Wikipedia: shortest common supersequence 

",Python,"def lcs(x, y):
    xl, yl = len(x), len(y)
    if xl == 0 or yl == 0:
        return """"
    x1, y1 = x[:xl-1], y[:yl-1]
    if x[xl-1] == y[yl-1]:
        return lcs(x1, y1) + x[xl-1]
    x2, y2 = lcs(x, y1), lcs(x1, y)
    if len(x2) > len(y2):
        return x2
    else:
        return y2
 
def scs(u, v):
    ul, vl = len(u), len(v)
    lcs = lcs(u, v)
    ui, vi = 0, 0
    sb = []
    for i in range(len(lcs)):
        while ui < ul and u[ui]!= lcs[i]:
            sb.append(u[ui])
            ui += 1
        while vi < vl and v[vi]!= lcs[i]:
            sb.append(v[vi])
            vi += 1
        sb.append(lcs[i])
        ui += 1
        vi += 1
    if ui < ul:
        sb.extend(u[ui:])
    if vi < vl:
        sb.extend(v[vi:])
    return """".join(sb)
 
u = ""abcbdab""
v = ""bdcaba""
print(scs(u, v))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Pancake_numbers,Pancake numbers,"Adrian Monk has problems and an assistant, Sharona Fleming. Sharona can deal with most of Adrian's problems except his lack of punctuality paying her remuneration. 2 pay checks down and she prepares him pancakes for breakfast. Knowing that he will be unable to eat them unless they are stacked in ascending order of size she leaves him only a skillet which he can insert at any point in the pile and flip all the above pancakes, repeating until the pile is sorted. Sharona has left the pile of n pancakes such that the maximum number of flips is required. Adrian is determined to do this in as few flips as possible. This sequence n->p(n) is known as the Pancake numbers.

The task is to determine p(n) for n = 1 to 9, and for each show an example requiring p(n) flips.

Sorting_algorithms/Pancake_sort actually performs the sort some giving the number of flips used. How do these compare with p(n)?

Few people know p(20), generously I shall award an extra credit for anyone doing more than p(16).



References
 Bill Gates and the pancake problem
 A058986

",Python,"""""""Pancake numbers. Requires Python>=3.7.""""""
import time
 
from collections import deque
from operator import itemgetter
from typing import Tuple
 
Pancakes = Tuple[int, ...]
 
 
def flip(pancakes: Pancakes, position: int) -> Pancakes:
    """"""Flip the stack of pancakes at the given position.""""""
    return tuple([*reversed(pancakes[:position]), *pancakes[position:]])
 
 
def pancake(n: int) -> Tuple[Pancakes, int]:
    """"""Return the nth pancake number.""""""
    init_stack = tuple(range(1, n + 1))
    stack_flips = {init_stack: 0}
    queue = deque([init_stack])
 
    while queue:
        stack = queue.popleft()
        flips = stack_flips[stack] + 1
 
        for i in range(2, n + 1):
            flipped = flip(stack, i)
            if flipped not in stack_flips:
                stack_flips[flipped] = flips
                queue.append(flipped)
 
    return max(stack_flips.items(), key=itemgetter(1))
 
 
if __name__ == ""__main__"":
    start = time.time()
 
    for n in range(1, 10):
        pancakes, p = pancake(n)
        print(f""pancake({n}) = {p:>2}. Example: {list(pancakes)}"")
 
    print(f""\nTook {time.time() - start:.3} seconds."")",Human_written,Python_from_C++
http://rosettacode.org/wiki/Introspection,Introspection,"Task

 verify the version/revision of your currently running (compiler/interpreter/byte-compiler/runtime environment/whatever your language uses) and exit if it is too old.
 check whether the variable ""bloop"" exists and whether the math-function ""abs()"" is available and if yes compute abs(bloop).


Extra credit

 Report the number of integer variables in global scope, and their sum.

",Python,"# version 1.0.6 (intro.py)
 
import sys
import java.lang.Math as Math
import java.lang.reflect.Method as Method
 
bloop = -3
i = 4
j = 5
k = 6
 
def main(args):
    # get version of JVM
    version = System.getProperty(""java.version"")
    if version >= ""1.6"":
        print(""The current JVM version is "" + version)
    else:
        print(""Must use version 1.6 or later"")
 
    # check that 'bloop' and 'Math.abs' are available
    # note that the class created by the Kotlin compiler for top level declarations will be called 'IntroKt'
    topLevel = Class.forName(""IntroKt"")
    math = Class.forName(""java.lang.Math"")
    abs = math.getDeclaredMethod(""abs"", Int::class.java)
    methods = topLevel.getDeclaredMethods()
    for method in methods:
        # note that the read-only Kotlin property 'bloop' is converted to the static method 'getBloop' in Java
        if method.name == ""getBloop"" and method.returnType == Int::class.java:
            print(""\nabs(bloop) = "" + abs.invoke(null, method.invoke(null)))
            break
 
    # now get the number of global integer variables and their sum
    count = 0
    sum = 0
    for method in methods:
        if method.returnType == Int::class.java:
            count += 1
            sum += method.invoke(null)
    print(""\nThere are "" + count + "" global integer variables and their sum is "" + sum)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Scope/Function_names_and_labels,Scope/Function names and labels,"Task

Explain or demonstrate the levels of visibility of function names and labels within the language.



See also

 Variables for levels of scope relating to visibility of program variables
 Scope modifiers for general scope modification facilities

",Python,"import sys
 
def sqr(x):
	return x * x
 
def greet():
	print(""Hello There!"")
 
def twice(x):
	return 2 * x
 
def main():
	x = 0
	print(""This will demonstrate function and label scopes."")
	print(""All output is happening through printf(), a function declared in the header stdio.h, which is external to this program."")
	print(""Enter a number: "")
	x = int(input())
	if x % 2 == 0:
		print(""You entered an even number."")
		print(""Its square is %d, which was computed by a macro. It has global scope within the translation unit."" % sqr(x))
	elif x % 2 == 1:
		print(""You entered an odd number."")
		greet()
		if x == -1:
			return
		print(""2 times %d is %d, which was computed by a function defined in this file. It has global scope within the translation unit."" % (x, twice(x)))
		print(""Since you jumped in, you will now be greeted, again!"")
		greet()
	print(""We now come to goto, it's extremely powerful but it's also prone to misuse. Its use is discouraged and it wasn't even adopted by Java and later languages."")
	if x!= -1:
		x = -1
		main()
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/FizzBuzz,FizzBuzz,"Task

Write a program that prints the integers from   1   to   100   (inclusive).



But:

   for multiples of three,   print   Fizz     (instead of the number)
   for multiples of five,   print   Buzz     (instead of the number)
   for multiples of both three and five,   print   FizzBuzz     (instead of the number) 


The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.



Also see

   (a blog)   dont-overthink-fizzbuzz
   (a blog)   fizzbuzz-the-programmers-stairway-to-heaven

",Python,"def fizzBuzz():
    for number in range(1, 101):
        if number % 15 == 0:
            print(""FizzBuzz"")
        elif number % 3 == 0:
            print(""Fizz"")
        elif number % 5 == 0:
            print(""Buzz"")
        else:
            print(number)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Test_integerness,Test integerness,"Mathematically,

 the integers Z are included in the rational numbers Q,
 which are included in the real numbers R,
 which can be generalized to the complex numbers C.


This means that each of those larger sets, and the data types used to represent them, include some integers.

Task[edit]
Given a rational, real, or complex number of any type, test whether it is mathematically an integer.

Your code should handle all numeric data types commonly used in your programming language.

Discuss any limitations of your code.

Definition
For the purposes of this task, integerness means that a number could theoretically be represented as an integer at no loss of precision (given an infinitely wide integer type).

In other words:



 Set

 Common representation

 C++ type

 Considered an integer...


 rational numbers Q

 fraction

 std::ratio

 ...if its denominator is 1 (in reduced form)


 real numbers Z
(approximated)

 fixed-point



 ...if it has no non-zero digits after the decimal point


 floating-point

 float, double

 ...if the number of significant decimal places of its mantissa isn't greater than its exponent


 complex numbers C

 pair of real numbers

 std::complex

 ...if its real part is considered an integer and its imaginary part is zero

Extra credit
Optionally, make your code accept a tolerance parameter for fuzzy testing. The tolerance is the maximum amount by which the number may differ from the nearest integer, to still be considered an integer.

This is useful in practice, because when dealing with approximate numeric types (such as floating point), there may already be round-off errors from previous calculations. For example, a float value of 0.9999999998 might actually be intended to represent the integer 1.

Test cases


 Input

 Output

 Comment


 Type

 Value

 exact

 tolerance = 0.00001


 decimal

 25.000000

 true




 24.999999

 false

 true




 25.000100

 false




 floating-point

 -2.1e120

 true

 This one is tricky, because in most languages it is too large to fit into a native integer type.
It is, nonetheless, mathematically an integer, and your code should identify it as such.


 -5e-2

 false




 NaN

 false




 Inf

 false

 This one is debatable. If your code considers it an integer, that's okay too.


 complex

 5.0+0.0i

 true




 5-5i

 false



(The types and notations shown in these tables are merely examples – you should use the native data types and number literals of your programming language and standard library. Use a different set of test-cases, if this one doesn't demonstrate all relevant behavior.)

",Python,"import math
import sys

def Main():
    print("" ***************************************************"")
    print("" *                                                 *"")
    print("" *              Integerness test                   *"")
    print("" *                                                 *"")
    print("" ***************************************************"")
    print()
    key = ConsoleKeyInfo('Y',ConsoleKey.Y,True,True,True)
    while key.Key == ConsoleKey.Y:
        # Get number value from keyboard
        print("" Enter number value : "", end="""")
        LINE = input()
        # Get tolerance value from keyboard
        print("" Enter tolerance value : "", end="""")
        TOLERANCE = float(input())
        # Resolve entered number format and set NUMBER value
        NUMBER = 0
        N = []
        # Real number value
        if not float.TryParse(LINE, NUMBER):
            # Rational number value
            if LINE.Contains(""/""):
                N = LINE.Split('/')
                NUMBER = float(N[0]) / float(N[1])
            # Inf value
            elif LINE.ToUpper().Contains(""INF""):
                NUMBER = float.PositiveInfinity
            # Complex value
            elif LINE.ToUpper().Contains(""I""):
                # Delete letter i
                LINE = LINE.ToUpper().Replace(""I"","""")
                r = """" # real part
                i = """" # imaginary part
                s = 1 # sign offset
                # Get sign
                if LINE[0] == '+' or LINE[0] == '-':
                    r += LINE[0].ToString()
                    LINE = LINE.Remove(0,1)
                    s -= 1
                # Get real part
                for element in LINE:
                    if element!= '+' and element!= '-':
                        r += element.ToString()
                    else:
                        break
                # get imaginary part
                i = LINE.Substring(LINE.Length-(r.Length+s))
                NUMBER = float(i)
                if NUMBER == 0:
                    NUMBER = float(r)
                else:
                    NUMBER = float.NaN
            # NaN value
            else:
                NUMBER = float.NaN
        # Test
        IS_INTEGER = False
        IS_INTEGER_T = False
        if float.IsNaN(NUMBER):
            IS_INTEGER = False
        elif math.Round(NUMBER,0).ToString() == NUMBER.ToString():
            IS_INTEGER = True
        elif (decimal)TOLERANCE >= (decimal)Math.Abs( (decimal)math.Round(NUMBER,0) - (decimal)NUMBER ):
            IS_INTEGER_T = True
        if IS_INTEGER:
            print("" Is exact integer "" + IS_INTEGER)
        else:
            print("" Is exact integer "" + IS_INTEGER)
            print("" Is integer with tolerance "" + IS_INTEGER_T)
        print()
        print("" Another test < Y /N >... "", end="""")
        key = Console.ReadKey(True)
        print()
        print()

if __name__ == '__main__':
    Main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/String_comparison,String comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Demonstrate how to compare two strings from within the language and how to achieve a lexical comparison.



The task should demonstrate:

 Comparing two strings for exact equality
 Comparing two strings for inequality (i.e., the inverse of exact equality)
 Comparing two strings to see if one is lexically ordered before than the other
 Comparing two strings to see if one is lexically ordered after than the other
 How to achieve both case sensitive comparisons and case insensitive comparisons within the language
 How the language handles comparison of numeric strings if these are not treated lexically
 Demonstrate any other kinds of string comparisons that the language provides, particularly as it relates to your type system. 


For example, you might demonstrate the difference between generic/polymorphic comparison and coercive/allomorphic comparison if your language supports such a distinction.



Here ""generic/polymorphic"" comparison means that the function or operator you're using doesn't always do string comparison, but bends the actual semantics of the comparison depending on the types one or both arguments; with such an operator, you achieve string comparison only if the arguments are sufficiently string-like in type or appearance.

In contrast, a ""coercive/allomorphic"" comparison function or operator has fixed string-comparison semantics regardless of the argument type;   instead of the operator bending, it's the arguments that are forced to bend instead and behave like strings if they can,   and the operator simply fails if the arguments cannot be viewed somehow as strings.   A language may have one or both of these kinds of operators;   see the Raku entry for an example of a language with both kinds of operators.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
import string
 
def demo_compare(a, b, semantically):
    print(a, ""and"", b, ""are"", (""not"", """")[a == b], ""exactly"", semantically, ""equal."")
    print(a, ""and"", b, ""are"", (""not"", """")[a!= b], semantically, ""inequal."")
    print(a, ""is"", (""not"", """")[a < b], semantically, ""ordered before"", b, ""."")
    print(a, ""is"", (""not"", """")[a > b], semantically, ""ordered after"", b, ""."")
 
if __name__ == ""__main__"":
    # Case-sensitive comparisons.
    a = sys.argv[1] if len(sys.argv) > 1 else ""1.2.Foo""
    b = sys.argv[2] if len(sys.argv) > 2 else ""1.3.Bar""
    demo_compare(a, b, ""lexically"")
 
    # Case-insensitive comparisons by folding both strings to a common case.
    a = a.lower()
    b = b.lower()
    demo_compare(a, b, ""lexically"")
 
    # Numeric comparisons; here 'double' could be any type for which the
    # relevant >> operator is defined, eg int, long, etc.
    numA = float(a)
    numB = float(b)
    demo_compare(numA, numB, ""numerically"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Loops/Infinite,Loops/Infinite,"Task

Print out        SPAM        followed by a   newline   in an infinite loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"while 1:
   print ""SPAM""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Successive_prime_differences,Successive prime differences,"The series of increasing prime numbers begins: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

The task applies a filter to the series returning groups of successive primes, (s'primes), that differ from the next by a given value or values.

Example 1: Specifying that the difference between s'primes be 2 leads to the groups:

(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), ...

(Known as Twin primes or Prime pairs)

Example 2: Specifying more than one difference between s'primes leads to groups of size one greater than the number of differences. Differences of 2, 4 leads to the groups:

(5, 7, 11), (11, 13, 17), (17, 19, 23), (41, 43, 47), .... 

In the first group 7 is two more than 5 and 11 is four more than 7; as well as 5, 7, and 11 being successive primes.
Differences are checked in the order of the values given, (differences of 4, 2 would give different groups entirely).

Task

 In each case use a list of primes less than 1_000_000
 For the following Differences show the first and last group, as well as the number of groups found:
 Differences of 2.
 Differences of 1.
 Differences of 2, 2.
 Differences of 2, 4.
 Differences of 4, 2.
 Differences of 6, 4, 2.
 Show output here.

Note: Generation of a list of primes is a secondary aspect of the task. Use of a built in function, well known library, or importing/use of prime generators from other Rosetta Code tasks is encouraged.

references
https://pdfs.semanticscholar.org/78a1/7349819304863ae061df88dbcb26b4908f03.pdf
https://www.primepuzzles.net/puzzles/puzz_011.htm
https://matheplanet.de/matheplanet/nuke/html/viewtopic.php?topic=232720&start=0",Python,"# https://docs.sympy.org/latest/index.html
from sympy import Sieve
 
def nsuccprimes(count, mx):
    ""return tuple of <count> successive primes <= mx (generator)""
    sieve = Sieve()
    sieve.extend(mx)
    primes = sieve._list
    return zip(*(primes[n:] for n in range(count)))
 
def check_value_diffs(diffs, values):
    ""Differences between successive values given by successive items in diffs?""
    return all(v[1] - v[0] == d 
               for d, v in zip(diffs, zip(values, values[1:])))
 
def successive_primes(offsets=(2, ), primes_max=1_000_000):
    return (sp for sp in nsuccprimes(len(offsets) + 1, primes_max) 
            if check_value_diffs(offsets, sp))
 
if __name__ == '__main__':
    for offsets, mx in [((2,),      1_000_000), 
                        ((1,),      1_000_000),
                        ((2, 2),    1_000_000),
                        ((2, 4),    1_000_000),
                        ((4, 2),    1_000_000),
                        ((6, 4, 2), 1_000_000),
                       ]:
        print(f""## SETS OF {len(offsets)+1} SUCCESSIVE PRIMES <={mx:_} WITH ""
              f""SUCCESSIVE DIFFERENCES OF {str(list(offsets))[1:-1]}"")
        for count, last in enumerate(successive_primes(offsets, mx), 1):
            if count == 1:
                first = last
        print(""  First group:"", str(first)[1:-1])
        print(""   Last group:"", str(last)[1:-1])
        print(""        Count:"", count)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",Python,"import calendar
calendar.isleap(year)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Amicable_pairs,Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",Python,"from proper_divisors import proper_divs
 
def amicable(rangemax=20000):
    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}
    for num, divsum in n2divsum.items():
        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:
            yield num, divsum
 
if __name__ == '__main__':
    for num, divsum in amicable():
        print('Amicable pair: %i and %i With proper divisors:\n    %r\n    %r'
              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Summarize_and_say_sequence,Summarize and say sequence,"There are several ways to generate a self-referential sequence. One very common one (the Look-and-say sequence) is to start with a positive integer, then generate the next term by concatenating enumerated groups of adjacent alike digits:

       0, 10, 1110, 3110, 132110, 1113122110, 311311222110 ...

The terms generated grow in length geometrically and never converge.

Another way to generate a self-referential sequence is to summarize the previous term.

Count how many of each alike digit there is, then concatenate the sum and digit for each of the sorted enumerated digits. Note that the first five terms are the same as for the previous sequence.

       0, 10, 1110, 3110, 132110, 13123110, 23124110 ... 

Sort the digits largest to smallest. Do not include counts of digits that do not appear in the previous term.

Depending on the seed value, series generated this way always either converge to a stable value or to a short cyclical pattern. (For our purposes, I'll use converge to mean an element matches a previously seen element.) The sequence shown, with a seed value of 0, converges to a stable value of 1433223110 after 11 iterations. The seed value that converges most quickly is 22. It goes stable after the first element. (The next element is 22, which has been seen before.)



Task

Find all the positive integer seed values under 1000000, for the above convergent self-referential sequence, that takes the largest number of iterations before converging. Then print out the number of iterations and the sequence they return. Note that different permutations of the digits of the seed will yield the same sequence. For this task, assume leading zeros are not permitted.

Seed Value(s): 9009 9090 9900

Iterations: 21 

Sequence: (same for all three seeds except for first element)
9009
2920
192210
19222110
19323110
1923123110
1923224110
191413323110
191433125110
19151423125110
19251413226110
1916151413325110
1916251423127110
191716151413326110
191726151423128110
19181716151413327110
19182716151423129110
29181716151413328110
19281716151423228110
19281716151413427110
19182716152413228110

Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Spelling of ordinal numbers



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Also see

   The On-Line Encyclopedia of Integer Sequences.

",Python,"cache = {}
def selfReferentialSequence_cached(n, seen = []):
    if n in cache:
        return cache[n]
    if n in seen:
        return []
 
    digit_count = [0] * 10
    for char in str(n):
        digit_count[int(char)] += 1
    term = ''
    for d in range(9, -1, -1):
        if digit_count[d] > 0:
            term += str(digit_count[d]) + str(d)
    term = int(term)
    cache[n] = [n] + selfReferentialSequence_cached(term, [n] + seen)
    return cache[n]
 
limit = 1_000_000
max_len = 0
max_vals = []
 
for n in range(1, limit):
    seq = selfReferentialSequence_cached(n)
    if len(seq) > max_len:
        max_len = len(seq)
        max_vals = [n]
    elif len(seq) == max_len:
        max_vals.append(n)
 
print(""values: {}"".format(max_vals))
print(""iterations: {}"".format(max_len))
print(""sequence:"")
for idx, val in enumerate(selfReferentialSequence_cached(max_vals[0])):
    print(""%2d %d"" % (idx + 1, val))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Python,"# version 1.1.3
 
from itertools import permutations
 
def dinesman(occupants, predicates):
    return [perm for perm in permutations(occupants) if all(pred(perm) for pred in predicates)]
 
occupants = [""Baker"", ""Cooper"", ""Fletcher"", ""Miller"", ""Smith""]
 
predicates = [
    lambda perm: perm[-1]!= ""Baker"",
    lambda perm: perm[0]!= ""Cooper"",
    lambda perm: perm[-1]!= ""Fletcher"" and perm[0]!= ""Fletcher"",
    lambda perm: perm.index(""Miller"") > perm.index(""Cooper""),
    lambda perm: abs(perm.index(""Smith"") - perm.index(""Fletcher"")) > 1,
    lambda perm: abs(perm.index(""Fletcher"") - perm.index(""Cooper"")) > 1
]
 
solutions = dinesman(occupants, predicates)
size = len(solutions)
if size == 0:
    print(""No solutions found"")
else:
    plural = """" if size == 1 else ""s""
    print(f""{size} solution{plural} found, namely:\n"")
    for solution in solutions:
        for i, name in enumerate(solution):
            print(f""Floor {i + 1} -> {name}"")
        print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Least_common_multiple,Least common multiple,"Least common multiple

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Compute the   least common multiple   (LCM)   of two integers.

Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.



Example

The least common multiple of   12   and   18   is   36,       because:

   12   is a factor     (12 × 3 = 36),     and 
   18   is a factor     (18 × 2 = 36),     and 
   there is no positive integer less than   36   that has both factors. 


As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.



One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.

If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.



 



lcm
⁡
(
m
,
n
)
=




|

m
×
n

|



gcd
⁡
(
m
,
n
)





{\displaystyle \operatorname {lcm} (m,n)={\frac {|m\times n|}{\operatorname {gcd} (m,n)}}}




One can also find   lcm   by merging the prime decompositions of both   m   and   n.



Related task
   greatest common divisor.


See also

   MathWorld entry:   Least Common Multiple.
   Wikipedia entry:   Least common multiple.

",Python,">>> import fractions
>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0
 
>>> lcm(12, 18)
36
>>> lcm(-6, 14)
42
>>> assert lcm(0, 2) == lcm(2, 0) == 0
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",Python,"# version 1.0.6
 
# 'progname.kt' packaged as 'progname.jar'
 
import sys
 
def main(args):
    print(sys.argv[0])
    print(sys.version)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Abelian_sandpile_model/Identity,Abelian sandpile model/Identity,"Our sandpiles are based on a 3 by 3 rectangular grid giving nine areas that
contain a number from 0 to 3 inclusive. (The numbers are said to represent
grains of sand in each area of the sandpile).

E.g. s1 =

    
    1 2 0
    2 1 1
    0 1 3

and s2 =

    2 1 3
    1 0 1
    0 1 0

Addition on sandpiles is done by adding numbers in corresponding grid areas,
so for the above:

              1 2 0     2 1 3     3 3 3
    s1 + s2 = 2 1 1  +  1 0 1  =  3 1 2
              0 1 3     0 1 0     0 2 3

If the addition would result in more than 3 ""grains of sand"" in any area then
those areas cause the whole sandpile to become ""unstable"" and the sandpile
areas are ""toppled"" in an ""avalanche"" until the ""stable"" result is obtained.

Any unstable area (with a number >= 4), is ""toppled"" by loosing one grain of
sand to each of its four horizontal or vertical neighbours. Grains are lost
at the edge of the grid, but otherwise increase the number in neighbouring
cells by one, whilst decreasing the count in the toppled cell by four in each
toppling.

A toppling may give an adjacent area more than four grains of sand leading to
a chain of topplings called an ""avalanche"".
E.g.

    
    4 3 3     0 4 3     1 0 4     1 1 0     2 1 0
    3 1 2 ==> 4 1 2 ==> 4 2 2 ==> 4 2 3 ==> 0 3 3
    0 2 3     0 2 3     0 2 3     0 2 3     1 2 3

The final result is the stable sandpile on the right.

Note: The order in which cells are toppled does not affect the final result.

Task

 Create a class or datastructure and functions to represent and operate on sandpiles. 
 Confirm the result of the avalanche of topplings shown above
 Confirm that s1 + s2 == s2 + s1 # Show the stable results
 If s3 is the sandpile with number 3 in every grid area, and s3_id is the following sandpile:
    2 1 2  
    1 0 1  
    2 1 2

 Show that s3 + s3_id == s3
 Show that s3_id + s3_id == s3_id


Show confirming output here, with your examples.



References

 https://www.youtube.com/watch?v=1MtEUErz7Gg
 https://en.wikipedia.org/wiki/Abelian_sandpile_model

",Python,"class Sandpile:
 
    def __init__(self, ar):
        self.grid = ar
 
    def to_a(self):
        return self.grid.copy()
 
    def __add__(self, other):
        res = [ [row1[i] + row2[i] for i in range(len(row1))] for row1, row2 in zip(self.to_a(), other.to_a()) ]
        return Sandpile(res)
 
    def stable(self):
        return all(v <= 3 for v in self.flatten())
 
    def avalanche(self):
        while not self.stable():
            self.topple()
        return self
 
    def __eq__(self, other):
        return self.avalanche().to_a() == other.avalanche().to_a()
 
    def topple(self):
        a = self.to_a()
        for row in range(len(a)):
            for col in range(len(a[row])):
                if a[row][col] < 4:
                    continue
                a[row+1][col] += 1 if row < len(a)-1 else 0
                a[row-1][col] += 1 if row > 0 else 0
                a[row][col+1] += 1 if col < len(a[row])-1 else 0
                a[row][col-1] += 1 if col > 0 else 0
                a[row][col]   -= 4
        return self
 
    def __str__(self):
        return ""\n"" + ""\n"".join(["" "".join([str(v) for v in row]) for row in self.to_a()])
 
print(""Sandpile:"")
print(demo = Sandpile([[4,3,3], [3,1,2],[0,2,3]]))
print(""\nAfter the avalanche:"")
print(demo.avalanche())
print(""_"" * 30)
 
s1 = Sandpile([[1, 2, 0], [2, 1, 1], [0, 1, 3]])
print(""s1: {}"".format(s1))
s2 = Sandpile([[2, 1, 3], [1, 0, 1], [0, 1, 0]])
print(""\ns2: {}"".format(s2))
print(""\ns1 + s2 == s2 + s1: {}"".format(s1 + s2 == s2 + s1))
print(""_"" * 30)
 
s3    = Sandpile([[3, 3, 3], [3, 3, 3], [3, 3, 3]])
s3_id = Sandpile([[2, 1, 2], [1, 0, 1], [2, 1, 2]])
print(""s3 + s3_id == s3: {}"".format(s3 + s3_id == s3))
print(""s3_id + s3_id == s3_id: {}"".format(s3_id + s3_id == s3_id))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort,Sorting algorithms/Cocktail sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The cocktail shaker sort is an improvement on the Bubble Sort.

The improvement is basically that values ""bubble"" both directions through the array, because on each iteration the cocktail shaker sort bubble sorts once forwards and once backwards. Pseudocode for the algorithm (from wikipedia):

function cocktailSort( A : list of sortable items )
 do
   swapped := false
   for each i in 0 to length( A ) - 2 do
     if A[ i ] > A[ i+1 ] then // test whether the two 
                               // elements are in the wrong 
                               // order
       swap( A[ i ], A[ i+1 ] ) // let the two elements
                                // change places
       swapped := true;
   if swapped = false then
     // we can exit the outer loop here if no swaps occurred.
     break do-while loop;
   swapped := false
   for each i in length( A ) - 2 down to 0 do
     if A[ i ] > A[ i+1 ] then
       swap( A[ i ], A[ i+1 ] )
       swapped := true;
 while swapped; // if no elements have been swapped, 
                // then the list is sorted

Related task

   cocktail sort with shifting bounds

",Python,"a = [170, 45, 75, -90, -802, 24, 2, 66]
print(""before:"", a)
cocktailSort(a)
print(""after: "", a)
 
def cocktailSort(a):
    last = len(a) - 1
    while True:
        swapped = False
        for i in range(0, last):
            if a[i] > a[i+1]:
                a[i], a[i+1] = a[i+1], a[i]
                swapped = True
        if not swapped:
            return
        swapped = False
        for i in range(last - 1, -1, -1):
            if a[i] > a[i+1]:
                a[i], a[i+1] = a[i+1], a[i]
                swapped = True
        if not swapped:
            return",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Doubly-linked_list/Definition,Doubly-linked list/Definition,"Define the data structure for a complete Doubly Linked List.

 The structure should support adding elements to the head, tail and middle of the list. 
 The structure should not allow circular loops


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"def show(node):
    if node is None:
        return
    print(node.data)
    show(node.next)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Conway%27s_Game_of_Life,Conway's Game of Life,"The Game of Life is a   cellular automaton   devised by the British mathematician   John Horton Conway   in 1970.   It is the best-known example of a cellular automaton.

Conway's game of life is described   here:

A cell   C   is represented by a   1   when alive,   or   0   when dead,   in an   m-by-m   (or m×m)   square array of cells.

We calculate   N   - the sum of live cells in C's   eight-location neighbourhood,   then cell   C   is alive or dead in the next generation based on the following table:

   C   N                 new C
   1   0,1             ->  0  # Lonely
   1   4,5,6,7,8       ->  0  # Overcrowded
   1   2,3             ->  1  # Lives
   0   3               ->  1  # It takes three to give birth!
   0   0,1,2,4,5,6,7,8 ->  0  # Barren

Assume cells beyond the boundary are always dead.

The ""game"" is actually a zero-player game, meaning that its evolution is determined by its initial state, needing no input from human players.   One interacts with the Game of Life by creating an initial configuration and observing how it evolves.



Task

Although you should test your implementation on more complex examples such as the   glider   in a larger universe,   show the action of the blinker   (three adjoining cells in a row all alive),   over three generations, in a 3 by 3 grid.



References

   Its creator John Conway, explains   the game of life.   Video from numberphile on youtube.
   John Conway   Inventing Game of Life   - Numberphile video.


Related task

   Langton's ant   - another well known cellular automaton.

",Python,"import random
 
def game_of_life(name, size, generations, initial_life=None):
  board = new_board(size)
  seed(board, size, initial_life)
  print_board(board, name, 0)
  reason = [None]
  for gen in range(generations):
    new = evolve(board, size)
    print_board(new, name, gen+1)
    if barren(new, size):
      reason[0] = ""all_dead""
      break
    if board == new:
      reason[0] = ""static""
      break
    board = new
  if reason[0] == ""all_dead"":
    print(""no more life."")
  elif reason[0] == ""static"":
    print(""no movement"")
  else:
    print(""specified lifetime ended"")
  print
 
def new_board(n):
  return [[0 for i in range(n)] for j in range(n)]
 
def seed(board, n, points=None):
  if points == None:
    # randomly seed board
    indices = []
    for i in range(n):
      for j in range(n):
        indices.append([i,j])
    random.shuffle(indices)
    for i,j in indices[0:10]:
      board[j][i] = 1
  else:
    for i,j in points:
      board[j][i] = 1
 
def evolve(board, n):
  new = new_board(n)
  for i in range(n):
    for j in range(n):
      new[i][j] = fate(board, i, j, n)
  return new
 
def fate(board, i, j, n):
  i1 = max(0, i-1); i2 = min(i+1, n-1)
  j1 = max(0, j-1); j2 = min(j+1, n-1)
  sum = 0
  for ii in range(i1, i2+1):
    for jj in range(j1, j2+1):
      if not (ii == i and jj == j):
        sum += board[ii][jj]
  return 1 if sum == 3 or (sum == 2 and board[i][j] == 1) else 0
 
def barren(board, n):
  for i in range(n):
    for j in range(n):
      if board[i][j] == 1:
        return False
  return True
 
def print_board(m, name, generation):
  print(""{}: generation {}"".format(name, generation))
  for row in m:
    for val in row:
      print(""#"" if val == 1 else ""."", end="" "")
    print()
 
game_of_life(""blinker"", 3, 2, [[1,0],[1,1],[1,2]])
game_of_life(""glider"", 4, 4, [[1,0],[2,1],[0,2],[1,2],[2,2]])
game_of_life(""random"", 5, 10)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Pseudo-random_numbers/PCG32,Pseudo-random numbers/PCG32,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
| Bitwise or operator
https://en.wikipedia.org/wiki/Bitwise_operation#OR
Bitwise comparison gives 1 if any of corresponding bits are 1
E.g Binary 00110101 | Binary 00110011 == Binary 00110111


PCG32 Generator (pseudo-code)

PCG32 has two unsigned 64-bit integers of internal state:

 state: All 2**64 values may be attained.
 sequence: Determines which of 2**63 sequences that state iterates through. (Once set together with state at time of seeding will stay constant for this generators lifetime).
Values of sequence allow 2**63 different sequences of random numbers from the same state.

The algorithm is given 2 U64 inputs called seed_state, and seed_sequence. The algorithm proceeds in accordance with the following pseudocode:-

const N<-U64 6364136223846793005
const inc<-U64 (seed_sequence << 1) | 1
state<-U64 ((inc+seed_state)*N+inc
do forever
  xs<-U32 (((state>>18)^state)>>27)
  rot<-INT (state>>59)
  OUTPUT U32 (xs>>rot)|(xs<<((-rot)&31))
  state<-state*N+inc
end do

Note that this an anamorphism – dual to catamorphism, and encoded in some languages as a general higher-order `unfold` function, dual to `fold` or `reduce`.

Task

 Generate a class/set of functions that generates pseudo-random
numbers using the above.

 Show that the first five integers generated with the seed 42, 54
are: 2707161783 2068313097 3122475824 2211639955 3215226955



 Show that for an initial seed of 987654321, 1 the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20049, 1: 20022, 2: 20115, 3: 19809, 4: 20005

 Show your output here, on this page.

",Python,"mask64 = (1 << 64) - 1
mask32 = (1 << 32) - 1
CONST = 6364136223846793005
 
 
class PCG32():
 
    def __init__(self, seed_state=None, seed_sequence=None):
        if all(type(x) == int for x in (seed_state, seed_sequence)):
            self.seed(seed_state, seed_sequence)
        else:
            self.state = self.inc = 0
 
    def seed(self, seed_state, seed_sequence):
        self.state = 0
        self.inc = ((seed_sequence << 1) | 1) & mask64
        self.next_int()
        self.state = (self.state + seed_state)
        self.next_int()
 
    def next_int(self):
        ""return random 32 bit unsigned int""
        old = self.state
        self.state = ((old * CONST) + self.inc) & mask64
        xorshifted = (((old >> 18) ^ old) >> 27) & mask32
        rot = (old >> 59) & mask32
        answer = (xorshifted >> rot) | (xorshifted << ((-rot) & 31))
        answer = answer &mask32
 
        return answer
 
    def  next_float(self):
        ""return random float between 0 and 1""
        return self.next_int() / (1 << 32)
 
 
if __name__ == '__main__':
    random_gen = PCG32()
    random_gen.seed(42, 54)
    for i in range(5):
        print(random_gen.next_int())
 
    random_gen.seed(987654321, 1)
    hist = {i:0 for i in range(5)}
    for i in range(100_000):
        hist[int(random_gen.next_float() *5)] += 1
    print(hist)",Human_written,Python_from_C
http://rosettacode.org/wiki/Atomic_updates,Atomic updates,"

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

 get the current value of any bucket
 remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

 As often as possible, pick two buckets and make their values closer to equal.
 As often as possible, pick two buckets and arbitrarily redistribute their values.
 At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.


The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.


This task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.



",Python,"import threading
import random
 
# A collection of buckets, filled with random non-negative integers.
# There are atomic operations to look at the bucket contents, and
# to move amounts between buckets.
class BucketStore:
 
    # Creates a BucketStore with +nbuckets+ buckets. Fills each bucket
    # with a random non-negative integer.
    def __init__(self, nbuckets):
        # Create an array for the buckets
        self.buckets = [random.randint(0, 1024) for i in range(nbuckets)]
 
        # Mutex used to make operations atomic
        self.mutex = threading.Lock()
 
    # Returns an array with the contents of all buckets.
    def buckets(self):
        self.mutex.acquire()
        try:
            return list(self.buckets)
        finally:
            self.mutex.release()
 
    # Transfers _amount_ to bucket at array index _destination_,
    # from bucket at array index _source_.
    def transfer(self, destination, source, amount):
        # Do nothing if both buckets are same
        if destination == source:
            return None
 
        self.mutex.acquire()
        try:
            # Clamp amount to prevent negative value in bucket
            amount = min(amount, self.buckets[source])
 
            self.buckets[source] -= amount
            self.buckets[destination] += amount
        finally:
            self.mutex.release()
        return None
 
# Create bucket store
bucket_store = BucketStore(8)
 
# Get total amount in the store
TOTAL = sum(bucket_store.buckets())
 
# Start a thread to equalize buckets
def equalize():
    while True:
        # Pick 2 buckets
        buckets = bucket_store.buckets()
        first = random.randint(0, len(buckets) - 1)
        second = random.randint(0, len(buckets) - 1)
 
        # Swap buckets so that _first_ has not more than _second_
        if buckets[first] > buckets[second]:
            first, second = second, first
 
        # Transfer half of the difference, rounded down
        bucket_store.transfer(first, second, (buckets[second] - buckets[first]) / 2)
 
t = threading.Thread(target=equalize)
t.start()
 
# Start a thread to distribute values among buckets
def distribute():
    while True:
        # Pick 2 buckets
        buckets = bucket_store.buckets()
        first = random.randint(0, len(buckets) - 1)
        second = random.randint(0, len(buckets) - 1)
 
        # Transfer random amount to _first_ from _second_
        bucket_store.transfer(first, second, random.randint(0, buckets[second]))
 
t = threading.Thread(target=distribute)
t.start()
 
# Loop to display buckets
while True:
    import time
    time.sleep(1)
 
    buckets = bucket_store.buckets()
 
    # Compute the total value in all buckets.
    # We calculate this outside BucketStore so BucketStore can't cheat by
    # always reporting the same value.
    n = sum(buckets)
 
    # Display buckets and total
    print ""%s, total %d"" % ("" "".join([str(v).rjust(4) for v in buckets]), n)
 
    if n != TOTAL:
        # This should never happen
        print ""ERROR: Total changed from %d to %d"" % (TOTAL, n)
        exit(1)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Greatest_element_of_a_list,Greatest element of a list,"Task

Create a function that returns the maximum value in a provided set of values,

where the number of values may not be known until run-time.



",Python,max(values),Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Classes,Classes,"In object-oriented programming class is a set (a transitive closure) of types bound by the relation of inheritance. It is said that all types derived from some base type T and the type T itself form a class T.

The first type T from the class T sometimes is called the root type of the class.

A class of types itself, as a type, has the values and operations of its own.
The operations of are usually called methods of the root type.
Both operations and values are called  polymorphic.

A polymorphic operation (method) selects an implementation depending on the actual specific type of the polymorphic argument.

The action of choice the type-specific implementation of a polymorphic operation is called dispatch. Correspondingly, polymorphic operations are often called dispatching or virtual.
Operations with multiple arguments and/or the results of the class are called multi-methods.
A further generalization of is the operation with arguments and/or results from different classes.

 single-dispatch languages are those that allow only one argument or result to control the dispatch. Usually it is the first parameter, often hidden, so that a prefix notation x.f() is used instead of mathematical f(x).
 multiple-dispatch languages allow many arguments and/or results to control the dispatch.


A polymorphic value has a type tag indicating its specific type from the class and the corresponding specific value of that type.
This type is sometimes called the most specific type of a [polymorphic] value.
The type tag of the value is used in order to resolve the dispatch.
The set of polymorphic values of a class is a transitive closure of the sets of values of all types from that class.

In many  OO languages
the type of the class of T and T itself are considered equivalent.
In some languages they are distinct (like in Ada).
When class T and T are equivalent, there is no way to distinguish
polymorphic and specific values.



Task

Create a basic class with a method, a constructor, an instance variable and how to instantiate it.



",Python,"class MyClass:
    name2 = 2 # Class attribute
 
    def __init__(self):
        """"""
        Constructor  (Technically an initializer rather than a true ""constructor"")
        """"""
        self.name1 = 0 # Instance attribute
 
    def someMethod(self):
        """"""
        Method
        """"""
        self.name1 = 1
        MyClass.name2 = 3
 
 
myclass = MyClass() # class name, invoked as a function is the constructor syntax.
 
class MyOtherClass:
    count = 0  # Population of ""MyOtherClass"" objects
    def __init__(self, name, gender=""Male"", age=None):
        """"""
        One initializer required, others are optional (with different defaults)
        """"""
        MyOtherClass.count += 1
        self.name = name
        self.gender = gender
        if age is not None:
            self.age = age
    def __del__(self):
        MyOtherClass.count -= 1
 
person1 = MyOtherClass(""John"")
print person1.name, person1.gender  # ""John Male""
print person1.age                   # Raises AttributeError exception!
person2 = MyOtherClass(""Jane"", ""Female"", 23)
print person2.name, person2.gender, person2.age  # ""Jane Female 23""",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"import os
os.environ[""HOME""]
os.environ",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sum_multiples_of_3_and_5,Sum multiples of 3 and 5,"Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

This is is the same as Project Euler problem 1.

Extra credit: do this efficiently for n = 1e20 or higher.



",Python,"class SumMultiples:
	def getSum(n):
		sum = 0
		for i in range(3, n):
			if i % 3 == 0 or i % 5 == 0: sum += i
		return sum
	def main(args):
		print(getSum(1000))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping,Sutherland-Hodgman polygon clipping,"The   Sutherland-Hodgman clipping algorithm   finds the polygon that is the intersection between an arbitrary polygon (the “subject polygon”) and a convex polygon (the “clip polygon”).

It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.



Task

Take the closed polygon defined by the points:

 



[
(
50
,
150
)
,
(
200
,
50
)
,
(
350
,
150
)
,
(
350
,
300
)
,
(
250
,
300
)
,
(
200
,
250
)
,
(
150
,
350
)
,
(
100
,
250
)
,
(
100
,
200
)
]


{\displaystyle [(50,150),(200,50),(350,150),(350,300),(250,300),(200,250),(150,350),(100,250),(100,200)]}


and clip it by the rectangle defined by the points:

 



[
(
100
,
100
)
,
(
300
,
100
)
,
(
300
,
300
)
,
(
100
,
300
)
]


{\displaystyle [(100,100),(300,100),(300,300),(100,300)]}


Print the sequence of points that define the resulting clipped polygon.



Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon.

(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)



",Python,"def clip(subjectPolygon, clipPolygon):
   def inside(p):
      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])
 
   def computeIntersection():
      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]
      dp = [ s[0] - e[0], s[1] - e[1] ]
      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
      n2 = s[0] * e[1] - s[1] * e[0] 
      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]
 
   outputList = subjectPolygon
   cp1 = clipPolygon[-1]
 
   for clipVertex in clipPolygon:
      cp2 = clipVertex
      inputList = outputList
      outputList = []
      s = inputList[-1]
 
      for subjectVertex in inputList:
         e = subjectVertex
         if inside(e):
            if not inside(s):
               outputList.append(computeIntersection())
            outputList.append(e)
         elif inside(s):
            outputList.append(computeIntersection())
         s = e
      cp1 = cp2
   return(outputList)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Polynomial_regression,Polynomial regression,"Find an approximating polynomial of known degree for a given data.

Example:
For input data:

x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};
y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};

The approximating polynomial is:

3 x2 + 2 x + 1

Here, the polynomial's coefficients are (3, 2, 1).

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.
",Python,">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]
>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]
>>> coeffs = numpy.polyfit(x,y,deg=2)
>>> coeffs
array([ 3.,  2.,  1.])",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort,Sorting algorithms/Bead sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of positive integers using the Bead Sort Algorithm.

A   bead sort   is also known as a   gravity sort.



Algorithm has   O(S),   where   S   is the sum of the integers in the input set:   Each bead is moved individually.

This is the case when bead sort is implemented without a mechanism to assist in finding empty spaces below the beads, such as in software implementations.



",Python,"# version 1.1.2
 
def beadSort(a):
    n = len(a)
    if n < 2:
        return
    max = max(a)
    beads = [0] * (max * n)
    # mark the beads
    for i in range(n):
        for j in range(a[i]):
            beads[i * max + j] = 1
 
    for j in range(max):
        # count how many beads are on each post
        sum = 0
        for i in range(n):
            sum += beads[i * max + j]
            beads[i * max + j] = 0
        # mark bottom sum beads
        for i in range(n - sum, n):
            beads[i * max + j] = 1
 
    for i in range(n):
        j = 0
        while j < max and beads[i * max + j] == 1:
            j += 1
        a[i] = j
 
if __name__ == '__main__':
    a = [5, 3, 1, 7, 4, 1, 1, 20]
    print(""Before sorting : {}"".format(a))
    beadSort(a)
    print(""After sorting  : {}"".format(a))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/AKS_test_for_primes,AKS test for primes,"The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

   a number   



p


{\displaystyle p}

   is prime   if and only if   all the coefficients of the polynomial expansion of
 



(
x
−
1

)

p


−
(

x

p


−
1
)


{\displaystyle (x-1)^{p}-(x^{p}-1)}


are divisible by   



p


{\displaystyle p}

.



Example

Using   



p
=
3


{\displaystyle p=3}

:

         (x-1)^3 - (x^3 - 1)
            = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
            = -3x^2 + 3x



And all the coefficients are divisible by 3,   so 3 is prime.





 Note:
This task is not the AKS primality test.   It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.



Task



 Create a function/subroutine/method that given   



p


{\displaystyle p}

   generates the coefficients of the expanded polynomial representation of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

.
 Use the function to show here the polynomial expansions of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

   for   



p


{\displaystyle p}

   in the range   0   to at least   7,   inclusive.
 Use the previous function in creating another function that when given   



p


{\displaystyle p}

   returns whether   



p


{\displaystyle p}

   is prime using the theorem.
 Use your test to generate a list of all primes under   35.
 As a stretch goal,   generate all primes under   50   (needs integers larger than 31-bit).


References

 Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) 
 Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed -- at best it is an oversimplification.

",Python,"def pascal():
    a = []
    def pascal_inner():
        if len(a) == 0:
            a = [1]
        else:
            b = [a[i] + a[i + 1] for i in range(len(a) - 1)]
            a = [1] + b + [1]
        return a
    return pascal_inner
 
def show(a):
    def show_x(e):
        if e == 0:
            return """"
        elif e == 1:
            return ""x""
        else:
            return ""x^"" + str(e)
    degree = len(a) - 1
    str = ""(x - 1)^"" + str(degree) + "" =""
    sgn = 1
    for i in range(len(a)):
        str +='' + (sgn > 0 and ""+"" or ""-"") +'' + str(a[i]) + show_x(degree - i)
        sgn = -sgn
    return str
 
def primerow(row):
    degree = len(row) - 1
    return all(row[i + 1] % degree == 0 for i in range(degree - 1))
 
p = pascal()
 
for i in range(8):
    print show(p())
 
p = pascal()
 
p()
 
p()
 
primes = [i + 1 for i in range(50) if primerow(p())]
 
print """"
 
print ""The primes upto 50 are: "" + str(primes)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/SEDOLs,SEDOLs,"Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.



That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.



Related tasks

   Luhn test
   ISIN

",Python,"def char2value(c):
  assert c not in 'AEIOU', ""No vowels""
  return int(c, 36)
 
sedolweight = [1,3,1,7,3,9]
 
def checksum(sedol):
    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,
                  sedol, sedolweight)
               )
    return str((10 - (tmp % 10)) % 10)
 
for sedol in '''
    710889
    B0YBKJ
    406566
    B0YBLH
    228276
    B0YBKL
    557910
    B0YBKR
    585284
    B0YBKT
    '''.split():
    print sedol + checksum(sedol)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Non-decimal_radices/Convert,Non-decimal radices/Convert,"Number base conversion is when you express a stored integer in an integer base, such as in octal (base 8) or binary (base 2). It also is involved when you take a string representing a number in a given base and convert it to the stored integer form. Normally, a stored integer is in binary, but that's typically invisible to the user, who normally enters or sees stored integers as decimal.



Task

Write a function (or identify the built-in function) which is passed a non-negative integer to convert, and another integer representing the base.

It should return a string containing the digits of the resulting number, without leading zeros except for the number   0   itself.

For the digits beyond 9, one should use the lowercase English alphabet, where the digit   a = 9+1,   b = a+1,   etc.

For example:   the decimal number   26   expressed in base   16   would be   1a.

Write a second function which is passed a string and an integer base, and it returns an integer representing that string interpreted in that base.

The programs may be limited by the word size or other such constraint of a given language. There is no need to do error checking for negatives, bases less than 2, or inappropriate digits.



",Python,"i = int('1a',16)  # returns the integer 26",Human_written,Python_from_C
http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",Python,"from ctypes import *
libm = CDLL(""libm.so.6"")
libm.inf.restype = c_double
libm.inf.argtypes = []
print libm.inf()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Wireworld,Wireworld,"Wireworld
Conway's Game of Life
It is capable of doing sophisticated computations with appropriate programs
(it is actually Turing complete),
and is much simpler to program for.

A Wireworld arena consists of a Cartesian grid of cells,
each of which can be in one of four states.
All cell transitions happen simultaneously.

The cell transition rules are this:



 Input State

 Output State

 Condition


 empty

 empty




 electron head 

 electron tail 




 electron tail 

 conductor




 conductor

 electron head 

 if 1 or 2 cells in the neighborhood of the cell are in the state “electron head”


 conductor

 conductor

 otherwise



Task

Create a program that reads a Wireworld program from a file and displays an animation of the processing. Here is a sample description file (using ""H"" for an electron head, ""t"" for a tail, ""."" for a conductor and a space for empty) you may wish to test with, which demonstrates two cycle-3 generators and an inhibit gate:

tH.........
.   .
   ...
.   .
Ht.. ......

While text-only implementations of this task are possible, mapping cells to pixels is advisable if you wish to be able to display large designs. The logic is not significantly more complex.



",Python,"'''
Wireworld implementation.
'''
 
from io import StringIO
from collections import namedtuple
from pprint import pprint as pp
import copy
 
WW = namedtuple('WW', 'world, w, h')
head, tail, conductor, empty = allstates = 'Ht. '
 
 
infile = StringIO('''\
tH.........
.   .
   ...
.   .
Ht.. ......\
''')
 
def readfile(f):
    '''file > initial world configuration'''
    world  = [row.rstrip('\r\n') for row in f]
    height = len(world)
    width  = max(len(row) for row in world)
    # fill right and frame in empty cells
    nonrow = [ "" %*s "" % (-width, """") ]
    world  = nonrow + \
               [ "" %*s "" % (-width, row) for row in world ] + \
               nonrow   
    world = [list(row) for row in world]
    return WW(world, width, height)
 
def newcell(currentworld, x, y):
    istate = currentworld[y][x]
    assert istate in allstates, 'Wireworld cell set to unknown value ""%s""' % istate
    if istate == head:
        ostate = tail
    elif istate == tail:
        ostate = conductor
    elif istate == empty:
        ostate = empty
    else: # istate == conductor
        n = sum( currentworld[y+dy][x+dx] == head
                 for dx,dy in ( (-1,-1), (-1,+0), (-1,+1),
                                (+0,-1),          (+0,+1),
                                (+1,-1), (+1,+0), (+1,+1) ) )
        ostate = head if 1 <= n <= 2 else conductor
    return ostate
 
def nextgen(ww):
    'compute next generation of wireworld'
    world, width, height = ww
    newworld = copy.deepcopy(world)
    for x in range(1, width+1):
        for y in range(1, height+1):
            newworld[y][x] = newcell(world, x, y)
    return WW(newworld, width, height)
 
def world2string(ww):
    return '\n'.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] )
 
ww = readfile(infile)
infile.close()
 
for gen in range(10):
    print ( (""\n%3i "" % gen) + '=' * (ww.w-4) + '\n' )
    print ( world2string(ww) )
    ww = nextgen(ww)",Human_written,Python_from_C
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"lp = open(""/dev/lp0"")
lp.write(""Hello World!\n"")
lp.close()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Harshad_or_Niven_series,Harshad or Niven series,"The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.

For example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.

Assume that the series is defined as the numbers in increasing order.



Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to:

   list the first 20 members of the sequence,   and
   list the first Harshad number greater than 1000.


Show your output here.



Related task
   Increasing gaps between consecutive Niven numbers


See also
    OEIS: A005349

",Python,">>> import itertools
>>> def harshad():
	for n in itertools.count(1):
		if n % sum(int(ch) for ch in str(n)) == 0:
			yield n
 
 
>>> list(itertools.islice(harshad(), 0, 20))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]
>>> for n in harshad():
	if n > 1000:
		print(n)
		break
 
 
1002
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Maximum_triangle_path_sum,Maximum triangle path sum,"Starting from the top of a pyramid of numbers like this, you can walk down going one step on the right or on the left, until you reach the bottom row:

                          55
                        94 48
                       95 30 96
                     77 71 26 67

One of such walks is 55 - 94 - 30 - 26.
You can compute the total of the numbers you have seen in such walk,
in this case it's 205.

Your problem is to find the maximum total among all possible paths from the top to the bottom row of the triangle. In the little example above it's 321.



Task

Find the maximum total in the triangle below:

                          55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93

Such numbers can be included in the solution code, or read from a ""triangle.txt"" file.

This task is derived from the Euler Problem #18.



",Python,"arr = [
[55],
[94, 48],
[95, 30, 96],
[77, 71, 26, 67],
[97, 13, 76, 38, 45],
[07, 36, 79, 16, 37, 68],
[48, 07, 09, 18, 70, 26, 06],
[18, 72, 79, 46, 59, 79, 29, 90],
[20, 76, 87, 11, 32, 07, 07, 49, 18],
[27, 83, 58, 35, 71, 11, 25, 57, 29, 85],
[14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55],
[02, 90, 03, 60, 48, 49, 41, 46, 33, 36, 47, 23],
[92, 50, 48, 02, 36, 59, 42, 79, 72, 20, 82, 77, 42],
[56, 78, 38, 80, 39, 75, 02, 71, 66, 66, 01, 03, 55, 72],
[44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36],
[85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 01, 01, 99, 89, 52],
[06, 71, 28, 75, 94, 48, 37, 10, 23, 51, 06, 48, 53, 18, 74, 98, 15],
[27, 02, 92, 23, 08, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93]
]
 
while len(arr)!= 1:
  len_ = len(arr)
  row = []
  current = arr[len_-2]
  current_len = len(current) - 1
  end = arr[len_-1]
 
  for i in range(current_len+1):
    row.append(max(current[i] + end[i] or 0, current[i] + end[i+1] or 0) )
 
  arr.pop()
  arr.pop()
 
  arr.append(row)
 
print(arr)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/List_rooted_trees,List rooted trees,"You came back from grocery shopping.   After putting away all the goods, you are left with a pile of plastic bags, which you want to save for later use, so you take one bag and stuff all the others into it, and throw it under the sink.   In doing so, you realize that there are various ways of nesting the bags, with all bags viewed as identical.

If we use a matching pair of parentheses to represent a bag, the ways are:

For 1 bag, there's one way:

 ()	<- a bag

for 2 bags, there's one way:

 (())	<- one bag in another

for 3 bags, there are two:

 ((())) <- 3 bags nested Russian doll style
 (()()) <- 2 bags side by side, inside the third

for 4 bags, four:

 (()()())
 ((())())
 ((()()))
 (((())))

Note that because all bags are identical, the two 4-bag strings ((())()) and (()(())) represent the same configuration.

It's easy to see that each configuration for n bags represents a n-node rooted tree, where a bag is a tree node, and a bag with its content forms a subtree. The outermost bag is the tree root. Number of configurations for given n is given by OEIS A81.



Task
 
Write a program that, when given n, enumerates all ways of nesting n bags.   You can use the parentheses notation above, or any tree representation that's unambiguous and preferably intuitive.

This task asks for enumeration of trees only; for counting solutions without enumeration, that OEIS page lists various formulas, but that's not encouraged by this task, especially if implementing it would significantly increase code size.

As an example output, run 5 bags.   There should be 9 ways.



",Python,"def bags(n,cache={}):
	if not n: return [(0, """")]
 
	upto = sum([bags(x) for x in range(n-1, 0, -1)], [])
	return [(c+1, '('+s+')') for c,s in bagchain((0, """"), n-1, upto)]
 
def bagchain(x, n, bb, start=0):
	if not n: return [x]
 
	out = []
	for i in range(start, len(bb)):
		c,s = bb[i]
		if c <= n: out += bagchain((x[0] + c, x[1] + s), n-c, bb, i)
	return out
 
# Maybe this lessens eye strain. Maybe not.
def replace_brackets(s):
	depth,out = 0,[]
	for c in s:
		if c == '(':
			out.append(""([{""[depth%3])
			depth += 1
		else:
			depth -= 1
			out.append("")]}""[depth%3])
	return """".join(out)
 
for x in bags(5): print(replace_brackets(x[1]))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",Python,"FLOAT
    :   '.' DIGITS (Exponent)?
    |   DIGITS '.' Exponent
    |   DIGITS ('.' (DIGITS (Exponent)?)? | Exponent)
    ;
 
DIGITS : ( '0' .. '9' )+ ;
 
Exponent
    :    ('e' | 'E') ( '+' | '-' )? DIGITS
    ;",Human_written,Python_from_C#
http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",Python,"from fractions import gcd
 
 
def pt1(maxperimeter=100):
    '''
# Naive method
    '''
    trips = []
    for a in range(1, maxperimeter):
        aa = a*a
        for b in range(a, maxperimeter-a+1):
            bb = b*b
            for c in range(b, maxperimeter-b-a+1):
                cc = c*c
                if a+b+c > maxperimeter or cc > aa + bb: break
                if aa + bb == cc:
                    trips.append((a,b,c, gcd(a, b) == 1))
    return trips
 
def pytrip(trip=(3,4,5),perim=100, prim=1):
    a0, b0, c0 = a, b, c = sorted(trip)
    t, firstprim = set(), prim>0
    while a + b + c <= perim:
        t.add((a, b, c, firstprim>0))
        a, b, c, firstprim = a+a0, b+b0, c+c0, False
    #
    t2 = set()
    for a, b, c, firstprim in t:
        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7
        if  a5 - b5 + c7 <= perim:
            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)
        if  a5 + b5 + c7 <= perim:
            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)
        if -a5 + b5 + c7 <= perim:
            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)
    return t | t2
 
def pt2(maxperimeter=100):
    '''
# Parent/child relationship method:
# http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples#XI.
    '''
    trips = pytrip((3,4,5), maxperimeter, 1)
    return trips
 
def printit(maxperimeter=100, pt=pt1):
    trips = pt(maxperimeter)
    print(""  Up to a perimeter of %i there are %i triples, of which %i are primitive""
          % (maxperimeter,
             len(trips),
             len([prim for a,b,c,prim in trips if prim])))
 
for algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):
    print(algo.__doc__)
    for maxperimeter in range(mn, mx+1, mn):
        printit(maxperimeter, algo)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_palindrome(s):
  return s == s[::-1]",Human_written,Python_from_C
http://rosettacode.org/wiki/Compare_length_of_two_strings,Compare length of two strings,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings of different length, determine which string is longer or shorter. Print both strings and their length, one on each line. Print the longer one first.

Measure the length of your string in terms of bytes or characters, as appropriate for your language. If your language doesn't have an operator for measuring the length of a string, note it.

Extra credit

Given more than two strings:

list = [""abcd"",""123456789"",""abcdef"",""1234567""]

Show the strings in descending length order.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"A = 'I am string'
B = 'I am string too'
 
if len(A) > len(B):
    print('""' + A + '""', 'has length', len(A), 'and is the longest of the two strings')
    print('""' + B + '""', 'has length', len(B), 'and is the shortest of the two strings')
elif len(A) < len(B):
    print('""' + B + '""', 'has length', len(B), 'and is the longest of the two strings')
    print('""' + A + '""', 'has length', len(A), 'and is the shortest of the two strings')
else:
    print('""' + A + '""', 'has length', len(A), 'and it is as long as the second string')
    print('""' + B + '""', 'has length', len(B), 'and it is as long as the second string')",Human_written,Python_from_C#
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"import math

def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Hostname,Hostname,"Task

Find the name of the host on which the routine is running.



",Python,"# version 1.1.4
 
def hello(name=""World"", *others, **others2):
    return ""Hello "" + name + ""!""
 
name = ""World""
print(hello(name))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Jump_anywhere,Jump anywhere,"Imperative programs
conditional structures
loops
local jumps
This task is to demonstrate a local jump and a global jump and the various other types of jumps that the language supports.
For the purpose of this task, the jumps need not be used for a single purpose and you have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.
This task provides a ""grab bag"" for several types of jumps. There are non-local jumps across function calls, or long jumps to anywhere within a program. Anywhere means not only to the tops of functions!

 Some languages can go to any global label in a program.
 Some languages can break multiple function calls, also known as unwinding the call stack.
 Some languages can save a continuation. The program can later continue from the same place. So you can jump anywhere, but only if you have a previous visit there (to save the continuation).

These jumps are not all alike.
A simple goto never touches the call stack.
A continuation saves the call stack, so you can continue a function call after it ends.



Task

Use your language to demonstrate the various types of jumps that it supports.

Because the possibilities vary by language, this task is not specific.
You have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.



",Python,"import sys
import types
 
def callcc(f):
    def g(x):
        return f(lambda y: g(y))
    return g(None)
 
def fizzbuzz(c, i):
    if i > 100:
        return
    if i % 3 == 0:
        sys.stdout.write(""Fizz"")
        if i % 5 == 0:
            sys.stdout.write(""Buzz"")
    elif i % 5 == 0:
        sys.stdout.write(""Buzz"")
    else:
        sys.stdout.write(str(i))
    sys.stdout.write(""\n"")
    return fizzbuzz(c, i + 1)
 
callcc(fizzbuzz)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/21_game,21 game,"21 game

You are encouraged to solve this task according to the task description, using any language you may know.
21 is a two player game, the game is played by choosing
a number (1, 2, or 3) to be added to the running total.

The game is won by the player whose chosen number causes the running total
to reach exactly 21.

The running total starts at zero.
One player will be the computer.

Players alternate supplying a number to be added to the running total.



Task

Write a computer program that will:

 do the prompting (or provide a button menu), 
 check for errors and display appropriate error messages, 
 do the additions (add a chosen number to the running total), 
 display the running total, 
 provide a mechanism for the player to quit/exit/halt/stop/close the program,
 issue a notification when there is a winner, and
 determine who goes first (maybe a random or user choice, or can be specified when the game begins). 

",Python,"from random import randint
def start():
	game_count=0
	print(""Enter q to quit at any time.\nThe computer will choose first.\nRunning total is now {}"".format(game_count))
	roundno=1
	while game_count<21:
		print(""\nROUND {}: \n"".format(roundno))
		t = select_count(game_count)
		game_count = game_count+t
		print(""Running total is now {}\n"".format(game_count))
		if game_count>=21:
			print(""So, commiserations, the computer has won!"")
			return 0
		t = request_count()
		if not t:
			print('OK,quitting the game')
			return -1
		game_count = game_count+t
		print(""Running total is now {}\n"".format(game_count))
		if game_count>=21:
			print(""So, congratulations, you've won!"")
			return 1
		roundno+=1
 
def select_count(game_count):
	'''selects a random number if the game_count is less than 18. otherwise chooses the winning number'''
	if game_count<18:
		t= randint(1,3)
	else:
		t = 21-game_count
	print(""The computer chooses {}"".format(t))
	return t
 
def request_count():
	'''request user input between 1,2 and 3. It will continue till either quit(q) or one of those numbers is requested.'''
	t=""""
	while True:
		try:
			t = raw_input('Your choice 1 to 3 :')
			if int(t) in [1,2,3]:
				return int(t)
			else:
				print(""Out of range, try again"")
		except:
			if t==""q"":
				return None
			else:
				print(""Invalid Entry, try again"")
 
c=0
m=0
r=True
while r:
	o = start()
	if o==-1:
		break
	else:
		c+=1 if o==0 else 0
		m+=1 if o==1 else 0
	print(""Computer wins {0} game, human wins {1} games"".format(c,m))
	t = raw_input(""Another game?(press y to continue):"")
	r = (t==""y"")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Perfect_numbers,Perfect numbers,"Write a function which says whether a number is perfect.


A perfect number is a positive integer that is the sum of its proper positive divisors excluding the number itself.

Equivalently, a perfect number is a number that is half the sum of all of its positive divisors (including itself).



Note:   The faster   Lucas-Lehmer test   is used to find primes of the form    2n-1,   all known perfect numbers can be derived from these primes
using the formula    (2n - 1) × 2n - 1.

It is not known if there are any odd perfect numbers (any that exist are larger than 102000).

The number of   known   perfect numbers is   51   (as of December, 2018),   and the largest known perfect number contains  49,724,095  decimal digits.



See also

   Rational Arithmetic
   Perfect numbers on OEIS
   Odd Perfect showing the current status of bounds on odd perfect numbers.

",Python,"def perf1(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",Human_written,Python_from_C
http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Python,"def execute_with_10(f):
	return f(10)
 
def square(n):
	return n*n
 
print(execute_with_10(lambda n: n*n)) # closure
print(execute_with_10(square))        # function",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting algorithms/Quicksort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm.

The elements must have a   strict weak order   and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.



Quicksort, also known as   partition-exchange sort,   uses these steps.

   Choose any element of the array to be the pivot.
   Divide all other elements (except the pivot) into two partitions.
   All elements less than the pivot must be in the first partition.
   All elements greater than the pivot must be in the second partition.
   Use recursion to sort both partitions.
   Join the first sorted partition, the pivot, and the second sorted partition.


The best pivot creates partitions of equal length (or lengths differing by   1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.



This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

 ""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

 Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
 Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.


With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.



",Python,"def quickSort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        less = []
        pivotList = []
        more = []
        for i in arr:
            if i < pivot:
                less.append(i)
            elif i > pivot:
                more.append(i)
            else:
                pivotList.append(i)
        less = quickSort(less)
        more = quickSort(more)
        return less + pivotList + more",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",Python,"from Crypto.Util.number import *
 
a = 2988348162058574136915891421498819466320163312926952423791023078876139
b = 2351399303373464486466122544523690094744975233415544072992656881240319
m = 10**40
 
print(pow(a, b, m))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Hough_transform,Hough transform,"Task

Implement the Hough transform, which is used as part of feature extraction with digital images.

It is a tool that makes it far easier to identify straight lines in the source image, whatever their orientation.

The transform maps each point in the target image, 



(
ρ
,
θ
)


{\displaystyle (\rho ,\theta )}

, to the average color of the pixels on the corresponding line of the source image (in 



(
x
,
y
)


{\displaystyle (x,y)}

-space, where the line corresponds to points of the form 



x
cos
⁡
θ
+
y
sin
⁡
θ
=
ρ


{\displaystyle x\cos \theta +y\sin \theta =\rho }

). The idea is that where there is a straight line in the original image, it corresponds to a bright (or dark, depending on the color of the background field) spot; by applying a suitable filter to the results of the transform, it is possible to extract the locations of the lines in the original image.

 Sample PNG image to use for the Hough transform.
The target space actually uses polar coordinates, but is conventionally plotted on rectangular coordinates for display. There's no specification of exactly how to map polar coordinates to a flat surface for display, but a convenient method is to use one axis for 



θ


{\displaystyle \theta }

 and the other for 



ρ


{\displaystyle \rho }

, with the center of the source image being the origin.

There is also a spherical Hough transform, which is more suited to identifying planes in 3D data.



",Python,"import math, grayscale_image
 
def houghTransform(im, hx=460, hy=360):
    assert im is not None
    assert hx > 0 and hy > 0
    assert (hy & 1) == 0, ""hy argument must be even.""
 
    result = grayscale_image.Image(hx, hy)
    result.clear(grayscale_image.Gray(255))
 
    rMax = math.hypot(im.nx, im.ny)
    dr = rMax / (hy / 2.0)
    dTh = math.pi / hx
 
    for y in range(im.ny):
        for x in range(im.nx):
            if im[x, y] == grayscale_image.Gray(255):
                continue
            for iTh in range(hx):
                th = dTh * iTh
                r = x * math.cos(th) + y * math.sin(th)
                iry = hy / 2 - int(math.floor(r / dr + 0.5))
                if result[iTh, iry] > grayscale_image.Gray(0):
                    result[iTh, iry] -= 1
    return result
 
if __name__ == ""__main__"":
    (grayscale_image.Image()
   .loadPPM6(""Pentagon.ppm"")
   .rgb2grayImage()
   .houghTransform()
   .savePGM(""Pentagon_hough.pgm""))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
 
def main():
    for i in range(0, 16):
        for j in range(32 + i, 128, 16):
            k = chr(j)
            if j == 32:
                k = ""Spc""
            elif j == 127:
                k = ""Del""
            print(""%3d : %-3s   "" % (j, k), end="""")
        print()
 
if __name__ == ""__main__"":
    sys.exit(main())",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/SHA-256_Merkle_tree,SHA-256 Merkle tree,"As described in its documentation, Amazon S3 Glacier requires that all uploaded files come with a checksum computed as a Merkle Tree using SHA-256.

Specifically, the SHA-256 hash is computed for each 1MiB block of the file. And then, starting from the beginning of the file, the raw hashes of consecutive blocks are paired up and concatenated together, and a new hash is computed from each concatenation. Then these are paired up and concatenated and hashed, and the process continues until there is only one hash left, which is the final checksum. The hexadecimal representation of this checksum is the value that must be included with the AWS API call to upload the object (or complete a multipart upload).

Implement this algorithm in your language; you can use the code from the SHA-256 task for the actual hash computations. For better manageability and portability, build the tree using a smaller block size of only 1024 bytes, and demonstrate it on the RosettaCode title image with that block size. The final result should be the hexadecimal digest value a4f902cf9d51fe51eda156a6792e1445dff65edf3a217a1f3334cc9cf1495c2c.
",Python,"#!/usr/bin/env python
# compute the root label for a SHA256 Merkle tree built on blocks of a given
# size (default 1MB) taken from the given file(s)
import argh
import hashlib  
import sys
 
@argh.arg('filename', nargs='?', default=None)
def main(filename, block_size=1024*1024):
    if filename:
        fin = open(filename, 'rb')
    else: 
        fin = sys.stdin
 
    stack = []
    block = fin.read(block_size)
    while block:
        # a node is a pair: ( tree-level, hash )
        node = (0, hashlib.sha256(block).digest())
        stack.append(node)
 
        # concatenate adjacent pairs at the same level
        while len(stack) >= 2 and stack[-2][0] == stack[-1][0]:
            a = stack[-2]
            b = stack[-1]
            l = a[0]
            stack[-2:] = [(l+1, hashlib.sha256(a[1] + b[1]).digest())]
 
        block = fin.read(block_size)
 
    while len(stack) > 1:
        # at the end we have to concatenate even across levels
        a = stack[-2]
        b = stack[-1]
        al = a[0]
        bl = b[0]
        stack[-2:] = [(max(al, bl)+1, hashlib.sha256(a[1] + b[1]).digest())]
 
    print(stack[0][1].hex())
 
 
argh.dispatch_command(main)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Munching_squares,Munching squares,"Render a graphical pattern where each pixel is colored by the value of 'x xor y' from an arbitrary color table.
",Python,"import Image, ImageDraw
 
image = Image.new(""RGB"", (256, 256))
drawingTool = ImageDraw.Draw(image)
 
for x in range(256):
    for y in range(256):
        drawingTool.point((x, y), (0, x^y, 0))
 
del drawingTool
image.save(""xorpic.png"", ""PNG"")",Human_written,Python_from_C#
http://rosettacode.org/wiki/OpenWebNet_password,OpenWebNet password,"Calculate the password requested by ethernet gateways from the Legrand / Bticino MyHome OpenWebNet home automation system when the user's ip address is not in the gateway's whitelist

Note: Factory default password is '12345'. Changing it is highly recommended !

conversation goes as follows

← *#*1##
→ *99*0##
← *#603356072##
at which point a password should be sent back, calculated from the ""password open"" that is set in the gateway, and the nonce that was just sent

→ *#25280520##
← *#*1##",Python,"def calcPass(pass, nonce):
    flag = True
    num1 = 0x0
    num2 = 0x0
    password = int(pass)
    for c in nonce:
        if c!= '0':
            if flag:
                num2 = password
            flag = False
        if c == '1':
            num1 = num2 & 0xFFFFFF80
            num1 = num1 >> 7
            num2 = num2 << 25
            num1 = num1 + num2
        elif c == '2':
            num1 = num2 & 0xFFFFFFF0
            num1 = num1 >> 4
            num2 = num2 << 28
            num1 = num1 + num2
        elif c == '3':
            num1 = num2 & 0xFFFFFFF8
            num1 = num1 >> 3
            num2 = num2 << 29
            num1 = num1 + num2
        elif c == '4':
            num1 = num2 << 1
            num2 = num2 >> 31
            num1 = num1 + num2
        elif c == '5':
            num1 = num2 << 5
            num2 = num2 >> 27
            num1 = num1 + num2
        elif c == '6':
            num1 = num2 << 12
            num2 = num2 >> 20
            num1 = num1 + num2
        elif c == '7':
            num1 = num2 & 0x0000FF00
            num1 = num1 + ((num2 & 0x000000FF) << 24)
            num1 = num1 + ((num2 & 0x00FF0000) >> 16)
            num2 = (num2 & 0xFF000000) >> 8
            num1 = num1 + num2
        elif c == '8':
            num1 = num2 & 0x0000FFFF
            num1 = num1 << 16
            num1 = num1 + (num2 >> 24)
            num2 = num2 & 0x00FF0000
            num2 = num2 >> 8
            num1 = num1 + num2
        elif c == '9':
            num1 = ~num2
        elif c == '0':
            num1 = num2
        num2 = num1
    return num1
 
def testCalcPass(pass, nonce, expected):
    res = calcPass(pass, nonce)
    m = pass +'' + nonce +'' + str(res) +'' + expected
    if res == int(expected):
        print('PASS'+ m)
    else:
        print('FAIL'+ m)
 
testCalcPass('12345', '603356072', '25280520')
testCalcPass('12345', '410501656', '119537670')
testCalcPass('12345', '630292165', '4269684735')
testCalcPass('12345', '523781130', '537331200')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Bitmap/Flood_fill,Bitmap/Flood fill,"Implement a flood fill.

A flood fill is a way of filling an area using color banks to define the contained area or a target color which ""determines"" the area (the valley that can be flooded; Wikipedia uses the term target color). It works almost like a water flooding from a point towards the banks (or: inside the valley): if there's a hole in the banks, the flood is not contained and all the image (or all the ""connected valleys"") get filled.

To accomplish the task, you need to implement just one of the possible algorithms (examples are on Wikipedia). Variations on the theme are allowed (e.g. adding a tolerance parameter or argument for color-matching of the banks or target color).

 
Testing: the basic algorithm is not suitable for truecolor images; a possible test image is the one shown on the right box; you can try to fill the white area, or the black inner circle.
",Python,"import Image
def FloodFill( fileName, initNode, targetColor, replaceColor ):
   img = Image.open( fileName )
   pix = img.load()
   xsize, ysize = img.size
   Q = []
   if pix[ initNode[0], initNode[1] ] != targetColor:
      return img
   Q.append( initNode )
   while Q != []:
      node = Q.pop(0)
      if pix[ node[0], node[1] ] == targetColor:
         W = list( node )
         if node[0] + 1 < xsize:
            E = list( [ node[0] + 1, node[1] ] )
         else:
            E = list( node )
      # Move west until color of node does not match targetColor
      while pix[ W[0], W[1] ] == targetColor:
         pix[ W[0], W[1] ] = replaceColor
         if W[1] + 1 < ysize:
            if pix[ W[0], W[1] + 1 ] == targetColor:
               Q.append( [ W[0], W[1] + 1 ] )
         if W[1] - 1 >= 0:
            if pix[ W[0], W[1] - 1 ] == targetColor:
               Q.append( [ W[0], W[1] - 1 ] )
         if W[0] - 1 >= 0:
            W[0] = W[0] - 1
         else:
            break
      # Move east until color of node does not match targetColor
      while pix[ E[0], E[1] ] == targetColor:
         pix[ E[0], E[1] ] = replaceColor
         if E[1] + 1 < ysize:
            if pix[ E[0], E[1] + 1 ] == targetColor:
               Q.append( [ E[0], E[1] + 1 ] )
         if E[1] - 1 >= 0:
            if pix[ E[0], E[1] - 1 ] == targetColor:
               Q.append( [ E[0], E[1] -1 ] )
         if E[0] + 1 < xsize:
            E[0] = E[0] + 1
         else:
            break
      return img",Human_written,Python_from_Go
http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.3.72
 
alphabet = ''.join([chr(i + 97) for i in range(26)])
 
print(alphabet)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Simulate_input/Mouse,Simulate input/Mouse,,Python,"import ctypes
 
def click():
    ctypes.windll.user32.mouse_event(0x2, 0,0,0,0)    # Mouse LClick Down, relative coords, dx=0, dy=0
    ctypes.windll.user32.mouse_event(0x4, 0,0,0,0)    # Mouse LClick Up, relative coords, dx=0, dy=0
 
click()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Euler%27s_sum_of_powers_conjecture,Euler's sum of powers conjecture,"There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.



Euler's (disproved) sum of powers   conjecture

  At least  k  positive  kth  powers are required to sum to a  kth  power,  
  except for the trivial case of one  kth power:  yk = yk 



In 1966,   Leon J. Lander   and   Thomas R. Parkin   used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.



Task

Write a program to search for an integer solution for:


  x05 + x15 + x25 + x35 == y5 

Where all     xi's   and    y    are distinct integers between   0   and   250   (exclusive).

Show an answer here.



Related tasks

   Pythagorean quadruples. 
   Pythagorean triples.

",Python,"import time
from math import pow
from bisect import bisect_left
 
def find():
    MAX = 250
    pow5 = [0] * MAX
    for i in range(1, MAX):
        pow5[i] = i * i * i * i * i
    for x0 in range(1, MAX):
        for x1 in range(1, x0):
            for x2 in range(1, x1):
                for x3 in range(1, x2):
                    sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]
                    if bisect_left(pow5, sum) < MAX:
                        print(x0, x1, x2, x3, pow(sum, 1.0 / 5.0))
                        return True
    # not found
    return False
 
tm = time.clock()
if not find():
    print(""Nothing found!"")
print(""time="", (time.clock() - tm) * 1000 / time.CLOCKS_PER_SEC, ""milliseconds"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Modular_inverse,Modular inverse,"From Wikipedia:

In modular arithmetic,   the modular multiplicative inverse of an integer    a    modulo    m    is an integer    x    such that





a

x
≡
1


(
mod

m
)

.


{\displaystyle a\,x\equiv 1{\pmod {m}}.}


Or in other words, such that:





∃
k
∈

Z

,

a

x
=
1
+
k

m


{\displaystyle \exists k\in \mathbb {Z} ,\qquad a\,x=1+k\,m}


It can be shown that such an inverse exists   if and only if    a    and    m    are coprime,   but we will ignore this for this task.



Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in
your language,   compute the modular inverse of   42 modulo 2017.



",Python,">>> def extended_gcd(aa, bb):
    lastremainder, remainder = abs(aa), abs(bb)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)
        x, lastx = lastx - quotient*x, x
        y, lasty = lasty - quotient*y, y
    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)
 
>>> def modinv(a, m):
	g, x, y = extended_gcd(a, m)
	if g != 1:
		raise ValueError
	return x % m
 
>>> modinv(42, 2017)
1969
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Python,"def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = _matrix[row][int(digit)] 
    return row == 0
 
_matrix = (
    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),
    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),
    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),
    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),
    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),
    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),
    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),
    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),
    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),
    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)
)
 
if __name__ == '__main__':
    for test in [5724, 5727, 112946]:
        print(f'{test}\t Validates as: {damm(test)}')",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Send_email,Send email,"Task

Write a function to send an email.

The function should have parameters for setting From, To and Cc addresses; the Subject, and the message text, and optionally fields for the server name and login details.

 If appropriate, explain what notifications of problems/success are given.
 Solutions using libraries or functions from the language are preferred, but failing that, external programs can be used with an explanation.
 Note how portable the solution given is between operating systems when multi-OS languages are used.


(Remember to obfuscate any sensitive data used in examples)



",Python,"import smtplib
 
def sendemail(from_addr, to_addr_list, cc_addr_list,
              subject, message,
              login, password,
              smtpserver='smtp.gmail.com:587'):
    header  = 'From: %s\n' % from_addr
    header += 'To: %s\n' % ','.join(to_addr_list)
    header += 'Cc: %s\n' % ','.join(cc_addr_list)
    header += 'Subject: %s\n\n' % subject
    message = header + message
 
    server = smtplib.SMTP(smtpserver)
    server.starttls()
    server.login(login,password)
    problems = server.sendmail(from_addr, to_addr_list, message)
    server.quit()
    return problems",Human_written,Python_from_Java
http://rosettacode.org/wiki/Levenshtein_distance,Levenshtein distance,"

 This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.



Example

The Levenshtein distance between ""kitten"" and ""sitting"" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

   kitten   sitten   (substitution of 'k' with 's')
   sitten   sittin   (substitution of 'e' with 'i')
   sittin   sitting   (insert 'g' at the end).

The Levenshtein distance between   ""rosettacode"",   ""raisethysword""   is   8.

The distance between two strings is same as that when both strings are reversed.



Task

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between   ""kitten""   and   ""sitting"".



Related task

   Longest common subsequence



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def levenshteinDistance(str1, str2):
    m = len(str1)
    n = len(str2)
    d = [[i] for i in range(1, m + 1)]   # d matrix rows
    d.insert(0, list(range(0, n + 1)))   # d matrix columns
    for j in range(1, n + 1):
        for i in range(1, m + 1):
            if str1[i - 1] == str2[j - 1]:   # Python (string) is 0-based
                substitutionCost = 0
            else:
                substitutionCost = 1
            d[i].insert(j, min(d[i - 1][j] + 1,
                               d[i][j - 1] + 1,
                               d[i - 1][j - 1] + substitutionCost))
    return d[-1][-1]
 
print(levenshteinDistance(""kitten"",""sitting""))
print(levenshteinDistance(""rosettacode"",""raisethysword""))",Human_written,Python_from_Java
http://rosettacode.org/wiki/AVL_tree,AVL tree,"

 This page uses content from Wikipedia. The original article was at AVL tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations. Note the tree of nodes comprise a set, so duplicate node keys are not allowed.

AVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations. Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.



Task

Implement an AVL tree in the language of choice, and provide at least basic operations.



",Python,"def tree(less, val, more):
    return {
        'depth': 1+max(less['depth'], more['depth']),
        'less': less,
        'val': val,
       'more': more,
    }
 
def node(val):
    return tree({'depth': 0}, val, {'depth': 0})
 
def insert(x,y):
    if 0 == y['depth']:
        return x
    if 0 == x['depth']:
        return y
    if 1 == x['depth'] and 1 == y['depth']:
        if y['val'] < x['val']:
            return tree(y, x['val'], {'depth': 0})
        elif y['val'] == x['val']:
            return y
        else:
            return tree(x, y['val'], {'depth': 0})
    if y['val'] < x['val']:
        return balance(insert(x['less'], y), x['val'], x['more'])
    elif y['val'] == x['val']:
        return balance(insert(x['less'], y['less']), x['val'], insert(x['more'], y['more']))
    else:
        return balance(x['less'], x['val'], insert(x['more'], y))
 
def balance(less,val,more):
    if 2 > abs(less['depth']-more['depth']):
        return tree(less,val,more)
    if more['depth'] > less['depth']:
        if more['more']['depth'] >= more['less']['depth']:
            return moreHeavy(less, val, more)
        else:
            return moreHeavy(less,val,lessHeavy(more['less'], more['val'], more['more']))
    else:
        if less['less']['depth'] >= less['more']['depth']:
            return lessHeavy(less, val, more)
        else:
            return lessHeavy(moreHeavy(less['less'], less['val'], less['more']), val, more)
 
def moreHeavy(less,val,more):
    return tree(tree(less,val,more['less']), more['val'], more['more'])
 
def lessHeavy(less,val,more):
    return tree(less['less'], less['val'], tree(less['more'], val, more))
 
def remove(val, y):
    if y['depth'] == 0:
        return y
    if y['depth'] == 1:
        if val == y['val']:
            return y['less']
        else:
            return y
    if y['val'] < val:
        return balance(y['less'], y['val'], remove(val, y['more']))
    elif y['val'] == val:
        return insert(y['less'], y['more'])
    else:
        return balance(remove(val, y['less']), y['val'], y['more'])
 
def lookup(val, y):
    if y['depth'] == 0:
        return y
    if y['depth'] == 1:
        if val == y['val']:
            return y
        else:
            return {'depth': 0}
    if y['val'] < val:
        return lookup(val, y['more'])
    elif y['val'] == val:
        return y
    else:
        return lookup(val, y['less'])",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"def write(x):
    print(x)

def read():
    return int(input())

def main():
    write(18 / 2 * 3 + 7)
    write(18 / (2 * 3) + 7)

main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bitmap/Read_an_image_through_a_pipe,Bitmap/Read an image through a pipe,"This task is the opposite of the PPM conversion through a pipe. In this task, using a delegate tool (like cjpeg, one of the netpbm package, or convert of the ImageMagick package) we read an image file and load it into the data storage type defined here. We can also use the code from Read ppm file, so that we can use PPM format like a (natural) bridge between the foreign image format and our simple data storage.
",Python,"import subprocess
import raster
 
def main():
    c = subprocess.Popen([""convert"", ""Unfilledcirc.png"", ""-depth"", ""1"", ""ppm:-""], stdout=subprocess.PIPE)
    b = raster.ReadPpmFrom(c.stdout)
    b.WritePpmFile(""Unfilledcirc.ppm"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number,Validate International Securities Identification Number,"An International Securities Identification Number (ISIN) is a unique international identifier for a financial security such as a stock or bond.



Task

Write a function or program that takes a string as input, and checks whether it is a valid ISIN.

It is only valid if it has the correct format,   and   the embedded checksum is correct.

Demonstrate that your code passes the test-cases listed below.



Details

The format of an ISIN is as follows:


┌───────────── a 2-character ISO country code (A-Z)
│ ┌─────────── a 9-character security code (A-Z, 0-9)
│ │        ┌── a checksum digit (0-9)
AU0000XVGZA3



For this task, you may assume that any 2-character alphabetic sequence is a valid country code.

The checksum can be validated as follows:

 Replace letters with digits, by converting each character from base 36 to base 10, e.g. AU0000XVGZA3 →1030000033311635103.
 Perform the Luhn test on this base-10 number.
There is a separate task for this test: Luhn test of credit card numbers.
You don't have to replicate the implementation of this test here   ───   you can just call the existing function from that task.   (Add a comment stating if you did this.)


Test cases



 ISIN

 Validity

 Comment


 US0378331005 
 valid 



 US0373831005 
 not valid 
 The transposition typo is caught by the checksum constraint.


 U50378331005 
 not valid 
 The substitution typo is caught by the format constraint.


 US03378331005 
 not valid 
 The duplication typo is caught by the format constraint.


 AU0000XVGZA3 
 valid 



 AU0000VXGZA3 
 valid 
 Unfortunately, not all transposition typos are caught by the checksum constraint.


 FR0000988040 
 valid 


(The comments are just informational.   Your function should simply return a Boolean result.   See #Raku for a reference solution.)



Related task:

 Luhn test of credit card numbers


Also see

 Interactive online ISIN validator
 Wikipedia article: International Securities Identification Number

",Python,"def check_isin(a):
    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):
        return False
    s = """".join(str(int(c, 36)) for c in a)
    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +
                 sum(ord(c) - 48 for c in s[::-2])) % 10
 
# A more readable version 
def check_isin_alt(a):
    if len(a) != 12:
        return False
    s = []
    for i, c in enumerate(a):
        if c.isdigit():
            if i < 2:
                return False
            s.append(ord(c) - 48)
        elif c.isupper():
            if i == 11:
                return False
            s += divmod(ord(c) - 55, 10)
        else:
            return False
    v = sum(s[::-2])
    for k in s[-2::-2]:
        k = 2 * k
        v += k - 9 if k > 9 else k
    return v % 10 == 0
 
[check_isin(s) for s in [""US0378331005"", ""US0373831005"", ""U50378331005"", ""US03378331005"",
                         ""AU0000XVGZA3"", ""AU0000VXGZA3"", ""FR0000988040""]]
 
# [True, False, False, False, True, True, True]",Human_written,Python_from_C#
http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",Python,"def isPrime(n):
    if n < 2:
        return False
    elif n % 2 == 0:
        return n == 2
    elif n % 3 == 0:
        return n == 3
    else:
        d = 5
        while d * d <= n:
            if n % d == 0:
                return False
            d += 2
            if n % d == 0:
                return False
            d += 4
        return True
 
def countPrimeFactors(n):
    if n == 1:
        return 0
    elif isPrime(n):
        return 1
    else:
        count = 0
        f = 2
        while True:
            if n % f == 0:
                count += 1
                n //= f
                if n == 1:
                    return count
                if isPrime(n):
                    f = n
            elif f >= 3:
                f += 2
            else:
                f = 3
 
def main():
    max = 120
    print(""The attractive numbers up to and including"", max, ""are:"")
    count = 0
    for i in range(1, max + 1):
        n = countPrimeFactors(i)
        if isPrime(n):
            print(""%4d"" % i, end="""")
            count += 1
            if count % 20 == 0:
                print()
    print()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Bioinformatics/base_count,Bioinformatics/base count,"Given this string representing ordered DNA bases:

CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT



Task

   ""Pretty print"" the sequence followed by a summary of the counts of each of the bases:   (A, C, G, and T)   in the sequence 
   print the total count of each base in the string.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from collections import Counter
 
dna = ""CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT""
 
base_count = Counter(dna)
total_count = sum(base_count.values())
 
print(""Sequence:"")
for i, base in enumerate(dna):
    if i % 50 == 0:
        print()
        print(""{:3}: "".format(i), end="""")
    print(base, end="""")
print()
 
print(""Base count:"")
print(""-----------"")
for base, count in sorted(base_count.items()):
    print(""  {}: {:3}"".format(base, count))
print()
print(""Total: {}"".format(total_count))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Text_processing/Max_licenses_in_use,Text processing/Max licenses in use,"A company currently pays a fixed sum for the use of a particular licensed software package.   In determining if it has a good deal it decides to calculate its maximum use of the software from its license management log file.

Assume the software's licensing daemon faithfully records a checkout event when a copy of the software starts and a checkin event when the software finishes to its log file.

An example of checkout and checkin events are:

 License OUT @ 2008/10/03_23:51:05 for job 4974
 ...
 License IN  @ 2008/10/04_00:18:22 for job 4974



Task

Save the 10,000 line log file from    here   into a local file, then write a program to scan the file extracting both the maximum licenses that were out at any time, and the time(s) at which this occurs.

Mirror of log file available as a zip here (offsite mirror).



",Python,"# version 1.1.51
 
import os
 
def main():
    filePath = ""mlijobs.txt""
    licenses = 0
    maxLicenses = 0
    dates = []
    with open(filePath) as f:
        for line in f:
            if line.startswith(""License OUT""):
                licenses += 1
                if licenses > maxLicenses:
                    maxLicenses = licenses
                    dates.clear()
                    dates.append(line[14:33])
                elif licenses == maxLicenses:
                    dates.append(line[14:33])
            elif line.startswith(""License IN""):
                licenses -= 1
    print(""Maximum simultaneous license use is {} at the following time(s):"".format(maxLicenses))
    for date in dates:
        print(""  {}"".format(date))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle,Catalan numbers/Pascal's triangle,"Task

Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.



See

   Catalan Numbers and the Pascal Triangle.     This method enables calculation of Catalan Numbers using only addition and subtraction.
   Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition.
   Sequence A000108 on OEIS has a lot of information on Catalan Numbers.
Related Tasks

Pascal's triangle
",Python,"n = 15
t = [0, 1] + [0] * (n + 1)
for i in range(1, n + 1):
    for j in range(i, 0, -1):
        t[j] += t[j - 1]
    t[i + 1] = t[i]
    for j in range(i + 1, 0, -1):
        t[j] += t[j - 1]
    print(""%2d : %d"" % (i, t[i + 1] - t[i]))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sort_numbers_lexicographically,Sort numbers lexicographically,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Given an integer   n,   return   1──►n   (inclusive)   in lexicographical order.



Show all output here on this page.



Example

Given   13,

return:   [1,10,11,12,13,2,3,4,5,6,7,8,9].
",Python,"n=13
print(sorted(range(1,n+1), key=str))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/OpenGL,OpenGL,"

Task

Display a smooth shaded triangle with OpenGL.

 Triangle created using C example compiled with GCC 4.1.2 and freeglut3.

",Python,"import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.DisplayMode;
import static org.lwjgl.opengl.GL11.*;
 
 
public class OpenGlExample:
 
	def run(self):
		Display.setDisplayMode(new DisplayMode(640, 480));
		Display.create();
 
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(-30, 30, -30, 30, -30, 30);
		glMatrixMode(GL_MODELVIEW);
 
		while(!Display.isCloseRequested()):
			render();
 
			Display.update();
 
		Display.destroy();
 
	def render(self):
 
		glClearColor(0.3f, 0.3f, 0.3f, 0.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
		glShadeModel(GL_SMOOTH);
 
		glLoadIdentity();
		glTranslatef(-15.0f, -15.0f, 0.0f);
 
		glBegin(GL_TRIANGLES);
		glColor3f(1.0f, 0.0f, 0.0f);
		glVertex2f(0.0f, 0.0f);
		glColor3f(0.0f, 1.0f, 0.0f);
		glVertex2f(30f, 0.0f);
		glColor3f(0.0f, 0.0f, 1.0f);
		glVertex2f(0.0f, 30.0f);
		glEnd();
 
	def main(self):
		OpenGlExample openGlExmpl = new OpenGlExample();
		try:
			openGlExmpl.run();
		except(LWJGLException e):
			System.err.println(e);",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Python,"import math
from processing import *
 
INCR = 0.1
 
def setup():
  sketch_title('Archimedian Spiral')
  theta = 0
  x = 0
  background(255)
  translate(width / 2.0, height / 2.0)
  begin_shape()
  for theta in range(0, 50 * math.pi, INCR):
    x = theta * math.cos(theta / math.pi)
    curve_vertex(x, theta * math.sin(theta / math.pi))
  end_shape()
 
def settings():
  size(300, 300)
 
if __name__ == '__main__':
  run()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Partial_function_application,Partial function application,"Partial function application   is the ability to take a function of many
parameters and apply arguments to some of the parameters to create a new
function that needs only the application of the remaining arguments to
produce the equivalent of applying all arguments to the original function.

E.g:

 Given values v1, v2
 Given f(param1, param2)
 Then partial(f, param1=v1) returns f'(param2)
 And f(param1=v1, param2=v2) == f'(param2=v2) (for any value v2)


Note that in the partial application of a parameter, (in the above case param1), other parameters are not explicitly mentioned. This is a recurring feature of partial function application.



Task 
 Create a function fs( f, s ) that takes a function, f( n ), of one value and a sequence of values s.
 Function fs should return an ordered sequence of the result of applying function f to every value of s in turn.
 Create function f1 that takes a value and returns it multiplied by 2.
 Create function f2 that takes a value and returns it squared.
 Partially apply f1 to fs to form function fsf1( s )
 Partially apply f2 to fs to form function fsf2( s )
 Test fsf1 and fsf2 by evaluating them with s being the sequence of integers from 0 to 3 inclusive and then the sequence of even integers from 2 to 8 inclusive.


Notes
 In partially applying the functions f1 or f2 to fs, there should be no explicit mention of any other parameters to fs, although introspection of fs within the partial applicator to find its parameters is allowed.
 This task is more about how results are generated rather than just getting results.

",Python,"from functools import partial
import operator

def fs(f, s):
    return map(f, s)

def fsf1(s):
    return fs(operator.mul, s)

def fsf2(s):
    return fs(operator.pow, s)

sequences = [
    [0, 1, 2, 3],
    [2, 4, 6, 8],
]

for array in sequences:
    print(
        ""array: {}\n""
        ""  fsf1(array): {}\n""
        ""  fsf2(array): {}\n"".format(
            array,
            fsf1(array),
            fsf2(array)))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Entropy/Narcissist,Entropy/Narcissist,"
Task

Write a computer program that computes and shows its own   entropy.



Related Tasks

   Fibonacci_word
   Entropy

",Python,"import math
from collections import Counter
 
def entropy(s):
    p, lns = Counter(s), float(len(s))
    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
 
with open(__file__) as f:
    b=f.read()
 
print(entropy(b))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Synchronous_concurrency,Synchronous concurrency,"The goal of this task is to create two concurrent activities (""Threads"" or ""Tasks"", not processes.) that share data synchronously. Your language may provide syntax or libraries to perform concurrency. Different languages provide different implementations of concurrency, often with different names. Some languages use the term threads, others use the term tasks, while others use co-processes. This task should not be implemented using fork, spawn, or the Linux/UNIX/Win32 pipe command, as communication should be between threads, not processes.

One of the concurrent units will read from a file named ""input.txt"" and send the contents of that file, one line at a time, to the other concurrent unit, which will print the line it receives to standard output. The printing unit must count the number of lines it prints. After the concurrent unit reading the file sends its last line to the printing unit, the reading unit will request the number of lines printed by the printing unit. The reading unit will then print the number of lines printed by the printing unit.

This task requires two-way communication between the concurrent units. All concurrent units must cleanly terminate at the end of the program.
",Python,"import libco
import sys
import os
 
def fail(message):
	print(message)
	sys.exit(1)
 
# These are global variables of this process. All cothreads of this
# process will share these global variables.
reader = None
printer = None
line = {
	'buf': None,	# Not a C string. No terminating '\0'.
	'len': 0,	# Length of line in buffer.
	'cap': 0,	# Maximum capacity of buffer.
}
count = 0		# Number of lines printed.
 
# The reader cothread reads every line of an input file, passes each
# line to the printer cothread, and reports the number of lines.
def reader_entry():
	input = open(""input.txt"", ""r"")
	if input == None:
		fail(""fopen"")
 
	line['buf'] = bytearray(4096)  # New buffer.
	line['len'] = 0  # Start with an empty line.
	line['cap'] = 4096
 
	while True:
		c = input.read(1)  # Read next character.
		if len(c) == 0:
			break
 
		eof = (c == EOF)
		if eof:
			# End of file is also end of line,
			# unless the line would be empty.
			eol = (line['len'] > 0)
		else:
			# Append c to the buffer.
			if line['len'] == line['cap']:
				# Need a bigger buffer!
				newcap = line['cap'] * 2
				newbuf = bytearray(newcap)
				line['buf'] = newbuf
				line['cap'] = newcap
			line['buf'][line['len']] = c
			line['len'] += 1
 
			# '\n' is end of line.
			eol = (c == '\n')
 
		if eol:
			# Pass our complete line to the printer.
			libco.co_switch(printer)
			line['len'] = 0  # Destroy our line.
 
	input.close()
	line['buf'] = None  # Stops a loop in the printer.
 
	print(""Printed %d lines."" % count)
	libco.co_switch(printer)
 
# The printer cothread starts the reader cothread, prints every line
# line from the reader cothread, and counts the number of lines.
def main():
	global reader, printer
	reader = libco.co_create(4096, reader_entry)
	printer = libco.co_active()
	count = 0
 
	while True:
		libco.co_switch(reader)
		if line['buf'] == None:
			break
 
		# Print this line. Count it.
		sys.stdout.write(line['buf'])
		count += 1
 
	libco.co_delete(reader)
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Python,"#Read the maximum number, set to 0 if it couldn't be read
max = int(input())
words = {}
 
#Read input three times for a factor and a word
for i in range(3):
    tokens = input().split(' ')
    words[int(tokens[0])] = tokens[1]
 
#Sort the words so they will be output in arithmetic order
sortedWords = sorted(words.items())
 
#Find the words with matching factors and print them, print the number if no factors match
for i in range(1, max + 1):
    wordsToPrint = [word for factor, word in sortedWords if i % factor == 0]
    if len(wordsToPrint) > 0:
        print(''.join(wordsToPrint))
    else:
        print(i)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Chowla_numbers,Chowla numbers,"Chowla numbers are also known as:

   Chowla's function
   chowla numbers 
   the chowla function
   the chowla number
   the chowla sequence




The chowla number of   n   is   (as defined by Chowla's function):

   the sum of the divisors of   n     excluding unity and   n
   where   n   is a positive integer


The sequence is named after   Sarvadaman D. S. Chowla,   (22 October 1907 ──► 10 December 1995),

a London born Indian American mathematician specializing in number theory.



German mathematician Carl Friedrich Gauss (1777─1855) said:

   ""Mathematics is the queen of the sciences ─ and number theory is the queen of mathematics"".



Definitions

Chowla numbers can also be expressed as:

   
   chowla(n) = sum of divisors of  n  excluding unity and  n
   chowla(n) = sum(       divisors(n))   - 1  -  n 
   chowla(n) = sum( properDivisors(n))   - 1       
   chowla(n) = sum(aliquotDivisors(n))   - 1        
   chowla(n) = aliquot(n)                - 1       
   chowla(n) = sigma(n)                  - 1  -  n 
   chowla(n) = sigmaProperDivisiors(n)   - 1       
 
   chowla(a*b) =  a + b,    if  a  and  b  are distinct primes
   if  chowla(n) =  0,       and n > 1,  then   n   is prime
   if  chowla(n) =  n - 1,  and n > 1,  then   n   is a perfect number
    

Task

   create a   chowla   function that returns the   chowla number   for a positive integer   n
   Find and display   (1 per line)   for the 1st   37   integers:
   the integer   (the index)
   the chowla number for that integer
   For finding primes, use the   chowla   function to find values of zero
   Find and display the   count   of the primes up to              100
   Find and display the   count   of the primes up to           1,000
   Find and display the   count   of the primes up to         10,000
   Find and display the   count   of the primes up to       100,000
   Find and display the   count   of the primes up to    1,000,000
   Find and display the   count   of the primes up to  10,000,000
   For finding perfect numbers, use the   chowla   function to find values of   n - 1
   Find and display all   perfect numbers   up to   35,000,000
   use commas within appropriate numbers
   show all output here




Related tasks

    totient function
    perfect numbers
   Proper divisors
   Sieve of Eratosthenes


See also

   the OEIS entry for   A48050 Chowla's function.

",Python,"# https://docs.sympy.org/latest/modules/ntheory.html#sympy.ntheory.factor_.divisors
from sympy import divisors
 
def chowla(n):
    return 0 if n < 2 else sum(divisors(n, generator=True)) - 1 -n
 
def is_prime(n):
    return chowla(n) == 0
 
def primes_to(n):
    return sum(chowla(i) == 0 for i in range(2, n))
 
def perfect_between(n, m):
    c = 0
    print(f""\nPerfect numbers between [{n:_}, {m:_})"")
    for i in range(n, m):
        if i > 1 and chowla(i) == i - 1:
            print(f""  {i:_}"")
            c += 1
    print(f""Found {c} Perfect numbers between [{n:_}, {m:_})"")
 
 
if __name__ == '__main__':
    for i in range(1, 38):
        print(f""chowla({i:2}) == {chowla(i)}"")
    for i in range(2, 6):
        print(f""primes_to({10**i:_}) == {primes_to(10**i):_}"")
    perfect_between(1, 1_000_000)
    print()
    for i in range(6, 8):
        print(f""primes_to({10**i:_}) == {primes_to(10**i):_}"")
    perfect_between(1_000_000, 35_000_000)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Luhn test of credit card numbers,"The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

 Reverse the order of the digits in the number.
 Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
 Taking the second, fourth ... and every other even digit in the reversed digits:
 Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
 Sum the partial sums of the even digits to form s2
 If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.


For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and

use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



Related tasks

   SEDOL
   ISIN

",Python,">>> def luhn(n):
	r = [int(ch) for ch in str(n)][::-1]
	return (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0
 
>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):
	print(n, luhn(n))",Human_written,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort,Sorting algorithms/Gnome sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Gnome sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Gnome sort is a sorting algorithm which is similar to Insertion sort, except that moving an element to its proper place is accomplished by a series of swaps, as in Bubble Sort.

The pseudocode for the algorithm is:

function gnomeSort(a[0..size-1])
    i := 1
    j := 2
    while i < size do
        if a[i-1] <= a[i] then
            // for descending sort, use >= for comparison
            i := j
            j := j + 1 
        else
            swap a[i-1] and a[i]
            i := i - 1
            if i = 0 then
                i := j
                j := j + 1
            endif
        endif
    done



Task

Implement the Gnome sort in your language to sort an array (or list) of numbers.



",Python,">>> def gnomesort(a):
	i,j,size = 1,2,len(a)
	while i < size:
		if a[i-1] <= a[i]:
			i,j = j, j+1
		else:
			a[i-1],a[i] = a[i],a[i-1]
			i -= 1
			if i == 0:
				i,j = j, j+1
	return a
 
>>> gnomesort([3,4,2,5,1,6])
[1, 2, 3, 4, 5, 6]
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm,Parsing/RPN calculator algorithm,"Task

Create a stack-based evaluator for an expression in   reverse Polish notation (RPN)   that also shows the changes in the stack as each individual token is processed as a table.



 Assume an input of a correct, space separated, string of tokens of an RPN expression
 Test with the RPN expression generated from the   Parsing/Shunting-yard algorithm   task: 

         3 4 2 * 1 5 - 2 3 ^ ^ / + 

 Print or display the output here


Notes

    ^    means exponentiation in the expression above.
    /    means division.


See also

   Parsing/Shunting-yard algorithm for a method of generating an RPN from an infix expression.
   Several solutions to 24 game/Solve make use of RPN evaluators (although tracing how they work is not a part of that task).
   Parsing/RPN to infix conversion.
   Arithmetic evaluation.

",Python,"def op_pow(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a ** b )
def op_mul(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a * b )
def op_div(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a / b )
def op_add(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a + b )
def op_sub(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a - b )
def op_num(stack, num):
    stack.append( num )
 
ops = {
 '^': op_pow,
 '*': op_mul,
 '/': op_div,
 '+': op_add,
 '-': op_sub,
 }
 
def get_input(inp = None):
    'Inputs an expression and returns list of tokens'
 
    if inp is None:
        inp = input('expression: ')
    tokens = inp.strip().split()
    return tokens
 
def rpn_calc(tokens):
    stack = []
    table = ['TOKEN,ACTION,STACK'.split(',')]
    for token in tokens:
        if token in ops:
            action = 'Apply op to top of stack'
            ops[token](stack)
            table.append( (token, action, ' '.join(str(s) for s in stack)) )
        else:
            action = 'Push num onto top of stack'
            op_num(stack, eval(token))
            table.append( (token, action, ' '.join(str(s) for s in stack)) )
    return table
 
if __name__ == '__main__':
    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'
    print( 'For RPN expression: %r\n' % rpn )
    rp = rpn_calc(get_input(rpn))
    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]
    row = rp[0]
    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))
    for row in rp[1:]:
        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))
 
    print('\n The final output value is: %r' % rp[-1][2])",Human_written,Python_from_C++
http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,">>> def fiblike(start):
	addnum = len(start)
	memo = start[:]
	def fibber(n):
		try:
			return memo[n]
		except IndexError:
			ans = sum(fibber(i) for i in range(n-addnum, n))
			memo.append(ans)
			return ans
	return fibber
 
>>> fibo = fiblike([1,1])
>>> [fibo(i) for i in range(10)]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
>>> lucas = fiblike([2,1])
>>> [lucas(i) for i in range(10)]
[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]
>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :
	fibber = fiblike([1] + [2**i for i in range(n-1)])
	print('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))
 
 
n= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...
n= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...
n= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...
n= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...
n= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...
n= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...
n= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...
n= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...
n=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",Python,"import inspect
import types
 
class example(object):
    def Foo(self):
        return 42
 
# create an object with a method
e = example()
# get the method by name
m = inspect.getmembers(e, predicate=inspect.ismethod)[0][1]
# call the method with no argments
r = m()
# interpret first return value as int
print(r) # => 42",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",Python,"'''
I could understand the explanation of the Monty Hall problem
but needed some more evidence
 
References:
  http://www.bbc.co.uk/dna/h2g2/A1054306
  http://en.wikipedia.org/wiki/Monty_Hall_problem especially:
  http://en.wikipedia.org/wiki/Monty_Hall_problem#Increasing_the_number_of_doors
'''
from random import randrange
 
doors, iterations = 3,100000  # could try 100,1000
 
def monty_hall(choice, switch=False, doorCount=doors):
  # Set up doors
  door = [False]*doorCount
  # One door with prize
  door[randrange(doorCount)] = True
 
  chosen = door[choice]
 
  unpicked = door
  del unpicked[choice]
 
  # Out of those unpicked, the alternative is either:
  #   the prize door, or
  #   an empty door if the initial choice is actually the prize.
  alternative = True in unpicked
 
  if switch:
    return alternative
  else:
    return chosen
 
print ""\nMonty Hall problem simulation:""
print doors, ""doors,"", iterations, ""iterations.\n""
 
print ""Not switching allows you to win"",
print sum(monty_hall(randrange(3), switch=False)
          for x in range(iterations)),
print ""out of"", iterations, ""times.""
print ""Switching allows you to win"",
print sum(monty_hall(randrange(3), switch=True)
          for x in range(iterations)),
print ""out of"", iterations, ""times.\n""",Human_written,Python_from_Java
http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ''
# or:
s = str()
 
if not s or s == '':
   print(""String is empty"")
 
if len(s) == 0:
    print(""String is empty"")
else:
    print(""String not empty"")
 
 
# boolean test function for python2 and python3
# test for regular (non-unicode) strings
# unicode strings
# None 
def emptystring(s):
   if isinstance(s, (''.__class__ , u''.__class__) ):
      if len(s) == 0: 
         return True
      else 
         return False
 
   elif s is None:
        return True",Human_written,Python_from_C
http://rosettacode.org/wiki/Define_a_primitive_data_type,Define a primitive data type,"Demonstrate how to define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10. Include all bounds checking you need to write, or explain how the compiler or interpreter creates those bounds checks for you.
",Python,">>> class num(int):
    def __init__(self, b):
        if 1 <= b <= 10:
            return int.__init__(self+0)
        else:
            raise ValueError,""Value %s should be >=0 and <= 10"" % b
 
 
>>> x = num(3)
>>> x = num(11)
 
Traceback (most recent call last):
  File ""<pyshell#394>"", line 1, in <module>
    x = num(11)
  File ""<pyshell#392>"", line 6, in __init__
    raise ValueError,""Value %s should be >=0 and <= 10"" % b
ValueError: Value 11 should be >=0 and <= 10
>>> x
3
>>> type(x)
<class '__main__.num'>
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Proper_divisors,Proper divisors,"The   proper divisors   of a positive integer N are those numbers, other than N itself, that divide N without remainder.

For N > 1 they will always include 1,   but for N == 1 there are no proper divisors.



Examples

The proper divisors of     6     are   1, 2, and 3.

The proper divisors of   100   are   1, 2, 4, 5, 10, 20, 25, and 50.



Task

 Create a routine to generate all the proper divisors of a number.
 use it to show the proper divisors of the numbers 1 to 10 inclusive.
 Find a number in the range 1 to 20,000 with the most proper divisors. Show the number and just the count of how many proper divisors it has.


Show all output here.



Related tasks

   Amicable pairs
   Abundant, deficient and perfect number classifications
   Aliquot sequence classifications
   Factors of an integer
   Prime decomposition

",Python,"# version 1.0.5-2
 
def listProperDivisors(limit):
    if limit < 1:
        return
    for i in range(1, limit + 1):
        print(str(i).rjust(2) + "" -> "", end="""")
        if i == 1:
            print(""(None)"")
            continue
        for j in range(1, i // 2 + 1):
            if i % j == 0:
                print("" "" + str(j), end="""")
        print()
 
def countProperDivisors(n):
    if n < 2:
        return 0
    return len([i for i in range(1, n // 2 + 1) if n % i == 0])
 
print(""The proper divisors of the following numbers are :\n"")
listProperDivisors(10)
print()
count = 0
maxCount = 0
most = [1]
for n in range(2, 20001):
    count = countProperDivisors(n)
    if count == maxCount:
        most.append(n)
    elif count > maxCount:
        maxCount = count
        most = [n]
print(""The following number(s) have the most proper divisors, namely "" + str(maxCount) + ""\n"")
for n in most:
    print(n)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort,Sorting algorithms/Pancake sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of integers (of any convenient size) into ascending order using Pancake sorting.

In short, instead of individual elements being sorted, the only operation allowed is to ""flip"" one end of the list, like so:

          Before:   6 7 8 9 2 5 3 4 1
          After:    9 8 7 6 2 5 3 4 1

Only one end of the list can be flipped; this should be the low end, but the high end is okay if it's easier to code or works better, but it must be the same end for the entire solution. (The end flipped can't be arbitrarily changed.)

Show both the initial, unsorted list and the final sorted list.

(Intermediate steps during sorting are optional.)

Optimizations are optional (but recommended).



Related tasks

   Number reversal game
   Topswops


Also see

   Wikipedia article:   pancake sorting.

",Python,"tutor = False
 
def pancakesort(data):
    if len(data) <= 1:
        return data
    if tutor: print()
    for size in range(len(data), 1, -1):
        maxindex = max(range(size), key=data.__getitem__)
        if maxindex+1 != size:
            # This indexed max needs moving
            if maxindex != 0:
                # Flip the max item to the left
                if tutor: print('With: %r doflip  %i'
                                % ( ' '.join(str(x) for x in data), maxindex+1 ))
                data[:maxindex+1] = reversed(data[:maxindex+1])
            # Flip it into its final position
            if tutor: print('With: %r  doflip %i'
                                % ( ' '.join(str(x) for x in data), size ))
            data[:size] = reversed(data[:size])
    if tutor: print()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Plasma_effect,Plasma effect,"The plasma effect is a visual effect created by applying various functions, notably sine and cosine, to the color values of screen pixels. When animated (not a task requirement) the effect may give the impression of a colorful flowing liquid.



Task
Create a plasma effect.




See also
 Computer Graphics Tutorial (lodev.org)
 Plasma (bidouille.org)

",Python,"import math
import colorsys
from PIL import Image
 
def plasma (w, h):
	out = Image.new(""RGB"", (w, h))
	pix = out.load()
	for x in range (w):
		for y in range(h):
			hue = 4.0 + math.sin(x / 19.0) + math.sin(y / 9.0) \
				+ math.sin((x + y) / 25.0) + math.sin(math.sqrt(x**2.0 + y**2.0) / 8.0)
			hsv = colorsys.hsv_to_rgb(hue/8.0, 1, 1)
			pix[x, y] = tuple([int(round(c * 255.0)) for c in hsv])
	return out
 
if __name__==""__main__"":
	im = plasma(400, 400)
	im.show()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Padovan_sequence,Padovan sequence,"

The Padovan sequence is similar to the Fibonacci sequence in several ways.
Some are given in the table below, and the referenced video shows some of the geometric
similarities.



 Comment 
 Padovan 
 Fibonacci


 
 



 Named after. 
 Richard Padovan 
 Leonardo of Pisa: Fibonacci


 
 



 Recurrence initial values. 
 P(0)=P(1)=P(2)=1 
 F(0)=0, F(1)=1


 Recurrence relation. 
 P(n)=P(n-2)+P(n-3) 
 F(n)=F(n-1)+F(n-2)


 
 



 First 10 terms. 
 1,1,1,2,2,3,4,5,7,9 
 0,1,1,2,3,5,8,13,21,34


 
 



 Ratio of successive terms... 
 Plastic ratio, p 
 Golden ratio, g


 
 1.324717957244746025960908854… 
 1.6180339887498948482...


 Exact formula of ratios p and q. 
 ((9+69**.5)/18)**(1/3) + ((9-69**.5)/18)**(1/3) 
 (1+5**0.5)/2


 Ratio is real root of polynomial. 
 p: x**3-x-1 
 g: x**2-x-1


 
 



 Spirally tiling the plane using. 
 Equilateral triangles 
 Squares


 
 



 Constants for ... 
 s= 1.0453567932525329623 
 a=5**0.5


 ... Computing by truncation. 
 P(n)=floor(p**(n-1) / s + .5) 
 F(n)=floor(g**n / a + .5)


 
 



 L-System Variables. 
 A,B,C 
 A,B


 L-System Start/Axiom. 
 A 
 A


 L-System Rules. 
 A->B,B->C,C->AB 
 A->B,B->AB

Task

 Write a function/method/subroutine to compute successive members of the Padovan series using the recurrence relation.
 Write a function/method/subroutine to compute successive members of the Padovan series using the floor function.
 Show the first twenty terms of the sequence.
 Confirm that the recurrence and floor based functions give the same results for 64 terms,
 Write a function/method/... using the L-system to generate successive strings.
 Show the first 10 strings produced from the L-system
 Confirm that the length of the first 32 strings produced is the Padovan sequence.
Show output here, on this page.

Ref

 The Plastic Ratio - Numberphile video.

",Python,"import math
import sys
 
# Generate the Padovan sequence using the recurrence
# relationship.
def pRec(n):
    memo = {}
    if n in memo:
        return memo[n]
    if n <= 2:
        memo[n] = 1
    else:
        memo[n] = pRec(n-2) + pRec(n-3)
    return memo[n]
 
# Calculate the N'th Padovan sequence using the
# floor function.
def pFloor(n):
    p = 1.324717957244746025960908854
    s = 1.0453567932525329623
    return int(math.pow(p, n-1)/s + 0.5)
 
# Return the N'th L-system string
def lSystem(n):
    memo = {}
    if n in memo:
        return memo[n]
    if n == 0:
        memo[n] = ""A""
    else:
        memo[n] = """"
        for ch in lSystem(n-1):
            if ch == 'A':
                memo[n] += 'B'
            elif ch == 'B':
                memo[n] += 'C'
            elif ch == 'C':
                memo[n] += 'AB'
    return memo[n]
 
# Compare two functions up to p_N
def compare(f1, f2, descr, stop):
    print(""The "" + descr + "" functions "", end="""")
    i = 0
    while i < stop:
        n1 = f1(i)
        n2 = f2(i)
        if n1!= n2:
            print(""do not match at "" + str(i) + "": "" + str(n1) + "" != "" + str(n2) + ""."")
            break
        i += 1
    if i == stop:
        print(""match from P_0 to P_"" + str(stop) + ""."")
 
# Print P_0 to P_19
print(""P_0.. P_19: "", end="""")
for i in range(20):
    print(pRec(i), end="" "")
print()
 
# Check that floor and recurrence match up to P_64
compare(pFloor, pRec, ""floor- and recurrence-based"", 64)
 
# Show first 10 L-system strings
print(""\nThe first 10 L-system strings are:"")
for i in range(10):
    print(lSystem(i))
print()
 
# Check lengths of strings against pFloor up to P_31
compare(pFloor, lambda n: len(lSystem(n)), ""floor- and L-system-based"", 32)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",Python,"from decimal import Decimal as D
from collections import namedtuple
 
Item = namedtuple('Item', 'price, quant')
 
items = dict( hamburger=Item(D('5.50'), D('4000000000000000')),
              milkshake=Item(D('2.86'), D('2')) )
tax_rate = D('0.0765')
 
fmt = ""%-10s %8s %18s %22s""
print(fmt % tuple('Item Price Quantity Extension'.upper().split()))
 
total_before_tax = 0
for item, (price, quant) in sorted(items.items()):
    ext = price * quant
    print(fmt % (item, price, quant, ext))
    total_before_tax += ext
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'subtotal', total_before_tax))
 
tax = (tax_rate * total_before_tax).quantize(D('0.00'))
print(fmt % ('', '', 'Tax', tax))
 
total = total_before_tax + tax
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'Total', total))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Elliptic_curve_arithmetic,Elliptic curve arithmetic,"Elliptic curves   are sometimes used in   cryptography   as a way to perform   digital signatures.

The purpose of this task is to implement a simplified (without modular arithmetic) version of the elliptic curve arithmetic which is required by the   elliptic curve DSA   protocol.

In a nutshell, an elliptic curve is a bi-dimensional curve defined by the following relation between the x and y coordinates of any point on the curve:

   




y

2


=

x

3


+
a
x
+
b


{\displaystyle y^{2}=x^{3}+ax+b}


a and b are arbitrary parameters that define the specific curve which is used.

For this particular task, we'll use the following parameters:

    a=0,   b=7 
The most interesting thing about elliptic curves is the fact that it is possible to define a   group   structure on it.

To do so we define an   internal composition   rule with an additive notation +,   such that for any three distinct points P, Q and R on the curve, whenever these points are aligned, we have:

    P + Q + R = 0  
Here   0   (zero)   is the infinity point,   for which the x and y values are not defined.   It's basically the same kind of point which defines the horizon in   projective geometry.

We'll also assume here that this infinity point is unique and defines the   neutral element   of the addition.

This was not the definition of the addition, but only its desired property.   For a more accurate definition, we proceed as such:

Given any three aligned points P, Q and R,   we define the sum   S = P + Q   as the point (possibly the infinity point) such that   S, R   and the infinity point are aligned.

Considering the symmetry of the curve around the x-axis, it's easy to convince oneself that two points S and R can be aligned with the infinity point if and only if S and R are symmetric of one another towards the x-axis   (because in that case there is no other candidate than the infinity point to complete the alignment triplet).

S is thus defined as the symmetric of R towards the x axis.

The task consists in defining the addition which, for any two points of the curve, returns the sum of these two points.   You will pick two random points on the curve, compute their sum and show that the symmetric of the sum is aligned with the two initial points.

You will use the a and b parameters of secp256k1, i.e. respectively zero and seven.

Hint:   You might need to define a ""doubling"" function, that returns P+P for any given point P.

Extra credit:   define the full elliptic curve arithmetic (still not modular, though) by defining a ""multiply"" function that returns,

for any point P and integer n,   the point P + P + ... + P     (n times).



",Python,"#!/usr/bin/env python3
 
class Point:
    b = 7
    def __init__(self, x=float('inf'), y=float('inf')):
        self.x = x
        self.y = y
 
    def copy(self):
        return Point(self.x, self.y)
 
    def is_zero(self):
        return self.x > 1e20 or self.x < -1e20
 
    def neg(self):
        return Point(self.x, -self.y)
 
    def dbl(self):
        if self.is_zero():
            return self.copy()
        try:
            L = (3 * self.x * self.x) / (2 * self.y)
        except ZeroDivisionError:
            return Point()
        x = L * L - 2 * self.x
        return Point(x, L * (self.x - x) - self.y)
 
    def add(self, q):
        if self.x == q.x and self.y == q.y:
            return self.dbl()
        if self.is_zero():
            return q.copy()
        if q.is_zero():
            return self.copy()
        try:
            L = (q.y - self.y) / (q.x - self.x)
        except ZeroDivisionError:
            return Point()
        x = L * L - self.x - q.x
        return Point(x, L * (self.x - x) - self.y)
 
    def mul(self, n):
        p = self.copy()
        r = Point()
        i = 1
        while i <= n:
            if i&n:
                r = r.add(p)
            p = p.dbl()
            i <<= 1
        return r
 
    def __str__(self):
        return ""({:.3f}, {:.3f})"".format(self.x, self.y)
 
def show(s, p):
    print(s, ""Zero"" if p.is_zero() else p)
 
def from_y(y):
    n = y * y - Point.b
    x = n**(1./3) if n>=0 else -((-n)**(1./3))
    return Point(x, y)
 
# demonstrate
a = from_y(1)
b = from_y(2)
show(""a ="", a)
show(""b ="", b)
c = a.add(b)
show(""c = a + b ="", c)
d = c.neg()
show(""d = -c ="", d)
show(""c + d ="", c.add(d))
show(""a + b + d ="", a.add(b.add(d)))
show(""a * 12345 ="", a.mul(12345))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",Python,"import inspect
 
# Sample classes for inspection
class Super(object):
  def __init__(self, name):
    self.name = name
 
  def __str__(self):
    return ""Super(%s)"" % (self.name,)
 
  def doSup(self):
    return 'did super stuff'
 
  @classmethod
  def cls(cls):
    return 'cls method (in sup)'
 
  @classmethod
  def supCls(cls):
    return 'Super method'
 
  @staticmethod
  def supStatic():
    return 'static method'
 
class Other(object):
  def otherMethod(self):
    return 'other method'
 
class Sub(Other, Super):
  def __init__(self, name, *args):
    super(Sub, self).__init__(name);
    self.rest = args;
    self.methods = {}
 
  def __dir__(self):
    return list(set( \
        sum([dir(base) for base in type(self).__bases__], []) \
        + type(self).__dict__.keys() \
        + self.__dict__.keys() \
        + self.methods.keys() \
      ))
 
  def __getattr__(self, name):
    if name in self.methods:
      if callable(self.methods[name]) and self.methods[name].__code__.co_argcount > 0:
        if self.methods[name].__code__.co_varnames[0] == 'self':
          return self.methods[name].__get__(self, type(self))
        if self.methods[name].__code__.co_varnames[0] == 'cls':
          return self.methods[name].__get__(type(self), type)
      return self.methods[name]
    raise AttributeError(""'%s' object has no attribute '%s'"" % (type(self).__name__, name))
 
  def __str__(self):
    return ""Sub(%s)"" % self.name
 
  def doSub():
    return 'did sub stuff'
 
  @classmethod
  def cls(cls):
    return 'cls method (in Sub)'
 
  @classmethod
  def subCls(cls):
    return 'Sub method'
 
  @staticmethod
  def subStatic():
    return 'Sub method'
 
sup = Super('sup')
sub = Sub('sub', 0, 'I', 'two')
sub.methods['incr'] = lambda x: x+1
sub.methods['strs'] = lambda self, x: str(self) * x
 
# names
[method for method in dir(sub) if callable(getattr(sub, method))]
# instance methods
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == sub]
#['__dir__', '__getattr__', '__init__', '__str__', 'doSub', 'doSup', 'otherMethod', 'strs']
# class methods 
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == type(sub)]
#['__subclasshook__', 'cls', 'subCls', 'supCls']
# static & free dynamic methods
[method for method in dir(sub) if callable(getattr(sub, method)) and type(getattr(sub, method)) == type(lambda:nil)]
#['incr', 'subStatic', 'supStatic']
 
# names & values; doesn't include wrapped, C-native methods
inspect.getmembers(sub, predicate=inspect.ismethod)
# names using inspect
map(lambda t: t[0], inspect.getmembers(sub, predicate=inspect.ismethod))
#['__dir__', '__getattr__', '__init__', '__str__', 'cls', 'doSub', 'doSup', 'otherMethod', 'strs', 'subCls', 'supCls']",Human_written,Python_from_Java
http://rosettacode.org/wiki/Cholesky_decomposition,Cholesky decomposition,"Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:





A
=
L

L

T




{\displaystyle A=LL^{T}}






L


{\displaystyle L}

 is called the Cholesky factor of 



A


{\displaystyle A}

, and can be interpreted as a generalized square root of 



A


{\displaystyle A}

, as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:









A



=


(




a

11





a

21





a

31







a

21





a

22





a

32







a

31





a

32





a

33





)








=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




l

11





l

21





l

31






0



l

22





l

32






0


0



l

33





)


≡
L

L

T








=


(




l

11


2





l

21



l

11





l

31



l

11







l

21



l

11





l

21


2


+

l

22


2





l

31



l

21


+

l

32



l

22







l

31



l

11





l

31



l

21


+

l

32



l

22





l

31


2


+

l

32


2


+

l

33


2





)








{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a_{11}&a_{21}&a_{31}\\a_{21}&a_{22}&a_{32}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}\\&={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}l_{11}&l_{21}&l_{31}\\0&l_{22}&l_{32}\\0&0&l_{33}\end{pmatrix}}\equiv LL^{T}\\&={\begin{pmatrix}l_{11}^{2}&l_{21}l_{11}&l_{31}l_{11}\\l_{21}l_{11}&l_{21}^{2}+l_{22}^{2}&l_{31}l_{21}+l_{32}l_{22}\\l_{31}l_{11}&l_{31}l_{21}+l_{32}l_{22}&l_{31}^{2}+l_{32}^{2}+l_{33}^{2}\end{pmatrix}}\end{aligned}}}


We can see that for the diagonal elements (




l

k
k




{\displaystyle l_{kk}}

) of 



L


{\displaystyle L}

 there is a calculation pattern:






l

11


=



a

11






{\displaystyle l_{11}={\sqrt {a_{11}}}}







l

22


=



a

22


−

l

21


2






{\displaystyle l_{22}={\sqrt {a_{22}-l_{21}^{2}}}}







l

33


=



a

33


−
(

l

31


2


+

l

32


2


)




{\displaystyle l_{33}={\sqrt {a_{33}-(l_{31}^{2}+l_{32}^{2})}}}


or in general:






l

k
k


=



a

k
k


−

∑

j
=
1


k
−
1



l

k
j


2






{\displaystyle l_{kk}={\sqrt {a_{kk}-\sum _{j=1}^{k-1}l_{kj}^{2}}}}


For the elements below the diagonal (




l

i
k




{\displaystyle l_{ik}}

, where 



i
>
k


{\displaystyle i>k}

) there is also a calculation pattern:






l

21


=


1

l

11





a

21




{\displaystyle l_{21}={\frac {1}{l_{11}}}a_{21}}







l

31


=


1

l

11





a

31




{\displaystyle l_{31}={\frac {1}{l_{11}}}a_{31}}







l

32


=


1

l

22




(

a

32


−

l

31



l

21


)


{\displaystyle l_{32}={\frac {1}{l_{22}}}(a_{32}-l_{31}l_{21})}


which can also be expressed in a general formula:






l

i
k


=


1

l

k
k





(

a

i
k


−

∑

j
=
1


k
−
1



l

i
j



l

k
j


)



{\displaystyle l_{ik}={\frac {1}{l_{kk}}}\left(a_{ik}-\sum _{j=1}^{k-1}l_{ij}l_{kj}\right)}


Task description

The task is to implement a routine which will return a lower Cholesky factor 



L


{\displaystyle L}

 for every given symmetric, positive definite nxn matrix 



A


{\displaystyle A}

. You should then test it on the following two examples and include your output.

Example 1:

25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

Example 2:

18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262



Note

 The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. 
 The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.",Python,"def cholesky(array):
	zeros = [[0 for i in range(len(array))] for j in range(len(array))]
	L = [[0 for i in range(len(array))] for j in range(len(array))]
	for r in range(len(array)):
		for c in range(len(array)):
			sum = 0
			for i in range(len(array)):
				if i < c:
					sum += L[r][i] * L[c][i]
			if c < r + 1:
				if r == c:
					L[r][c] = (array[r][r] - sum) ** 0.5
				else:
					L[r][c] = (array[r][c] - sum) / L[c][c]
			else:
				L[r][c] = 0
	return L
 
arr3 = [[25, 15, -5], [15, 18, 0], [-5, 0, 11]]
print(cholesky(arr3))
arr4 = [[18, 22, 54, 42], [22, 70, 86, 62], [54, 86, 174, 134], [42, 62, 134, 106]]
print(cholesky(arr4))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Perfect_shuffle,Perfect shuffle,"A perfect shuffle (or faro/weave shuffle) means splitting a deck of cards into equal halves, and perfectly interleaving them - so that you end up with the first card from the left half, followed by the first card from the right half, and so on:



 7♠ 8♠ 9♠ J♠ Q♠ K♠→7♠  8♠  9♠
  J♠  Q♠  K♠→7♠ J♠ 8♠ Q♠ 9♠ K♠


When you repeatedly perform perfect shuffles on an even-sized deck of unique cards, it will at some point arrive back at its original order. How many shuffles this takes, depends solely on the number of cards in the deck - for example for a deck of eight cards it takes three shuffles:





 original: 

1
2
3
4
5
6
7
8



 after 1st shuffle: 

1
5
2
6
3
7
4
8



 after 2nd shuffle: 

1
3
5
7
2
4
6
8



 after 3rd shuffle: 

1
2
3
4
5
6
7
8




The Task
 Write a function that can perform a perfect shuffle on an even-sized list of values.
 Call this function repeatedly to count how many shuffles are needed to get a deck back to its original order, for each of the deck sizes listed under ""Test Cases"" below.
 You can use a list of numbers (or anything else that's convenient) to represent a deck; just make sure that all ""cards"" are unique within each deck.
 Print out the resulting shuffle counts, to demonstrate that your program passes the test-cases.
Test Cases


 input (deck size) 
 output (number of shuffles required)


 8 
 3


 24 
 11


 52 
 8


 100 
 30


 1020 
 1018


 1024 
 10


 10000 
 300


",Python,"import doctest
import random
 
 
def flatten(lst):
    """"""
    >>> flatten([[3,2],[1,2]])
    [3, 2, 1, 2]
    """"""
    return [i for sublst in lst for i in sublst]
 
def magic_shuffle(deck):
    """"""
    >>> magic_shuffle([1,2,3,4])
    [1, 3, 2, 4]
    """"""
    half = len(deck) // 2 
    return flatten(zip(deck[:half], deck[half:]))
 
def after_how_many_is_equal(shuffle_type,start,end):
    """"""
    >>> after_how_many_is_equal(magic_shuffle,[1,2,3,4],[1,2,3,4])
    2
    """"""
 
    start = shuffle_type(start)
    counter = 1
    while start != end:
        start = shuffle_type(start)
        counter += 1
    return counter
 
def main():
    doctest.testmod()
 
    print(""Length of the deck of cards | Perfect shuffles needed to obtain the same deck back"")
    for length in (8, 24, 52, 100, 1020, 1024, 10000):
        deck = list(range(length))
        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)
        print(""{} | {}"".format(length,shuffles_needed))
 
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",Python,"def calcPi():
    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3
    while True:
        if 4*q+r-t < n*t:
            yield n
            nr = 10*(r-n*t)
            n  = ((10*(3*q+r))//t)-10*n
            q  *= 10
            r  = nr
        else:
            nr = (2*q+r)*l
            nn = (q*(7*k)+2+(r*l))//(t*l)
            q  *= k
            t  *= l
            l  += 2
            k += 1
            n  = nn
            r  = nr
 
import sys
pi_digits = calcPi()
i = 0
for d in pi_digits:
    sys.stdout.write(str(d))
    i += 1
    if i == 40: print(""""); i = 0",Human_written,Python_from_Go
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"def add(x, y):
    return x + y

def mul(x, y):
    return x * y

add(1, mul(2, 3))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Polynomial_regression,Polynomial regression,"Find an approximating polynomial of known degree for a given data.

Example:
For input data:

x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};
y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};

The approximating polynomial is:

3 x2 + 2 x + 1

Here, the polynomial's coefficients are (3, 2, 1).

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.
",Python,">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]
>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]
>>> coeffs = numpy.polyfit(x,y,deg=2)
>>> coeffs
array([ 3.,  2.,  1.])",Human_written,Python_from_C
http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import deque
 
# Create a queue and ""push"" items into it
queue = deque()
queue.append(1)
queue.append(3)
queue.append(5)
 
# ""Pop"" items from the queue in FIFO order
print(queue.popleft()) # 1
print(queue.popleft()) # 3
print(queue.popleft()) # 5
 
# To tell if the queue is empty, we check the length
empty = len(queue) == 0
print(empty) # ""True""
 
# If we try to pop from an empty queue, an exception
# is thrown.
try:
    queue.popleft()
except IndexError:
    print(""Queue empty."")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/String_matching,String matching,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings, demonstrate the following three types of string matching:

   Determining if the first string starts with second string
   Determining if the first string contains the second string at any location
   Determining if the first string ends with the second string


Optional requirements:

   Print the location of the match for part 2
   Handle multiple occurrences of a string for part 2.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"""abcd"".startswith(""ab"") #returns True
""abcd"".endswith(""zn"") #returns False
""bb"" in ""abab"" #returns False
""ab"" in ""abab"" #returns True
loc = ""abab"".find(""bb"") #returns -1
loc = ""abab"".find(""ab"") #returns 0
loc = ""abab"".find(""ab"",loc+1) #returns 2",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Extensible_prime_generator,Extensible prime generator,"Task

Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.

The routine should demonstrably rely on either:

 Being based on an open-ended counter set to count without upper limit other than system or programming language limits. In this case, explain where this counter is in the code.
 Being based on a limit that is extended automatically. In this case, choose a small limit that ensures the limit will be passed when generating some of the values to be asked for below.
 If other methods of creating an extensible prime generator are used, the algorithm's means of extensibility/lack of limits should be stated.


The routine should be used to:

 Show the first twenty primes.
 Show the primes between 100 and 150.
 Show the number of primes between 7,700 and 8,000.
 Show the 10,000th prime.


Show output on this page.

Note: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).

Note 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).

Note 3:The task is written so it may be useful in solving the task   Emirp primes   as well as others (depending on its efficiency).





Reference

 Prime Numbers. Website with large count of primes.

",Python,"islice(count(7), 0, None, 2)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Sierpinski_triangle/Graphical,Sierpinski triangle/Graphical,"Produce a graphical representation of a Sierpinski triangle of order N in any orientation.

An example of Sierpinski's triangle (order = 8) looks like this: 



",Python,"import numpy as np
import matplotlib.pyplot as plt

def sierpinski(order):
    width = 1 << order
    margin = 10
    bounds = np.array([[-margin, -margin], [width+2*margin, width+2*margin]])
    im = np.ones(bounds.shape)
    for y in range(width):
        for x in range(width):
            if x&y == 0:
                im[x, y] = 0
    return im

plt.imshow(sierpinski(8), cmap='gray')
plt.show()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation,Horner's rule for polynomial evaluation,"A fast scheme for evaluating a polynomial such as:

 



−
19
+
7
x
−
4

x

2


+
6

x

3





{\displaystyle -19+7x-4x^{2}+6x^{3}\,}


when

 



x
=
3



{\displaystyle x=3\;}

.
is to arrange the computation as follows:

 



(
(
(
(
0
)
x
+
6
)
x
+
(
−
4
)
)
x
+
7
)
x
+
(
−
19
)



{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\;}


And compute the result from the innermost brackets outwards as in this pseudocode:

coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.
Cf. Formal power series
",Python,">>> def horner(coeffs, x):
	acc = 0
	for c in reversed(coeffs):
		acc = acc * x + c
	return acc
 
>>> horner( (-19, 7, -4, 6), 3)
128",Human_written,Python_from_Go
http://rosettacode.org/wiki/Forest_fire,Forest fire,"

 This page uses content from Wikipedia. The original article was at Forest-fire model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Drossel and Schwabl definition of the forest-fire model.



It is basically a 2D   cellular automaton   where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)

 A burning cell turns into an empty cell
 A tree will burn if at least one neighbor is burning
 A tree ignites with probability   f    even if no neighbor is burning
 An empty space fills with a tree with probability    p 

Neighborhood is the   Moore neighborhood;   boundary conditions are so that on the boundary the cells are always empty (""fixed"" boundary condition).

At the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.

Task's requirements do not include graphical display or the ability to change parameters (probabilities    p    and    f )   through a graphical or command line interface.



Related tasks

   See   Conway's Game of Life 
   See   Wireworld.

",Python,"'''
Forest-Fire Cellular automation
 See: http://en.wikipedia.org/wiki/Forest-fire_model
'''
 
L = 15
# d = 2 # Fixed
initial_trees = 0.55
p = 0.01
f = 0.001
 
try:
    raw_input
except:
    raw_input = input
 
import random
 
 
tree, burning, space = 'TB.'
hood = ((-1,-1), (-1,0), (-1,1),
        (0,-1),          (0, 1),
        (1,-1),  (1,0),  (1,1))
 
def initialise():
    grid = {(x,y): (tree if random.random()<= initial_trees else space)
            for x in range(L)
            for y in range(L) }
    return grid
 
def gprint(grid):
    txt = '\n'.join(''.join(grid[(x,y)] for x in range(L))
                    for y in range(L))
    print(txt)
 
def quickprint(grid):
    t = b = 0
    ll = L * L
    for x in range(L):
        for y in range(L):
            if grid[(x,y)] in (tree, burning):
                t += 1
                if grid[(x,y)] == burning:
                    b += 1
    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'
          + ' (%6.3f%%, %6.3f%%)')
          % (ll, t, b, 100. * t / ll, 100. * b / ll))
 
 
def gnew(grid):
    newgrid = {}
    for x in range(L):
        for y in range(L):
            if grid[(x,y)] == burning:
                newgrid[(x,y)] = space
            elif grid[(x,y)] == space:
                newgrid[(x,y)] = tree if random.random()<= p else space
            elif grid[(x,y)] == tree:
                newgrid[(x,y)] = (burning
                                   if any(grid.get((x+dx,y+dy),space) == burning
                                            for dx,dy in hood)
                                        or random.random()<= f 
                                   else tree)
    return newgrid
 
if __name__ == '__main__':
    grid = initialise()
    iter = 0
    while True:
        quickprint(grid)
        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()
        if inp:
            if inp[0] == 'p':
                gprint(grid)
            elif inp.isdigit():
                for i in range(int(inp)):
                    iter +=1
                    grid = gnew(grid)
                    quickprint(grid)
            elif inp[0] == 'q':
                break
        grid = gnew(grid)
        iter +=1",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Check_that_file_exists,Check that file exists,"Task

Verify that a file called     input.txt     and   a directory called     docs     exist.



This should be done twice:  

   once for the current working directory,   and
   once for a file and a directory in the filesystem root.


Optional criteria (May 2015):   verify it works with:

   zero-length files
   an unusual filename:     `Abdu'l-Bahá.txt  

",Python,"# version 1.0.6
 
import os
 
filePaths = [""input.txt"", ""c:\\input.txt"", ""zero_length.txt"", ""`Abdu'l-Bahá.txt""]
dirPaths = [""docs"", ""c:\\docs""]
for filePath in filePaths:
    f = os.path.join(filePath)
    print(f""{filePath} {'exists' if os.path.exists(f) and not os.path.isdir(f) else 'does not exist'}"")
for dirPath in dirPaths:
    d = os.path.join(dirPath)
    print(f""{dirPath} {'exists' if os.path.exists(d) and os.path.isdir(d) else 'does not exist'}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/First-class_functions,First-class functions,"A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

 Create new functions from preexisting functions at run-time
 Store functions in collections
 Use functions as arguments to other functions
 Use functions as return values of other functions


Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections ""A"" and ""B"". These names are only used in the preceding paragraph for clarity.)



Related task
 
First-class Numbers
",Python,"from __future__ import division
from math import cos, tan, acos, atan, sqrt

def compose(f, g):
	return lambda x: f(g(x))

functions = [cos, tan, lambda x: x * x]
inverse = [acos, atan, sqrt]

print ""Compositions:""
for i in range(len(functions)):
	print compose(functions[i], inverse[i])(0.5)

print ""Hard-coded compositions:""
print cos(acos(0.5))
print tan(atan(0.5))
print pow(sqrt(0.5), 2)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Currying,Currying,"

 This page uses content from Wikipedia. The original article was at Currying. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Create a simple demonstrative example of Currying in a specific language.

Add any historic details as to how the feature made its way into the language.



",Python,"def addN(n):
    def curry(x):
        return x + n
    return curry

add2 = addN(2)
print(add2)
print(add2(7))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Non-decimal_radices/Output,Non-decimal radices/Output,"Programming languages often have built-in routines to convert a non-negative integer for printing in different number bases. Such common number bases might include binary, Octal and Hexadecimal.



Task

Print a small range of integers in some different bases, as supported by standard routines of your programming language.



Note

This is distinct from Number base conversion as a user-defined conversion function is not asked for.)

The reverse operation is Common number base parsing.



",Python,"bases = [2, 8, 10, 16, 24]
for n in range(34):
    row = []
    for i in range(len(bases)):
        row.append(str(n).format(bases[i]))
    print(', '.join(row))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Factors of a Mersenne number,"A Mersenne number is a number in the form of 2P-1.

If P is prime, the Mersenne number may be a Mersenne prime
(if P is not prime, the Mersenne number is also not prime).

In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, Lucas-Lehmer test.

There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1).
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).

The following is how to implement this modPow yourself:

For example, let's compute 223 mod 47.
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it.
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47.
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1.
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.)
Since we've shown that 47 is a factor, 223-1 is not prime.
Further properties of Mersenne numbers allow us to refine the process even more.
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8.
Finally any potential factor q must be prime.
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).

These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.



Task

Using the above method find a factor of 2929-1 (aka M929)



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division


See also

   Computers in 1948: 2127 - 1 
       (Note:   This video is no longer available because the YouTube account associated with this video has been terminated.)

",Python,"from prime import is_prime
from math import sqrt
 
def mersenne_factor(p):
    limit = sqrt(2**p - 1)
    k = 1
    while (2*k*p - 1) < limit:
        q = 2*k*p + 1
        if is_prime(q) and (q % 8 == 1 or q % 8 == 7) and trial_factor(2,p,q):
            # q is a factor of 2**p-1
            return q
        k += 1
    return None
 
def trial_factor(base, exp, mod):
    square = 1
    for bit in ""%b"" % exp:
        square = square**2 * (1 if bit == ""1"" else base) % mod
    return (square == 1)
 
def check_mersenne(p):
    print ""M%d = 2**%d-1 is "" % (p, p),
    f = mersenne_factor(p)
    if f is None:
        print ""prime""
    else:
        print ""composite with factor %d"" % f
 
for p in range(3, 54):
    check_mersenne(p)
check_mersenne(929)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Spinning_rod_animation/Text,Spinning rod animation/Text,"Task

An animation with the following frames in the following order (if certain characters aren't available or can't be used correctly in the programming language, alternate characters can replace any of these frames) must animate with a delay of 0.25 seconds between each frame, with the previous frame being cleared before the next frame appears: 

   |
   /
   - or ─
   \



A stand-alone version that loops and/or a version that doesn't loop can be made. These examples can also be converted into a system used in game development which is called on a HUD or GUI element requiring it to be called each frame to output the text, and advance the frame when the frame delay has passed. You can also use alternate text such as the . animation ( . | .. | ... | .. | repeat from . ) or the logic can be updated to include a ping/pong style where the frames advance forward, reach the end and then play backwards and when they reach the beginning they start over ( technically, you'd stop one frame prior to prevent the first frame playing twice, or write it another way ).



There are many different ways you can incorporate text animations. Here are a few text ideas - each frame is in quotes. If you can think of any, add them to this page! There are 2 examples for several of these; the first is the base animation with only unique sets of characters. The second consists of the primary set from a - n and doubled, minus the first and last element ie: We only want the center. This way an animation can play forwards, and then in reverse ( ping ponging ) without having to code that feature. For the animations with 3 elements, we only add 1, the center. with 4, it becomes 6. with 10, it becomes 18.



We don't need the second option for some of the animations if they connect smoothly, when animated, back to the first element. ... doesn't connect with . cleanly - there is a large leap. The rotating pipe meets the first perfectly so it isn't necessary, etc..





   Dots - Option A requires ping / pong enabled script. Option B just adds the elements in the center.
   '.', '..', '...'
   '.', '..', '...', '..'
   Pipe - This has the uniform sideways pipe instead of a hyphen to prevent non-uniform sizing.
   '|', '/', '─', '\'
   Stars - Option A requires ping / pong enabled script. Option B just adds the elements from the center.
   '⁎', '⁑', '⁂'
   '⁎', '⁑', '⁂', '⁑'
   Clock - These need to be ordered. I haven't done this yet as the application I was testing the system in doesn't support these wingdings / icons. But this would look quite nice and you could set it up to go forward, or backward during an undo process, etc..
   '🕛', '🕧', '🕐', '🕜', '🕑', '🕝', '🕒', '🕞', '🕓', '🕟', '🕔', '🕠', '🕕', '🕖', '🕗', '🕘', '🕙', '🕚', '🕡', '🕢', '🕣', '🕤', '🕥', '🕦'
   Arrows:
   '⬍', '⬈', '➞', '⬊', '⬍', '⬋', '⬅', '⬉'
   Bird - This looks decent but may be missing something.
   '︷', '︵', '︹', '︺', '︶', '︸'
   '︷', '︵', '︹', '︺', '︶', '︸', '︶', '︺', '︹', '︵'
   Plants - This isn't quite complete
   '☘', '❀', '❁'
   '☘', '❀', '❁', '❀'
   Eclipse - From Raku Throbber post author
   '🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'

",Python,"from time import sleep
while True:
    for rod in r'\|/-':
        print(rod, end='\r')
        sleep(0.25)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Currying,Currying,"

 This page uses content from Wikipedia. The original article was at Currying. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Create a simple demonstrative example of Currying in a specific language.

Add any historic details as to how the feature made its way into the language.



",Python,"def addN(n):
     def adder(x):
         return x + n
     return adder",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Hello_world/Newbie,Hello world/Newbie,"Task

Guide a new user of a language through the steps necessary
to install the programming language and selection of a text editor if needed,
to run the languages' example in the Hello world/Text task.

 Assume the language-newbie is a programmer in another language.
 Assume the language-newbie is competent in installing software for the platform.
 Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor).
 Refer to, (and link to), already existing documentation as much as possible (but provide a summary here).
 Remember to state where to view the output.
 If particular IDE's or editors are required that are not standard, then point to/explain their installation too.


Note:
 If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated.
 You may use sub-headings if giving instructions for multiple platforms.

",Python,>>> print('hello world'),Human_written,Python_from_C#
http://rosettacode.org/wiki/Hamming_numbers,Hamming numbers,"Hamming numbers are numbers of the form  

    H = 2i × 3j × 5k
           where 
     i,  j,  k  ≥  0 

Hamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).



Task

Generate the sequence of Hamming numbers, in increasing order.   In particular:

 Show the   first twenty   Hamming numbers.
 Show the   1691st   Hamming number (the last one below   231).
 Show the   one millionth   Hamming number (if the language – or a convenient library – supports arbitrary-precision integers).


Related tasks

 Humble numbers
 N-smooth numbers


References

 Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
 Wikipedia entry:   Smooth number
 OEIS entry:   A051037   5-smooth   or   Hamming numbers
 Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

",Python,"def hamming():
    queues = {2: [], 3: [], 5: []}
    base = None
    next_ham = 1
    while True:
        yield next_ham
        for base in queues:
            queues[base].append(next_ham * base)
        next_ham = min(queue[0] for queue in queues.values())
        for base in queues:
            if queues[base][0] == next_ham:
                queues[base].pop(0)

ham = hamming()
first20 = []
for i in range(1, 21):
    first20.append(next(ham))
print(', '.join(map(str, first20)))
print('...')
for i in range(21, 1691):
    next(ham)
print(str(i) + "" => "" + str(next(ham)))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Range_expansion,Range expansion,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).



Task

Expand the range description:

  -6,-3--1,3-5,7-11,14,15,17-20 

Note that the second element above,
is the range from minus 3 to minus 1. 



Related task

   Range extraction

",Python,"def rangeexpand(txt):
    lst = []
    for r in txt.split(','):
        if '-' in r[1:]:
            r0, r1 = r[1:].split('-', 1)
            lst += range(int(r[0] + r0), int(r1) + 1)
        else:
            lst.append(int(r))
    return lst
 
print(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))",Human_written,Python_from_C
http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",Python,"class Example(object):
     def foo(self, x):
             return 42 + x
 
name = ""foo""
getattr(Example(), name)(5)      # => 47",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",Python,"def fix_price(num):
    if 0.96 <= num <= 1.00:
        return 1.00
    elif 0.91 <= num <= 0.96:
        return 0.98
    elif 0.86 <= num <= 0.91:
        return 0.94
    elif 0.81 <= num <= 0.86:
        return 0.90
    elif 0.76 <= num <= 0.81:
        return 0.86
    elif 0.71 <= num <= 0.76:
        return 0.82
    elif 0.66 <= num <= 0.71:
        return 0.78
    elif 0.61 <= num <= 0.66:
        return 0.74
    elif 0.56 <= num <= 0.61:
        return 0.70
    elif 0.51 <= num <= 0.56:
        return 0.66
    elif 0.46 <= num <= 0.51:
        return 0.62
    elif 0.41 <= num <= 0.46:
        return 0.58
    elif 0.36 <= num <= 0.41:
        return 0.54
    elif 0.31 <= num <= 0.36:
        return 0.50
    elif 0.26 <= num <= 0.31:
        return 0.44
    elif 0.21 <= num <= 0.26:
        return 0.38
    elif 0.16 <= num <= 0.21:
        return 0.32
    elif 0.11 <= num <= 0.16:
        return 0.26
    elif 0.06 <= num <= 0.11:
        return 0.18
    elif 0.00 <= num <= 0.06:
        return 0.10
    else:
        raise ValueError(""Invalid value"")
 
n = 0.04
while n <= 1.00:
    print(f""{n:.2f} => {fix_price(n)}"")
    n += 0.04
 
# and a unit test to check that we haven't forgotten a branch, use 'python -m unittest' to execute test.
#
# typically this could be included in the match as those check for exhaustiveness already
# by explicitly listing all remaining ranges / values instead of a catch-all underscore (_)
# but f64::NaN, f64::INFINITY and f64::NEG_INFINITY can't be matched like this
class TestExhaustiveness(unittest.TestCase):
    def test_exhaustiveness(self):
        input_price = 0.
        while input_price <= 1.:
            fix_price(input_price)
            input_price += 0.01",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Create_a_file,Create a file,"In this task, the job is to create a new empty file called ""output.txt"" of size 0 bytes
and an empty directory called ""docs"". This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.
",Python,"import os
import sys
 
FILE_NAME = ""output.txt""
DIR_NAME = ""docs""
 
def create(root):
    f_path = os.path.join(root, FILE_NAME)
    d_path = os.path.join(root, DIR_NAME)
    try:
        os.makedirs(d_path)
    except OSError:
        pass
    try:
        return open(f_path, ""w"")
    except IOError as e:
        error_handler(e, 1)
 
def error_handler(error, code):
    sys.stderr.write(""Error: {}\n"".format(error))
    sys.exit(code)
 
if __name__ == ""__main__"":
    create(""."")
    create(""/"")",Ai_generated,Python_from_Rust
"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
with open(""daynames.txt"") as f:
    for line in f:
        line = line.strip()
        if not line:
            continue
        abbr = re.findall(r""\b\w"", line)
        print(""Minimum size: {}"".format(len(abbr)))
        print(abbr)
        print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Galton_box_animation,Galton box animation," Example of a Galton Box at the end of animation.


A   Galton device   Sir Francis Galton's device   is also known as a   bean machine,   a   Galton Board,   or a   quincunx.



Description of operation

In a Galton box, there are a set of pins arranged in a triangular pattern.   A number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin.   The ball continues to fall to the left or right of lower pins before arriving at one of the collection points between and to the sides of the bottom row of pins.

Eventually the balls are collected into bins at the bottom   (as shown in the image),   the ball column heights in the bins approximate a   bell curve.   Overlaying   Pascal's triangle   onto the pins shows the number of different paths that can be taken to get to each bin.



Task

Generate an animated simulation of a Galton device.



Task requirements

   The box should have at least 5 pins on the bottom row. 
   A solution can use graphics or ASCII animation. 
   Provide a sample of the output/display such as a screenshot.
   There can be one or more balls in flight at the same time. 
   If multiple balls are in flight, ensure they don't interfere with each other.
   A solution should allow users to specify the number of balls, or it should run until full or a preset limit. 
   Optionally,   display the number of balls.

",Python,"#!/usr/bin/python
 
import sys, os
import random
import time
 
def print_there(x, y, text):
     sys.stdout.write(""\x1b7\x1b[%d;%df%s\x1b8"" % (x, y, text))
     sys.stdout.flush()
 
 
class Ball():
    def __init__(self):
        self.x = 0
        self.y = 0
 
    def update(self):
        self.x += random.randint(0,1)
        self.y += 1
 
    def fall(self):
        self.y +=1
 
 
class Board():
    def __init__(self, width, well_depth, N):
        self.balls = []
        self.fallen = [0] * (width + 1)
        self.width = width
        self.well_depth = well_depth
        self.N = N
        self.shift = 4
 
    def update(self):
        for ball in self.balls:
            if ball.y < self.width:
                ball.update()
            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:
                ball.fall()
            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:
                self.fallen[ball.x] += 1
            else:
                pass
 
    def balls_on_board(self):
        return len(self.balls) - sum(self.fallen)
 
    def add_ball(self):
        if(len(self.balls) <= self.N):
            self.balls.append(Ball())
 
    def print_board(self):
        for y in range(self.width + 1):
            for x in range(y):
                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, ""#"")
    def print_ball(self, ball):
        if ball.y <= self.width:
            x = self.width - ball.y + 2*ball.x + self.shift
        else:
            x = 2*ball.x + self.shift
        y = ball.y + 1
        print_there(y, x, ""*"")
 
    def print_all(self):
        print(chr(27) + ""[2J"")
        self.print_board();
        for ball in self.balls:
            self.print_ball(ball)
 
 
def main():
    board = Board(width = 15, well_depth = 5, N = 10)
    board.add_ball() #initialization
    while(board.balls_on_board() > 0):
         board.print_all()
         time.sleep(0.25)
         board.update()
         board.print_all()
         time.sleep(0.25)
         board.update()
         board.add_ball()
 
 
if __name__==""__main__"":
    main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm,Trabb Pardo–Knuth algorithm,"The TPK algorithm is an early example of a programming chrestomathy.
It was used in Donald Knuth and Luis Trabb Pardo's Stanford tech report The Early Development of Programming Languages.
The report traces the early history of work in developing computer languages in the 1940s and 1950s, giving several translations of the algorithm.

From the wikipedia entry:

ask for 11 numbers to be read into a sequence S
reverse sequence S
for each item in sequence S
    result := call a function to do an operation
    if result overflows
        alert user
    else
        print result

The task is to implement the algorithm:

 Use the function:     



f
(
x
)
=

|

x


|


0.5


+
5

x

3




{\displaystyle f(x)=|x|^{0.5}+5x^{3}}


 The overflow condition is an answer of greater than 400.
 The 'user alert' should not stop processing of other items of the sequence.
 Print a prompt before accepting eleven, textual, numeric inputs.
 You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
 The sequence    S    may be 'implied' and so not shown explicitly.
 Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).

",Python,"Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> def f(x): return abs(x) ** 0.5 + 5 * x**3
 
>>> print(', '.join('%s:%s' % (x, v if v<=400 else ""TOO LARGE!"")
	           for x,v in ((y, f(float(y))) for y in input('\nnumbers: ').strip().split()[:11][::-1])))
 
11 numbers: 1 2 3 4 5 6 7 8 9 10 11
11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Runtime_evaluation,Runtime evaluation,"Task

Demonstrate a language's ability for programs to execute code written in the language provided at runtime.

Show what kind of program fragments are permitted (e.g. expressions vs. statements), and how to get values in and out (e.g. environments, arguments, return values), if applicable what lexical/static environment the program is evaluated in, and what facilities for restricting (e.g. sandboxes, resource limits) or customizing (e.g. debugging facilities) the execution.

You may not invoke a separate evaluator program, or invoke a compiler and then its output, unless the interface of that program, and the syntax and means of executing it, are considered part of your language/library/platform.

For a more constrained task giving a specific program fragment to evaluate, see Eval in environment.



",Python,"a, b = 5, -7
ans = abs(a * b)  # => 35",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Simple_windowed_application,Simple windowed application,"Task

Create a window that has:

   a label that says   ""There have been no clicks yet"" 
   a button that says   ""click me""


Upon clicking the button with the mouse, the label should change and show the number of times the button has been clicked.



",Python,"from functools import partial
import tkinter as tk
 
def on_click(label: tk.Label,
             counter: tk.IntVar) -> None:
    counter.set(counter.get() + 1)
    label[""text""] = f""Number of clicks: {counter.get()}""
 
def main():
    window = tk.Tk()
    window.geometry(""200x50+100+100"")
    label = tk.Label(master=window,
                     text=""There have been no clicks yet"")
    label.pack()
    counter = tk.IntVar()
    update_counter = partial(on_click,
                             label=label,
                             counter=counter)
    button = tk.Button(master=window,
                       text=""click me"",
                       command=update_counter)
    button.pack()
    window.mainloop()
 
if __name__ == '__main__':
    main()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Parsing/Shunting-yard_algorithm,Parsing/Shunting-yard algorithm,"Task

Given the operator characteristics and input from the Shunting-yard algorithm page and tables, use the algorithm to show the changes in the operator stack and RPN output
as each individual token is processed.

 Assume an input of a correct, space separated, string of tokens representing an infix expression
 Generate a space separated output string representing the RPN
 Test with the input string:
  3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3  
 print and display the output here.
 Operator precedence is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



Extra credit
Add extra text explaining the actions and an optional comment for the action on receipt of each token.



Note
The handling of functions and arguments is not required.



See also

 Parsing/RPN calculator algorithm for a method of calculating a final value from this output RPN expression.
 Parsing/RPN to infix conversion.

",Python,"from collections import namedtuple
from pprint import pprint as pp
 
OpInfo = namedtuple('OpInfo', 'prec assoc')
L, R = 'Left Right'.split()
 
ops = {
 '^': OpInfo(prec=4, assoc=R),
 '*': OpInfo(prec=3, assoc=L),
 '/': OpInfo(prec=3, assoc=L),
 '+': OpInfo(prec=2, assoc=L),
 '-': OpInfo(prec=2, assoc=L),
 '(': OpInfo(prec=9, assoc=L),
 ')': OpInfo(prec=0, assoc=L),
 }
 
NUM, LPAREN, RPAREN = 'NUMBER ( )'.split()
 
 
def get_input(inp = None):
    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'
 
    if inp is None:
        inp = input('expression: ')
    tokens = inp.strip().split()
    tokenvals = []
    for token in tokens:
        if token in ops:
            tokenvals.append((token, ops[token]))
        #elif token in (LPAREN, RPAREN):
        #    tokenvals.append((token, token))
        else:    
            tokenvals.append((NUM, token))
    return tokenvals
 
def shunting(tokenvals):
    outq, stack = [], []
    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]
    for token, val in tokenvals:
        note = action = ''
        if token is NUM:
            action = 'Add number to output'
            outq.append(val)
            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )
        elif token in ops:
            t1, (p1, a1) = token, val
            v = t1
            note = 'Pop ops from stack to output' 
            while stack:
                t2, (p2, a2) = stack[-1]
                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):
                    if t1 != RPAREN:
                        if t2 != LPAREN:
                            stack.pop()
                            action = '(Pop op)'
                            outq.append(t2)
                        else:    
                            break
                    else:        
                        if t2 != LPAREN:
                            stack.pop()
                            action = '(Pop op)'
                            outq.append(t2)
                        else:    
                            stack.pop()
                            action = '(Pop & discard ""("")'
                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )
                            break
                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )
                    v = note = ''
                else:
                    note = ''
                    break
                note = '' 
            note = '' 
            if t1 != RPAREN:
                stack.append((token, val))
                action = 'Push op token to stack'
            else:
                action = 'Discard "")""'
            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )
    note = 'Drain stack to output'
    while stack:
        v = ''
        t2, (p2, a2) = stack[-1]
        action = '(Pop op)'
        stack.pop()
        outq.append(t2)
        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )
        v = note = ''
    return table
 
if __name__ == '__main__':
    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'
    print( 'For infix expression: %r\n' % infix )
    rp = shunting(get_input(infix))
    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]
    row = rp[0]
    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))
    for row in rp[1:]:
        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))
 
    print('\n The final output RPN is: %r' % rp[-1][2])",Human_written,Python_from_C#
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"Python 3.2.3 (default, May  3 2012, 15:54:42) 
[GCC 4.6.3] on linux2
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> help('pprint.pprint')
Help on function pprint in pprint:
 
pprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)
    Pretty-print a Python object to a stream [default is sys.stdout].
 
>>> from pprint import pprint
>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),
	          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),
	          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:
	print(""\nTree %r can be pprint'd as:"" % (tree, ))
	pprint(tree, indent=1, width=1)
 
 
 
Tree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:
(1,
 2,
 3,
 4,
 5,
 6,
 7,
 8)
 
Tree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:
(1,
 ((2,
   3),
  (4,
   (5,
    ((6,
      7),
     8)))))
 
Tree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:
((((1,
    2),
   3),
  4),
 5,
 6,
 7,
 8)
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Menu,Menu,"Task

Given a prompt and a list containing a number of strings of which one is to be selected, create a function that:

 prints a textual menu formatted as an index value followed by its corresponding string for each item in the list;
 prompts the user to enter a number;
 returns the string corresponding to the selected index number.


The function should reject input that is not an integer or is out of range by redisplaying the whole menu before asking again for a number. The function should return an empty string if called with an empty list.

For test purposes use the following four phrases in a list:

   fee fie
   huff and puff
   mirror mirror
   tick tock

Note

This task is fashioned after the action of the Bash select statement.
",Python,"import sys
 
def menu_select(items, prompt):
	if items == None:
		return None
	i = 0
	while True:
		for i in range(0, len(items)):
			print ""%d) %s"" % (i + 1, items[i])
		choice_max = i
		if prompt!= None:
			print ""%s "" % prompt
		else:
			print ""Choice? ""
		buf = sys.stdin.readline()
		choice = int(buf)
		if 1 > choice or choice > choice_max:
			continue
		else:
			break
	return items[choice - 1]
 
if __name__ == ""__main__"":
	items = [""fee fie"", ""huff and puff"", ""mirror mirror"", ""tick tock""]
	prompt = ""Which is from the three pigs?""
	print ""You chose %s."" % menu_select(items, prompt)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Bioinformatics/Sequence_mutation,Bioinformatics/Sequence mutation,"Task

Given a string of characters A, C, G, and T representing a DNA sequence write a routine to mutate the sequence, (string) by:

 Choosing a random base position in the sequence.
 Mutate the sequence by doing one of either:
 Swap the base at that position by changing it to one of A, C, G, or T. (which has a chance of swapping the base for the same base)
 Delete the chosen base at the position.
 Insert another base randomly chosen from A,C, G, or T into the sequence at that position.
 Randomly generate a test DNA sequence of at least 200 bases
 ""Pretty print"" the sequence and a count of its size, and the count of each base in the sequence
 Mutate the sequence ten times.
 ""Pretty print"" the sequence after all mutations, and a count of its size, and the count of each base in the sequence.
Extra credit

 Give more information on the individual mutations applied.
 Allow mutations to be weighted and/or chosen.",Python,"import random
import string
 
bases = ""ACGT""
 
def mutate(dna, w):
    le = len(dna)
    p = random.randint(0, le-1)
    r = random.randint(0, 299)
    bytes = list(dna)
    if r < w[0]: # swap
        base = random.choice(bases)
        print(""  Change @%3d %q to %q"" % (p, bytes[p], base))
        bytes[p] = base
    elif r < w[0]+w[1]: # delete
        print(""  Delete @%3d %q"" % (p, bytes[p]))
        del bytes[p]
    else: # insert
        base = random.choice(bases)
        bytes.insert(p, base)
        print(""  Insert @%3d %q"" % (p, base))
    return """".join(bytes)
 
def generate(le):
    return """".join(random.choice(bases) for _ in range(le))
 
def pretty_print(dna, row_len):
    print(""SEQUENCE:"")
    le = len(dna)
    for i in range(0, le, row_len):
        k = i + row_len
        if k > le:
            k = le
        print(""%5d: %s"" % (i, dna[i:k]))
    base_map = {} # allows for 'any' base
    for i in range(le):
        base_map[dna[i]] = base_map.get(dna[i], 0) + 1
    bases = sorted(base_map.keys())
    print(""\nBASE COUNT:"")
    for base in bases:
        print(""    %c: %3d"" % (base, base_map[base]))
    print(""    ------"")
    print(""    Σ:"", le)
    print(""    ======\n"")
 
def wstring(w):
    return ""  Change: %d\n  Delete: %d\n  Insert: %d\n"" % (w[0], w[1], w[2])
 
if __name__ == ""__main__"":
    dna = generate(250)
    pretty_print(dna, 50)
    muts = 10
    w = [100, 100, 100] # use e.g. [0, 300, 0] to choose only deletions
    print(""WEIGHTS (ex 300):"")
    print(wstring(w))
    print(""MUTATIONS (%d):"" % muts)
    for i in range(muts):
        dna = mutate(dna, w)
    print()
    pretty_print(dna, 50)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Bulls_and_cows,Bulls and cows,"Bulls and Cows


Task

Create a four digit random number from the digits   1   to   9,   without duplication.

The program should:

   ask for guesses to this number
   reject guesses that are malformed
   print the score for the guess


The score is computed as:

 The player wins if the guess is the same as the randomly chosen number, and the program ends.
 A score of one bull is accumulated for each digit in the guess that equals the corresponding digit in the randomly chosen initial number.
 A score of one cow is accumulated for each digit in the guess that also appears in the randomly chosen number, but in the wrong position.


Related tasks

   Bulls and cows/Player
   Guess the number
   Guess the number/With Feedback
   Mastermind

",Python,"import random
 
def contains_duplicates(s):
    s = sorted(s)
    return any(s[i] == s[i+1] for i in range(len(s)-1))
 
def game():
    symbols = ""0123456789""
    selection_length = 4
    random.shuffle(symbols)
    selection = symbols[:selection_length]
    guess = """"
    while True:
        guess = input(""Your guess? "")
        if len(guess)!= selection_length or any(c not in symbols for c in guess) or contains_duplicates(guess):
            print(guess, ""is not a valid guess!"")
            continue
 
        bulls = 0
        cows = 0
        for i in range(selection_length):
            pos = selection.find(guess[i])
            if pos == i:
                bulls += 1
            elif pos!= -1:
                cows += 1
        print(bulls, ""bulls,"", cows, ""cows."")
        if bulls == selection_length:
            print(""Congratulations! You have won!"")
            return
 
if __name__ == ""__main__"":
    print(""Welcome to bulls and cows!"")
    while True:
        answer = input(""Do you want to play? "")
        if answer in (""yes"", ""Yes"", ""y"", ""Y""):
            game()
        elif answer in (""no"", ""No"", ""n"", ""N""):
            print(""Ok. Goodbye."")
            break
        else:
            print(""Please answer yes or no: "")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sum_and_product_puzzle,Sum and product puzzle,"Task[edit]
Solve the ""Impossible Puzzle"":


X and Y are two different whole numbers greater than 1. Their sum is no greater than 100, and Y is greater than X. S and P are two mathematicians (and consequently perfect logicians); S knows the sum X+Y and P knows the product X*Y. Both S and P know all the information in this paragraph.
The following conversation occurs:

 S says ""P does not know X and Y.""
 P says ""Now I know X and Y.""
 S says ""Now I also know X and Y!""
What are X and Y?


Guidance
It can be hard to wrap one's head around what the three lines of dialog between S (the ""sum guy"") and P (the ""product guy"") convey about the values of X and Y.

So for your convenience, here's a break-down:





 Quote

 Implied fact


 1)

 S says ""P does not know X and Y.""

 For every possible sum decomposition of the number X+Y, the product has in turn more than one product decomposition.


 2)

 P says ""Now I know X and Y.""

 The number X*Y has only one product decomposition for which fact 1 is true.


 3)

 S says ""Now I also know X and Y.""

 The number X+Y has only one sum decomposition for which fact 2 is true.

Terminology:

 ""sum decomposition"" of a number = Any pair of positive integers (A, B) so that A+B equals the number. Here, with the additional constraint 2 ≤ A < B.
 ""product decomposition"" of a number = Any pair of positive integers (A, B) so that A*B equals the number. Here, with the additional constraint 2 ≤ A < B.


Your program can solve the puzzle by considering all possible pairs (X, Y) in the range 2 ≤ X < Y ≤ 98, and then successively eliminating candidates based on the three facts. It turns out only one solution remains!

See the Python example for an implementation that uses this approach with a few optimizations.

See also
   Wikipedia:   Sum and Product Puzzle
",Python,"#!/usr/bin/env python
 
from collections import Counter
 
def decompose_sum(s):
    return [(a,s-a) for a in range(2,int(s/2+1))]
 
# Generate all possible pairs
all_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)
 
# Fact 1 --> Select pairs for which all sum decompositions have non-unique product
product_counts = Counter(c*d for c,d in all_pairs)
unique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)
s_pairs = [(a,b) for a,b in all_pairs if
    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]
 
# Fact 2 --> Select pairs for which the product is unique
product_counts = Counter(c*d for c,d in s_pairs)
p_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]
 
# Fact 3 --> Select pairs for which the sum is unique
sum_counts = Counter(c+d for c,d in p_pairs)
final_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]
 
print(final_pairs)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test,Miller–Rabin primality test,"

 This page uses content from Wikipedia. The original article was at Miller–Rabin primality test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime or not.

The algorithm, as modified by Michael O. Rabin to avoid the generalized Riemann hypothesis, is a probabilistic algorithm.

The pseudocode, from Wikipedia is:

Input: n > 2, an odd integer to be tested for primality;
       k, a parameter that determines the accuracy of the test
Output: composite if n is composite, otherwise probably prime
write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1
LOOP: repeat k times:
   pick a randomly in the range [2, n − 1]
   x ← ad mod n
   if x = 1 or x = n − 1 then do next LOOP
   repeat s − 1 times:
      x ← x2 mod n
      if x = 1 then return composite
      if x = n − 1 then do next LOOP
   return composite
return probably prime

 The nature of the test involves big numbers, so the use of ""big numbers"" libraries (or similar features of the language of your choice) are suggested, but not mandatory.
 Deterministic variants of the test exist and can be implemented as extra (not mandatory to complete the task)

",Python,"def miller_rabin_prime(n, g):
    d = n - 1
    s = 0
    while d % 2 == 0:
        d /= 2
        s += 1
    for i in range(g):
        a = 2 + random.randint(0, n - 4)
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for r in range(s - 1):
            x = pow(x, 2, n)
            if x == 1:
                return False
            if x == n - 1:
                break
        if x!= n - 1:
            return False
    return True
 
primes = [i for i in range(3, 1000, 2) if miller_rabin_prime(i, 10)]
print(primes)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Minimal_steps_down_to_1,Minimal steps down to 1,"

Given:

 A starting, positive integer (greater than one), N.
 A selection of possible integer perfect divisors, D.
 And a selection of possible subtractors, S.
The goal is find the minimum number of steps necessary to reduce N down to one.

At any step, the number may be:

 Divided by any member of D if it is perfectly divided by D, (remainder zero).
 OR have one of S subtracted from it, if N is greater than the member of S.


There may be many ways to reduce the initial N down to 1. Your program needs to:

 Find the minimum number of steps to reach 1.
 Show one way of getting fron N to 1 in those minimum steps.


Examples

No divisors, D. a single subtractor of 1.

Obviousely N will take N-1 subtractions of 1 to reach 1
Single divisor of 2; single subtractor of 1:

N = 7 Takes 4 steps N -1=> 6, /2=> 3, -1=> 2, /2=> 1
N = 23 Takes 7 steps N -1=>22, /2=>11, -1=>10, /2=> 5, -1=> 4, /2=> 2, /2=> 1
Divisors 2 and 3; subtractor 1:

N = 11 Takes 4 steps N -1=>10, -1=> 9, /3=> 3, /3=> 1
Task

Using the possible divisors D, of 2 and 3; together with a possible subtractor S, of 1:

1. Show the number of steps and possible way of diminishing the numbers 1 to 10 down to 1.
2. Show a count of, and the numbers that: have the maximum minimal_steps_to_1, in the range 1 to 2,000.
Using the possible divisors D, of 2 and 3; together with a possible subtractor S, of 2:

3. Show the number of steps and possible way of diminishing the numbers 1 to 10 down to 1.
4. Show a count of, and the numbers that: have the maximum minimal_steps_to_1, in the range 1 to 2,000.


Optional stretch goal

2a, and 4a: As in 2 and 4 above, but for N in the range 1 to 20_000


Reference

 Learn Dynamic Programming (Memoization & Tabulation) Video of similar task.",Python,"from collections import namedtuple
from itertools import chain
from operator import itemgetter
from typing import List, Tuple
 
def minimal_steps(goal: int, divisors: List[int], subtractors: List[int]) -> None:
    lookup = create_lookup(goal, divisors, subtractors)
    print(f""Divisors: [{', '.join(map(str, divisors))}], Subtractors: [{', '.join(map(str, subtractors))}]"")
    print_range(lookup, 10)
    print_max_mins(lookup)
    lookup = create_lookup(20_000, divisors, subtractors)
    print_max_mins(lookup)
    print()
 
    subtractors = [2]
    lookup = create_lookup(2_000, divisors, subtractors)
    print(f""Divisors: [{', '.join(map(str, divisors))}], Subtractors: [{', '.join(map(str, subtractors))}]"")
    print_range(lookup, 10)
    print_max_mins(lookup)
    lookup = create_lookup(20_000, divisors, subtractors)
    print_max_mins(lookup)
 
def print_range(lookup: List[Tuple[str, int, int]], limit: int) -> None:
    for goal in range(1, limit + 1):
        x = lookup[goal]
        if x[1] == 0:
            print(f""{goal} cannot be reached with these numbers."")
            continue
        print(f""{goal} takes {x[2]} {'step' if x[2] == 1 else'steps'}: "", end="""")
        for n in range(goal, 1, -1):
            print(f""{n},{x[0]}{x[1]}=> "", end="""")
            n = n // x[1] if x[0] == '/' else n - x[1]
            x = lookup[n]
        print(""1"")
 
def print_max_mins(lookup: List[Tuple[str, int, int]]) -> None:
    max_steps = max(x[2] for x in lookup)
    items = [(i, x) for i, x in enumerate(lookup) if x[2] == max_steps]
    if len(items) == 1:
        print(f""There is one number below {len(lookup) - 1} that requires {max_steps} steps: {items[0][0]}"")
    else:
        print(f""There are {len(items)} numbers below {len(lookup) - 1} that require {max_steps} steps: {', '.join(map(str, (i for i, _ in items)))}"")
 
def create_lookup(goal: int, divisors: List[int], subtractors: List[int]) -> List[Tuple[str, int, int]]:
    lookup = [("""", 0, 0) for _ in range(goal + 1)]
    lookup[1] = (""/"", 1, 0)
    for n in range(1, len(lookup)):
        ln = lookup[n]
        if ln[1] == 0:
            continue
        for d in range(len(divisors)):
            target = n * divisors[d]
            if target > goal:
                break
            if lookup[target][2] == 0 or lookup[target][2] > ln[2]:
                lookup[target] = (""/"", divisors[d], ln[2] + 1)
        for s in range(len(subtractors)):
            target = n + subtractors[s]
            if target > goal:
                break
            if lookup[target][2] == 0 or lookup[target][2] > ln[2]:
                lookup[target] = (""-"", subtractors[s], ln[2] + 1)
    return lookup
 
if __name__ == ""__main__"":
    minimal_steps(2_000, [2, 3], [1])",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Abundant_odd_numbers,Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",Python,"#!/usr/bin/python
# Abundant odd numbers - Python
 
oddNumber  = 1
aCount  = 0
dSum  = 0
 
from math import sqrt
 
def divisorSum(n):
    sum = 1
    i = int(sqrt(n)+1)
 
    for d in range (2, i):
        if n % d == 0:
            sum += d
            otherD = n // d
            if otherD != d:
                sum += otherD
    return sum
 
print (""The first 25 abundant odd numbers:"")
while aCount  < 25:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
        print(""{0:5} proper divisor sum: {1}"". format(oddNumber ,dSum ))
    oddNumber  += 2
 
while aCount  < 1000:
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        aCount  += 1
    oddNumber  += 2
print (""\n1000th abundant odd number:"")
print (""    "",(oddNumber - 2),"" proper divisor sum: "",dSum)
 
oddNumber  = 1000000001
found  = False
while not found :
    dSum  = divisorSum(oddNumber )
    if dSum  > oddNumber :
        found  = True
        print (""\nFirst abundant odd number > 1 000 000 000:"")
        print (""    "",oddNumber,"" proper divisor sum: "",dSum)
    oddNumber  += 2",Human_written,Python_from_Go
http://rosettacode.org/wiki/Singleton,Singleton,"A Global Singleton is a class of which only one instance exists within a program.

Any attempt to use non-static members of the class involves performing operations on this one instance.



",Python,"# version 1.1.2
 
class Singleton:
    def speak(self):
        print(""I am a singleton"")
 
if __name__ == ""__main__"":
    Singleton().speak()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Find_the_last_Sunday_of_each_month,Find the last Sunday of each month,"Write a program or a script that returns the last Sundays of each month of a given year. The year may be given through any simple input method in your language (command line, std in, etc).

Example of an expected output:

./last_sundays 2013
2013-01-27
2013-02-24
2013-03-31
2013-04-28
2013-05-26
2013-06-30
2013-07-28
2013-08-25
2013-09-29
2013-10-27
2013-11-24
2013-12-29


Related tasks
 Day of the week
 Five weekends
 Last Friday of each month

",Python,"import math
 
def is_prime(n):
  if n < 2:
    return False
  for i in range(2, int(math.sqrt(n)) + 1):
    if n % i == 0:
      return False
  return True
 
def primes_up_to(n):
  return [i for i in range(2, n + 1) if is_prime(i)]
 
print(primes_up_to(100))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Enforced_immutability,Enforced immutability,"Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.



",Python,">>> s = ""Hello""
>>> s[0] = ""h""
 
Traceback (most recent call last):
  File ""<pyshell#1>"", line 1, in <module>
    s[0] = ""h""
TypeError: 'str' object does not support item assignment",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Summarize_primes,Summarize primes,"Task

Considering in order of length, n, all sequences of consecutive
primes, p, from 2 onwards, where p < 1000 and n>0, select those
sequences whose sum is prime, and for these display the length of the
sequence, the last item in the sequence, and the sum.



",Python,"import math
 
def is_prime(n):
    if n < 2:
        return False
 
    if n % 2 == 0:
        return n == 2
 
    if n % 3 == 0:
        return n == 3
 
    i = 5
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
 
        if n % i == 0:
            return False
        i += 4
 
    return True
 
start = 1
stop = 1000
 
sum = 0
count = 0
sc = 0
 
for p in range(start, stop):
    if is_prime(p):
        count += 1
        sum += p
        if is_prime(sum):
            print(""The sum of %3d primes in [2, %3d] is %5d which is also prime"" % (count, p, sum))
            sc += 1
 
print(""There are %d summerized primes in [%d, %d)"" % (sc, start, stop))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Tic-tac-toe,Tic-tac-toe,"
Task

Play a game of tic-tac-toe.

Ensure that legal moves are played and that a winning position is notified.


Tic-tac-toe   is also known as:

   naughts and crosses 
   tic tac toe 
   tick tack toe 
   three in a row 
   tres en rayo       and
   Xs  and  Os


See also
   MathWorld™, Tic-Tac-Toe game.
   Wikipedia tic-tac-toe.

",Python,"'''
    Tic-tac-toe game player.
    Input the index of where you wish to place your mark at your turn.
'''
 
import random
 
board = list('123456789')
wins = ((0,1,2), (3,4,5), (6,7,8),
        (0,3,6), (1,4,7), (2,5,8),
        (0,4,8), (2,4,6))
 
def printboard():
    print('\n'.join(' '.join(board[x:x+3]) for x in(0,3,6)))
 
def score():
    for w in wins:
        b = board[w[0]]
        if b in 'XO' and all (board[i] == b for i in w):
            return b, [i+1 for i in w]
    return None, None
 
def finished():
    return all (b in 'XO' for b in board)
 
def space():
    return [ b for b in board if b not in 'XO']
 
def my_turn(xo):
    options = space()
    choice = random.choice(options)
    board[int(choice)-1] = xo
    return choice
 
def your_turn(xo):
    options = space()
    while True:
        choice = input("" Put your %s in any of these positions: %s ""
                       % (xo, ''.join(options))).strip()
        if choice in options:
            break
        print( ""Whoops I don't understand the input"" )
    board[int(choice)-1] = xo
    return choice
 
def me(xo='X'):
    printboard()
    print('I go at', my_turn(xo))
    return score()
    assert not s[0], ""\n%s wins across %s"" % s
 
def you(xo='O'):
    printboard()
    # Call my_turn(xo) below for it to play itself
    print('You went at', your_turn(xo))
    return score()
    assert not s[0], ""\n%s wins across %s"" % s
 
 
print(__doc__)
while not finished():
    s = me('X')
    if s[0]:
        printboard()
        print(""\n%s wins across %s"" % s)
        break
    if not finished():
        s = you('O')
        if s[0]:
            printboard()
            print(""\n%s wins across %s"" % s)
            break
else:
    print('\nA draw')",Human_written,Python_from_Rust
http://rosettacode.org/wiki/DNS_query,DNS query,"DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.

Use DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.



",Python,">>> import socket
>>> ips = set(i[4][0] for i in socket.getaddrinfo('www.kame.net', 80))
>>> for ip in ips: print ip
...
2001:200:dff:fff1:216:3eff:feb1:44d7
203.178.141.194",Human_written,Python_from_C++
http://rosettacode.org/wiki/Set_puzzle,Set puzzle,"Set Puzzles are created with a deck of cards from the Set Game™. The object of the puzzle is to find sets of 3 cards in a rectangle of cards that have been dealt face up. 


There are 81 cards in a deck.
Each card contains a unique variation of the following four features: color, symbol, number and shading.

 there are three colors:
    red, green, purple

 there are three symbols:
    oval, squiggle, diamond

 there is a number of symbols on the card:
    one, two, three

 there are three shadings:
    solid, open, striped

Three cards form a set if each feature is either the same on each card, or is different on each card. For instance: all 3 cards are red, all 3 cards have a different symbol, all 3 cards have a different number of symbols, all 3 cards are striped.

There are two degrees of difficulty: basic and advanced. The basic mode deals 9 cards, that contain exactly 4 sets; the advanced mode deals 12 cards that contain exactly 6 sets.

When creating sets you may use the same card more than once.




Task
Write code that deals the cards (9 or 12, depending on selected mode) from a shuffled deck in which the total number of sets that could be found is 4 (or 6, respectively); and print the contents of the cards and the sets.

For instance:



DEALT 9 CARDS:

green, one, oval, striped
green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid
purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open
red, three, oval, open
red, three, diamond, solid

CONTAINING 4 SETS:

green, one, oval, striped
purple, two, squiggle, open
red, three, diamond, solid


green, one, diamond, open
green, one, diamond, striped
green, one, diamond, solid


green, one, diamond, open
purple, two, squiggle, open
red, three, oval, open


purple, one, diamond, open
purple, two, squiggle, open
purple, three, oval, open

",Python,"from itertools import product
from random import shuffle
from typing import List, Tuple
 
Feature = Tuple[int, str]
Card = Tuple[Feature, Feature, Feature, Feature]
 
numbers: List[Feature] = [(1, ""One""), (2, ""Two""), (3, ""Three"")]
colors: List[Feature] = [(1, ""Red""), (2, ""Green""), (3, ""Purple"")]
shadings: List[Feature] = [(1, ""Open""), (2, ""Striped""), (3, ""Solid"")]
symbols: List[Feature] = [(1, ""Oval""), (2, ""Squiggle""), (3, ""Diamond"")]
 
def main():
    deck = [
        (number, color, shading, symbol)
        for number in numbers
        for color in colors
        for shading in shadings
        for symbol in symbols
    ]
    random = Random()
    deal(deck, 9, 4, random)
    print()
    print()
    deal(deck, 12, 6, random)
 
def deal(deck: List[Card], size: int, target: int, random: Random):
    sets: List[Card]
    while True:
        shuffle(deck, random.randint)
        sets = [
            (deck[i], deck[j], deck[k])
            for i in range(size - 2)
            for j in range(i + 1, size - 1)
            for k in range(j + 1, size)
            if is_set((deck[i], deck[j], deck[k]))
        ]
        if len(sets) == target:
            break
    print(""The board:"")
    for card in deck[:size]:
        print(card)
    print()
    print(""Sets:"")
    for s in sets:
        print(s)
 
def is_set(t: Card) -> bool:
    return (
        are_same_or_different(t[0][0], t[1][0], t[2][0])
        and are_same_or_different(t[0][1], t[1][1], t[2][1])
        and are_same_or_different(t[0][2], t[1][2], t[2][2])
        and are_same_or_different(t[0][3], t[1][3], t[2][3])
    )
 
def are_same_or_different(a: int, b: int, c: int) -> bool:
    return (a + b + c) % 3 == 0
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Simple_windowed_application,Simple windowed application,"Task

Create a window that has:

   a label that says   ""There have been no clicks yet"" 
   a button that says   ""click me""


Upon clicking the button with the mouse, the label should change and show the number of times the button has been clicked.



",Python,"from browser import document, html, window

box = html.INPUT(style = {'position': 'absolute', 'left': '10px', 'top': '60px'})
box.style.border = '3px solid white'
box.value = 'There have been no clicks yet'
box.style.width = '220px'
document <= box

clicks = 0

def count_clicks(ev):
    global clicks
    clicks += 1
    document['clicks'].text = clicks

button = html.BUTTON('Click me')
button.bind('click', count_clicks)
document <= button

document <= html.P('Clicks: ', html.A(id = 'clicks', text = '0'))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",Python,"def move(n, from, to, via):
    if n == 1:
        print(""Move disk from pole "" + str(from) + "" to pole "" + str(to))
    else:
        move(n - 1, from, via, to)
        move(1, from, to, via)
        move(n - 1, via, to, from)",Ai_generated,Python_from_C#
