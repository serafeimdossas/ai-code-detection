task_url,task_name,task_description,language_name,code,target,set
http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",Python,"table = [
	[0.06, 0.10], [0.11, 0.18], [0.16, 0.26], [0.21, 0.32],
	[0.26, 0.38], [0.31, 0.44], [0.36, 0.50], [0.41, 0.54],
	[0.46, 0.58], [0.51, 0.62], [0.56, 0.66], [0.61, 0.70],
	[0.66, 0.74], [0.71, 0.78], [0.76, 0.82], [0.81, 0.86],
	[0.86, 0.90], [0.91, 0.94], [0.96, 0.98], [1.01, 1.00],
	[-1, 0], # guarding element
]
 
def price_fix(x):
	for i in range(len(table)):
		if x < table[i][0]: return table[i][1]
 
	abort() # what else to do?
 
for i in range(101):
	print ""%.2f %.2f"" % (i / 100., price_fix(i / 100.))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",Python,"import asyncio
import sys
import time
import threading
 
def wait_key():
    def key_listen(str,key):
        nonlocal key_listen
        sys.stdin.remove_event_handler(key_listen)
        return key
    sys.stdin.add_event_handler(key_listen)
    return key_listen
 
def done():
    sys.exit()
 
async def go():
    while True:
        print('Press any key...')
        key = await wait_key()
        print(""Key pressed is"",key)
        await asyncio.sleep(1)
        if key == 'y':
            break
    done()
 
asyncio.run(go())",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Execute_SNUSP,Execute SNUSP,"Execute SNUSP is an implementation of SNUSP.
Other implementations of SNUSP.
RCSNUSP
SNUSP
An implementation need only properly implement the Core SNUSP instructions ('$', '\', '/', '+', '-', '<', '>', ',', '.', '!', and '?'). Modular SNUSP ('#', '@') and Bloated SNUSP (':', ';', '%', and '&') are also allowed, but not required. Any extra characters that you implement should be noted in the description of your implementation. Any cell size is allowed, EOF support is optional, as is whether you have bounded or unbounded memory.
",Python,"#!/usr/bin/env python3
 
HW = r'''
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/'''
 
def snusp(store, code):
    ds = bytearray(store)  # data store
    dp = 0                 # data pointer
    cs = code.splitlines() # 2 dimensional code store
    ipr, ipc = 0, 0        # instruction pointers in row and column
    for r, row in enumerate(cs):
        try:
            ipc = row.index('$')
            ipr = r
            break
        except ValueError:
            pass
    rt, dn, lt, up = range(4)
    id = rt  # instruction direction.  starting direction is always rt
    def step():
        nonlocal ipr, ipc
        if id&1:
            ipr += 1 - (id&2)
        else:
            ipc += 1 - (id&2)
    while ipr >= 0 and ipr < len(cs) and ipc >= 0 and ipc < len(cs[ipr]):
        op = cs[ipr][ipc]
        if op == '>':
            dp += 1
        elif op == '<':
            dp -= 1
        elif op == '+':
            ds[dp] += 1
        elif op == '-':
            ds[dp] -= 1
        elif op == '.':
            print(chr(ds[dp]), end='')
        elif op == ',':
            ds[dp] = input()
        elif op == '/':
            id = ~id
        elif op == '\\':
            id ^= 1
        elif op == '!':
            step()
        elif op == '?':
            if not ds[dp]:
                step()
        step()
 
if __name__ == '__main__':
    snusp(5, HW)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",Python,"def comma_quibbling(a):
    return a[0] if len(a) == 1 else a[-1] if len(a) == 2 else a[0] + ','+ a[-1]
 
print(comma_quibbling([]))
print(comma_quibbling(['ABC']))
print(comma_quibbling(['ABC', 'DEF']))
print(comma_quibbling(['ABC', 'DEF', 'G', 'H']))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Feigenbaum_constant_calculation,Feigenbaum constant calculation,"Task

Calculate the Feigenbaum constant.



See

   Details in the Wikipedia article:   Feigenbaum constant.

",Python,"from __future__ import print_function
 
def feigenbaum():
    i, j, k, max_it, max_it_j = 0, 0, 0, 13, 10
    a, x, y, d, a1, a2, d1 = 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 3.2
    print("" i       d"")
    for i in range(2, max_it + 1):
        a = a1 + (a1 - a2) / d1
        for j in range(1, max_it_j + 1):
            x = 0.0
            y = 0.0
            for k in range(1, 1 << i):
                y = 1.0 - 2.0 * y * x
                x = a - x * x
            a -= x / y
        d = (a1 - a2) / (a - a1)
        print(""%2d    %.8f"" % (i, d))
        d1 = d
        a2 = a1
        a1 = a
 
if __name__ == ""__main__"":
    feigenbaum()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Commatizing_numbers,Commatizing numbers,"Commatizing   numbers (as used here, is a handy expedient made-up word) is the act of adding commas to a number (or string), or to the numeric part of a larger string.



Task

Write a function that takes a string as an argument with optional arguments or parameters (the format of parameters/options is left to the programmer) that in general, adds commas (or some
other characters, including blanks or tabs) to the first numeric part of a string (if it's suitable for commatizing as per the rules below), and returns that newly commatized string.

Some of the commatizing rules (specified below) are arbitrary, but they'll be a part of this task requirements, if only to make the results consistent amongst national preferences and other disciplines.

The number may be part of a larger (non-numeric) string such as:

   «US$1744 millions»       ──or──
   ±25000 motes.


The string may possibly not have a number suitable for commatizing, so it should be untouched and no error generated.

If any argument (option) is invalid, nothing is changed and no error need be generated (quiet execution, no fail execution).   Error message generation is optional.

The exponent part of a number is never commatized.   The following string isn't suitable for commatizing:   9.7e+12000

Leading zeroes are never commatized.   The string   0000000005714.882   after commatization is:   0000000005,714.882

Any   period   (.)   in a number is assumed to be a   decimal point.

The original string is never changed   except   by the addition of commas   [or whatever character(s) is/are used for insertion], if at all.

To wit, the following should be preserved:

   leading signs (+, -)       ── even superfluous signs
   leading/trailing/embedded blanks, tabs, and other whitespace 
   the case (upper/lower) of the exponent indicator, e.g.:   4.8903d-002


Any exponent character(s) should be supported:

   1247e12
   57256.1D-4
   4444^60
   7500∙10**35
   8500x10**35
   9500↑35
   +55000↑3
   1000**100
   2048²
   409632
   10000pow(pi)

Numbers may be terminated with any non-digit character, including subscripts and/or superscript:   41421356243   or   7320509076(base 24).

The character(s) to be used for the comma can be specified, and may contain blanks, tabs, and other whitespace characters, as well as multiple characters.   The default is the comma (,) character.

The   period length   can be specified   (sometimes referred to as ""thousands"" or ""thousands separators"").   The   period length   can be defined as the length (or number) of the decimal digits between commas.   The default period length is   3.

 E.G.:   in this example, the   period length   is five:   56789,12340,14148
The location of where to start the scanning for the target field (the numeric part) should be able to be specified.   The default is   1.

The character strings below may be placed in a file (and read) or stored as simple strings within the program.



Strings to be used as a minimum

The value of   pi   (expressed in base 10)   should be separated with blanks every   5   places past the decimal point,

the Zimbabwe dollar amount should use a decimal point for the ""comma"" separator:

   pi=3.14159265358979323846264338327950288419716939937510582097494459231
   The author has two Z$100000000000000 Zimbabwe notes (100 trillion).
   ""-in Aus$+1411.8millions""
   ===US$0017440 millions=== (in 2000 dollars)
   123.e8000 is pretty big.
   The land area of the earth is 57268900(29% of the surface) square miles.
   Ain't no numbers in this here words, nohow, no way, Jose.
   James was never known as 0000000007
   Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.
   ␢␢␢$-140000±100 millions.
   6/9/1946 was a good year for some.

where the penultimate string has three leading blanks   (real blanks are to be used).



Also see

 The Wiki entry:   (sir) Arthur Eddington's number of protons in the universe. 

",Python,"import re

inputs = [
	""pi=3.14159265358979323846264338327950288419716939937510582097494459231"",
	""The author has two Z$100000000000000 Zimbabwe notes (100 trillion)."",
	""\""-in Aus$+1411.8millions\"""",
	""===US$0017440 millions=== (in 2000 dollars)""
]

def commatize(text, start_position, interval, separator):
	matches = re.finditer(""[0-9]*"", text[start_position:])
	x = [commatize(match, interval, separator, text) for match in matches]
	return """".join(x)

def commatize(match, interval, separator, original):
	if len(match.group(0)) <= interval:
		return original[match.start():match.end()] if match.end()!= len(original) else original[match.start():match.start() + 1]
	return separator.join(match.group(0)[i:i + interval] for i in range(0, len(match.group(0)), interval))

for input in inputs:
	print(commatize(input, 0, 3, "",""))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order,Magic squares of doubly even order,"A magic square is an   N×N  square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column,   and   both diagonals are equal to the same sum   (which is called the magic number or magic constant).

A magic square of doubly even order has a size that is a multiple of four   (e.g.     4, 8, 12).

This means that the subsquares also have an even size, which plays a role in the construction.



1
2
62
61
60
59
7
8


9
10
54
53
52
51
15
16


48
47
19
20
21
22
42
41


40
39
27
28
29
30
34
33


32
31
35
36
37
38
26
25


24
23
43
44
45
46
18
17


49
50
14
13
12
11
55
56


57
58
6
5
4
3
63
64



Task
Create a magic square of   8 × 8.



Related tasks
 Magic squares of odd order
 Magic squares of singly even order



See also

 Doubly Even Magic Squares (1728.org)

",Python,"def MagicSquareDoublyEven(order):
    sq = [range(1+n*order,order + (n*order)+1) for n in range(order) ]
    n1 = order/4
    for r in range(n1):
        r1 = sq[r][n1:-n1]
        r2 = sq[order -r - 1][n1:-n1]
        r1.reverse()
        r2.reverse()
        sq[r][n1:-n1] = r2
        sq[order -r - 1][n1:-n1] = r1
    for r in range(n1, order-n1):
        r1 = sq[r][:n1]
        r2 = sq[order -r - 1][order-n1:]
        r1.reverse()
        r2.reverse()
        sq[r][:n1] = r2
        sq[order -r - 1][order-n1:] = r1
    return sq
 
def printsq(s):
    n = len(s)
    bl = len(str(n**2))+1
    for i in range(n):
        print ''.join( [ (""%""+str(bl)+""s"")%(str(x)) for x in s[i]] )
    print ""\nMagic constant = %d""%sum(s[0])
 
printsq(MagicSquareDoublyEven(8))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Window_creation/X11,Window creation/X11,"Task

Create a simple X11 application,   using an X11 protocol library such as Xlib or XCB,   that draws a box and   ""Hello World""   in a window.

Implementations of this task should   avoid using a toolkit   as much as possible.



",Python,"from Xlib import X, display
 
class Window:
    def __init__(self, display, msg):
        self.display = display
        self.msg = msg
 
        self.screen = self.display.screen()
        self.window = self.screen.root.create_window(
            10, 10, 100, 100, 1,
            self.screen.root_depth,
            background_pixel=self.screen.white_pixel,
            event_mask=X.ExposureMask | X.KeyPressMask,
            )
        self.gc = self.window.create_gc(
            foreground = self.screen.black_pixel,
            background = self.screen.white_pixel,
            )
 
        self.window.map()
 
    def loop(self):
        while True:
            e = self.display.next_event()
 
            if e.type == X.Expose:
                self.window.fill_rectangle(self.gc, 20, 20, 10, 10)
                self.window.draw_text(self.gc, 10, 50, self.msg)
            elif e.type == X.KeyPress:
                raise SystemExit
 
 
if __name__ == ""__main__"":
    Window(display.Display(), ""Hello, World!"").loop()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Determine_if_a_string_is_squeezable,Determine if a string is squeezable,"Determine if a character string is   squeezable.

And if so,   squeeze the string   (by removing any number of
a   specified   immediately repeated   character).



This task is very similar to the task     Determine if a character string is collapsible     except
that only a specified character is   squeezed   instead of any character that is immediately repeated.



If a character string has a specified   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



A specified   immediately repeated   character is any specified character that is   immediately  
followed by an identical character (or characters).   Another word choice could've been   duplicated
character,   but that might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around
November 2019)   PL/I   BIF:   squeeze.}



Examples

In the following character string with a specified   immediately repeated   character of   e:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   e   is an specified repeated character,   indicated by an underscore
(above),   even though they (the characters) appear elsewhere in the character string.



So, after squeezing the string, the result would be:

 The better the 4-whel drive, the further you'll be from help when ya get stuck! 





Another example:
In the following character string,   using a specified immediately repeated character   s:

 headmistressship 



The ""squeezed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to locate a   specified immediately repeated   character
and   squeeze   (delete)   them from the character string.   The
character string can be processed from either direction.



Show all output here, on this page:

   the   specified repeated character   (to be searched for and possibly squeezed):
   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

                                                                                  immediately
 string                                                                            repeated
 number                                                                            character
                                                                                     ( ↓   a blank,  a minus,  a seven,  a period)
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗    ' '    ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║    '-'
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║    '7'
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║    '.'
   5    ║                                                    --- Harry S Truman  ║  (below)  ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝     ↑
                                                                                       │
                                                                                       │
        For the 5th string  (Truman's signature line),  use each of these  specified immediately  repeated characters:
                                  •  a blank
                                  •  a minus
                                  •  a lowercase  r



Note:   there should be seven results shown,   one each for the 1st four strings,   and three results for
the 5th string.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
def squeeze(str, ch):
    return re.sub(ch + '+', ch, str)
 
def test(str, ch):
    print(""character: '"" + ch + ""'"")
    print(""original: <<<"" + str + "">>>, length: "" + str(len(str)))
    squeezed = squeeze(str, ch)
    print(""result: <<<"" + squeezed + "">>>, length: "" + str(len(squeezed)))
    print()
 
test("""",'')
test(""\""If I were two-faced, would I be wearing this one?\"" ---  "", '-')
test(""..1111111111111111111111111111111111111111111111111111111111111117777888"", '7')
test(""I never give 'em hell, I just tell the truth, and they think it's hell. "", '.')
truman = ""                                                    ---   ""
test(truman,'')
test(truman, '-')
test(truman, 'r')",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",Python,"from itertools import repeat
 
def sierpinski(order):
    triangle = ['*']
    for i in range(order):
        space = ''.join(repeat(' ', 2**i))
 
        # save original state
        d = triangle[:]
 
        # extend existing lines
        for j, r in enumerate(d):
            new_row = '{}{}{}'.format(space, r, space)
            d[j] = new_row
 
        # add new lines
        for r in triangle:
            new_row = '{} {}{}'.format(r,'', r)
            d.append(new_row)
 
        triangle = d
 
    for r in triangle:
        print(r)
 
if __name__ == '__main__':
    import sys
    order = int(sys.argv[1]) if len(sys.argv) > 1 else 4
    sierpinski(order)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Animation,Animation,"
Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.



Task

Create a window containing the string ""Hello World! "" (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.



",Python,"import time
import sys
import os
import tcell

msg = ""Hello World! ""
x0, y0 = 8, 3
shiftsPerSecond = 4
clicksToExit = 5

s = tcell.Screen()
s.init()
s.clear()
s.enable_mouse()
tick = time.Tick(time.Second / shiftsPerSecond)
click = make(chan bool)

def main():
    for inc, shift, clicks in 1, 0, 0:
        select:
            case <-tick:
                shift = (shift + inc) % len(msg)
                for i, r in enumerate(msg):
                    s.set_content(x0+((shift+i)%len(msg)), y0, r, None, 0)
                s.show()
            case <-click:
                clicks++
                if clicks == clicksToExit:
                    s.fini()
                    return
                inc = len(msg) - inc

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Percolation/Mean_cluster_density,Percolation/Mean cluster density,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Let 



c


{\displaystyle c}

 be a 2D boolean square matrix of 



n
×
n


{\displaystyle n\times n}

 values of either 1 or 0 where the
probability of any value being 1 is 



p


{\displaystyle p}

, (and of 0 is therefore 



1
−
p


{\displaystyle 1-p}

).
We define a cluster of 1's as being a group of 1's connected vertically or
horizontally (i.e., using the Von Neumann neighborhood rule) and bounded by either 



0


{\displaystyle 0}

 or by the limits of the matrix.
Let the number of such clusters in such a randomly constructed matrix be 




C

n




{\displaystyle C_{n}}

.

Percolation theory states that 



K
(
p
)


{\displaystyle K(p)}

 (the mean cluster density) will satisfy 



K
(
p
)
=

C

n



/


n

2




{\displaystyle K(p)=C_{n}/n^{2}}

 as 



n


{\displaystyle n}

 tends to infinity. For 



p
=
0.5


{\displaystyle p=0.5}

, 



K
(
p
)


{\displaystyle K(p)}

 is found numerically to approximate 



0.065770


{\displaystyle 0.065770}

...

Task
Show the effect of varying 



n


{\displaystyle n}

 on the accuracy of simulated 



K
(
p
)


{\displaystyle K(p)}

 for 



p
=
0.5


{\displaystyle p=0.5}

 and
for values of 



n


{\displaystyle n}

 up to at least 



1000


{\displaystyle 1000}

.
Any calculation of 




C

n




{\displaystyle C_{n}}

 for finite 



n


{\displaystyle n}

 is subject to randomness, so an approximation should be
computed as the average of 



t


{\displaystyle t}

 runs, where 



t


{\displaystyle t}

 ≥ 



5


{\displaystyle 5}

.

For extra credit, graphically show clusters in a 



15
×
15


{\displaystyle 15\times 15}

, 



p
=
0.5


{\displaystyle p=0.5}

 grid.

Show your output here.

See also
 s-Cluster on Wolfram mathworld.",Python,"import random
import sys
 
def make_map(p):
	thresh = random.randint(0, sys.maxint) * p
	map = []
	for i in range(w * w):
		map.append(-1 if random.randint(0, sys.maxint) < thresh else 0)
	return map
 
def show_cluster(map):
	for i in range(w):
		for j in range(w):
			print "" %c"" % (alpha[1 + map[i * w + j]] if map[i * w + j] < ALEN else '?'),
		print
 
def recur(x, v, map):
	if x >= 0 and x < w * w and map[x] == -1:
		map[x] = v
		recur(x - w, v, map)
		recur(x - 1, v, map)
		recur(x + 1, v, map)
		recur(x + w, v, map)
 
def count_clusters(map):
	cls = 0
	for i in range(w * w):
		if map[i] == -1:
			cls += 1
			recur(i, cls, map)
	return cls
 
def tests(n, p):
	k = 0
	for i in range(n):
		map = make_map(p)
		k += count_clusters(map)
	return k / float(n)
 
alpha = ""+.ABCDEFGHIJKLMNOPQRSTUVWXYZ"" + ""abcdefghijklmnopqrstuvwxyz""
ALEN = len(alpha) - 3
 
w = 15
map = make_map(.5)
print ""width=15, p=0.5, %d clusters:"" % count_clusters(map)
show_cluster(map)
 
print ""\np=0.5, iter=5:""
for w in range(1<<2, 1<<14, 1<<2):
	print ""%5d %9.6f"" % (w, tests(5,.5))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Variables,Variables,"Task

Demonstrate a language's methods of:

   variable declaration
   initialization
   assignment
   datatypes
   scope 
   referencing,     and 
   other variable related facilities

",Python,"# these examples, respectively, refer to integer, float, boolean, and string objects
example1 = 3
example2 = 3.0
example3 = True
example4 = ""hello""
 
# example1 now refers to a string object.
example1 = ""goodbye""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sockets,Sockets,"For this exercise a program is open a socket to localhost on port 256 and send the message ""hello socket world"" before closing the socket.

Catching any exceptions or errors is not required.



",Python,"import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((""localhost"", 256))
sock.sendall(""hello socket world"") 
sock.close()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"import javax.swing.*;
import java.awt.*;
 
public class OutputSwing {
 
    public static void main(String[] args) {
 
        SwingUtilities.invokeLater(new Runnable(){
            public void run() {
                JOptionPane.showMessageDialog (null, ""Goodbye, World!""); # in alert box
                JFrame frame = new JFrame(""Goodbye, World!"");            # on title bar
                JTextArea text = new JTextArea(""Goodbye, World!"");       # in editable area
                JButton button = new JButton(""Goodbye, World!"");         # on button
 
                frame.setLayout(new FlowLayout());
                frame.add(button);
                frame.add(text);
                frame.pack();
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setVisible(true);
            }
        });
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Deconvolution/1D,Deconvolution/1D,"The convolution of two functions 





F




{\displaystyle {\mathit {F}}}

 and 





H




{\displaystyle {\mathit {H}}}

 of
an integer variable is defined as the function 





G




{\displaystyle {\mathit {G}}}


satisfying





G
(
n
)
=

∑

m
=
−
∞


∞


F
(
m
)
H
(
n
−
m
)


{\displaystyle G(n)=\sum _{m=-\infty }^{\infty }F(m)H(n-m)}


for all integers 





n




{\displaystyle {\mathit {n}}}

. Assume 



F
(
n
)


{\displaystyle F(n)}

 can be non-zero only for 



0


{\displaystyle 0}

 ≤ 





n




{\displaystyle {\mathit {n}}}

 ≤ 




|



F



|



{\displaystyle |{\mathit {F}}|}

, where 




|



F



|



{\displaystyle |{\mathit {F}}|}

 is the ""length"" of 





F




{\displaystyle {\mathit {F}}}

, and similarly for 





G




{\displaystyle {\mathit {G}}}

 and 





H




{\displaystyle {\mathit {H}}}

, so that the functions can be modeled as finite sequences by identifying 




f

0


,

f

1


,

f

2


,
…


{\displaystyle f_{0},f_{1},f_{2},\dots }

 with 



F
(
0
)
,
F
(
1
)
,
F
(
2
)
,
…


{\displaystyle F(0),F(1),F(2),\dots }

, etc.
Then for example, values of 




|



F



|

=
6


{\displaystyle |{\mathit {F}}|=6}

 and 




|



H



|

=
5


{\displaystyle |{\mathit {H}}|=5}

 would determine the following value of 





g




{\displaystyle {\mathit {g}}}

 by definition.










g

0




=



f

0



h

0







g

1




=



f

1



h

0




+



f

0



h

1







g

2




=



f

2



h

0




+



f

1



h

1




+



f

0



h

2







g

3




=



f

3



h

0




+



f

2



h

1




+



f

1



h

2




+



f

0



h

3







g

4




=



f

4



h

0




+



f

3



h

1




+



f

2



h

2




+



f

1



h

3




+



f

0



h

4







g

5




=



f

5



h

0




+



f

4



h

1




+



f

3



h

2




+



f

2



h

3




+



f

1



h

4







g

6




=





f

5



h

1




+



f

4



h

2




+



f

3



h

3




+



f

2



h

4







g

7




=







f

5



h

2




+



f

4



h

3




+



f

3



h

4







g

8




=









f

5



h

3




+



f

4



h

4







g

9




=











f

5



h

4








{\displaystyle {\begin{array}{lllllllllll}g_{0}&=&f_{0}h_{0}\\g_{1}&=&f_{1}h_{0}&+&f_{0}h_{1}\\g_{2}&=&f_{2}h_{0}&+&f_{1}h_{1}&+&f_{0}h_{2}\\g_{3}&=&f_{3}h_{0}&+&f_{2}h_{1}&+&f_{1}h_{2}&+&f_{0}h_{3}\\g_{4}&=&f_{4}h_{0}&+&f_{3}h_{1}&+&f_{2}h_{2}&+&f_{1}h_{3}&+&f_{0}h_{4}\\g_{5}&=&f_{5}h_{0}&+&f_{4}h_{1}&+&f_{3}h_{2}&+&f_{2}h_{3}&+&f_{1}h_{4}\\g_{6}&=&&&f_{5}h_{1}&+&f_{4}h_{2}&+&f_{3}h_{3}&+&f_{2}h_{4}\\g_{7}&=&&&&&f_{5}h_{2}&+&f_{4}h_{3}&+&f_{3}h_{4}\\g_{8}&=&&&&&&&f_{5}h_{3}&+&f_{4}h_{4}\\g_{9}&=&&&&&&&&&f_{5}h_{4}\end{array}}}


We can write this in matrix form as:






(





g

0







g

1







g

2







g

3







g

4







g

5







g

6







g

7







g

8







g

9






)

=

(





f

0







f

1





f

0







f

2





f

1





f

0







f

3





f

2





f

1





f

0







f

4





f

3





f

2





f

1





f

0







f

5





f

4





f

3





f

2





f

1








f

5





f

4





f

3





f

2









f

5





f

4





f

3










f

5





f

4











f

5






)



(





h

0







h

1







h

2







h

3







h

4






)



{\displaystyle \left({\begin{array}{l}g_{0}\\g_{1}\\g_{2}\\g_{3}\\g_{4}\\g_{5}\\g_{6}\\g_{7}\\g_{8}\\g_{9}\\\end{array}}\right)=\left({\begin{array}{lllll}f_{0}\\f_{1}&f_{0}\\f_{2}&f_{1}&f_{0}\\f_{3}&f_{2}&f_{1}&f_{0}\\f_{4}&f_{3}&f_{2}&f_{1}&f_{0}\\f_{5}&f_{4}&f_{3}&f_{2}&f_{1}\\&f_{5}&f_{4}&f_{3}&f_{2}\\&&f_{5}&f_{4}&f_{3}\\&&&f_{5}&f_{4}\\&&&&f_{5}\end{array}}\right)\;\left({\begin{array}{l}h_{0}\\h_{1}\\h_{2}\\h_{3}\\h_{4}\\\end{array}}\right)}


or





g
=
A

h


{\displaystyle g=A\;h}


For this task, implement a function (or method, procedure, subroutine, etc.) deconv to perform deconvolution (i.e., the inverse of convolution) by constructing and solving such a system of equations represented by the above matrix 



A


{\displaystyle A}

 for 





h




{\displaystyle {\mathit {h}}}

 given 





f




{\displaystyle {\mathit {f}}}

 and 





g




{\displaystyle {\mathit {g}}}

.

 The function should work for 





G




{\displaystyle {\mathit {G}}}

 of arbitrary length (i.e., not hard coded or constant) and 





F




{\displaystyle {\mathit {F}}}

 of any length up to that of 





G




{\displaystyle {\mathit {G}}}

. Note that 




|



H



|



{\displaystyle |{\mathit {H}}|}

 will be given by 




|



G



|

−

|



F



|

+
1


{\displaystyle |{\mathit {G}}|-|{\mathit {F}}|+1}

.
 There may be more equations than unknowns. If convenient, use a function from a library that finds the best fitting solution to an overdetermined system of linear equations (as in the Multiple regression task). Otherwise, prune the set of equations as needed and solve as in the Reduced row echelon form task.
 Test your solution on the following data. Be sure to verify both that deconv



(
g
,
f
)
=
h


{\displaystyle (g,f)=h}

 and deconv



(
g
,
h
)
=
f


{\displaystyle (g,h)=f}

 and display the results in a human readable form.

h = [-8,-9,-3,-1,-6,7]

f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]

g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]

",Python,"def ToReducedRowEchelonForm( M ):
    if not M: return
    lead = 0
    rowCount = len(M)
    columnCount = len(M[0])
    for r in range(rowCount):
        if lead >= columnCount:
            return
        i = r
        while M[i][lead] == 0:
            i += 1
            if i == rowCount:
                i = r
                lead += 1
                if columnCount == lead:
                    return
        M[i],M[r] = M[r],M[i]
        lv = M[r][lead]
        M[r] = [ mrx / lv for mrx in M[r]]
        for i in range(rowCount):
            if i != r:
                lv = M[i][lead]
                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]
        lead += 1
    return M
 
def pmtx(mtx):
    print ('\n'.join(''.join(' %4s' % col for col in row) for row in mtx))
 
def convolve(f, h):
    g = [0] * (len(f) + len(h) - 1)
    for hindex, hval in enumerate(h):
        for findex, fval in enumerate(f):
            g[hindex + findex] += fval * hval
    return g
 
def deconvolve(g, f):
    lenh = len(g) - len(f) + 1
    mtx = [[0 for x in range(lenh+1)] for y in g]
    for hindex in range(lenh):
        for findex, fval in enumerate(f):
            gindex = hindex + findex
            mtx[gindex][hindex] = fval
    for gindex, gval in enumerate(g):        
        mtx[gindex][lenh] = gval
    ToReducedRowEchelonForm( mtx )
    return [mtx[i][lenh] for i in range(lenh)]  # h
 
if __name__ == '__main__':
    h = [-8,-9,-3,-1,-6,7]
    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]
    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]
    assert convolve(f,h) == g
    assert deconvolve(g, f) == h",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sum_multiples_of_3_and_5,Sum multiples of 3 and 5,"Task

The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below n.

Show output for n = 1000.

This is is the same as Project Euler problem 1.

Extra credit: do this efficiently for n = 1e20 or higher.



",Python,"def sum35a(n):
    'Direct count'
    # note: ranges go to n-1
    return sum(x for x in range(n) if x%3==0 or x%5==0)
 
def sum35b(n): 
    ""Count all the 3's; all the 5's; minus double-counted 3*5's""
    # note: ranges go to n-1
    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))
 
def sum35c(n):
    'Sum the arithmetic progressions: sum3 + sum5 - sum15'
    consts = (3, 5, 15)
    # Note: stop at n-1
    divs = [(n-1) // c for c in consts]
    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]
    return sums[0] + sums[1] - sums[2]
 
#test
for n in range(1001):
    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)
    assert sa == sb == sc  # python tests aren't like those of c.
 
print('For n = %7i -> %i\n' % (n, sc))
 
# Pretty patterns
for p in range(7):
    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))
 
# Scalability 
p = 20
print('\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Undefined_values,Undefined values,"
",Python,"from __future__ import print_function
 
s = []
p = None
f = None
i = None
m = None
c = None
 
def main():
    print(""Exercise nil objects:"")
    status()
 
    # initialize objects
    global s
    s = [None]
    global p
    p = s[0] # yes, reference element of slice just created
    global f
    f = lambda: print(""function call"")
    global i
    i = user(0) # see user defined type just below
    global m
    m = {}
    global c
    c = []
 
    print(""\nExercise objects after initialization:"")
    status()
 
class user(int):
    def m(self):
        print(""method call"")
 
def status():
    trySlice()
    tryPointer()
    tryFunction()
    tryInterface()
    tryMap()
    tryChannel()
 
def reportPanic():
    if x := recover(); x!= None:
        print(""panic:"", x)
 
def trySlice():
    try:
        print(""s[0] ="", s[0])
    except:
        reportPanic()
 
def tryPointer():
    try:
        print(""*p ="", *p)
    except:
        reportPanic()
 
def tryFunction():
    try:
        f()
    except:
        reportPanic()
 
def tryInterface():
    try:
        # normally the nil identifier accesses a nil value for one of
        # six predefined types.  In a type switch however, nil can be used
        # as a type.  In this case, it matches the nil interface.
        if i == None:
            print(""i is nil interface"")
        elif isinstance(i, interface {
        m()}):
            print(""i has method m"")
    except:
        reportPanic()
 
    # assert type with method and then call method
    i.(interface {
        m()}).m()
 
def tryMap():
    try:
        m[0] = 0
        print(""m[0] ="", m[0])
    except:
        reportPanic()
 
def tryChannel():
    try:
        close(c)
        print(""channel closed"")
    except:
        reportPanic()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Number_names,Number names,"Task

Show how to spell out a number in English.

You can use a preexisting implementation or roll your own, but you should support inputs up to at least one million (or the maximum value of your language's default bounded integer type, if that's less).

Support for inputs other than positive integers (like zero, negative integers, and floating-point numbers) is optional.



Related task

   Spelling of ordinal numbers.

",Python,"TENS = [None, None, ""twenty"", ""thirty"", ""forty"",
        ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety""]
SMALL = [""zero"", ""one"", ""two"", ""three"", ""four"", ""five"",
         ""six"", ""seven"", ""eight"", ""nine"", ""ten"", ""eleven"",
         ""twelve"", ""thirteen"", ""fourteen"", ""fifteen"",
         ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen""]
HUGE = [None, None] + [h + ""illion"" 
                       for h in (""m"", ""b"", ""tr"", ""quadr"", ""quint"", ""sext"", 
                                  ""sept"", ""oct"", ""non"", ""dec"")]
 
def nonzero(c, n, connect=''):
    return """" if n == 0 else connect + c + spell_integer(n)
 
def last_and(num):
    if ',' in num:
        pre, last = num.rsplit(',', 1)
        if ' and ' not in last:
            last = ' and' + last
        num = ''.join([pre, ',', last])
    return num
 
def big(e, n):
    if e == 0:
        return spell_integer(n)
    elif e == 1:
        return spell_integer(n) + "" thousand""
    else:
        return spell_integer(n) + "" "" + HUGE[e]
 
def base1000_rev(n):
    # generates the value of the digits of n in base 1000
    # (i.e. 3-digit chunks), in reverse.
    while n != 0:
        n, r = divmod(n, 1000)
        yield r
 
def spell_integer(n):
    if n < 0:
        return ""minus "" + spell_integer(-n)
    elif n < 20:
        return SMALL[n]
    elif n < 100:
        a, b = divmod(n, 10)
        return TENS[a] + nonzero(""-"", b)
    elif n < 1000:
        a, b = divmod(n, 100)
        return SMALL[a] + "" hundred"" + nonzero("" "", b, ' and')
    else:
        num = "", "".join([big(e, x) for e, x in
                         enumerate(base1000_rev(n)) if x][::-1])
        return last_and(num)
 
if __name__ == '__main__':
    # examples
    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):
        print('%+4i -> %s' % (n, spell_integer(n)))
    print('')  
 
    n = 201021002001
    while n:
        print('%-12i -> %s' % (n, spell_integer(n)))
        n //= -10
    print('%-12i -> %s' % (n, spell_integer(n)))
    print('')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Naming_conventions,Naming conventions,"Many languages have naming conventions regarding the identifiers used in the language, its libraries, and programs written in the language. Such conventions, which may be classified as de facto or de jure depending on how they are enforced,
often take the form of rules regarding prefixes, suffixes, and the use of upper-case and lower-case characters.

The naming conventions are sometimes a bit haphazard, especially if the language and/or library has gone through periods of evolution. (In this case: give a brief example and description.)

Document (with simple examples where possible) the evolution and current status of these naming conventions.
For example, name conventions for:

 Procedure and operator names. (Intrinsic or external)
 Class, Subclass and instance names.
 Built-in versus libraries names.


If possible, indicate where the naming conventions are implicit, explicit, mandatory or discretionary.
Any tools that enforced the the naming conventions.
Any cases where the naming convention as commonly violated.

If possible, indicate where the convention is used to hint at other issues. For example the C standard library uses a prefix of ""_"" to ""hide"" raw Operating System calls from the non systems-programmer, whereas Python embeds member functions in between ""__"" to make a member function ""private"".

See also

 Wikipedia: Naming convention (programming)

",Python,"#lang racket 
render-game-state 
send-message-to-client 
traverse-forest",Human_written,Python_from_Go
http://rosettacode.org/wiki/Inheritance/Multiple,Inheritance/Multiple,"Multiple inheritance allows to specify that one  class is a subclass of several other classes.

Some languages allow multiple inheritance for arbitrary classes,   others restrict it to interfaces,   some don't allow it at all.



Task

Write two classes (or interfaces) Camera and MobilePhone,   then write a class CameraPhone which is both a Camera and a MobilePhone.

There is no need to implement any functions for those classes.



",Python,"class Camera:
	def __init__(self, focalLength, resolution, memory):
		self.focalLength = focalLength
		self.resolution = resolution
		self.memory = memory

class Phone:
	def __init__(self, balance, batteryLevel, contacts):
		self.balance = balance
		self.batteryLevel = batteryLevel
		self.contacts = contacts

class CameraPhone:
	def __init__(self, cameraSample, phoneSample):
		self.cameraSample = cameraSample
		self.phoneSample = phoneSample",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Odd_word_problem,Odd word problem,"Task

Write a program that solves the odd word problem with the restrictions given below.



Description

You are promised an input stream consisting of English letters and punctuations.

It is guaranteed that:

 the words (sequence of consecutive letters) are delimited by one and only one punctuation,
 the stream will begin with a word,
 the words will be at least one letter long,   and 
 a full stop (a period, [.]) appears after, and only after, the last word.


Example

A stream with six words:

 what,is,the;meaning,of:life. 


The task is to reverse the letters in every other word while leaving punctuations intact, producing:

 what,si,the;gninaem,of:efil. 
while observing the following restrictions:

 Only I/O allowed is reading or writing one character at a time, which means: no reading in a string, no peeking ahead, no pushing characters back into the stream, and no storing characters in a global variable for later use;
 You are not to explicitly save characters in a collection data structure, such as arrays, strings, hash tables, etc, for later reversal;
 You are allowed to use recursions, closures, continuations, threads, co-routines, etc., even if their use implies the storage of multiple characters.


Test cases

Work on both the   ""life""   example given above, and also the text:

 we,are;not,in,kansas;any,more.

",Python,"import sys
import io
import unicodedata
 
def main():
    owp(sys.stdout, io.BytesIO(b""what,is,the;meaning,of:life.""))
    print()
    owp(sys.stdout, io.BytesIO(b""we,are;not,in,kansas;any,more.""))
    print()
 
def owp(dst, src):
    def byte_in():
        return src.read(1)
    def byte_out(b):
        dst.write(b)
    def odd():
        s = byte_in()
        if unicodedata.category(s.decode()) == ""Po"":
            return s
        b = odd()
        byte_out(s)
        return b
    while True:
        while True:
            b = byte_in()
            byte_out(b)
            if b == b""."":
                return
            if unicodedata.category(b.decode()) == ""Po"":
                break
        b = odd()
        byte_out(b)
        if b == b""."":
            return
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"import argparse
import random
import shapely.geometry as geometry
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
 
 
def main(args):
    # Styles
    plt.style.use(""ggplot"")
 
    # Creating figure
    fig = plt.figure()
    line, = plt.plot([], [], ""."")
 
    # Limit axes
    plt.xlim(0, 1)
    plt.ylim(0, 1)
 
    # Titles
    title = ""Chaos Game""
    plt.title(title)
    fig.canvas.set_window_title(title)
 
    # Getting data
    data = get_data(args.frames)
 
    # Creating animation
    line_ani = animation.FuncAnimation(
        fig=fig,
        func=update_line,
        frames=args.frames,
        fargs=(data, line),
        interval=args.interval,
        repeat=False
    )
 
    # To save the animation install ffmpeg and uncomment
    # line_ani.save(""chaos_game.gif"")
 
    plt.show()
 
 
def get_data(n):
    """"""
    Get data to plot
    """"""
    leg = 1
    triangle = get_triangle(leg)
    cur_point = gen_point_within_poly(triangle)
    data = []
    for _ in range(n):
        data.append((cur_point.x, cur_point.y))
        cur_point = next_point(triangle, cur_point)
    return data
 
 
def get_triangle(n):
    """"""
    Create right triangle
    """"""
    ax = ay = 0.0
    a = ax, ay
 
    bx = 0.5  *  n
    by = 0.75 * (n ** 2)
    b = bx, by
 
    cx = n
    cy = 0.0
    c = cx, cy
 
    triangle = geometry.Polygon([a, b, c])
    return triangle
 
 
def gen_point_within_poly(poly):
    """"""
    Generate random point inside given polygon
    """"""
    minx, miny, maxx, maxy = poly.bounds
    while True:
        x = random.uniform(minx, maxx)
        y = random.uniform(miny, maxy)
        point = geometry.Point(x, y)
        if point.within(poly):
            return point
 
 
def next_point(poly, point):
    """"""
    Generate next point according to chaos game rules
    """"""
    vertices = poly.boundary.coords[:-1]  # Last point is the same as the first one
    random_vertex = geometry.Point(random.choice(vertices))
    line = geometry.linestring.LineString([point, random_vertex])
    return line.centroid
 
 
def update_line(num, data, line):
    """"""
    Update line with new points
    """"""
    new_data = zip(*data[:num]) or [(), ()]
    line.set_data(new_data)
    return line,
 
 
if __name__ == ""__main__"":
    arg_parser = argparse.ArgumentParser(description=""Chaos Game by Suenweek (c) 2017"")
    arg_parser.add_argument(""-f"", dest=""frames"", type=int, default=1000)
    arg_parser.add_argument(""-i"", dest=""interval"", type=int, default=10)
 
    main(arg_parser.parse_args())",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification,Ramer-Douglas-Peucker line simplification,"Ramer-Douglas-Peucker line simplification

You are encouraged to solve this task according to the task description, using any language you may know.
The   Ramer–Douglas–Peucker   algorithm is a line simplification algorithm for reducing the number of points used to define its shape.



Task

Using the   Ramer–Douglas–Peucker   algorithm, simplify the   2D   line defined by the points:

   (0,0)  (1,0.1)  (2,-0.1)  (3,5)  (4,6)  (5,7)  (6,8.1)  (7,9)  (8,9)  (9,9) 

The error threshold to be used is:   1.0.

Display the remaining points here.



Reference

   the Wikipedia article:   Ramer-Douglas-Peucker algorithm.

",Python,"from typing import List, Tuple

pointType = Tuple[float, float]

def RDP(l: List[pointType], eps: float) -> List[pointType]:
    last = len(l) - 1
    p1 = l[0]
    p2 = l[last]
    x21 = p2[0] - p1[0]
    y21 = p2[1] - p1[1]

    dMax, x = max(
        (
            (
                abs(y21 * p[0] - x21 * p[1] + p2[0] * p1[1] - p2[1] * p1[0]),
                i + 1,
            )
            for i, p in enumerate(l[1:last])
        ),
        key=lambda t: t[0],
    )

    if dMax > eps:
        return RDP(l[:x], eps) + RDP(l[x:], eps)[1:]
    return [l[0], l[last]]

points = [
    (0, 0),
    (1, 0.1),
    (2, -0.1),
    (3, 5),
    (4, 6),
    (5, 7),
    (6, 8.1),
    (7, 9),
    (8, 9),
    (9, 9),
]

print(RDP(points, 1))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Van_der_Corput_sequence,Van der Corput sequence,"When counting integers in binary, if you put a (binary) point to the righEasyLangt of the count then the column immediately to the left denotes a digit with a multiplier of 




2

0




{\displaystyle 2^{0}}

; the digit in the next column to the left has a multiplier of 




2

1




{\displaystyle 2^{1}}

; and so on.

So in the following table:

  0.
  1.
 10.
 11.
 ...
the binary number ""10"" is 



1
×

2

1


+
0
×

2

0




{\displaystyle 1\times 2^{1}+0\times 2^{0}}

.

You can also have binary digits to the right of the “point”, just as in the decimal number system. In that case, the digit in the place immediately to the right of the point has a weight of 




2

−
1




{\displaystyle 2^{-1}}

, or 



1

/

2


{\displaystyle 1/2}

.
The weight for the second column to the right of the point is 




2

−
2




{\displaystyle 2^{-2}}

 or 



1

/

4


{\displaystyle 1/4}

. And so on.

If you take the integer binary count of the first table, and reflect the digits about the binary point, you end up with the van der Corput sequence of numbers in base 2.

  .0
  .1
  .01
  .11
  ...
The third member of the sequence, binary 0.01, is therefore 



0
×

2

−
1


+
1
×

2

−
2




{\displaystyle 0\times 2^{-1}+1\times 2^{-2}}

 or 



1

/

4


{\displaystyle 1/4}

.



 Distribution of 2500 points each: Van der Corput (top) vs pseudorandom




0
≤
x
<
1


{\displaystyle 0\leq x<1}


Monte Carlo simulations
This sequence is also a superset of the numbers representable by the ""fraction"" field of an old IEEE floating point standard. In that standard, the ""fraction"" field represented the fractional part of a binary number beginning with ""1."" e.g. 1.101001101.

Hint

A hint at a way to generate members of the sequence is to modify a routine used to change the base of an integer:

>>> def base10change(n, base):
	digits = []
	while n:
		n,remainder = divmod(n, base)
		digits.insert(0, remainder)
	return digits
 
>>> base10change(11, 2)
[1, 0, 1, 1]
the above showing that 11 in decimal is 



1
×

2

3


+
0
×

2

2


+
1
×

2

1


+
1
×

2

0




{\displaystyle 1\times 2^{3}+0\times 2^{2}+1\times 2^{1}+1\times 2^{0}}

.

Reflected this would become .1101 or 



1
×

2

−
1


+
1
×

2

−
2


+
0
×

2

−
3


+
1
×

2

−
4




{\displaystyle 1\times 2^{-1}+1\times 2^{-2}+0\times 2^{-3}+1\times 2^{-4}}





Task description

 Create a function/method/routine that given n, generates the n'th term of the van der Corput sequence in base 2.
 Use the function to compute and display the first ten members of the sequence. (The first member of the sequence is for n=0).
 As a stretch goal/extra credit, compute and show members of the sequence for bases other than 2.


See also

 The Basic Low Discrepancy Sequences
 Non-decimal radices/Convert
 Van der Corput sequence

",Python,"import math
 
def vdc(n, base = 2):
    vdc = 0
    denom = 1
    while n:
        vdc += math.fmod(n, base) / (denom *= base)
        n /= base # note: conversion from 'double' to 'int'
    return vdc
 
for base in range(2, 6):
    print(""Base "", base)
    for n in range(0, 10):
        print(vdc(n, base), "" "")
    print(""\n\n"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Morse_code,Morse code,"Morse code
It has been in use for more than 175 years — longer than any other electronic encoding system.



Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).



As the standard Morse code does not contain all possible characters,
you may either ignore unknown characters in the file,
or indicate them somehow   (e.g. with a different pitch).



",Python,"import time, winsound #, sys
 
char2morse = {          
          ""!"": ""---."",      ""\"""": "".-..-."",     ""$"": ""...-..-"",    ""'"": "".----."",  
          ""("": ""-.--."",      "")"": ""-.--.-"",     ""+"": "".-.-."",      "","": ""--..--"", 
          ""-"": ""-....-"",     ""."": "".-.-.-"",     ""/"": ""-..-."", 
          ""0"": ""-----"",      ""1"": "".----"",      ""2"": ""..---"",      ""3"": ""...--"", 
          ""4"": ""....-"",      ""5"": ""....."",      ""6"": ""-...."",      ""7"": ""--..."", 
          ""8"": ""---.."",      ""9"": ""----."", 
          "":"": ""---..."",     "";"": ""-.-.-."",     ""="": ""-...-"",      ""?"": ""..--.."", 
          ""@"": "".--.-."", 
          ""A"": "".-"",         ""B"": ""-..."",       ""C"": ""-.-."",       ""D"": ""-.."", 
          ""E"": ""."",          ""F"": ""..-."",       ""G"": ""--."",        ""H"": ""...."", 
          ""I"": "".."",         ""J"": "".---"",       ""K"": ""-.-"",        ""L"": "".-.."", 
          ""M"": ""--"",         ""N"": ""-."",         ""O"": ""---"",        ""P"": "".--."", 
          ""Q"": ""--.-"",       ""R"": "".-."",        ""S"": ""..."",        ""T"": ""-"", 
          ""U"": ""..-"",        ""V"": ""...-"",       ""W"": "".--"",        ""X"": ""-..-"", 
          ""Y"": ""-.--"",       ""Z"": ""--.."", 
          ""["": ""-.--."",      ""]"": ""-.--.-"",     ""_"": ""..--.-"",
 }
 
e = 50      # Element time in ms. one dit is on for e then off for e
f = 1280    # Tone freq. in hertz
chargap = 1 # Time between characters of a word, in units of e
wordgap = 7 # Time between words, in units of e
 
def gap(n=1):
    time.sleep(n * e / 1000)
off = gap
 
def on(n=1):
    winsound.Beep(f, n * e)
 
def dit():
    on(); off()
 
def dah():
    on(3); off()
 
def bloop(n=3):
    winsound.Beep(f//2, n * e)
 
def windowsmorse(text):
    for word in text.strip().upper().split():
        for char in word:
            for element in char2morse.get(char, '?'):
                if element == '-':
                    dah()
                elif element == '.':
                    dit()
                else:
                    bloop()
            gap(chargap)
        gap(wordgap)
 
# Outputs its own source file as Morse. An audible quine!
#with open(sys.argv[0], 'r') as thisfile:
#    windowsmorse(thisfile.read())
 
while True:
    windowsmorse(input('A string to change into morse: '))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Statistics/Basic,Statistics/Basic,"Statistics is all about large groups of numbers.
When talking about a set of sampled data, most frequently used is their mean value and standard deviation (stddev).
If you have set of data 




x

i




{\displaystyle x_{i}}

 where 



i
=
1
,
2
,
…
,
n




{\displaystyle i=1,2,\ldots ,n\,\!}

, the mean is 






x
¯



≡


1
n



∑

i



x

i




{\displaystyle {\bar {x}}\equiv {1 \over n}\sum _{i}x_{i}}

, while the stddev is 



σ
≡




1
n



∑

i




(

x

i


−



x
¯



)


2






{\displaystyle \sigma \equiv {\sqrt {{1 \over n}\sum _{i}\left(x_{i}-{\bar {x}}\right)^{2}}}}

.

When examining a large quantity of data, one often uses a histogram, which shows the counts of data samples falling into a prechosen set of intervals (or bins).
When plotted, often as bar graphs, it visually indicates how often each data value occurs.

Task Using your language's random number routine, generate real numbers in the range of [0, 1]. It doesn't matter if you chose to use open or closed range.
Create 100 of such numbers (i.e. sample size 100) and calculate their mean and stddev.
Do so for sample size of 1,000 and 10,000, maybe even higher if you feel like.
Show a histogram of any of these sets.
Do you notice some patterns about the standard deviation?

Extra Sometimes so much data need to be processed that it's impossible to keep all of them at once. Can you calculate the mean, stddev and histogram of a trillion numbers? (You don't really need to do a trillion numbers, just show how it can be done.)

Hint

For a finite population with equal probabilities at all points, one can derive:








(
x
−


x
¯



)

2



¯


=



x

2


¯


−



x
¯



2




{\displaystyle {\overline {(x-{\overline {x}})^{2}}}={\overline {x^{2}}}-{\overline {x}}^{2}}


Or, more verbosely:







1
N



∑

i
=
1


N


(

x

i


−


x
¯



)

2


=


1
N



(

∑

i
=
1


N



x

i


2


)

−



x
¯



2


.


{\displaystyle {\frac {1}{N}}\sum _{i=1}^{N}(x_{i}-{\overline {x}})^{2}={\frac {1}{N}}\left(\sum _{i=1}^{N}x_{i}^{2}\right)-{\overline {x}}^{2}.}


See also
 Statistics/Normal distribution
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"import random
import math
import numpy as np
import matplotlib.pyplot as plt

def sample(n):
    # generate data
    d = [random.random() for i in range(n)]
    # show mean, standard deviation
    sum = 0
    ssq = 0
    for s in d:
        sum += s
        ssq += s * s
    print(n, ""numbers"")
    m = sum / float(n)
    print(""Mean:  "", m)
    print(""Stddev:"", math.sqrt(ssq/float(n)-m*m))
    # show histogram
    h = [0 for i in range(10)]
    for s in d:
        h[int(s*10)] += 1
    for c in h:
        print(""*"" * (c*205/int(n)))
    print()

sample(100)
sample(1000)
sample(10000)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Search_a_list_of_records,Search a list of records,"Many programming languages provide convenient ways to look for a known value in a simple list of strings or numbers.

But what if the elements of the list are themselves compound records/objects/data-structures, and the search condition is more complex than a simple equality test?

Task[edit]
Write a function/method/etc. that can find the first element in a given list matching a given condition.

It should be as generic and reusable as possible.

(Of course if your programming language already provides such a feature, you can use that instead of recreating it.)

Then to demonstrate its functionality, create the data structure specified under #Data set, and perform on it the searches specified under #Test cases.

Data set
The data structure to be used contains the names and populations (in millions) of the 10 largest metropolitan areas in Africa, and looks as follows when represented in JSON:

[
  { ""name"": ""Lagos"",                ""population"": 21.0  },
  { ""name"": ""Cairo"",                ""population"": 15.2  },
  { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
  { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
  { ""name"": ""Mogadishu"",            ""population"":  5.85 },
  { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
  { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
  { ""name"": ""Alexandria"",           ""population"":  4.58 },
  { ""name"": ""Abidjan"",              ""population"":  4.4  },
  { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
However, you shouldn't parse it from JSON, but rather represent it natively in your programming language.

 The top-level data structure should be an ordered collection (i.e. a list, array, vector, or similar).
 Each element in this list should be an associative collection that maps from keys to values (i.e. a struct, object, hash map, dictionary, or similar).
 Each of them has two entries: One string value with key ""name"", and one numeric value with key ""population"".
 You may rely on the list being sorted by population count, as long as you explain this to readers.


If any of that is impossible or unreasonable in your programming language, then feel free to deviate, as long as you explain your reasons in a comment above your solution.

Test cases


 Search

 Expected result


 Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""

 6


 Find the name of the first city in this list whose population is less than 5 million

 Khartoum-Omdurman


 Find the population of the first city in this list whose name starts with the letter ""A""

 4.58

Guidance
If your programming language supports higher-order programming, then the most elegant way to implement the requested functionality in a generic and reusable way, might be to write a function (maybe called ""find_index"" or similar), that takes two arguments:

 The list to search through.
 A function/lambda/closure (the so-called ""predicate""), which will be applied in turn to each element in the list, and whose boolean return value defines whether that element matches the search requirement.
If this is not the approach which would be most natural or idiomatic in your language, explain why, and show what is.

Related tasks
 Search a list
",Python,"cities = [
    { ""name"": ""Lagos"",                ""population"": 21.0  },
    { ""name"": ""Cairo"",                ""population"": 15.2  },
    { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
    { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
    { ""name"": ""Mogadishu"",            ""population"":  5.85 },
    { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
    { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
    { ""name"": ""Alexandria"",           ""population"":  4.58 },
    { ""name"": ""Abidjan"",              ""population"":  4.4  },
    { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
 
def first(query):
    return next(query, None)
 
print(
    first(index for index, city in enumerate(cities)
        if city['name'] == ""Dar Es Salaam""),
    first(city['name'] for city in cities if city['population'] < 5),
    first(city['population'] for city in cities if city['name'][0] == 'A'),
    sep='\n')",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Send_an_unknown_method_call,Send an unknown method call,"Task

Invoke an object method where the name of the method to be invoked can be generated at run time.



Related tasks

 Respond to an unknown method call.
 Runtime evaluation

",Python,"class Example(object):
     def foo(self, x):
             return 42 + x
 
name = ""foo""
getattr(Example(), name)(5)      # => 47",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",Python,"from decimal import Decimal as D
from collections import namedtuple
 
Item = namedtuple('Item', 'price, quant')
 
items = dict( hamburger=Item(D('5.50'), D('4000000000000000')),
              milkshake=Item(D('2.86'), D('2')) )
tax_rate = D('0.0765')
 
fmt = ""%-10s %8s %18s %22s""
print(fmt % tuple('Item Price Quantity Extension'.upper().split()))
 
total_before_tax = 0
for item, (price, quant) in sorted(items.items()):
    ext = price * quant
    print(fmt % (item, price, quant, ext))
    total_before_tax += ext
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'subtotal', total_before_tax))
 
tax = (tax_rate * total_before_tax).quantize(D('0.00'))
print(fmt % ('', '', 'Tax', tax))
 
total = total_before_tax + tax
print(fmt % ('', '', '', '--------------------'))
print(fmt % ('', '', 'Total', total))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Singly-linked_list/Element_insertion,Singly-linked list/Element insertion,"Singly-Linked List (element)
singly-linked list
Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"def insert_after(list_node, new_node):
  new_node.next = list_node.next
  list_node.next = new_node",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Top_rank_per_group,Top rank per group,"Task

Find the top   N   salaries in each department,   where   N   is provided as a parameter.

Use this data as a formatted internal data structure (adapt it to your language-native idioms, rather than parse at runtime), or identify your external data source:

Employee Name,Employee ID,Salary,Department
Tyler Bennett,E10297,32000,D101
John Rappl,E21437,47000,D050
George Woltman,E00127,53500,D101
Adam Smith,E63535,18000,D202
Claire Buckman,E39876,27800,D202
David McClellan,E04242,41500,D101
Rich Holcomb,E01234,49500,D202
Nathan Adams,E41298,21900,D050
Richard Potter,E43128,15900,D101
David Motsinger,E27002,19250,D202
Tim Sampair,E03033,27000,D101
Kim Arlich,E10001,57000,D190
Timothy Grove,E16398,29900,D190


",Python,"import os
import sys
import re
import collections

class Employee:
    def __init__(self, rec):
        self.name = rec[0]
        self.id = rec[1]
        self.salary = int(rec[2])
        self.department = rec[3]

    def __str__(self):
        return ""%s %s %d %s"" % (self.id, self.name, self.salary, self.department)

def main():
    N = int(sys.argv[1]) if len(sys.argv) > 1 else 3

    records = collections.defaultdict(list)
    with open(""data.txt"") as f:
        for line in f:
            rec = line.strip().split("", "")
            records[rec[3]].append(Employee(rec))

    for key, val in records.items():
        print(""\nDepartment %s"" % key)
        for emp in sorted(val, key=lambda x: x.salary, reverse=True)[:N]:
            print(emp)

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Case-sensitivity_of_identifiers,Case-sensitivity of identifiers,"Three dogs (Are there three dogs or one dog?) is a code snippet used to illustrate the lettercase sensitivity of the programming language. For a case-sensitive language, the identifiers dog, Dog and DOG are all different and we should get the output:

The three dogs are named Benjamin, Samba and Bernie.

For a language that is lettercase insensitive, we get the following output:

There is just one dog named Bernie.



Related task

 Unicode variable names

",Python,"dog = ""Benjamin""
Dog = ""Samba""
DOG = ""Bernie""
 
print(""The three dogs are named"", dog, "","", Dog, "", and"", DOG)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Pythagoras_tree,Pythagoras tree,"
The Pythagoras tree is a fractal tree constructed from squares. It is named after Pythagoras because each triple of touching squares encloses a right triangle, in a configuration traditionally used to represent the Pythagorean theorem.




Task
Construct a Pythagoras tree of order 7 using only vectors (no rotation or trigonometric functions).




Related tasks
 Fractal tree

",Python,"from turtle import goto, pu, pd, color, done
 
def level(ax, ay, bx, by, depth=0):
    if depth > 0:
        dx,dy = bx-ax, ay-by
        x3,y3 = bx-dy, by-dx
        x4,y4 = ax-dy, ay-dx
        x5,y5 = x4 + (dx - dy)/2, y4 - (dx + dy)/2
        goto(ax, ay), pd()
        for x, y in ((bx, by), (x3, y3), (x4, y4), (ax, ay)):
            goto(x, y)
        pu()
        level(x4,y4, x5,y5, depth - 1)
        level(x5,y5, x3,y3, depth - 1)
 
if __name__ == '__main__':
    color('red', 'yellow')
    pu()
    level(-100, 500, 100, 500, depth=8)
    done()",Human_written,Python_from_C
http://rosettacode.org/wiki/Brace_expansion,Brace expansion,"Brace expansion is a type of parameter expansion made popular by Unix shells, where it allows users to specify multiple similar string parameters without having to type them all out. E.g. the parameter enable_{audio,video} would be interpreted as if both enable_audio and enable_video had been specified.



Task[edit]
Write a function that can perform brace expansion on any input string, according to the following specification.

Demonstrate how it would be used, and that it passes the four test cases given below.

Specification
In the input string, balanced pairs of braces containing comma-separated substrings (details below) represent alternations that specify multiple alternatives which are to appear at that position in the output. In general, one can imagine the information conveyed by the input string as a tree of nested alternations interspersed with literal substrings, as shown in the middle part of the following diagram:


It{{em,alic}iz,erat}e{d,}

parse 
―――――▶
‌



It




⎧
⎨
⎩





⎧
⎨
⎩

em

⎫
⎬
⎭


alic



iz


⎫
⎬
⎭


erat


e




⎧
⎨
⎩

d

⎫
⎬
⎭


‌





expand 
―――――▶
‌
Itemized
Itemize
Italicized
Italicize
Iterated
Iterate


input string

alternation tree

output (list of strings)

This tree can in turn be transformed into the intended list of output strings by, colloquially speaking, determining all the possible ways to walk through it from left to right while only descending into one branch of each alternation one comes across (see the right part of the diagram). When implementing it, one can of course combine the parsing and expansion into a single algorithm, but this specification discusses them separately for the sake of clarity.

Expansion of alternations can be more rigorously described by these rules:





a




⎧
⎨
⎩

2

⎫
⎬
⎭


1


b




⎧
⎨
⎩

X

⎫
⎬
⎭


Y
X


c



⟶

a2bXc
a2bYc
a2bXc
a1bXc
a1bYc
a1bXc




An alternation causes the list of alternatives that will be produced by its parent branch to be increased 𝑛-fold, each copy featuring one of the 𝑛 alternatives produced by the alternation's child branches, in turn, at that position.


This means that multiple alternations inside the same branch are cumulative  (i.e. the complete list of alternatives produced by a branch is the string-concatenating ""Cartesian product"" of its parts).


All alternatives (even duplicate and empty ones) are preserved, and they are ordered like the examples demonstrate  (i.e. ""lexicographically"" with regard to the alternations).


The alternatives produced by the root branch constitute the final output.


Parsing the input string involves some additional complexity to deal with escaped characters and ""incomplete"" brace pairs:


a\\{\\\{b,c\,d}
⟶


a\\




⎧
⎨
⎩

\\\{b

⎫
⎬
⎭


c\,d





{a,b{c{,{d}}e}f
⟶


{a,b{c




⎧
⎨
⎩

‌

⎫
⎬
⎭


{d}


e}f





An unescaped backslash which precedes another character, escapes that character (to force it to be treated as literal). The backslashes are passed along to the output unchanged.


Balanced brace pairs are identified by, conceptually, going through the string from left to right and associating each unescaped closing brace that is encountered with the nearest still unassociated unescaped opening brace to its left (if any). Furthermore, each unescaped comma is associated with the innermost brace pair that contains it (if any). With that in mind:


Each brace pair that has at least one comma associated with it, forms an alternation (whose branches are the brace pair's contents split at its commas). The associated brace and comma characters themselves do not become part of the output.


Brace characters from pairs without any associated comma, as well as unassociated brace and comma characters, as well as all characters that are not covered by the preceding rules, are instead treated as literals.




For every possible input string, your implementation should produce exactly the output which this specification mandates. Please comply with this even when it's inconvenient, to ensure that all implementations are comparable. However, none of the above should be interpreted as instructions (or even recommendations) for how to implement it. Try to come up with a solution that is idiomatic in your programming language. (See #Perl for a reference implementation.)

Test Cases


 Input
(single string)

 Ouput
(list/array of strings)



~/{Downloads,Pictures}/*.{jpg,gif,png}



~/Downloads/*.jpg
~/Downloads/*.gif
~/Downloads/*.png
~/Pictures/*.jpg
~/Pictures/*.gif
~/Pictures/*.png




It{{em,alic}iz,erat}e{d,}, please.



Itemized, please.
Itemize, please.
Italicized, please.
Italicize, please.
Iterated, please.
Iterate, please.




{,{,gotta have{ ,\, again\, }}more }cowbell!



cowbell!
more cowbell!
gotta have more cowbell!
gotta have\, again\, more cowbell!




{}} some }{,{\\{ edge, edge} \,}{ cases, {here} \\\\\}



{}} some }{,{\\ edge \,}{ cases, {here} \\\\\}
{}} some }{,{\\ edge \,}{ cases, {here} \\\\\}




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




   Brace_expansion_using_ranges

",Python,"def getitem(s, depth=0):
    out = [""""]
    while s:
        c = s[0]
        if depth and (c == ',' or c == '}'):
            return out,s
        if c == '{':
            x = getgroup(s[1:], depth+1)
            if x:
                out,s = [a+b for a in out for b in x[0]], x[1]
                continue
        if c == '\\' and len(s) > 1:
            s, c = s[1:], c + s[1]
 
        out, s = [a+c for a in out], s[1:]
 
    return out,s
 
def getgroup(s, depth):
    out, comma = [], False
    while s:
        g,s = getitem(s, depth)
        if not s: break
        out += g
 
        if s[0] == '}':
            if comma: return out, s[1:]
            return ['{' + a + '}' for a in out], s[1:]
 
        if s[0] == ',':
            comma,s = True, s[1:]
 
    return None
 
# stolen cowbells from Raku example
for s in '''~/{Downloads,Pictures}/*.{jpg,gif,png}
It{{em,alic}iz,erat}e{d,}, please.
{,{,gotta have{ ,\, again\, }}more }cowbell!
{}} some }{,{\\\\{ edge, edge} \,}{ cases, {here} \\\\\\\\\}'''.split('\n'):
    print ""\n\t"".join([s] + getitem(s)[0]) + ""\n""",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",Python,"import inspect
 
# Sample classes for inspection
class Super(object):
  def __init__(self, name):
    self.name = name
 
  def __str__(self):
    return ""Super(%s)"" % (self.name,)
 
  def doSup(self):
    return 'did super stuff'
 
  @classmethod
  def cls(cls):
    return 'cls method (in sup)'
 
  @classmethod
  def supCls(cls):
    return 'Super method'
 
  @staticmethod
  def supStatic():
    return 'static method'
 
class Other(object):
  def otherMethod(self):
    return 'other method'
 
class Sub(Other, Super):
  def __init__(self, name, *args):
    super(Sub, self).__init__(name);
    self.rest = args;
    self.methods = {}
 
  def __dir__(self):
    return list(set( \
        sum([dir(base) for base in type(self).__bases__], []) \
        + type(self).__dict__.keys() \
        + self.__dict__.keys() \
        + self.methods.keys() \
      ))
 
  def __getattr__(self, name):
    if name in self.methods:
      if callable(self.methods[name]) and self.methods[name].__code__.co_argcount > 0:
        if self.methods[name].__code__.co_varnames[0] == 'self':
          return self.methods[name].__get__(self, type(self))
        if self.methods[name].__code__.co_varnames[0] == 'cls':
          return self.methods[name].__get__(type(self), type)
      return self.methods[name]
    raise AttributeError(""'%s' object has no attribute '%s'"" % (type(self).__name__, name))
 
  def __str__(self):
    return ""Sub(%s)"" % self.name
 
  def doSub():
    return 'did sub stuff'
 
  @classmethod
  def cls(cls):
    return 'cls method (in Sub)'
 
  @classmethod
  def subCls(cls):
    return 'Sub method'
 
  @staticmethod
  def subStatic():
    return 'Sub method'
 
sup = Super('sup')
sub = Sub('sub', 0, 'I', 'two')
sub.methods['incr'] = lambda x: x+1
sub.methods['strs'] = lambda self, x: str(self) * x
 
# names
[method for method in dir(sub) if callable(getattr(sub, method))]
# instance methods
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == sub]
#['__dir__', '__getattr__', '__init__', '__str__', 'doSub', 'doSup', 'otherMethod', 'strs']
# class methods 
[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == type(sub)]
#['__subclasshook__', 'cls', 'subCls', 'supCls']
# static & free dynamic methods
[method for method in dir(sub) if callable(getattr(sub, method)) and type(getattr(sub, method)) == type(lambda:nil)]
#['incr', 'subStatic', 'supStatic']
 
# names & values; doesn't include wrapped, C-native methods
inspect.getmembers(sub, predicate=inspect.ismethod)
# names using inspect
map(lambda t: t[0], inspect.getmembers(sub, predicate=inspect.ismethod))
#['__dir__', '__getattr__', '__init__', '__str__', 'cls', 'doSub', 'doSup', 'otherMethod', 'strs', 'subCls', 'supCls']",Human_written,Python_from_C#
http://rosettacode.org/wiki/MAC_Vendor_Lookup,MAC Vendor Lookup,"Every connected device around the world comes with a unique Media Access Control address, or a   MAC address.

A common task a network administrator may come across is being able to identify a network device's manufacturer when given only a MAC address.



Task

Interface with one (or numerous) APIs that exist on the internet and retrieve the device manufacturer based on a supplied MAC address.

A MAC address that does not return a valid result should return the String ""N/A"".   An error related to the network connectivity or the API should return a null result.

Many implementations on this page use http://api.macvendors.com/ which, as of 19th September 2021, is throttling requests. After only 2 calls, the following response is returned for all subsequent requests. If you are planning to use the same provider or going to run the examples on this page, consider building in a delay between two calls.

{""errors"":{""detail"":""Too Many Requests"",""message"":""Please slow down your requests or upgrade your plan at https://macvendors.com""}}
",Python,"import requests
import time
 
def get_vendor(mac):
    url = ""http://api.macvendors.com/"" + mac
    try:
        res = requests.get(url)
        if res.status_code == 200:
            if ""Not Found"" in res.text:
                return ""N/A""
            else:
                return res.text
        else:
            return None
    except Exception as e:
        print(e)
        return None
 
if __name__ == ""__main__"":
    print(get_vendor(""88:53:2E:67:07:BE""))
    time.sleep(1)
    print(get_vendor(""FC:FB:FB:01:FA:21""))
    time.sleep(1)
    print(get_vendor(""FC-A1-3E""))
    time.sleep(1)
    print(get_vendor(""abcdefg""))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"import sys

a, b = map(int, sys.stdin.readline().split())

if a < b:
    print(a, ""is less than"", b)

if a == b:
    print(a, ""is equal to"", b)

if a > b:
    print(a, ""is greater than"", b)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",Python,"from PIL import Image
 
if __name__ == ""__main__"":
	w, h, zoom = 800,600,1
	bitmap = Image.new(""RGB"", (w, h), ""white"")
	pix = bitmap.load()
 
	cX, cY = -0.7, 0.27015
	moveX, moveY = 0.0, 0.0
	maxIter = 255
 
	for x in range(w):
		for y in range(h):
			zx = 1.5*(x - w/2)/(0.5*zoom*w) + moveX
			zy = 1.0*(y - h/2)/(0.5*zoom*h) + moveY
			i = maxIter
			while zx*zx + zy*zy < 4 and i > 1:
				tmp = zx*zx - zy*zy + cX
				zy,zx = 2.0*zx*zy + cY, tmp
				i -= 1
			# convert byte to RGB (3 bytes), kinda magic to get nice colors
			pix[x][y] = (i << 21) + (i << 10) + i*8
 
	bitmap.show()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",Python,"import numpy as np
cimport numpy as np
N = 100000
q = np.zeros(N+1)
q[1] = q[2] = 1
for i in range(3,N+1):
	q[i] = q[i - q[i - 1]] + q[i - q[i - 2]]
for i in range(1,11):
	print(q[i], end=' ')
print()
print(q[1000])
flip = 0
for i in range(1,N):
	if q[i] > q[i+1]:
		flip += 1
print(""flips: "", flip)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Fast_Fourier_transform,Fast Fourier transform,"Task

Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.

The most general case allows for complex numbers at the input
and results in a sequence of equal length, again of complex numbers.
If you need to restrict yourself to real numbers, the output should
be the magnitude   (i.e.:   sqrt(re2 + im2))   of the complex result.

The classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.
Further optimizations are possible but not required.



",Python,"from cmath import exp, pi
 
def fft(x):
    N = len(x)
    if N <= 1: return x
    even = fft(x[0::2])
    odd =  fft(x[1::2])
    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]
    return [even[k] + T[k] for k in range(N//2)] + \
           [even[k] - T[k] for k in range(N//2)]
 
print( ' '.join(""%5.3f"" % abs(f) 
                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Terminal_control/Inverse_video,Terminal control/Inverse video,"Task

Display a word in inverse video   (or reverse video)   followed by a word in normal video.



",Python,"#!/usr/bin/env python
 
print ""\033[7mReversed\033[m Normal""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Copy_a_string,Copy a string,"This task is about copying a string.



Task

Where it is relevant, distinguish between copying the contents of a string
versus making an additional reference to an existing string.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> src = ""hello""
>>> a = src
>>> b = src[:]
>>> import copy
>>> c = copy.copy(src)
>>> d = copy.deepcopy(src)
>>> src is a is b is c is d
True",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Associative_array/Creation,Associative array/Creation,"Task

The goal is to create an associative array (also known as a dictionary, map, or hash).



Related tasks:

 Associative arrays/Iteration
 Hash from two arrays


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"hash = dict()  # 'dict' is the dictionary type.
hash = dict(red=""FF0000"", green=""00FF00"", blue=""0000FF"")
hash = { 'key1':1, 'key2':2, }
value = hash[key]",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Loops/Foreach,Loops/Foreach,"Loop through and print each element in a collection in order.

Use your language's ""for each"" loop if it has one, otherwise iterate through the collection in order with some other loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"for i in collection:
   print i",Human_written,Python_from_C
http://rosettacode.org/wiki/Collections,Collections,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Collections are abstractions to represent sets of values. 

In statically-typed languages, the values are typically of a common data type.



Task

Create a collection, and add a few values to it.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"collection = [0, '1']                 # Lists are mutable (editable) and can be sorted in place
x = collection[0]                     # accessing an item (which happens to be a numeric 0 (zero)
collection.append(2)                  # adding something to the end of the list
collection.insert(0, '-1')            # inserting a value into the beginning
y = collection[0]                     # now returns a string of ""-1""
collection.extend([2,'3'])            # same as [collection.append(i) for i in [2,'3']] ... but faster
collection += [2,'3']                 # same as previous line
collection[2:6]                       # a ""slice"" (collection of the list elements from the third up to but not including the sixth)
len(collection)                       # get the length of (number of elements in) the collection
collection = (0, 1)                   # Tuples are immutable (not editable)
collection[:]                         # ... slices work on these too; and this is equivalent to collection[0:len(collection)]
collection[-4:-1]                     # negative slices count from the end of the string
collection[::2]                       # slices can also specify a stride --- this returns all even elements of the collection
collection=""some string""              # strings are treated as sequences of characters
x = collection[::-1]                  # slice with negative step returns reversed sequence (string in this case).
collection[::2] == ""some string""[::2] # True, literal objects don't need to be bound to name/variable to access slices or object methods
collection.__getitem__(slice(0,len(collection),2))  # same as previous expressions.
collection = {0: ""zero"", 1: ""one""}    # Dictionaries (Hash)
collection['zero'] = 2                # Dictionary members accessed using same syntax as list/array indexes.
collection = set([0, '1'])            # sets (Hash)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Monads/Writer_monad,Monads/Writer monad,"The Writer monad is a programming design pattern which makes it possible to compose functions which return their result values paired with a log string. The final result of a composed function yields both a value, and a concatenation of the logs from each component function application.

Demonstrate in your programming language the following:

 Construct a Writer monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that monad (or just use what the language already provides)
 Write three simple functions: root, addOne, and half
 Derive Writer monad versions of each of these functions
 Apply a composition of the Writer versions of root, addOne, and half to the integer 5, deriving both a value for the Golden Ratio φ, and a concatenated log of the function applications (starting with the initial value, and followed by the application of root, etc.)",Python,"# version 1.2.10
 
from math import sqrt
 
class Writer:
    def __init__(self, value, s):
        self.value = value
        self.log = ""  {:<17}: {}\n"".format(s, value)
 
    def bind(self, f):
        new = f(self.value)
        new.log = self.log + new.log
        return new
 
    @staticmethod
    def unit(t, s):
        return Writer(t, s)
 
def root(d):
    return Writer.unit(sqrt(d), ""Took square root"")
 
def addOne(d):
    return Writer.unit(d + 1.0, ""Added one"")
 
def half(d):
    return Writer.unit(d / 2.0, ""Divided by two"")
 
if __name__ == ""__main__"":
    iv = Writer.unit(5.0, ""Initial value"")
    fv = iv.bind(root).bind(addOne).bind(half)
    print(""The Golden Ratio is {}"".format(fv.value))
    print(""\nThis was derived as follows:-\n{}"".format(fv.log))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Fibonacci_word/fractal,Fibonacci word/fractal,"
The Fibonacci word may be represented as a fractal as described here:


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)



For F_wordm start with F_wordCharn=1
Draw a segment forward
If current F_wordChar is 0
Turn left if n is even
Turn right if n is odd
next n and iterate until end of F_word


Task

Create and display a fractal similar to Fig 1.


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)
",Python,"import math
from PIL import Image, ImageDraw
 
def word_fractal(i):
    if i < 2:
        if i == 1:
            return ""1""
        return """"
    f1 = ""1""
    f2 = ""0""
    for j in range(i - 2, 0, -1):
        tmp = f2
        f2 += f1
        f1 = tmp
    return f2
 
def draw(draw, x, y, dx, dy, wf):
    for i, c in enumerate(wf):
        draw.line((x, y, x + dx, y + dy), fill=""black"")
        x += dx
        y += dy
        if c == '0':
            tx = dx
            dx = dy
            if i % 2 == 0:
                dx = -dy
            dy = -tx
            if i % 2 == 0:
                dy = tx
 
wf = word_fractal(23)
img = Image.new(""RGB"", (450, 620), ""white"")
draw = ImageDraw.Draw(img)
draw(draw, 20, 20, 1, 0, wf)
img.save(""fib_wordfractal.png"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Combinations_and_permutations,Combinations and permutations,"

 This page uses content from Wikipedia. The original article was at Combination. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



 This page uses content from Wikipedia. The original article was at Permutation. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)

Task

Implement the combination    (nCk)    and permutation    (nPk)    operators in the target language:

 






n



C

k


=



(


n
k


)



=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle ^{n}\operatorname {C} _{k}={\binom {n}{k}}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}


 






n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




See the Wikipedia articles for a more detailed description.

To test, generate and print examples of:

   A sample of permutations from 1 to 12 and Combinations from 10 to 60 using exact Integer arithmetic.
   A sample of permutations from 5 to 15000 and Combinations from 100 to 1000 using approximate Floating point arithmetic.
 This 'floating point' code could be implemented using an approximation, e.g., by calling the Gamma function.


Related task

   Evaluate binomial coefficients



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"from __future__ import print_function
 
from scipy.misc import factorial as fact
from scipy.misc import comb
 
def perm(N, k, exact=0):
    return comb(N, k, exact) * fact(k, exact)
 
exact=True
print('Sample Perms 1..12')
for N in range(1, 13):
    k = max(N-2, 1)
    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\n')
 
print('\n\nSample Combs 10..60')
for N in range(10, 61, 10):
    k = N-2
    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\n')
 
exact=False
print('\n\nSample Perms 5..1500 Using FP approximations')
for N in [5, 15, 150, 1500, 15000]:
    k = N-2
    print('%iP%i =' % (N, k), perm(N, k, exact))
 
print('\nSample Combs 100..1000 Using FP approximations')
for N in range(100, 1001, 100):
    k = N-2
    print('%iC%i =' % (N, k), comb(N, k, exact))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Pseudo-random_numbers/Xorshift_star,Pseudo-random numbers/Xorshift star,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
Xorshift_star Generator (pseudo-code)

   /* Let u64 denote an unsigned 64 bit integer type. */
   /* Let u32 denote an unsigned 32 bit integer type. */



   class Xorshift_star
       u64 state       /* Must be seeded to non-zero initial value */
       u64 const = HEX '2545F4914F6CDD1D'

       method seed(u64 num):
           state =  num
       end method
       
       method next_int():
           u64 x = state
           x = x ^ (x >> 12)
           x = x ^ (x << 25)
           x = x ^ (x >> 27)
           state = x
           u32 answer = ((x * const) >> 32)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / (1 << 32)
       end method
       
   end class
       

Xorshift use

   random_gen = instance Xorshift_star
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 3540625527 */
   print(random_gen.next_int())   /* 2750739987 */
   print(random_gen.next_int())   /* 4037983143 */
   print(random_gen.next_int())   /* 1993361440 */
   print(random_gen.next_int())   /* 3809424708 */

Task

 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers genrated with the seed 1234567
are as shown above

 Show that for an initial seed of 987654321, the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20103, 1: 19922, 2: 19937, 3: 20031, 4: 20007

 Show your output here, on this page.

",Python,"mask64 = (1 << 64) - 1
mask32 = (1 << 32) - 1
const = 0x2545F4914F6CDD1D
 
 
 
class Xorshift_star():
 
    def __init__(self, seed=0):
        self.state = seed & mask64
 
    def seed(self, num):
        self.state =  num & mask64
 
    def next_int(self):
        ""return random int between 0 and 2**32""
        x = self.state
        x = (x ^ (x >> 12)) & mask64
        x = (x ^ (x << 25)) & mask64
        x = (x ^ (x >> 27)) & mask64
        self.state = x
        answer = (((x * const) & mask64) >> 32) & mask32 
        return answer
 
    def  next_float(self):
        ""return random float between 0 and 1""
        return self.next_int() / (1 << 32)
 
 
if __name__ == '__main__':
    random_gen = Xorshift_star()
    random_gen.seed(1234567)
    for i in range(5):
        print(random_gen.next_int())
 
    random_gen.seed(987654321)
    hist = {i:0 for i in range(5)}
    for i in range(100_000):
        hist[int(random_gen.next_float() *5)] += 1
    print(hist)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Barnsley_fern,Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",Python,"import random
import turtle
 
def barnsleyFern(windowWidth, iter):
 
	x0=0
	y0=0
	x1=0
	y1=0
 
	for i in range(iter):
		diceThrow = random.randint(0,100)
 
		if(diceThrow==0):
			x1 = 0
			y1 = 0.16*y0
 
		elif(diceThrow>=1 and diceThrow<=7):
			x1 = -0.15*x0 + 0.28*y0
			y1 = 0.26*x0 + 0.24*y0 + 0.44
 
		elif(diceThrow>=8 and diceThrow<=15):
			x1 = 0.2*x0 - 0.26*y0
			y1 = 0.23*x0 + 0.22*y0 + 1.6
 
		else:
			x1 = 0.85*x0 + 0.04*y0
			y1 = -0.04*x0 + 0.85*y0 + 1.6
 
		turtle.goto(30*x1 + windowWidth/2.0,30*y1)
 
		x0 = x1
		y0 = y1
 
def main():
	num = int(input(""Enter number of iterations : ""))
 
	turtle.speed(0)
	turtle.penup()
	turtle.goto(-250,0)
	turtle.pendown()
	turtle.goto(250,0)
	turtle.goto(0,250)
	turtle.goto(0,-250)
	turtle.goto(-250,0)
	turtle.penup()
	turtle.goto(0,0)
	turtle.pendown()
 
	barnsleyFern(500,num)
 
	turtle.exitonclick()
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Text_processing/1,Text processing/1,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.
Often data is produced by one program, in the wrong format for later use by another program or person. In these situations another program can be written to parse and transform the original data into a format useful to the other. The term ""Data Munging"" is often used in programming circles for this task.

A request on the comp.lang.awk newsgroup led to a typical data munging task:

I have to analyse data files that have the following format:
Each row corresponds to 1 day and the field logic is: $1 is the date,
followed by 24 value/flag pairs, representing measurements at 01:00,
02:00 ... 24:00 of the respective day. In short:

<date> <val1> <flag1> <val2> <flag2> ...  <val24> <flag24>

Some test data is available at: 
... (nolonger available at original location)

I have to sum up the values (per day and only valid data, i.e. with
flag>0) in order to calculate the mean. That's not too difficult.
However, I also need to know what the ""maximum data gap"" is, i.e. the
longest period with successive invalid measurements (i.e values with
flag<=0)
The data is free to download and use and is of this format:

Data is no longer available at that link. Zipped mirror available here (offsite mirror).

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Only a sample of the data showing its format is given above. The full example file may be downloaded here.

Structure your program to show statistics for each line of the file, (similar to the original Python, Perl, and AWK examples below), followed by summary statistics for the file. When showing example output just show a few line statistics and the full end summary.
",Python,"# version 1.2.31
 
import re
import sys
 
rx = re.compile(r'\s+')
fmt = ""Line:  %s  Reject: %2d  Accept: %2d  Line_tot: %7.3f  Line_avg: %7.3f""
grandTotal = 0.0
readings = 0
date = """"
run = 0
maxRun = -1
finishLine = """"
 
with open(""readings.txt"") as file:
    for line in file:
        fields = rx.split(line)
        date = fields[0]
        if len(fields) == 49:
            accept = 0
            total = 0.0
            for i in range(1, len(fields), 2):
                if int(fields[i + 1]) >= 1:
                    accept += 1
                    total += float(fields[i])
                    if run > maxRun:
                        maxRun = run
                        finishLine = date
                    run = 0
                else:
                    run += 1
            grandTotal += total
            readings += accept
            print(fmt % (date, 24 - accept, accept, total, total / accept))
        else:
            print(""Line:  %s does not have 49 fields and has been ignored"" % date)
 
if run > maxRun:
    maxRun = run
    finishLine = date
average = grandTotal / readings
print(""\nFile     = %s"" % file.name)
print(""Total    = %7.3f"" % grandTotal)
print(""Readings = %d"" % readings)
print(""Average  = %7.3f"" % average)
print(""\nMaximum run of %d consecutive false readings"" % maxRun)
print(""ends at line starting with date: %s"" % finishLine)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/XML/DOM_serialization,XML/DOM serialization,"Create a simple DOM and having it serialize to:

 <?xml version=""1.0"" ?>
 <root>
     <element>
         Some text here
     </element>
 </root>
",Python,"from xml.etree.ElementTree import ElementTree, Element

root = Element('root')
element = Element('element')
element.text = 'Some text here'
root.append(element)

# save to a string
serialized = ElementTree(root).write(StringIO(), encoding='utf-8')
print serialized",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Ludic_numbers,Ludic numbers,"Ludic numbers   are related to prime numbers as they are generated by a sieve quite like the Sieve of Eratosthenes is used to generate prime numbers.

The first ludic number is   1.

To generate succeeding ludic numbers create an array of increasing integers starting from   2.

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
(Loop)

 Take the first member of the resultant array as the next ludic number   2.
 Remove every   2nd   indexed item from the array (including the first).
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
 (Unrolling a few loops...)
 Take the first member of the resultant array as the next ludic number   3.
 Remove every   3rd   indexed item from the array (including the first).
3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 ...
 Take the first member of the resultant array as the next ludic number   5.
 Remove every   5th   indexed item from the array (including the first).
5 7 11 13 17 19 23 25 29 31 35 37 41 43 47 49 53 55 59 61 65 67 71 73 77 ...
 Take the first member of the resultant array as the next ludic number   7.
 Remove every   7th   indexed item from the array (including the first).
7 11 13 17 23 25 29 31 37 41 43 47 53 55 59 61 67 71 73 77 83 85 89 91 97 ...
  ... 
 Take the first member of the current array as the next ludic number   L.
 Remove every   Lth   indexed item from the array (including the first).
  ... 


Task

 Generate and show here the first 25 ludic numbers.
 How many ludic numbers are there less than or equal to 1000?
 Show the 2000..2005th ludic numbers.


Stretch goal

Show all triplets of ludic numbers < 250.

 A triplet is any three numbers     



x
,


{\displaystyle x,}

   



x
+
2
,


{\displaystyle x+2,}

   



x
+
6


{\displaystyle x+6}

      where all three numbers are also ludic numbers. 

",Python,"def ludicUpTo(n):
	ludics = []
	for i in range(1, n + 1):
		ludics.append(i)
 
	for cursor in range(1, len(ludics)):
		thisLudic = ludics[cursor]
		removeCursor = cursor + thisLudic
		while removeCursor < len(ludics):
			ludics.remove(ludics[removeCursor])
			removeCursor = removeCursor + thisLudic - 1
	return ludics
 
def getTriplets(ludics):
	triplets = []
	for i in range(0, len(ludics) - 2):
		thisLudic = ludics[i]
		if thisLudic + 2 in ludics and thisLudic + 6 in ludics:
			triplet = [thisLudic, thisLudic + 2, thisLudic + 6]
			triplets.append(triplet)
	return triplets
 
print(""First 25 Ludics: "" + str(ludicUpTo(110)))
print(""Ludics up to 1000: "" + str(len(ludicUpTo(1000))))
print(""2000th - 2005th Ludics: "" + str(ludicUpTo(22000)[1999:2005]))
print(""Triplets up to 250: "" + str(getTriplets(ludicUpTo(250))))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Roman_numerals/Encode,Roman numerals/Encode,"Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.



In Roman numerals:

 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
 2008 is written as 2000=MM, 8=VIII; or MMVIII
 1666 uses each Roman symbol in descending order: MDCLXVI

",Python,"class Roman:
    def __init__(self):
        self.map = [
            1000, 'M', 900, 'CM', 500, 'D', 400, 'CD', 100, 'C', 90, 'XC',
            50, 'L', 40, 'XL', 10, 'X', 9, 'IX', 5, 'V', 4, 'IV', 1, 'I',
        ]

    def int_to_roman(self, n):
        value = ''
        for idx in range(0, len(self.map), 2):
            while n >= self.map[idx]:
                value += self.map[idx + 1]
                n -= self.map[idx]
        return value

roman = Roman()
roman.int_to_roman(1999) # ""MCMXCIX""",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,pq = queue.priority_queue(int),Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",Python,"from __future__ import print_function
from string import ascii_lowercase
 
SYMBOLTABLE = list(ascii_lowercase)
 
def move2front_encode(strng, symboltable):
    sequence, pad = [], symboltable[::]
    for char in strng:
        indx = pad.index(char)
        sequence.append(indx)
        pad = [pad.pop(indx)] + pad
    return sequence
 
def move2front_decode(sequence, symboltable):
    chars, pad = [], symboltable[::]
    for indx in sequence:
        char = pad[indx]
        chars.append(char)
        pad = [pad.pop(indx)] + pad
    return ''.join(chars)
 
if __name__ == '__main__':
    for s in ['broood', 'bananaaa', 'hiphophiphop']:
        encode = move2front_encode(s, SYMBOLTABLE)
        print('%14r encodes to %r' % (s, encode), end=', ')
        decode = move2front_decode(encode, SYMBOLTABLE)
        print('which decodes back to %r' % decode)
        assert s == decode, 'Whoops!'",Human_written,Python_from_C++
"http://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion","Angles (geometric), normalization and conversion","This task is about the normalization and/or conversion of (geometric) angles using
some common scales.



The angular scales that will be used in this task are:

   degree
   gradian
   mil
   radian


Definitions

The angular scales used or referenced here:

   turn   is a full turn or 360 degrees, also shown as 360º
   degree   is   1/360   of a turn
   gradian   is   1/400   of a turn
   mil   is   1/6400   of a turn
   radian   is   1/2



π


{\displaystyle \pi }

   of a turn   (or   0.5/



π


{\displaystyle \pi }

   of a turn)


Or, to put it another way,   for a full circle:

   there are   360   degrees
   there are   400   gradians
   there are   6,400   mils
   there are   2



π


{\displaystyle \pi }

   radians   (roughly equal to 6.283+)


A   mil   is approximately equal to a   milliradian   (which is   1/1000   of a radian).

There is another definition of a   mil   which
is   1/1000   of a radian   ─── this
definition won't be used in this Rosetta Code task.


Turns   are sometimes known or shown as:

   turn(s)
   360 degrees
   unit circle
   a (full) circle

Degrees   are sometimes known or shown as:

   degree(s)
   deg
   º       (a symbol)
   °       (another symbol)

Gradians   are sometimes known or shown as:

   gradian(s)
   grad(s)
   grade(s)
   gon(s)
   metric degree(s)
   (Note that   centigrade   was used for 1/100th of a grade, see the note below.)

Mils   are sometimes known or shown as:

   mil(s)
   NATO mil(s)

Radians   are sometimes known or shown as:

   radian(s)
   rad(s)


Notes

In continental Europe, the French term   centigrade   was used
for   1/100   of a grad (grade);   this was
one reason for the adoption of the term   Celsius   to
replace   centigrade   as the name of a temperature scale.

Gradians were commonly used in civil engineering.

Mils were normally used for artillery   (elevations of the gun barrel for ranging).



Positive and negative angles

Although the definition of the measurement of an angle doesn't support the
concept of a negative angle,   it's frequently useful to impose a convention that
allows positive and negative angular values to represent orientations and/or rotations
in opposite directions relative to some reference.   It is this reason that
negative angles will keep their sign and not be normalized to positive angles.



Normalization

Normalization   (for this Rosetta Code task)   will keep the same
sign,   but it will reduce the magnitude to less than a full circle;   in
other words, less than 360º.

Normalization   shouldn't   change   -45º   to   315º,

An angle of   0º,   +0º,   0.000000,   or   -0º   should be
shown as   0º.



Task

   write a function (or equivalent) to do the normalization for each scale
 Suggested names:
 d2d,   g2g,   m2m,   and  r2r
   write a function (or equivalent) to convert one scale to another
 Suggested names for comparison of different computer language function names:
 d2g,   d2m,   and   d2r   for degrees
 g2d,   g2m,   and   g2r   for gradians
 m2d,   m2g,   and   m2r   for mils
 r2d,   r2g,   and   r2m   for radians
   normalize all angles used   (except for the ""original"" or ""base"" angle)
   show the angles in every scale and convert them to all other scales
   show all output here on this page


For the (above) conversions,   use these dozen numbers   (in the order shown):

   -2   -1   0   1   2   6.2831853   16   57.2957795   359   399   6399   1000000

",Python,"import math
 
class Angles:
    BASES = {""d"": 360, ""g"": 400, ""m"": 6400, ""r"": math.pi*2, ""h"": 24}
 
    def __getattr__(self, meth):
        from_, to = Angles.BASES.values()
        raise AttributeError, meth
        mod = (angle * to / from_) % to
        return mod - to if angle < 0 else mod
 
#Demo
names = Angles.BASES.keys()
print "" "" + ""%12s ""*len(names) % names
test = [-2, -1, 0, 1, 2*math.pi, 16, 360/(2*math.pi), 360-1, 400-1, 6400-1, 1_000_000]
 
for n in test:
    for first in names:
        res = [Angles.send((first + ""2"" + last), n) for last in names]
        print first + ""%12g ""*len(names) % res
    print",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Check_that_file_exists,Check that file exists,"Task

Verify that a file called     input.txt     and   a directory called     docs     exist.



This should be done twice:  

   once for the current working directory,   and
   once for a file and a directory in the filesystem root.


Optional criteria (May 2015):   verify it works with:

   zero-length files
   an unusual filename:     `Abdu'l-Bahá.txt  

",Python,"import os
 
os.path.isfile(""input.txt"")
os.path.isfile(""/input.txt"")
os.path.isdir(""docs"")
os.path.isdir(""/docs"")",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Entropy,Entropy,"Task

Calculate the Shannon entropy   H   of a given input string.

Given the discrete random variable 



X


{\displaystyle X}

 that is a string of 



N


{\displaystyle N}

 ""symbols"" (total characters) consisting of 



n


{\displaystyle n}

 different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :






H

2


(
X
)
=
−

∑

i
=
1


n





c
o
u
n

t

i



N



log

2


⁡

(



c
o
u
n

t

i



N


)



{\displaystyle H_{2}(X)=-\sum _{i=1}^{n}{\frac {count_{i}}{N}}\log _{2}\left({\frac {count_{i}}{N}}\right)}


where 



c
o
u
n

t

i




{\displaystyle count_{i}}

 is the count of character 




n

i




{\displaystyle n_{i}}

.

For this task, use X=""1223334444"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.

This coding problem calculates the ""specific"" or ""intensive"" entropy that finds its parallel in physics with ""specific entropy"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the ""information"" content of a file. It comes from Boltzmann's H-theorem where 



S
=

k

B


N
H


{\displaystyle S=k_{B}NH}

 where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a ""per molecule"" basis.

The ""total"", ""absolute"", or ""extensive"" information entropy is





S
=

H

2


N


{\displaystyle S=H_{2}N}

 bits
This is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of ""information"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have 



S
=
N

log

2


⁡
(
16
)


{\displaystyle S=N\log _{2}(16)}

 bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.

The H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much ""order"" was in the data.

Two other ""entropies"" are useful:

Normalized specific entropy:






H

n


=




H

2


∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle H_{n}={\frac {H_{2}*\log(2)}{\log(n)}}}

 
which varies from 0 to 1 and it has units of ""entropy/symbol"" or just 1/symbol. For this example, Hn<\sub>= 0.923.

Normalized total (extensive) entropy:






S

n


=




H

2


N
∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle S_{n}={\frac {H_{2}N*\log(2)}{\log(n)}}}


which varies from 0 to N and does not have units. It is simply the ""entropy"", but it needs to be called ""total normalized extensive entropy"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\sub>= 9.23.

Shannon himself is the reason his ""entropy/symbol"" H function is very confusingly called ""entropy"". That's like calling a function that returns a speed a ""meter"". See section 1.7 of his classic A Mathematical Theory of Communication and search on ""per symbol"" and ""units"" to see he always stated his entropy H has units of ""bits/symbol"" or ""entropy/symbol"" or ""information/symbol"". So it is legitimate to say entropy NH is ""information"".

In keeping with Landauer's limit, the physics entropy generated from erasing N bits is 



S
=

H

2


N

k

B


ln
⁡
(
2
)


{\displaystyle S=H_{2}Nk_{B}\ln(2)}

 if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.

Related tasks

 Fibonacci_word
 Entropy/Narcissist

",Python,"from __future__ import division
import math
 
def hist(source):
    hist = {}; l = 0;
    for e in source:
        l += 1
        if e not in hist:
            hist[e] = 0
        hist[e] += 1
    return (l,hist)
 
def entropy(hist,l):
    elist = []
    for v in hist.values():
        c = v / l
        elist.append(-c * math.log(c ,2))
    return sum(elist)
 
def printHist(h):
    flip = lambda (k,v) : (v,k)
    h = sorted(h.iteritems(), key = flip)
    print 'Sym\thi\tfi\tInf'
    for (k,v) in h:
        print '%s\t%f\t%f\t%f'%(k,v,v/l,-math.log(v/l, 2))
 
 
 
source = ""1223334444""
(l,h) = hist(source);
print '.[Results].'
print 'Length',l
print 'Entropy:', entropy(h, l)
printHist(h)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Write_to_Windows_event_log,Write to Windows event log,"Task

Write script status to the Windows Event Log



",Python,"import subprocess
import sys
import time
 
def main():
    if sys.platform.startswith(""win""):
        subprocess.run([""EventCreate"", ""/t"", ""INFORMATION"", ""/id"", ""123"", ""/l"", ""APPLICATION"", ""/so"", ""Java"", ""/d"", ""Rosetta Code Example""])
    else:
        print(""Not windows"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",Python,"from __future__ import print_function
from string import ascii_lowercase
 
SYMBOLTABLE = list(ascii_lowercase)
 
def move2front_encode(strng, symboltable):
    sequence, pad = [], symboltable[::]
    for char in strng:
        indx = pad.index(char)
        sequence.append(indx)
        pad = [pad.pop(indx)] + pad
    return sequence
 
def move2front_decode(sequence, symboltable):
    chars, pad = [], symboltable[::]
    for indx in sequence:
        char = pad[indx]
        chars.append(char)
        pad = [pad.pop(indx)] + pad
    return ''.join(chars)
 
if __name__ == '__main__':
    for s in ['broood', 'bananaaa', 'hiphophiphop']:
        encode = move2front_encode(s, SYMBOLTABLE)
        print('%14r encodes to %r' % (s, encode), end=', ')
        decode = move2front_decode(encode, SYMBOLTABLE)
        print('which decodes back to %r' % decode)
        assert s == decode, 'Whoops!'",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Monads/Writer_monad,Monads/Writer monad,"The Writer monad is a programming design pattern which makes it possible to compose functions which return their result values paired with a log string. The final result of a composed function yields both a value, and a concatenation of the logs from each component function application.

Demonstrate in your programming language the following:

 Construct a Writer monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that monad (or just use what the language already provides)
 Write three simple functions: root, addOne, and half
 Derive Writer monad versions of each of these functions
 Apply a composition of the Writer versions of root, addOne, and half to the integer 5, deriving both a value for the Golden Ratio φ, and a concatenated log of the function applications (starting with the initial value, and followed by the application of root, etc.)",Python,"""""""A Writer Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
 
import functools
import math
import os
 
from typing import Any
from typing import Callable
from typing import Generic
from typing import List
from typing import TypeVar
from typing import Union
 
 
T = TypeVar(""T"")
 
 
class Writer(Generic[T]):
    def __init__(self, value: Union[T, Writer[T]], *msgs: str):
        if isinstance(value, Writer):
            self.value: T = value.value
            self.msgs: List[str] = value.msgs + list(msgs)
        else:
            self.value = value
            self.msgs = list(f""{msg}: {self.value}"" for msg in msgs)
 
    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        writer = func(self.value)
        return Writer(writer, *self.msgs)
 
    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        return self.bind(func)
 
    def __str__(self):
        return f""{self.value}\n{os.linesep.join(reversed(self.msgs))}""
 
    def __repr__(self):
        return f""Writer({self.value}, \""{', '.join(reversed(self.msgs))}\"")""
 
 
def lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:
    """"""Return a writer monad version of the simple function `func`.""""""
 
    @functools.wraps(func)
    def wrapped(value):
        return Writer(func(value), msg)
 
    return wrapped
 
 
if __name__ == ""__main__"":
    square_root = lift(math.sqrt, ""square root"")
    add_one = lift(lambda x: x + 1, ""add one"")
    half = lift(lambda x: x / 2, ""div two"")
 
    print(Writer(5, ""initial"") >> square_root >> add_one >> half)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Brazilian_numbers,Brazilian numbers,"Brazilian numbers are so called as they were first formally presented at the 1994 math Olympiad Olimpiada Iberoamericana de Matematica in Fortaleza, Brazil.

Brazilian numbers are defined as:

The set of positive integer numbers where each number N has at least one natural number B where 1 < B < N-1 where the representation of N in base B has all equal digits.



E.G.

 1, 2 & 3 can not be Brazilian; there is no base B that satisfies the condition 1 < B < N-1.
 4 is not Brazilian; 4 in base 2 is 100. The digits are not all the same.
 5 is not Brazilian; 5 in base 2 is 101, in base 3 is 12. There is no representation where the digits are the same.
 6 is not Brazilian; 6 in base 2 is 110, in base 3 is 20, in base 4 is 12. There is no representation where the digits are the same.
 7 is Brazilian; 7 in base 2 is 111. There is at least one representation where the digits are all the same.
 8 is Brazilian; 8 in base 3 is 22. There is at least one representation where the digits are all the same.
 and so on...


All even integers 2P >= 8 are Brazilian because 2P = 2(P-1) + 2, which is 22 in base P-1 when P-1 > 2. That becomes true when P >= 4.

More common: for all all integers R and S, where R > 1 and also S-1 > R, then R*S is Brazilian because R*S = R(S-1) + R, which is RR in base S-1

The only problematic numbers are squares of primes, where R = S. Only 11^2 is brazilian to base 3.

All prime integers, that are brazilian, can only have the digit 1. Otherwise one could factor out the digit, therefore it cannot be a prime number. Mostly in form of 111 to base Integer(sqrt(prime number)). Must be an odd count of 1 to stay odd like primes > 2


Task

Write a routine (function, whatever) to determine if a number is Brazilian and use the routine to show here, on this page;

 the first 20 Brazilian numbers;
 the first 20 odd Brazilian numbers;
 the first 20 prime Brazilian numbers;


See also

 OEIS:A125134 - Brazilian numbers
 OEIS:A257521 - Odd Brazilian numbers
 OEIS:A085104 - Prime Brazilian numbers

",Python,"'''Brazilian numbers'''
 
from itertools import count, islice
 
 
# isBrazil :: Int -> Bool
def isBrazil(n):
    '''True if n is a Brazilian number,
       in the sense of OEIS:A125134.
    '''
    return 7 <= n and (
        0 == n % 2 or any(
            map(monoDigit(n), range(2, n - 1))
        )
    )
 
 
# monoDigit :: Int -> Int -> Bool
def monoDigit(n):
    '''True if all the digits of n,
       in the given base, are the same.
    '''
    def go(base):
        def g(b, n):
            (q, d) = divmod(n, b)
 
            def p(qr):
                return d != qr[1] or 0 == qr[0]
 
            def f(qr):
                return divmod(qr[0], b)
            return d == until(p)(f)(
                (q, d)
            )[1]
        return g(base, n)
    return go
 
 
# -------------------------- TEST --------------------------
# main :: IO ()
def main():
    '''First 20 members each of:
        OEIS:A125134
        OEIS:A257521
        OEIS:A085104
    '''
    for kxs in ([
            (' ', count(1)),
            (' odd ', count(1, 2)),
            (' prime ', primes())
    ]):
        print(
            'First 20' + kxs[0] + 'Brazilians:\n' +
            showList(take(20)(filter(isBrazil, kxs[1]))) + '\n'
        )
 
 
# ------------------- GENERIC FUNCTIONS --------------------
 
# primes :: [Int]
def primes():
    ''' Non finite sequence of prime numbers.
    '''
    n = 2
    dct = {}
    while True:
        if n in dct:
            for p in dct[n]:
                dct.setdefault(n + p, []).append(p)
            del dct[n]
        else:
            yield n
            dct[n * n] = [n]
        n = 1 + n
 
 
# showList :: [a] -> String
def showList(xs):
    '''Stringification of a list.'''
    return '[' + ','.join(str(x) for x in xs) + ']'
 
 
# take :: Int -> [a] -> [a]
# take :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.
    '''
    def go(xs):
        return (
            xs[0:n]
            if isinstance(xs, (list, tuple))
            else list(islice(xs, n))
        )
    return go
 
 
# until :: (a -> Bool) -> (a -> a) -> a -> a
def until(p):
    '''The result of repeatedly applying f until p holds.
       The initial seed value is x.
    '''
    def go(f):
        def g(x):
            v = x
            while not p(v):
                v = f(v)
            return v
        return g
    return go
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Mutual_recursion,Mutual recursion,"Two functions are said to be mutually recursive if the first calls the second,
and in turn the second calls the first.

Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:










F
(
0
)



=
1
 
;
 
M
(
0
)
=
0




F
(
n
)



=
n
−
M
(
F
(
n
−
1
)
)
,

n
>
0




M
(
n
)



=
n
−
F
(
M
(
n
−
1
)
)
,

n
>
0.






{\displaystyle {\begin{aligned}F(0)&=1\ ;\ M(0)=0\\F(n)&=n-M(F(n-1)),\quad n>0\\M(n)&=n-F(M(n-1)),\quad n>0.\end{aligned}}}





(If a language does not allow for a solution using mutually recursive functions
then state this rather than give a solution by other means).



",Python,"def F(n): return 1 if n == 0 else n - M(F(n-1))
def M(n): return 0 if n == 0 else n - F(M(n-1))
 
print ([ F(n) for n in range(20) ])
print ([ M(n) for n in range(20) ])",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Mutual_recursion,Mutual recursion,"Two functions are said to be mutually recursive if the first calls the second,
and in turn the second calls the first.

Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:










F
(
0
)



=
1
 
;
 
M
(
0
)
=
0




F
(
n
)



=
n
−
M
(
F
(
n
−
1
)
)
,

n
>
0




M
(
n
)



=
n
−
F
(
M
(
n
−
1
)
)
,

n
>
0.






{\displaystyle {\begin{aligned}F(0)&=1\ ;\ M(0)=0\\F(n)&=n-M(F(n-1)),\quad n>0\\M(n)&=n-F(M(n-1)),\quad n>0.\end{aligned}}}





(If a language does not allow for a solution using mutually recursive functions
then state this rather than give a solution by other means).



",Python,"def F(n): return 1 if n == 0 else n - M(F(n-1))
def M(n): return 0 if n == 0 else n - F(M(n-1))
 
print ([ F(n) for n in range(20) ])
print ([ M(n) for n in range(20) ])",Human_written,Python_from_C
http://rosettacode.org/wiki/Langton%27s_ant,Langton's ant,"Langton's ant is a cellular automaton that models an ant sitting on a plane of cells, all of which are white initially, the ant facing in one of four directions.

Each cell can either be black or white.

The ant moves according to the color of the cell it is currently sitting in, with the following rules:

   If the cell is black, it changes to white and the ant turns left;
   If the cell is white, it changes to black and the ant turns right;
   The ant then moves forward to the next cell, and repeat from step 1.

This rather simple ruleset leads to an initially chaotic movement pattern, and after about 10000 steps, a cycle appears where the ant moves steadily away from the starting location in a diagonal corridor about 10 cells wide.
Conceptually the ant can then walk infinitely far away.



Task

Start the ant near the center of a 100x100 field of cells, which is about big enough to contain the initial chaotic part of the movement.

Follow the movement rules for the ant, terminate when it moves out of the region, and show the cell colors it leaves behind.



The problem has received some analysis; for more details, please take a look at the Wikipedia article   (a link is below)..



See also

   Wikipedia:   Langton's ant.


Related task

   Rosetta Code:   Conway's Game of Life.

",Python,"import numpy as np
from PIL import Image
 
UP = 0
RT = 1
DN = 2
LT = 3
 
def main():
    bounds = (0, 0, 100, 100)
    im = np.zeros(bounds, dtype=np.uint8)
    pos = (50, 50)
    dir = UP
    while pos[0] >= 0 and pos[0] < 100 and pos[1] >= 0 and pos[1] < 100:
        if im[pos[0], pos[1]] == 0:
            im[pos[0], pos[1]] = 255
            dir -= 1
        else:
            im[pos[0], pos[1]] = 0
            dir += 1
        if dir & 1 == 1:
            pos = (pos[0] + (1 - dir & 2), pos[1])
        else:
            pos = (pos[0], pos[1] - (1 - dir & 2))
    im = Image.fromarray(im)
    im.save(""ant.png"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Use_another_language_to_call_a_function,Use another language to call a function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
This task is inverse to the task Call foreign language function. Consider the following C program:

#include <stdio.h>
 
extern int Query (char * Data, size_t * Length);
 
int main (int argc, char * argv [])
{
   char     Buffer [1024];
   size_t   Size = sizeof (Buffer);
 
   if (0 == Query (Buffer, &Size))
   {
      printf (""failed to call Query\n"");
   }
   else
   {
      char * Ptr = Buffer;
      while (Size-- > 0) putchar (*Ptr++);
      putchar ('\n');
   }
}
Implement the missing Query function in your language, and let this C program call it. The function should place the string Here am I into the buffer which is passed to it as the parameter Data. The buffer size in bytes is passed as the parameter Length. When there is no room in the buffer, Query shall return 0. Otherwise it overwrites the beginning of Buffer, sets the number of overwritten bytes into Length and returns 1.
",Python,"# store this in file rc_embed.py
# store this in file rc_embed.py
def query(buffer_length):
    message = b'Here am I'
    L = len(message)
    return message[0:L*(L <= buffer_length)]",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Execute_Brain****,Execute Brain****,"Execute Brain**** is an implementation of Brainf***.
Other implementations of Brainf***.
RCBF is a set of Brainf*** compilers and interpreters written for Rosetta Code in a variety of languages.

Below are links to each of the versions of RCBF.

An implementation need only properly implement the following instructions:



Command

Description


 > 
 Move the pointer to the right


 < 
 Move the pointer to the left


 + 
 Increment the memory cell under the pointer


 - 
 Decrement the memory cell under the pointer


 . 
 Output the character signified by the cell at the pointer


 , 
 Input a character and store it in the cell at the pointer


 [ 
 Jump past the matching ] if the cell under the pointer is 0


 ] 
 Jump back to the matching [ if the cell under the pointer is nonzero

Any cell size is allowed,   EOF   (End-O-File)   support is optional, as is whether you have bounded or unbounded memory.



",Python,"[ stack ]                                        is switch.arg (       --> [     )
 
  [ switch.arg put ]                               is switch     (     x -->       )
 
  [ switch.arg release ]                           is otherwise  (       -->       )
 
  [ switch.arg share != iff ]else[ done  
    otherwise  ]'[ do ]done[ ]                     is case       (     x -->       )
 
  [ dip tuck unrot poke swap ]                     is poketape   ( [ n n --> [ n   )
 
  [ 1+ over size over = if [ dip [ 0 join ] ] ]    is stepright  (   [ n --> [ n   )
 
  [ dup 0 = iff [ 0 rot join swap ] else [ 1 - ] ] is stepleft   (   [ n --> [ n   )
 
  [ 2dup peek 1 + poketape ]                       is increment  (   [ n --> [ n   )
 
  [ 2dup peek 1 - poketape ]                       is decrement  (   [ n --> [ n   )
 
  [ 2dup peek emit ]                               is print      (   [ n --> [ n   )
 
  [ temp take dup $ """" = iff 0 else behead
    swap temp put poketape ]                       is getchar    (   [ n --> [ n   )
 
  [ 2dup peek 0 = ]                                is zero       (   [ n --> [ n b )
 
  [ temp put $ """" swap witheach
      [ switch
        [ char > case [ $ ""stepright ""      join ]
          char < case [ $ ""stepleft ""       join ] 
          char + case [ $ ""increment ""      join ]
          char - case [ $ ""decrement ""      join ]
          char . case [ $ ""print ""          join ] 
          char , case [ $ ""getchar ""        join ]
          char [ case [ $ ""[ zero if done "" join ] 
          char ] case [ $ ""zero until ] ""   join ] 
          otherwise ( ignore ) ] ]
    0 nested 0 rot quackery temp release 2drop ]   is brainf***  (   $ $ -->       )",Human_written,Python_from_C
http://rosettacode.org/wiki/HTTPS/Authenticated,HTTPS/Authenticated,"The goal of this task is to demonstrate HTTPS requests with authentication.
Implementations of this task should not use client certificates for this: that is the subject of another task.
",Python,"import requests
 
res = requests.get(
    ""https://www.example.com"",
    auth=(""user"", """"),
    headers={""Connection"": ""close""},
)
 
print(res.text)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Semiprime,Semiprime,"Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.


Semiprimes   are also known as:

   semi-primes
   biprimes
   bi-primes
    2-almost    primes
   or simply:    P2  


Example
 
   1679  =  23 × 73  

(This particular number was chosen as the length of the Arecibo message).



Task

Write a function determining whether a given number is semiprime.



See also

 The Wikipedia article:  semiprime.
 The Wikipedia article:  almost prime.
 The OEIS sequence:  A001358: semiprimes  which has a shorter definition: the product of two primes.

",Python,"from prime_decomposition import decompose
 
def semiprime(n):
    d = decompose(n)
    try:
        return next(d) * next(d) == n
    except StopIteration:
        return False",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Integer_overflow,Integer overflow,"Some languages support one or more integer types of the underlying processor.

This integer types have fixed size;   usually   8-bit,   16-bit,   32-bit,   or   64-bit.

The integers supported by such a type can be   signed   or   unsigned.

Arithmetic for machine level integers can often be done by single CPU instructions.

This allows high performance and is the main reason to support machine level integers.



Definition

An integer overflow happens when the result of a computation does not fit into the fixed size integer.
The result can be too small or too big to be representable in the fixed size integer.



Task

When a language has fixed size integer types, create a program that
does arithmetic computations for the fixed size integers of the language.

These computations must be done such that the result would overflow.

The program should demonstrate what the following expressions do.



For 32-bit signed integers:



Expression

Result that does not fit into a 32-bit signed integer


 -(-2147483647-1)

 2147483648


 2000000000 + 2000000000

 4000000000


 -2147483647 - 2147483647

 -4294967294


 46341 * 46341

 2147488281


 (-2147483647-1) / -1

 2147483648

For 64-bit signed integers:



Expression

Result that does not fit into a 64-bit signed integer


 -(-9223372036854775807-1)

 9223372036854775808


 5000000000000000000+5000000000000000000

 10000000000000000000


 -9223372036854775807 - 9223372036854775807

 -18446744073709551614


 3037000500 * 3037000500

 9223372037000250000


 (-9223372036854775807-1) / -1

 9223372036854775808

For 32-bit unsigned integers:



Expression

Result that does not fit into a 32-bit unsigned integer


 -4294967295

 -4294967295


 3000000000 + 3000000000

 6000000000


 2147483647 - 4294967295

 -2147483648


 65537 * 65537

 4295098369

For 64-bit unsigned integers:



Expression

Result that does not fit into a 64-bit unsigned integer


 -18446744073709551615

 -18446744073709551615


 10000000000000000000 + 10000000000000000000

 20000000000000000000


 9223372036854775807 - 18446744073709551615

 -9223372036854775808


 4294967296 * 4294967296

 18446744073709551616



Notes

   When the integer overflow does trigger an exception show how the exception is caught.
   When the integer overflow produces some value,   print it.
   It should be explicitly noted when an integer overflow is not recognized,   the program continues with wrong results.
   This should be done for signed and unsigned integers of various sizes supported by the computer programming language.
   When a language has no fixed size integer type,   or when no integer overflow can occur for other reasons,   this should be noted.
   It is okay to mention,   when a language supports unlimited precision integers,   but this task is NOT the place to demonstrate the 
  capabilities of unlimited precision integers.

",Python,"Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> for calc in '''   -(-2147483647-1)
   2000000000 + 2000000000
   -2147483647 - 2147483647
   46341 * 46341
   (-2147483647-1) / -1'''.split('\n'):
	ans = eval(calc)
	print('Expression: %r evaluates to %s of type %s'
	      % (calc.strip(), ans, type(ans)))
 
 
Expression: '-(-2147483647-1)' evaluates to 2147483648 of type <type 'long'>
Expression: '2000000000 + 2000000000' evaluates to 4000000000 of type <type 'long'>
Expression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <type 'long'>
Expression: '46341 * 46341' evaluates to 2147488281 of type <type 'long'>
Expression: '(-2147483647-1) / -1' evaluates to 2147483648 of type <type 'long'>
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",Python,"#!/usr/bin/env python
 
import sys
 
def main():
    program = sys.argv[0]
    print(""Program: %s"" % program)
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Count_the_coins,Count the coins,"There are four types of common coins in   US   currency:

   quarters   (25 cents)
   dimes   (10 cents)
   nickels   (5 cents),   and 
   pennies   (1 cent) 


There are six ways to make change for 15 cents:

   A dime and a nickel 
   A dime and 5 pennies
   3 nickels
   2 nickels and 5 pennies
   A nickel and 10 pennies
   15 pennies


Task

How many ways are there to make change for a dollar using these common coins?     (1 dollar = 100 cents).



Optional

Less common are dollar coins (100 cents);   and very rare are half dollars (50 cents).   With the addition of these two coins, how many ways are there to make change for $1000?

(Note:   the answer is larger than   232).



References

 an algorithm from the book Structure and Interpretation of Computer Programs.
 an article in the algorithmist.
 Change-making problem on Wikipedia.

",Python,"def changes(amount, coins):
    ways = [0] * (amount + 1)
    ways[0] = 1
    for coin in coins:
        for j in xrange(coin, amount + 1):
            ways[j] += ways[j - coin]
    return ways[amount]
 
print changes(100, [1, 5, 10, 25])
print changes(100000, [1, 5, 10, 25, 50, 100])",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Python,"from itertools import product

# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f, xs):
    return [y for x in xs for y in f(x)]

# range :: Int -> Int -> [Int]
def range(m, n):
    return list(range(m, n + 1))

# and :: [Bool] -> Bool
def and(xs):
    return all(xs)

# nubBy :: (a -> a -> Bool) -> [a] -> [a]
def nubBy(p, xs):
    return [x for i, x in enumerate(xs) if not any(p(x, y) for y in xs[:i])]

# PROBLEM DECLARATION

floors = range(1, 5)

return concatMap(lambda b: concatMap(lambda c: concatMap(lambda f: concatMap(lambda m: concatMap(lambda s: and([ # CONDITIONS
    len(nubBy(lambda a, b: a == b, [b, c, f, m, s])) == 5,
    b!= 5, c!= 1, f!= 1, f!= 5,
    m > c, abs(s - f) > 1, abs(c - f) > 1
]) and [{
    'Baker': b,
    'Cooper': c,
    'Fletcher': f,
    'Miller': m,
    'Smith': s
}]), floors), floors), floors), floors), floors)

# --> [{""Baker"":3, ""Cooper"":2, ""Fletcher"":4, ""Miller"":5, ""Smith"":1}]",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Flipping_bits_game,Flipping bits game,"The game

Given an   N×N   square array of zeroes or ones in an initial configuration,   and a target configuration of zeroes and ones.



The game is to transform one to the other in as few moves as possible by inverting whole numbered rows or whole lettered
columns at once   (as one move).

In an inversion.   any  1  becomes  0,   and any  0  becomes  1  for that whole row or column.



Task

Create a program to score for the Flipping bits game.

 The game should create an original random target configuration and a starting configuration.
 Ensure that the starting position is never the target position.
 The target position must be guaranteed as reachable from the starting position.   (One possible way to do this is to generate the start position by legal flips from a random target position.   The flips will always be reversible back to the target from the given start position).
 The number of moves taken so far should be shown.


Show an example of a short game here, on this page, for a   3×3   array of bits.



",Python,"""""""
Given a %i by %i sqare array of zeroes or ones in an initial
configuration, and a target configuration of zeroes and ones
The task is to transform one to the other in as few moves as 
possible by inverting whole numbered rows or whole lettered 
columns at once.
In an inversion any 1 becomes 0 and any 0 becomes 1 for that
whole row or column.
 
""""""
 
from random import randrange
from copy import deepcopy
from string import ascii_lowercase
 
 
try:    # 2to3 fix
    input = raw_input
except:
    pass
 
N = 3   # N x N Square arrray
 
board  = [[0]* N for i in range(N)]
 
def setbits(board, count=1):
    for i in range(count):
        board[randrange(N)][randrange(N)] ^= 1
 
def shuffle(board, count=1):
    for i in range(count):
        if randrange(0, 2):
            fliprow(randrange(N))
        else:
            flipcol(randrange(N))
 
 
def pr(board, comment=''):
    print(str(comment))
    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))
    print('  ' + '\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])
                             for j, line in enumerate(board, 1)))
 
def init(board):
    setbits(board, count=randrange(N)+1)
    target = deepcopy(board)
    while board == target:
        shuffle(board, count=2 * N)
    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], 
                                                    ascii_lowercase[N-1])
    return target, prompt
 
def fliprow(i):
    board[i-1][:] = [x ^ 1 for x in board[i-1] ]
 
def flipcol(i):
    for row in board:
        row[i] ^= 1
 
if __name__ == '__main__':
    print(__doc__ % (N, N))
    target, prompt = init(board)
    pr(target, 'Target configuration is:')
    print('')
    turns = 0
    while board != target:
        turns += 1
        pr(board, '%i:' % turns)
        ans = input(prompt).strip()
        if (len(ans) == 1 
            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):
            flipcol(ascii_lowercase.index(ans))
        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:
            fliprow(int(ans))
        elif ans == 'T':
            pr(target, 'Target configuration is:')
            turns -= 1
        elif ans == 'X':
            break
        else:
            print(""  I don't understand %r... Try again. ""
                  ""(X to exit or T to show target)\n"" % ans[:9])
            turns -= 1
    else:
        print('\nWell done!\nBye.')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Chat_server,Chat server,"Task

Write a server for a minimal text based chat.

People should be able to connect via ‘telnet’, sign on with a nickname, and type messages which will then be seen by all other connected users. Arrivals and departures of chat members should generate appropriate notification messages.



",Python,"import socket
import threading
 
clients = {}
 
def broadcast_message(user, message):
    for client in clients:
        if client!= user:
            client.send(message)
 
def chat_loop(sock):
    while True:
        client, address = sock.accept()
        print(""Accepted connection from {}."".format(address))
 
        name = client.recv(1024).decode(""utf-8"")
        if name in clients:
            client.send(""That username is taken."".encode(""utf-8""))
            client.close()
            continue
 
        print(""User {} connected."".format(name))
        client.send(""Welcome, {}!"".format(name).encode(""utf-8""))
 
        clients[name] = client
        broadcast_message(name, ""{} has joined the chat room."".format(name).encode(""utf-8""))
 
        while True:
            message = client.recv(1024)
            if not message:
                break
 
            broadcast_message(name, ""{}: {}"".format(name, message.decode(""utf-8"")).encode(""utf-8""))
 
        del clients[name]
        broadcast_message(name, ""{} has left the chat room."".format(name).encode(""utf-8""))
 
        client.close()
 
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind((""localhost"", 7000))
sock.listen(5)
 
threading.Thread(target=chat_loop, args=(sock,)).start()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Paraffins,Paraffins,"
This organic chemistry task is essentially to implement a tree enumeration algorithm.



Task

Enumerate, without repetitions and in order of increasing size, all possible paraffin molecules (also known as alkanes).



Paraffins are built up using only carbon atoms, which has four bonds, and hydrogen, which has one bond.   All bonds for each atom must be used, so it is easiest to think of an alkane as linked carbon atoms forming the ""backbone"" structure, with adding hydrogen atoms linking the remaining unused bonds.

In a paraffin, one is allowed neither double bonds (two bonds between the same pair of atoms), nor cycles of linked carbons.   So all paraffins with   n   carbon atoms share the empirical formula     CnH2n+2

But for all   n ≥ 4   there are several distinct molecules (""isomers"") with the same formula but different structures.

The number of isomers rises rather rapidly when   n   increases.

In counting isomers it should be borne in mind that the four bond positions on a given carbon atom can be freely interchanged and bonds rotated (including 3-D ""out of the paper"" rotations when it's being observed on a flat diagram),   so rotations or re-orientations of parts of the molecule (without breaking bonds) do not give different isomers.   So what seem at first to be different molecules may in fact turn out to be different orientations of the same molecule.



Example

With   n = 3   there is only one way of linking the carbons despite the different orientations the molecule can be drawn;   and with   n = 4   there are two configurations:

   a   straight   chain:     (CH3)(CH2)(CH2)(CH3) 
   a branched chain:       (CH3)(CH(CH3))(CH3)


Due to bond rotations, it doesn't matter which direction the branch points in.

The phenomenon of ""stereo-isomerism"" (a molecule being different from its mirror image due to the actual 3-D arrangement of bonds) is ignored for the purpose of this task.

The input is the number   n   of carbon atoms of a molecule (for instance 17).

The output is how many different different paraffins there are with   n   carbon atoms (for instance   24,894   if   n = 17).

The sequence of those results is visible in the OEIS entry:  

   oeis:A00602 number of n-node unrooted quartic trees; number of n-carbon alkanes C(n)H(2n+2) ignoring stereoisomers. 
The sequence is (the index starts from zero, and represents the number of carbon atoms):

1, 1, 1, 1, 2, 3, 5, 9, 18, 35, 75, 159, 355, 802, 1858, 4347, 10359,
24894, 60523, 148284, 366319, 910726, 2278658, 5731580, 14490245,
36797588, 93839412, 240215803, 617105614, 1590507121, 4111846763,
10660307791, 27711253769, ...



Extra credit

Show the paraffins in some way. 

A flat 1D representation, with arrays or lists is enough, for instance:

*Main> all_paraffins 1
                        [CCP H H H H]
*Main> all_paraffins 2
                        [BCP (C H H H) (C H H H)]
*Main> all_paraffins 3
                        [CCP H H (C H H H) (C H H H)]
*Main> all_paraffins 4
                        [BCP (C H H (C H H H)) (C H H (C H H H)),
                         CCP H (C H H H) (C H H H) (C H H H)]
*Main> all_paraffins 5
                        [CCP H H (C H H (C H H H)) (C H H (C H H H)),
                         CCP H (C H H H) (C H H H) (C H H (C H H H)),
                         CCP (C H H H) (C H H H) (C H H H) (C H H H)]
*Main> all_paraffins 6
                        [BCP (C H H (C H H (C H H H))) (C H H (C H H (C H H H))),
                         BCP (C H H (C H H (C H H H))) (C H (C H H H) (C H H H)),
                         BCP (C H (C H H H) (C H H H)) (C H (C H H H) (C H H H)),
                         CCP H (C H H H) (C H H (C H H H)) (C H H (C H H H)),
                         CCP (C H H H) (C H H H) (C H H H) (C H H (C H H H))]
Showing a basic 2D ASCII-art representation of the paraffins is better; for instance (molecule names aren't necessary):

       methane          ethane               propane               isobutane
 
          H              H   H              H   H   H              H   H   H
          │              │   │              │   │   │              │   │   │
      H ─ C ─ H      H ─ C ─ C ─ H      H ─ C ─ C ─ C ─ H      H ─ C ─ C ─ C ─ H
          │              │   │              │   │   │              │   │   │
          H              H   H              H   H   H              H   │   H
                                                                       │
                                                                   H ─ C ─ H
                                                                       │
                                                                       H
Links

   A paper that explains the problem and its solution in a functional language:
http://www.cs.wright.edu/~tkprasad/courses/cs776/paraffins-turner.pdf

   A Haskell implementation:
https://github.com/ghc/nofib/blob/master/imaginary/paraffins/Main.hs

   A Scheme implementation:
http://www.ccs.neu.edu/home/will/Twobit/src/paraffins.scm

   A Fortress implementation:         (this site has been closed)
http://java.net/projects/projectfortress/sources/sources/content/ProjectFortress/demos/turnersParaffins0.fss?rev=3005
",Python,"try:
    import psyco
    psyco.full()
except ImportError:
    pass
 
MAX_N = 300
BRANCH = 4
 
ra = [0] * MAX_N
unrooted = [0] * MAX_N
 
def tree(br, n, l, sum = 1, cnt = 1):
    global ra, unrooted, MAX_N, BRANCH
    for b in xrange(br + 1, BRANCH + 1):
        sum += n
        if sum >= MAX_N:
            return
 
        # prevent unneeded long math
        if l * 2 >= sum and b >= BRANCH:
            return
 
        if b == br + 1:
            c = ra[n] * cnt
        else:
            c = c * (ra[n] + (b - br - 1)) / (b - br)
 
        if l * 2 < sum:
            unrooted[sum] += c
 
        if b < BRANCH:
            ra[sum] += c;
            for m in range(1, n):
                tree(b, m, l, sum, c)
 
def bicenter(s):
    global ra, unrooted
    if not (s & 1):
        aux = ra[s / 2]
        unrooted[s] += aux * (aux + 1) / 2
 
 
def main():
    global ra, unrooted, MAX_N
    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1
 
    for n in xrange(1, MAX_N):
        tree(0, n, n)
        bicenter(n)
        print ""%d: %d"" % (n, unrooted[n])
 
main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Arithmetic/Complex,Arithmetic/Complex,"A   complex number   is a number which can be written as:




a
+
b
×
i


{\displaystyle a+b\times i}


(sometimes shown as:




b
+
a
×
i


{\displaystyle b+a\times i}


where   



a


{\displaystyle a}

   and   



b


{\displaystyle b}

  are real numbers,   and   



i


{\displaystyle i}

   is   √ -1 



Typically, complex numbers are represented as a pair of real numbers called the ""imaginary part"" and ""real part"",   where the imaginary part is the number to be multiplied by 



i


{\displaystyle i}

.



Task

 Show addition, multiplication, negation, and inversion of complex numbers in separate functions. (Subtraction and division operations can be made with pairs of these operations.) 
 Print the results for each operation tested.
 Optional: Show complex conjugation.


By definition, the   complex conjugate   of




a
+
b
i


{\displaystyle a+bi}


is




a
−
b
i


{\displaystyle a-bi}





Some languages have complex number libraries available.   If your language does, show the operations.   If your language does not, also show the definition of this type.



",Python,"class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
 
    def __add__(self, other):
        return Complex(self.real + other.real, self.imag + other.imag)
 
    def __mul__(self, other):
        return Complex(
            self.real * other.real - self.imag * other.imag,
            self.real * other.imag + self.imag * other.real
        )
 
    def inv(self):
        denom = self.real * self.real + self.imag * self.imag
        return Complex(self.real / denom, -self.imag / denom)
 
    def __neg__(self):
        return Complex(-self.real, -self.imag)
 
    def __sub__(self, other):
        return self + (-other)
 
    def __truediv__(self, other):
        return self * other.inv()
 
    def conj(self):
        return Complex(self.real, -self.imag)
 
    def __str__(self):
        if self.imag >= 0.0:
            return f""{self.real} + {self.imag}i""
        else:
            return f""{self.real} - {-self.imag}i""
 
if __name__ == ""__main__"":
    x = Complex(1.0, 3.0)
    y = Complex(5.0, 2.0)
    print(f""x     =  {x}"")
    print(f""y     =  {y}"")
    print(f""x + y =  {x + y}"")
    print(f""x - y =  {x - y}"")
    print(f""x * y =  {x * y}"")
    print(f""x / y =  {x / y}"")
    print(f""-x    =  {-x}"")
    print(f""1 / x =  {x.inv()}"")
    print(f""x*    =  {x.conj()}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Keyboard_input/Flush_the_keyboard_buffer,Keyboard input/Flush the keyboard buffer,"Flush the   keyboard   buffer.

This reads characters from the keyboard input and
discards them until there are no more currently buffered,  
and then allows the program to continue.

The program must not wait for users to type anything.
",Python,"import sys
 
def main():
    # Get a chance to make stdin input buffer dirty.
    #
    text = []
    sys.stdin.read(1)
 
    # This DOES NOT WORK properly on all modern systems including Linux & W10.
    # Obsolete, don't use this. BTW, there is no fpurge in MSVC libs in 2020.
    #
    # fflush(stdin);
 
    # Always works. Readed characters may remain somethere in RAM.
    #
    sys.stdin.seek(0, 2)
 
    # A very dirty solution - an unbuffered stream does not need any flushing.
    #
    # setvbuf(stdin, NULL, _IONBF, 0);
 
    # Now we are able to check if the buffer is really empty.
    #
    text = sys.stdin.read()
    print(text)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/String_append,String append,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Most languages provide a way to concatenate two string values, but some languages also provide a convenient way to append in-place to an existing string variable without referring to the variable twice.



Task

Create a string variable equal to any text value.

Append the string variable with another string literal in the most idiomatic way, without double reference if your language supports it.

Show the contents of the variable after the append operation.



",Python,"x = 1
y = 2
z = 3
w = 4
sum = x + y + z + w
product = x * y * z * w
average = sum / 4
remainder = sum % 4
quotient = sum / 4
remainder2 = quotient % 2
print(sum)
print(product)
print(average)
print(remainder)
print(quotient)
print(remainder2)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Percentage_difference_between_images,Percentage difference between images,"basic bitmap storage
Useful for comparing two JPEG images saved with a different compression ratios.

You can use these pictures for testing (use the full-size version of each):



50% quality JPEG

100% quality JPEG







link to full size 50% image

link to full size 100% image

The expected difference for these two images is 1.62125%
",Python,"# version 1.2.10
 
from PIL import Image
import math
 
def getDifferencePercent(img1, img2):
    width = img1.width
    height = img1.height
    width2 = img2.width
    height2 = img2.height
    if width!= width2 or height!= height2:
        f = ""(%d,%d) vs. (%d,%d)"" % (width, height, width2, height2)
        raise ValueError(""Images must have the same dimensions: %s"" % f)
    diff = 0
    for y in range(height):
        for x in range(width):
            diff += pixelDiff(img1.getpixel((x, y)), img2.getpixel((x, y)))
    maxDiff = 3 * 255 * width * height
    return 100.0 * diff / maxDiff
 
def pixelDiff(rgb1, rgb2):
    r1, g1, b1 = rgb1
    r2, g2, b2 = rgb2
    return abs(r1 - r2) + abs(g1 - g2) + abs(b1 - b2)
 
img1 = Image.open(""Lenna50.jpg"")
img2 = Image.open(""Lenna100.jpg"")
 
p = getDifferencePercent(img1, img2)
print(""The percentage difference is %.6f%%"" % p)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Catalan_numbers,Catalan numbers,"Catalan numbers

You are encouraged to solve this task according to the task description, using any language you may know.


Catalan numbers are a sequence of numbers which can be defined directly:






C

n


=


1

n
+
1






(



2
n

n


)



=



(
2
n
)
!


(
n
+
1
)
!

n
!





 for 

n
≥
0.


{\displaystyle C_{n}={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\,n!}}\qquad {\mbox{ for }}n\geq 0.}


Or recursively:






C

0


=
1


and



C

n
+
1


=

∑

i
=
0


n



C

i




C

n
−
i




for 

n
≥
0
;


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0;}


Or alternatively (also recursive):






C

0


=
1


and



C

n


=



2
(
2
n
−
1
)


n
+
1




C

n
−
1


,


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n}={\frac {2(2n-1)}{n+1}}C_{n-1},}




Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization   is not required, but may be worth the effort when using the second method above.



Related tasks

Catalan numbers/Pascal's triangle
Evaluate binomial coefficients

",Python,"from math import factorial
import functools
 
 
def memoize(func):
    cache = {}
 
    def memoized(key):
        # Returned, new, memoized version of decorated function
        if key not in cache:
            cache[key] = func(key)
        return cache[key]
    return functools.update_wrapper(memoized, func)
 
 
@memoize
def fact(n):
    return factorial(n)
 
 
def cat_direct(n):
    return fact(2 * n) // fact(n + 1) // fact(n)
 
 
@memoize
def catR1(n):
    return 1 if n == 0 else (
        sum(catR1(i) * catR1(n - 1 - i) for i in range(n))
    )
 
 
@memoize
def catR2(n):
    return 1 if n == 0 else (
        ((4 * n - 2) * catR2(n - 1)) // (n + 1)
    )
 
 
if __name__ == '__main__':
    def pr(results):
        fmt = '%-10s %-10s %-10s'
        print((fmt % tuple(c.__name__ for c in defs)).upper())
        print(fmt % (('=' * 10,) * 3))
        for r in zip(*results):
            print(fmt % r)
 
    defs = (cat_direct, catR1, catR2)
    results = [tuple(c(i) for i in range(15)) for c in defs]
    pr(results)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Stack_traces,Stack traces,"Many programming languages allow for introspection of the current call stack environment. This can be for a variety of purposes such as enforcing security checks, debugging, or for getting access to the stack frame of callers.



Task

Print out (in a manner considered suitable for the platform) the current call stack.

The amount of information printed for each frame on the call stack is not constrained, but should include at least the name of the function or method at that level of the stack frame.

You may explicitly add a call to produce the stack trace to the (example) code being instrumented for examination.

The task should allow the program to continue after generating the stack trace.

The task report here must include the trace from a sample program.



",Python,"import traceback
 
def f(): return g()
def g(): traceback.print_stack()
 
f()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Gapful_numbers,Gapful numbers,"Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

187   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    187. 



About   7.46%   of positive integers are   gapful.



Task

   Generate and show all sets of numbers (below) on one line (horizontally) with a title,   here on this page
   Show the first   30   gapful numbers
   Show the first   15   gapful numbers    ≥           1,000,000
   Show the first   10   gapful numbers    ≥    1,000,000,000


Related tasks

   Harshad or Niven series.
   palindromic gapful numbers.
   largest number divisible by its digits.


Also see

   The OEIS entry:   A108343 gapful numbers.
   numbersaplenty gapful numbers

",Python,"import math
 
def commatize(n):
    s = str(n)
    le = len(s)
    for i in range(le - 3, 0, -3):
        s = s[:i] + ',' + s[i:]
    return s
 
starts = [100, 1000000, 10000000, 1000000000, 7123]
counts = [30, 15, 15, 10, 25]
for i in range(len(starts)):
    count = 0
    j = starts[i]
    pow = 100
    while j >= pow * 10:
        pow *= 10
    print(f""First {counts[i]} gapful numbers starting at {commatize(starts[i])}:"")
    while count < counts[i]:
        fl = (j // pow) * 10 + (j % 10)
        if j % fl == 0:
            print(j, end=' ')
            count += 1
        j += 1
        if j >= 10 * pow:
            pow *= 10
    print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"root = BinaryTreeNode.from_array([1, [2, [4, 7], [5]], [3, [6, [8], [9]]]])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order,Magic squares of doubly even order,"A magic square is an   N×N  square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column,   and   both diagonals are equal to the same sum   (which is called the magic number or magic constant).

A magic square of doubly even order has a size that is a multiple of four   (e.g.     4, 8, 12).

This means that the subsquares also have an even size, which plays a role in the construction.



1
2
62
61
60
59
7
8


9
10
54
53
52
51
15
16


48
47
19
20
21
22
42
41


40
39
27
28
29
30
34
33


32
31
35
36
37
38
26
25


24
23
43
44
45
46
18
17


49
50
14
13
12
11
55
56


57
58
6
5
4
3
63
64



Task
Create a magic square of   8 × 8.



Related tasks
 Magic squares of odd order
 Magic squares of singly even order



See also

 Doubly Even Magic Squares (1728.org)

",Python,"import sys

def main():
    n = int(sys.argv[1])
    mc = (n * n + 1) * n / 2
    print(""Magic constant: {}"".format(mc))
    bits = 0b1001_0110_0110_1001
    size = n * n
    width = len(str(size)) + 1
    mult = n / 4
    i = 0
    for r in range(n):
        for c in range(n):
            bit_pos = c // mult + (r // mult) * 4
            print(""{e:>{w}}"".format(e=i + 1 if bits & (1 << bit_pos) else size - i, w=width), end="""")
            i += 1
        print()

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class Node(object):
     def __init__(self, data = None, prev = None, next = None):
         self.prev = prev
         self.next = next
         self.data = data
     def __str__(self):
         return str(self.data)
     def __repr__(self):
         return repr(self.data)
     def iter_forward(self):
         c = self
         while c != None:
             yield c
             c = c.next
     def iter_backward(self):
         c = self
         while c != None:
             yield c
             c = c.prev",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",Python,"from math import gcd

def pythagorean_triples(limit):
    triples = []
    for a in range(1, limit // 3):
        for b in range(a + 1, limit // 2):
            c = limit - a - b
            if a ** 2 + b ** 2 == c ** 2:
                triples.append((a, b, c))
    return triples

def primitive_triples(triples):
    primitives = []
    for a, b, c in triples:
        if gcd(a, b) == 1:
            primitives.append((a, b, c))
    return primitives

def main():
    limit = 100
    triples = pythagorean_triples(limit)
    primitives = primitive_triples(triples)
    print(f""Up to a perimeter of {limit}, there are {len(triples)} triples, of which {len(primitives)} are primitive."")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Doubly-linked_list/Element_definition,Doubly-linked list/Element definition,"Task

Define the data structure for a doubly-linked list element.

The element should include a data member to hold its value and pointers to both the next element in the list and the previous element in the list.

The pointers should be mutable.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class Node(object):
    def __init__(self, n=None, p=None, elem=None):
        self.next = n
        self.prev = p
        self.element = elem

    def setNext(self, n):
        self.next = n

    def getNext(self):
        return self.next

    def setElem(self, elem):
        self.element = elem

    def getElem(self):
        return self.element

    def setPrev(self, p):
        self.prev = p

    def getPrev(self):
        return self.prev",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sort_an_integer_array,Sort an integer array,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of integers in ascending numerical order.



Use a sorting facility provided by the language/library if possible.



",Python,"nums = [2,4,3,1,2]
nums.sort()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Text_processing/1,Text processing/1,"This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified. See this page's Talk page for discussion.
Often data is produced by one program, in the wrong format for later use by another program or person. In these situations another program can be written to parse and transform the original data into a format useful to the other. The term ""Data Munging"" is often used in programming circles for this task.

A request on the comp.lang.awk newsgroup led to a typical data munging task:

I have to analyse data files that have the following format:
Each row corresponds to 1 day and the field logic is: $1 is the date,
followed by 24 value/flag pairs, representing measurements at 01:00,
02:00 ... 24:00 of the respective day. In short:

<date> <val1> <flag1> <val2> <flag2> ...  <val24> <flag24>

Some test data is available at: 
... (nolonger available at original location)

I have to sum up the values (per day and only valid data, i.e. with
flag>0) in order to calculate the mean. That's not too difficult.
However, I also need to know what the ""maximum data gap"" is, i.e. the
longest period with successive invalid measurements (i.e values with
flag<=0)
The data is free to download and use and is of this format:

Data is no longer available at that link. Zipped mirror available here (offsite mirror).

1991-03-30	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1
1991-03-31	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	10.000	1	20.000	1	20.000	1	20.000	1	35.000	1	50.000	1	60.000	1	40.000	1	30.000	1	30.000	1	30.000	1	25.000	1	20.000	1	20.000	1	20.000	1	20.000	1	20.000	1	35.000	1
1991-03-31	40.000	1	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2	0.000	-2
1991-04-01	0.000	-2	13.000	1	16.000	1	21.000	1	24.000	1	22.000	1	20.000	1	18.000	1	29.000	1	44.000	1	50.000	1	43.000	1	38.000	1	27.000	1	27.000	1	24.000	1	23.000	1	18.000	1	12.000	1	13.000	1	14.000	1	15.000	1	13.000	1	10.000	1
1991-04-02	8.000	1	9.000	1	11.000	1	12.000	1	12.000	1	12.000	1	27.000	1	26.000	1	27.000	1	33.000	1	32.000	1	31.000	1	29.000	1	31.000	1	25.000	1	25.000	1	24.000	1	21.000	1	17.000	1	14.000	1	15.000	1	12.000	1	12.000	1	10.000	1
1991-04-03	10.000	1	9.000	1	10.000	1	10.000	1	9.000	1	10.000	1	15.000	1	24.000	1	28.000	1	24.000	1	18.000	1	14.000	1	12.000	1	13.000	1	14.000	1	15.000	1	14.000	1	15.000	1	13.000	1	13.000	1	13.000	1	12.000	1	10.000	1	10.000	1

Only a sample of the data showing its format is given above. The full example file may be downloaded here.

Structure your program to show statistics for each line of the file, (similar to the original Python, Perl, and AWK examples below), followed by summary statistics for the file. When showing example output just show a few line statistics and the full end summary.
",Python,"import fileinput
import sys
 
nodata = 0;             # Current run of consecutive flags<0 in lines of file
nodata_max=-1;          # Max consecutive flags<0 in lines of file
nodata_maxline=[];      # ... and line number(s) where it occurs
 
tot_file = 0            # Sum of file data
num_file = 0            # Number of file data items with flag>0
 
infiles = sys.argv[1:]
 
for line in fileinput.input():
  tot_line=0;             # sum of line data
  num_line=0;             # number of line data items with flag>0
 
  # extract field info
  field = line.split()
  date  = field[0]
  data  = [float(f) for f in field[1::2]]
  flags = [int(f)   for f in field[2::2]]
 
  for datum, flag in zip(data, flags):
    if flag<1:
      nodata += 1
    else:
      # check run of data-absent fields
      if nodata_max==nodata and nodata>0:
        nodata_maxline.append(date)
      if nodata_max<nodata and nodata>0:
        nodata_max=nodata
        nodata_maxline=[date]
      # re-initialise run of nodata counter
      nodata=0; 
      # gather values for averaging
      tot_line += datum
      num_line += 1
 
  # totals for the file so far
  tot_file += tot_line
  num_file += num_line
 
  print ""Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f"" % (
        date, 
        len(data) -num_line, 
        num_line, tot_line, 
        tot_line/num_line if (num_line>0) else 0)
 
print """"
print ""File(s)  = %s"" % ("", "".join(infiles),)
print ""Total    = %10.3f"" % (tot_file,)
print ""Readings = %6i"" % (num_file,)
print ""Average  = %10.3f"" % (tot_file / num_file,)
 
print ""\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s"" % (
    nodata_max, "", "".join(nodata_maxline))",Human_written,Python_from_C
http://rosettacode.org/wiki/Averages/Median,Averages/Median,"Task[edit]
Write a program to find the   median   value of a vector of floating-point numbers.

The program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.

There are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle.

Sorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.

See also
Quickselect_algorithm

Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,"def median(aray):
    srtd = sorted(aray)
    alen = len(srtd)
    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])
 
a = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)
print a, median(a)
a = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)
print a, median(a)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",Python,">>> def strcat(sequence):
    return '{%s}' % ', '.join(sequence)[::-1].replace(',', 'dna ', 1)[::-1]
 
>>> for seq in ([], [""ABC""], [""ABC"", ""DEF""], [""ABC"", ""DEF"", ""G"", ""H""]):
    print('Input: %-24r -> Output: %r' % (seq, strcat(seq)))
 
 
Input: []                       -> Output: '{}'
Input: ['ABC']                  -> Output: '{ABC}'
Input: ['ABC', 'DEF']           -> Output: '{ABC and DEF}'
Input: ['ABC', 'DEF', 'G', 'H'] -> Output: '{ABC, DEF, G and H}'
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Proper_divisors,Proper divisors,"The   proper divisors   of a positive integer N are those numbers, other than N itself, that divide N without remainder.

For N > 1 they will always include 1,   but for N == 1 there are no proper divisors.



Examples

The proper divisors of     6     are   1, 2, and 3.

The proper divisors of   100   are   1, 2, 4, 5, 10, 20, 25, and 50.



Task

 Create a routine to generate all the proper divisors of a number.
 use it to show the proper divisors of the numbers 1 to 10 inclusive.
 Find a number in the range 1 to 20,000 with the most proper divisors. Show the number and just the count of how many proper divisors it has.


Show all output here.



Related tasks

   Amicable pairs
   Abundant, deficient and perfect number classifications
   Aliquot sequence classifications
   Factors of an integer
   Prime decomposition

",Python,">>> def proper_divs2(n):
...     return {x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x}
... 
>>> [proper_divs2(n) for n in range(1, 11)]
[set(), {1}, {1}, {1, 2}, {1}, {1, 2, 3}, {1}, {1, 2, 4}, {1, 3}, {1, 2, 5}]
>>> 
>>> n, length = max(((n, len(proper_divs2(n))) for n in range(1, 20001)), key=lambda pd: pd[1])
>>> n
15120
>>> length
79
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Filter,Filter,"Task

Select certain elements from an Array into a new Array in a generic way.



To demonstrate, select all even numbers from an Array.

As an option, give a second solution which filters destructively,
by modifying the original Array rather than creating a new Array.



",Python,"arr = [1,2,3,4,5]
evens = [a for a in arr if a % 2 == 0]
doubleEvens = [a * 2 for a in evens]
sum = reduce(lambda a, b: a + b, doubleEvens)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort,Sorting algorithms/Sleep sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.
",Python,"from time import sleep
from threading import Timer
 
def sleepsort(values):
    sleepsort.result = []
    def add1(x):
        sleepsort.result.append(x)
    mx = values[0]
    for v in values:
        if mx < v: mx = v
        Timer(v, add1, [v]).start()
    sleep(mx+1)
    return sleepsort.result
 
if __name__ == '__main__':
    x = [3,2,4,7,3,6,9,1]
    if sleepsort(x) == sorted(x):
        print('sleep sort worked for:',x)
    else:
        print('sleep sort FAILED for:',x)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Active_object,Active object,"In object-oriented programming an object is active when its state depends on clock. Usually an active object encapsulates a task that updates the object's state. To the outer world the object looks like a normal object with methods that can be called from outside. Implementation of such methods must have a certain synchronization mechanism with the encapsulated task in order to prevent object's state corruption.

A typical instance of an active object is an animation widget. The widget state changes with the time, while as an object it has all properties of a normal widget.

The task

Implement an active integrator object. The object has an input and output. The input can be set using the method Input. The input is a function of time. The output can be queried using the method Output. The object integrates its input over the time and the result becomes the object's output. So if the input is K(t) and the output is S, the object state S is changed to S + (K(t1) + K(t0)) * (t1 - t0) / 2, i.e. it integrates K using the trapeze method. Initially K is constant 0 and S is 0.

In order to test the object:

 set its input to sin (2π f t), where the frequency f=0.5Hz. The phase is irrelevant.
 wait 2s
 set the input to constant 0
 wait 0.5s
Verify that now the object's output is approximately 0 (the sine has the period of 2s). The accuracy of the result will depend on the OS scheduler time slicing and the accuracy of the clock.
",Python,"from time import time, sleep
from threading import Thread
 
class Integrator(Thread):
    'continuously integrate a function `K`, at each `interval` seconds'
    def __init__(self, K=lambda t:0, interval=1e-4):
        Thread.__init__(self)
        self.interval  = interval
        self.K   = K
        self.S   = 0.0
        self.__run = True
        self.start()
 
    def run(self):
        ""entry point for the thread""
        interval = self.interval
        start = time()
        t0, k0 = 0, self.K(0)
        while self.__run:
            sleep(interval)
            t1 = time() - start
            k1 = self.K(t1)
            self.S += (k1 + k0)*(t1 - t0)/2.0
            t0, k0 = t1, k1
 
    def join(self):
        self.__run = False
        Thread.join(self)
 
if __name__ == ""__main__"":
    from math import sin, pi
 
    ai = Integrator(lambda t: sin(pi*t))
    sleep(2)
    print(ai.S)
    ai.K = lambda t: 0
    sleep(0.5)
    print(ai.S)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Roman_numerals/Encode,Roman numerals/Encode,"Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.



In Roman numerals:

 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
 2008 is written as 2000=MM, 8=VIII; or MMVIII
 1666 uses each Roman symbol in descending order: MDCLXVI

",Python,"m0 = ["""", ""I"", ""II"", ""III"", ""IV"", ""V"", ""VI"", ""VII"", ""VIII"", ""IX""]
m1 = ["""", ""X"", ""XX"", ""XXX"", ""XL"", ""L"", ""LX"", ""LXX"", ""LXXX"", ""XC""]
m2 = ["""", ""C"", ""CC"", ""CCC"", ""CD"", ""D"", ""DC"", ""DCC"", ""DCCC"", ""CM""]
m3 = ["""", ""M"", ""MM"", ""MMM"", ""I̅V̅"", ""V̅"", ""V̅I̅"", ""V̅I̅I̅"", ""V̅I̅I̅I̅"", ""I̅X̅""]
m4 = ["""", ""X̅"", ""X̅X̅"", ""X̅X̅X̅"", ""X̅L̅"", ""L̅"", ""L̅X̅"", ""L̅X̅X̅"", ""L̅X̅X̅X̅"", ""X̅C̅""]
m5 = ["""", ""C̅"", ""C̅C̅"", ""C̅C̅C̅"", ""C̅D̅"", ""D̅"", ""D̅C̅"", ""D̅C̅C̅"", ""D̅C̅C̅C̅"", ""C̅M̅""]
m6 = ["""", ""M̅"", ""M̅M̅"", ""M̅M̅M̅""]
 
def formatRoman(n):
    if n < 1 or n >= 4e6:
        return False
    return m6[n//1e6] + m5[n%1e6//1e5] + m4[n%1e5//1e4] + m3[n%1e4//1e3] + m2[n%1e3//1e2] + m1[n%100//10] + m0[n%10]
 
for n in [1990, 2008, 1666]:
    r = formatRoman(n)
    if r:
        print(n, ""=="", r)
    else:
        print(n, ""not representable"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/List_comprehensions,List comprehensions,"A list comprehension is a special syntax in some programming languages to describe lists. It is similar to the way mathematicians describe sets, with a set comprehension, hence the name.

Some attributes of a list comprehension are:

 They should be distinct from (nested) for loops and the use of map and filter functions within the syntax of the language.
 They should return either a list or an iterator (something that returns successive members of a collection, in order).
 The syntax has parts corresponding to that of set-builder notation. 


Task

Write a list comprehension that builds the list of all Pythagorean triples with elements between   1   and   n.

If the language has multiple ways for expressing such a construct (for example, direct list comprehensions and generators), write one example for each.



",Python,"from math import sqrt
from itertools import combinations
 
def list_comprehension(upper_border):
    return [a for a, b, c in combinations(range(1, upper_border), 3)
            if a**2 + b**2 == c**2]
 
if __name__ == '__main__':
    print(list_comprehension(20))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",Python,"compose = lambda f, g: lambda x: f( g(x) )",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Read_a_file_character_by_character/UTF8,Read a file character by character/UTF8,"Task

Read a file one character at a time, as opposed to reading the entire file at once.

The solution may be implemented as a procedure, which returns the next character in the file on each consecutive call (returning EOF when the end of the file is reached).

The procedure should support the reading of files containing UTF8 encoded wide characters, returning whole characters for each consecutive read.

Related task

   Read a file line by line

",Python,"# version 1.1.2
 
import io
 
EOF = -1
 
def main(args):
    reader = io.open(""input.txt"", ""r"", encoding=""utf-8"")
    try:
        while True:
            c = reader.read()
            if c == EOF:
                break
            print(chr(c))
    finally:
        reader.close()
 
if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Random_numbers,Random numbers,"Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers
with a mean of   1.0   and a   standard deviation   of   0.5



Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.



Related task

   Standard deviation

",Python,">>> import random
>>> values = [random.gauss(1, .5) for i in range(1000)]
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",Python,"for i in range(10):
  if i % 2 == 0:
    print(i)
  else:
    print(""odd"")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Rep-string,Rep-string,"Given a series of ones and zeroes in a string, define a repeated string or rep-string as a string which is created by repeating a substring of the first N characters of the string truncated on the right to the length of the input string, and in which the substring appears repeated at least twice in the original.

For example, the string 10011001100 is a rep-string as the leftmost four characters of 1001 are repeated three times and truncated on the right to give the original string.

Note that the requirement for having the repeat occur two or more times means that the repeating unit is never longer than half the length of the input string.



Task

 Write a function/subroutine/method/... that takes a string and returns an indication of if it is a rep-string and the repeated string.   (Either the string that is repeated, or the number of repeated characters would suffice). 
 There may be multiple sub-strings that make a string a rep-string - in that case an indication of all, or the longest, or the shortest would suffice.
 Use the function to indicate the repeating substring if any, in the following:

1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1


 Show your output on this page.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"ar = [""1001110011"",
      ""1110111011"",
      ""0010010010"",
      ""1010101010"",
      ""1111111111"",
      ""0100101101"",
      ""0100100"",
      ""101"",
      ""11"",
      ""00"",
      ""1""]

for str in ar:
    rep_pos = (len(str)//2)
    while rep_pos > 0:
        if str.startswith(str[rep_pos:]):
            break
        rep_pos -= 1
    if rep_pos > 0:
        print(str)
        print("" "" * rep_pos + str[0:rep_pos])
    else:
        print(str)
        print(""(no repetition)"")
    print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Date_format,Date format,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Task

Display the   current date   in the formats of:

   2007-11-23     and 
   Friday, November 23, 2007

",Python,"import datetime
today = datetime.date.today()
# The first requested format is a method of datetime objects:
today.isoformat()
# For full flexibility, use the strftime formatting codes from the link above:
today.strftime(""%A, %B %d, %Y"")
# This mechanism is integrated into the general string formatting system.
# You can do this with positional arguments referenced by number
""The date is {0:%A, %B %d, %Y}"".format(d)
# Or keyword arguments referenced by name
""The date is {date:%A, %B %d, %Y}"".format(date=d)
# Since Python 3.6, f-strings allow the value to be inserted inline
f""The date is {d:%A, %B %d, %Y}""",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Sierpinski_carpet,Sierpinski carpet,"Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N.



For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art.

The important requirement is the placement of whitespace and non-whitespace characters.



Related task

   Sierpinski triangle

",Python,"def in_carpet(x, y):
    while True:
        if x == 0 or y == 0:
            return True
        elif x % 3 == 1 and y % 3 == 1:
            return False
 
        x /= 3
        y /= 3
 
def carpet(n):
    for i in xrange(3 ** n):
        for j in xrange(3 ** n):
            if in_carpet(i, j):
                print '*',
            else:
                print ' ',
        print",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Speech_synthesis,Speech synthesis,"Render the text       This is an example of speech synthesis      as speech.



Related task

   using a speech engine to highlight words



",Python,"from gtts import gTTS
import os

tts = gTTS(text='This is an example of speech synthesis.', lang='en')
tts.save(""good.mp3"")
os.system(""mpg321 good.mp3"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",Python,"print(""Hello world!"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Image_convolution,Image convolution,"One class of image digital filters is described by a rectangular matrix of real coefficients called kernel convoluted in a sliding window of image pixels. Usually the kernel is square 




K

k
l




{\displaystyle K_{kl}}

, where k, l are in the range -R,-R+1,..,R-1,R. W=2R+1 is the kernel width. The filter determines the new value of a monochromatic image pixel Pij as a convolution of the image pixels in the window centered in i, j and the kernel values:







P

i
j


=


∑

k
=
−
R


R



∑

l
=
−
R


R



P

i
+
k
 
j
+
l



K

k
l





{\displaystyle P_{ij}=\displaystyle \sum _{k=-R}^{R}\sum _{l=-R}^{R}P_{i+k\ j+l}K_{kl}}




Color images are usually split into the channels which are filtered independently. A color model can be changed as well, i.e. filtration is performed not necessarily in RGB. Common kernels sizes are 3x3 and 5x5. The complexity of filtrating grows quadratically (O(n2)) with the kernel width.

Task: Write a generic convolution 3x3 kernel filter. Optionally show some end user filters that use this generic one.

(You can use, to test the functions below, these input and output solutions.)
",Python,"from PIL import Image
from progressbar import ProgressBar

class Pixmap(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.pixels = []
        for i in range(width * height):
            self.pixels.append(RGBColour(0, 0, 0))

    def __getitem__(self, index):
        return self.pixels[index]

    def __setitem__(self, index, value):
        self.pixels[index] = value

    def convolute(self, kernel):
        newimg = Pixmap(self.width, self.height)
        pb = ProgressBar(self.width) if __debug__ else None
        for x in range(self.width):
            for y in range(self.height):
                self.apply_kernel(x, y, kernel, newimg)
            if __debug__:
                pb.update(x)
        if __debug__:
            pb.close()
        return newimg

    def apply_kernel(self, x, y, kernel, newimg):
        x0 = 0 if x == 0 else x - 1
        y0 = 0 if y == 0 else y - 1
        x1 = x
        y1 = y
        x2 = self.width - 1 if x + 1 == self.width else x + 1
        y2 = self.height - 1 if y + 1 == self.height else y + 1

        r = g = b = 0.0
        for xx, kcol in zip([x0, x1, x2], kernel):
            for yy, k in zip([y0, y1, y2], kcol):
                r += k * self[xx, yy].r
                g += k * self[xx, yy].g
                b += k * self[xx, yy].b
        newimg[x, y] = RGBColour(self.luma(r), self.luma(g), self.luma(b))

    def luma(self, value):
        if value < 0:
            return 0
        elif value > 255:
            return 255
        else:
            return value

    @classmethod
    def open(cls, filename):
        im = Image.open(filename)
        width, height = im.size
        pixmap = Pixmap(width, height)
        for x in range(width):
            for y in range(height):
                r, g, b = im.getpixel((x, y))
                pixmap[x, y] = RGBColour(r, g, b)
        return pixmap

    def save(self, filename):
        im = Image.new('RGB', (self.width, self.height))
        for x in range(self.width):
            for y in range(self.height):
                im.putpixel((x, y), (self[x, y].r, self[x, y].g, self[x, y].b))
        im.save(filename)

class RGBColour(object):
    def __init__(self, r, g, b):
        self.r = r
        self.g = g
        self.b = b

# Demonstration code using the teapot image from Tk's widget demo
teapot = Pixmap.open('teapot.ppm')
for label, kernel in [
    ('Emboss', [[-2.0, -1.0, 0.0], [-1.0, 1.0, 1.0], [0.0, 1.0, 2.0]]),
    ('Sharpen', [[-1.0, -1.0, -1.0], [-1.0, 9.0, -1.0], [-1.0, -1.0, -1.0]]),
    ('Blur', [[0.1111, 0.1111, 0.1111], [0.1111, 0.1111, 0.1111], [0.1111, 0.1111, 0.1111]]),
]:
    savefile = 'teapot_' + label.lower() + '.ppm'
    teapot.convolute(kernel).save(savefile)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/String_append,String append,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Most languages provide a way to concatenate two string values, but some languages also provide a convenient way to append in-place to an existing string variable without referring to the variable twice.



Task

Create a string variable equal to any text value.

Append the string variable with another string literal in the most idiomatic way, without double reference if your language supports it.

Show the contents of the variable after the append operation.



",Python,"s1 = ""Hello""
s1 += "", World!""
print(s1)

s2 = ""Goodbye""
# concat() returns the strings together, but doesn't edit existing string
# concat can also have multiple parameters
print(s2.concat("", World!""))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",Python,"from string import letters
from random import choice, random
 
target  = list(""METHINKS IT IS LIKE A WEASEL"")
charset = letters + ' '
parent  = [choice(charset) for _ in range(len(target))]
minmutaterate  = .09
C = range(100)
 
perfectfitness = float(len(target))
 
def fitness(trial):
    'Sum of matching chars by position'
    return sum(t==h for t,h in zip(trial, target))
 
def mutaterate():
    'Less mutation the closer the fit of the parent'
    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))
 
def mutate(parent, rate):
    return [(ch if random() <= rate else choice(charset)) for ch in parent]
 
def que():
    '(from the favourite saying of Manuel in Fawlty Towers)'
    print (""#%-4i, fitness: %4.1f%%, '%s'"" %
           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))
 
def mate(a, b):
    place = 0
    if choice(xrange(10)) < 7:
        place = choice(xrange(len(target)))
    else:
        return a, b
 
    return a, b, a[:place] + b[place:], b[:place] + a[place:]
 
iterations = 0
center = len(C)/2
while parent != target:
    rate = mutaterate()
    iterations += 1
    if iterations % 100 == 0: que()
    copies = [ mutate(parent, rate) for _ in C ]  + [parent]
    parent1 = max(copies[:center], key=fitness)
    parent2 = max(copies[center:], key=fitness)
    parent = max(mate(parent1, parent2), key=fitness)
que()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Permutations/Derangements,Permutations/Derangements,"A derangement is a permutation of the order of distinct items in which no item appears in its original place.

For example, the only two derangements of the three items (0, 1, 2) are (1, 2, 0), and (2, 0, 1).

The number of derangements of n distinct items is known as the subfactorial of n, sometimes written as !n.
There are various ways to calculate !n.



Task

 Create a named function/method/subroutine/... to generate derangements of the integers 0..n-1, (or 1..n if you prefer). 
 Generate and show all the derangements of 4 integers using the above routine.
 Create a function that calculates the subfactorial of n, !n.
 Print and show a table of the counted number of derangements of n vs. the calculated !n for n from 0..9 inclusive.


Optional stretch goal

   Calculate    !20 


Related tasks

   Anagrams/Deranged anagrams
   Best shuffle
   Left_factorials



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import permutations
import math
 
 
def derangements(n):
    'All deranged permutations of the integers 0..n-1 inclusive'
    return ( perm for perm in permutations(range(n))
             if all(indx != p for indx, p in enumerate(perm)) )
 
def subfact(n):
    if n == 2 or n == 0:
        return 1
    elif n == 1:
        return 0
    elif  1 <= n <=18:
        return round(math.factorial(n) / math.e)
    elif n.imag == 0 and n.real == int(n.real) and n > 0:
        return (n-1) * ( subfact(n - 1) + subfact(n - 2) )
    else:
        raise ValueError()
 
def _iterlen(iter):
    'length of an iterator without taking much memory'
    l = 0
    for x in iter:
        l += 1
    return l
 
if __name__ == '__main__':
    n = 4
    print(""Derangements of %s"" % (tuple(range(n)),))
    for d in derangements(n):
        print(""  %s"" % (d,))
 
    print(""\nTable of n vs counted vs calculated derangements"")
    for n in range(10):
        print(""%2i %-5i %-5i"" %
              (n, _iterlen(derangements(n)), subfact(n)))
 
    n = 20
    print(""\n!%i = %i"" % (n, subfact(n)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Ramanujan%27s_constant,Ramanujan's constant,"Calculate Ramanujan's constant (as described on the OEIS site) with at least
32 digits of precision, by the method of your choice. Optionally, if using the 𝑒**(π*√x) approach,
show that when evaluated with the last four Heegner numbers
the result is almost an integer.
",Python,"from mpmath import mp
heegner = [19,43,67,163]
mp.dps = 50
x = mp.exp(mp.pi*mp.sqrt(163))
print(""calculated Ramanujan's constant: {}"".format(x))
print(""Heegner numbers yielding 'almost' integers:"")
for i in heegner:
    print("" for {}: {} ~ {} error: {}"".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Middle_three_digits,Middle three digits,"Task

Write a function/procedure/subroutine that is called with an integer value and returns the middle three digits of the integer if possible or a clear indication of an error if this is not possible.

Note: The order of the middle digits should be preserved.

Your function should be tested with the following values; the first line should return valid answers, those of the second line should return clear indications of an error:

123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345
1, 2, -1, -10, 2002, -2002, 0

Show your output on this page.



",Python,">>> def middle_three_digits(i):
	s = str(abs(i))
	length = len(s)
	assert length >= 3 and length % 2 == 1, ""Need odd and >= 3 digits""
	mid = length // 2
	return s[mid-1:mid+2]
 
>>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]
>>> failing = [1, 2, -1, -10, 2002, -2002, 0]
>>> for x in passing + failing:
	try:
		answer = middle_three_digits(x)
	except AssertionError as error:
		answer = error
	print(""middle_three_digits(%s) returned: %r"" % (x, answer))
 
 
middle_three_digits(123) returned: '123'
middle_three_digits(12345) returned: '234'
middle_three_digits(1234567) returned: '345'
middle_three_digits(987654321) returned: '654'
middle_three_digits(10001) returned: '000'
middle_three_digits(-10001) returned: '000'
middle_three_digits(-123) returned: '123'
middle_three_digits(-100) returned: '100'
middle_three_digits(100) returned: '100'
middle_three_digits(-12345) returned: '234'
middle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)
middle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Egyptian_division,Egyptian division,"Egyptian division is a method of dividing integers using addition and
doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

 Start the construction of a table of two columns: powers_of_2, and doublings; by a first row of a 1 (i.e. 2^0) in the first column and 1 times the divisor in the first row second column.
 Create the second row with columns of 2 (i.e 2^1), and 2 * divisor in order.
 Continue with successive i’th rows of 2^i and 2^i * divisor.
 Stop adding rows, and keep only those rows, where 2^i * divisor is less than or equal to the dividend.
 We now assemble two separate sums that both start as zero, called here answer and accumulator
 Consider each row of the table, in the reverse order of its construction.
 If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers_of_2 cell value to the answer.
 When the first row has been considered as above, then the integer division of dividend by divisor is given by answer.
 (And the remainder is given by the absolute value of accumulator - dividend).


Example: 580 / 34

 Table creation: 



 powers_of_2

 doublings


 1

 34


 2

 68


 4

 136


 8

 272


 16

 544

 Initialization of sums: 



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544










 0

 0

 Considering table rows, bottom-up: 

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544

 16

 544



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272

 16

 544


 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136

 16

 544


 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68

 16

 544


 4

 136






 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34

 17

 578


 2

 68






 4

 136






 8

 272






 16

 544





Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.



Task

The task is to create a function that does Egyptian division. The function should

closely follow the description above in using a list/array of powers of two, and

another of doublings.

 Functions should be clear interpretations of the algorithm.
 Use the function to divide 580 by 34 and show the answer here, on this page.


Related tasks

   Egyptian fractions


References

   Egyptian Number System

",Python,"# EGYPTIAN DIVISION --------------------------------

# eqyptianQuotRem :: Int -> Int -> (Int, Int)
def eqyptianQuotRem(m, n):
    def expansion(i_x):
        i, x = i_x
        return (
            None if x > m else
            (i, x),
            (i + i, x + x)
        )
    def collapse(i_x, q_r):
        i, x = i_x
        q, r = q_r
        return (
            q + i, r - x
        ) if x < r else (
            q, r
        )
    return foldr(
        collapse,
        (0, m),
        unfoldr(expansion, (1, n))
    )

# TEST ---------------------------------------------

# main :: IO ()
def main():
    showLog(
        eqyptianQuotRem(580, 34)
    )
    # -> [17, 2]

# GENERIC FUNCTIONS --------------------------------

# Just :: a -> Maybe a
def Just(x):
    return {
        'type': 'Maybe',
        'Nothing': False,
        'Just': x
    }

# Nothing :: Maybe a
def Nothing():
    return {
        'type': 'Maybe',
        'Nothing': True,
    }

# flip :: (a -> b -> c) -> b -> a -> c
def flip(f):
    return (
        lambda a, b: f(b, a)
        if 1 < len(f.__code__.co_varnames) else
        lambda x: lambda y: f(y)(x)
    )

# foldr :: (a -> b -> b) -> b -> [a] -> b
def foldr(f, a, xs):
    return (
        a if not xs else
        f(xs[0], foldr(f, a, xs[1:]))
    )

# unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
def unfoldr(f, v):
    xr = [v, v]
    xs = []
    while True:
        mb = f(xr[1])
        if mb['Nothing']:
            return xs
        else:
            xr = mb['Just']
            xs.append(xr[0])

# showLog :: a -> IO ()
def showLog(*args):
    print(
       '-> '.join(
            map(
                lambda x: str(x),
                args
            )
        )
    )

# MAIN ---
if __name__ == '__main__':
    main()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sierpinski_pentagon,Sierpinski pentagon,"Produce a graphical or ASCII-art representation of a Sierpinski pentagon (aka a Pentaflake) of order 5. Your code should also be able to correctly generate representations of lower orders: 1 to 4.





See also
 Sierpinski pentagon

",Python,"from turtle import *
import math
speed(0)      # 0 is the fastest speed. Otherwise, 1 (slow) to 10 (fast)
hideturtle()  # hide the default turtle
 
part_ratio = 2 * math.cos(math.radians(72))
side_ratio = 1 / (part_ratio + 2)
 
hide_turtles = True   # show/hide turtles as they draw
path_color = ""black""  # path color
fill_color = ""black""  # fill color
 
# turtle, size
def pentagon(t, s):
  t.color(path_color, fill_color)
  t.pendown()
  t.right(36)
  t.begin_fill()
  for i in range(5):
    t.forward(s)
    t.right(72)
  t.end_fill()
 
# iteration, turtle, size
def sierpinski(i, t, s):
  t.setheading(0)
  new_size = s * side_ratio
 
  if i > 1:
    i -= 1
 
    # create four more turtles
    for j in range(4):
      t.right(36)
      short = s * side_ratio / part_ratio
      dist = [short, s, s, short][j]
 
      # spawn a turtle
      spawn = Turtle()
      if hide_turtles:spawn.hideturtle()
      spawn.penup()
      spawn.setposition(t.position())
      spawn.setheading(t.heading())
      spawn.forward(dist)
 
      # recurse for spawned turtles
      sierpinski(i, spawn, new_size)
 
    # recurse for parent turtle
    sierpinski(i, t, new_size)
 
  else:
    # draw a pentagon
    pentagon(t, s)
    # delete turtle
    del t
 
def main():
  t = Turtle()
  t.hideturtle()
  t.penup()
  screen = t.getscreen()
  y = screen.window_height()
  t.goto(0, y/2-20)
 
  i = 5       # depth. i >= 1
  size = 300  # side length
 
  # so the spawned turtles move only the distance to an inner pentagon
  size *= part_ratio
 
  # begin recursion
  sierpinski(i, t, size)
 
main()",Human_written,Python_from_C
http://rosettacode.org/wiki/Copy_a_string,Copy a string,"This task is about copying a string.



Task

Where it is relevant, distinguish between copying the contents of a string
versus making an additional reference to an existing string.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> src = ""hello""
>>> a = src
>>> b = src[:]
>>> import copy
>>> c = copy.copy(src)
>>> d = copy.deepcopy(src)
>>> src is a is b is c is d
True",Human_written,Python_from_Go
http://rosettacode.org/wiki/Pythagorean_quadruples,Pythagorean quadruples,"

One form of   Pythagorean quadruples   is   (for positive integers   a,   b,   c,   and   d):



    a2   +   b2   +   c2     =     d2 


An example:

    22   +   32   +   62     =     72 
 which is:
    4    +   9    +   36     =     49 


Task

For positive integers up   2,200   (inclusive),   for all values of   a,  
b,   c,   and   d,

find   (and show here)   those values of   d   that   can't   be represented.

Show the values of   d   on one line of output   (optionally with a title).



Related tasks

   Euler's sum of powers conjecture. 
   Pythagorean triples.


Reference

   the Wikipedia article:   Pythagorean quadruple.

",Python,"MAX = 2200
MAX2 = MAX * MAX * 2
found = [False] * (MAX + 1)
a2b2 = [False] * (MAX2 + 1)
s = 3
for a in range(1, MAX + 1):
    a2 = a * a
    for b in range(a, MAX + 1):
        a2b2[a2 + b * b] = True
for c in range(1, MAX + 1):
    s1 = s
    s += 2
    s2 = s
    for d in range(c + 1, MAX + 1):
        if a2b2[s1]:
            found[d] = True
        s1 += s2
        s2 += 2
print(""The values of d <= {0} which can't be represented:"".format(MAX))
for d in range(1, MAX):
    if not found[d]:
        print(""{0}  "".format(d), end="""")
print()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Determine_if_a_string_is_squeezable,Determine if a string is squeezable,"Determine if a character string is   squeezable.

And if so,   squeeze the string   (by removing any number of
a   specified   immediately repeated   character).



This task is very similar to the task     Determine if a character string is collapsible     except
that only a specified character is   squeezed   instead of any character that is immediately repeated.



If a character string has a specified   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



A specified   immediately repeated   character is any specified character that is   immediately  
followed by an identical character (or characters).   Another word choice could've been   duplicated
character,   but that might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around
November 2019)   PL/I   BIF:   squeeze.}



Examples

In the following character string with a specified   immediately repeated   character of   e:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   e   is an specified repeated character,   indicated by an underscore
(above),   even though they (the characters) appear elsewhere in the character string.



So, after squeezing the string, the result would be:

 The better the 4-whel drive, the further you'll be from help when ya get stuck! 





Another example:
In the following character string,   using a specified immediately repeated character   s:

 headmistressship 



The ""squeezed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to locate a   specified immediately repeated   character
and   squeeze   (delete)   them from the character string.   The
character string can be processed from either direction.



Show all output here, on this page:

   the   specified repeated character   (to be searched for and possibly squeezed):
   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

                                                                                  immediately
 string                                                                            repeated
 number                                                                            character
                                                                                     ( ↓   a blank,  a minus,  a seven,  a period)
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗    ' '    ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║    '-'
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║    '7'
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║    '.'
   5    ║                                                    --- Harry S Truman  ║  (below)  ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝     ↑
                                                                                       │
                                                                                       │
        For the 5th string  (Truman's signature line),  use each of these  specified immediately  repeated characters:
                                  •  a blank
                                  •  a minus
                                  •  a lowercase  r



Note:   there should be seven results shown,   one each for the 1st four strings,   and three results for
the 5th string.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import groupby
 
def squeezer(s, txt):
    return ''.join(item if item == s else ''.join(grp)
                   for item, grp in groupby(txt))
 
if __name__ == '__main__':
    strings = [
            """",
            '""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ',
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                   ---  Harry S Truman  "",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""aardvark"",
            ""😍😀🙌💃😍😍😍🙌"",
            ]
    squeezers = ' ,-,7,., -r,e,s,a,😍'.split(',')
    for txt, chars in zip(strings, squeezers):
        this = ""Original""
        print(f""\n{this:14} Size: {len(txt)} «««{txt}»»»"" )
        for ch in chars:
            this = f""Squeezer '{ch}'""
            sqz = squeezer(ch, txt)
            print(f""{this:>14} Size: {len(sqz)} «««{sqz}»»»"" )",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Singly-linked_list/Element_definition,Singly-linked list/Element definition,"singly-linked list
See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Python,"class LinkedList(object):
     """"""USELESS academic/classroom example of a linked list implemented in Python.
        Don't ever consider using something this crude!  Use the built-in list() type!
     """"""
	class Node(object):
		def __init__(self, item):
			self.value  = item
			self.next = None
	def __init__(self, item=None):
		if item is not None:
			self.head = Node(item); self.tail = self.head
		else:
			self.head = None; self.tail = None
	def append(self, item):
		if not self.head:
			self.head = Node(item)
			self.tail = self.head
		elif self.tail:
			self.tail.next = Node(item)
			self.tail = self.tail.next
		else:
			self.tail = Node(item)
	def __iter__(self):
		cursor = self.head
		while cursor:
			yield cursor.value
			cursor = cursor.next",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",Python,"def hanoi(ndisks, startPeg=1, endPeg=3):
    if ndisks:
        hanoi(ndisks-1, startPeg, 6-startPeg-endPeg)
        print ""Move disk %d from peg %d to peg %d"" % (ndisks, startPeg, endPeg)
        hanoi(ndisks-1, 6-startPeg-endPeg, endPeg)
 
hanoi(ndisks=4)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Metered_concurrency,Metered concurrency,"The goal of this task is to create a counting semaphore used to control the execution of a set of concurrent units. This task intends to demonstrate coordination of active concurrent units through the use of a passive concurrent unit. The operations for a counting semaphore are acquire, release, and count. Each active concurrent unit should attempt to acquire the counting semaphore before executing its assigned duties. In this case the active concurrent unit should report that it has acquired the semaphore. It should sleep for 2 seconds and then release the semaphore.
",Python,"# version 1.1.54
import threading
import time
 
num_permits = 4
num_threads = 9
semaphore = threading.Semaphore(num_permits)
 
def run(i):
    name = ""Unit #"" + str(i)
    semaphore.acquire()
    print(name + "" has acquired the semaphore"")
    time.sleep(2.0)
    semaphore.release()
    print(name + "" has released the semaphore"")
 
for i in range(1, num_threads + 1):
    threading.Thread(target=run, args=(i,)).start()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import csv
 
with open('test_in.csv', 'r') as f:
    reader = csv.reader(f)
    with open('test_out.csv', 'w') as f2:
        writer = csv.writer(f2)
        for i, row in enumerate(reader):
            if i == 0:
                row.append('SUM')
            else:
                row.append(sum(int(x) for x in row))
            writer.writerow(row)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",Python,"def isqrt ( x ):
    q = 1
    while q <= x : 
        q *= 4
    z,r = x,0
    while q > 1 :
        q  /= 4
        t,r = z-r-q,r/2
        if t >= 0 :
            z,r = t,r+q
    return r 
 
print ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))
print '\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))",Human_written,Python_from_C
http://rosettacode.org/wiki/Honeycombs,Honeycombs,"The task is to produce a matrix of 20 hexagon shaped widgets in a honeycomb arrangement. The matrix should be arranged in such a manner that there are five
columns of four hexagons. The hexagons in columns one, three and five are aligned horizontally, whereas the hexagons in columns two and four occupy a lower position within the arrangement. Each hexagon should be the same colour, and should
display a unique randomly selected single capital letter on the front. The application should now wait for the user to select a hexagon, either by using a pointing device, or by pressing a key that carries a corresponding letter on a hexagon. For platforms that support pointing devices and keyboards, the application should support both methods of selection. A record of the chosen letters should be maintained and the code should be suitably commented, at the point where the the selected letter has been determined. The selected hexagon should now change colour on the display. The cycle repeats until the user has chosen all of the letters. Note that each letter can only be selected once and previously selected hexagons retain their colour after selection. The program terminates when all letters have been chosen.

Optionally: output the list of selected letters and show the last selected letter, cater for a different number of columns or a different number of hexagons in each column, cater for two players, (turns alternate and the hexagons change a different colour depending on whether they were selected by player one or player two and records of both players selections are maintained.)


",Python,"#lang racket
 
(struct Hex (x y letter clicked?) #:mutable #:transparent)
 
(define hexes
  (let* ([A (char->integer #\A)]
         [letters (take (shuffle (map (compose string integer->char)
                                      (range A (+ A 26))))
                        20)])
    (for*/list ([row 4] [column 5])
      (Hex (* 3/2 column) (* 2 (+ row (if (odd? column) 1/2 0)))
           (list-ref letters (+ (* 5 row) column))
           false))))
 
(require 2htdp/image)
(define (blank width height) (rectangle width height 'outline (color 0 0 0 0)))
 
(define (hexagon mode color) (regular-polygon 1 6 mode color))
(define aspect-ratio (sin (/ pi 3)))
 
(define (board _)
  (scale 100
         (for/fold ([the-board (blank 8 (* aspect-ratio 9))])
           ([hex hexes])
           (define-values (letter-color hex-color)
             (if (Hex-clicked? hex) (values 'black 'purple) (values 'red 'yellow)))
           (underlay/align/offset
            'left 'top the-board
            (Hex-x hex) (* aspect-ratio (Hex-y hex))
            (overlay (scale 1/10 (text (Hex-letter hex) 10 letter-color))
                     (hexagon 'outline 'black)
                     (hexagon 'solid hex-color))))))
 
#| Closest hex in hexes to x y, as one with minimum distance to its center. |#
(define (hex-at x y)
  (argmin (λ (hex) (+ (sqr (- x (* 100 (add1 (Hex-x hex)))))
                      (sqr (- y (* aspect-ratio 100 (add1 (Hex-y hex)))))))
          hexes))
 
(define letters-chosen '())
(define (choose hex)
  (set-Hex-clicked?! hex true)
  (define letter (Hex-letter hex))
  (when (not (member letter letters-chosen))
    (set! letters-chosen (list* (Hex-letter hex) letters-chosen))))
 
(require 2htdp/universe)
(void (big-bang
       (void)
       [to-draw board]
       [stop-when (λ (_) (andmap Hex-clicked? hexes)) board]
       [on-key (λ (_ k)
                 (define hex (findf (λ (hex) (key=? k (string-downcase (Hex-letter hex))))
                                    hexes))
                 (when hex (choose hex)))]
       [on-mouse (λ (_ x y event-type)
                   (when (equal? ""button-down"" event-type)
                     (choose (hex-at x y))))]))
 
(displayln ""The letters were chosen in the order:"")
(for-each display (add-between (reverse letters-chosen) "" ""))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"q)3*2+1
9
q)(3*2)+1    / Brackets give the usual order of precedence
7
q)x:5
q)(x+5; x:20; x-5)
25 20 0",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"print(""Goodbye, World!"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Collections,Collections,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Collections are abstractions to represent sets of values. 

In statically-typed languages, the values are typically of a common data type.



Task

Create a collection, and add a few values to it.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"def main(args):
    i = 0
 
    while i < 3:
        print(i)
        i += 1
 
if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Mandelbrot_set,Mandelbrot set,"Mandelbrot set

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Generate and draw the Mandelbrot set.



Note that there are many algorithms to draw Mandelbrot set and there are many functions which generate it .



",Python,"import cmath
 
def mandelbrot(a):
    z = 0
    for c in range(50):
        z = z*z + a
    return z
 
for y in range(100,0,-5):
    for x in range(-200,50,3):
        print '*' if abs(mandelbrot(complex(x/100.0,y/100.0))) < 2 else'',
    print",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Plasma_effect,Plasma effect,"The plasma effect is a visual effect created by applying various functions, notably sine and cosine, to the color values of screen pixels. When animated (not a task requirement) the effect may give the impression of a colorful flowing liquid.



Task
Create a plasma effect.




See also
 Computer Graphics Tutorial (lodev.org)
 Plasma (bidouille.org)

",Python,"import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import static java.awt.image.BufferedImage.*;
import static java.lang.Math.*;
import javax.swing.*;
 
public class PlasmaEffect extends JPanel {
    float[][] plasma;
    float hueShift = 0;
    BufferedImage img;
 
    public PlasmaEffect() {
        Dimension dim = new Dimension(640, 640);
        setPreferredSize(dim);
        setBackground(Color.white);
 
        img = new BufferedImage(dim.width, dim.height, TYPE_INT_RGB);
        plasma = createPlasma(dim.height, dim.width);
 
        # animate about 24 fps and shift hue value with every frame
        new Timer(42, (ActionEvent e) -> {
            hueShift = (hueShift + 0.02f) % 1;
            repaint();
        }).start();
    }
 
    float[][] createPlasma(int w, int h) {
        float[][] buffer = new float[h][w];
 
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++) {
 
                double value = sin(x / 16.0);
                value += sin(y / 8.0);
                value += sin((x + y) / 16.0);
                value += sin(sqrt(x * x + y * y) / 8.0);
                value += 4; # shift range from -4.. 4 to 0.. 8
                value /= 8; # bring range down to 0.. 1
 
                # requires VM option -ea
                assert (value >= 0.0 && value <= 1.0) : ""Hue value out of bounds"";
 
                buffer[y][x] = (float) value;
            }
        return buffer;
    }
 
    void drawPlasma(Graphics2D g) {
        int h = plasma.length;
        int w = plasma[0].length;
        for (int y = 0; y < h; y++)
            for (int x = 0; x < w; x++) {
                float hue = hueShift + plasma[y][x] % 1;
                img.setRGB(x, y, Color.HSBtoRGB(hue, 1, 1));
            }
        g.drawImage(img, 0, 0, null);
    }
 
    @Override
    public void paintComponent(Graphics gg) {
        super.paintComponent(gg);
        Graphics2D g = (Graphics2D) gg;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);
 
        drawPlasma(g);
    }
 
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame f = new JFrame();
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            f.setTitle(""Plasma Effect"");
            f.setResizable(false);
            f.add(new PlasmaEffect(), BorderLayout.CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Array_length,Array length,"Task

Determine the amount of elements in an array.



As an example use an array holding the strings 'apple' and 'orange'.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"array = [""foo"", ""bar"", ""baz"", ""biff""]
print(""the array has {} elements"".format(len(array)))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Loops/Do-while,Loops/Do-while,"Start with a value at 0. Loop while value mod 6 is not equal to 0.
Each time through the loop, add 1 to the value then print it.
The loop must execute at least once.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges


Reference

 Do while loop Wikipedia.

",Python,"val = 0
while True:
   val +=1
   print val
   if val % 6 == 0: break",Human_written,Python_from_C++
http://rosettacode.org/wiki/Draw_a_sphere,Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Python,"import math
 
shades = ('.',':','!','*','o','e','&','#','%','@')
 
def normalize(v):
	len = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)
	return (v[0]/len, v[1]/len, v[2]/len)
 
def dot(x,y):
	d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
	return -d if d < 0 else 0
 
def draw_sphere(r, k, ambient, light):
	for i in range(int(math.floor(-r)),int(math.ceil(r)+1)):
		x = i + 0.5
		line = ''
 
		for j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):
			y = j/2 + 0.5
			if x*x + y*y <= r*r:
				vec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))
				b = dot(light,vec)**k + ambient
				intensity = int((1-b)*(len(shades)-1))
				line += shades[intensity] if 0 <= intensity < len(shades) else shades[0]
			else:
				line += ' '
 
		print(line)
 
light = normalize((30,30,-50))
draw_sphere(20,4,0.1, light)
draw_sphere(10,2,0.4, light)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Ordered_partitions,Ordered partitions,"In this task we want to find the ordered partitions into fixed-size blocks.

This task is related to Combinations in that it has to do with discrete mathematics and moreover a helper function to compute combinations is (probably) needed to solve this task.





p
a
r
t
i
t
i
o
n
s
(



a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n


)


{\displaystyle partitions({\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n})}

 should generate all distributions of the elements in 



{
1
,
.
.
.
,

Σ

i
=
1


n





a
r
g



i


}


{\displaystyle \{1,...,\Sigma _{i=1}^{n}{\mathit {arg}}_{i}\}}

 into 



n


{\displaystyle n}

 blocks of respective size 






a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

.

Example 1: 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

 would create:

{({1, 2}, {}, {3, 4}), 
 ({1, 3}, {}, {2, 4}), 
 ({1, 4}, {}, {2, 3}), 
 ({2, 3}, {}, {1, 4}), 
 ({2, 4}, {}, {1, 3}), 
 ({3, 4}, {}, {1, 2})}

Example 2: 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 would create:

{({1}, {2}, {3}), 
 ({1}, {3}, {2}), 
 ({2}, {1}, {3}), 
 ({2}, {3}, {1}), 
 ({3}, {1}, {2}), 
 ({3}, {2}, {1})}

Note that the number of elements in the list is








(






a
r
g



1


+



a
r
g



2


+
.
.
.
+



a
r
g



n






a
r
g



1




)



⋅



(






a
r
g



2


+



a
r
g



3


+
.
.
.
+



a
r
g



n






a
r
g



2




)



⋅
…
⋅



(





a
r
g



n





a
r
g



n




)





{\displaystyle {{\mathit {arg}}_{1}+{\mathit {arg}}_{2}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{1}}\cdot {{\mathit {arg}}_{2}+{\mathit {arg}}_{3}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{2}}\cdot \ldots \cdot {{\mathit {arg}}_{n} \choose {\mathit {arg}}_{n}}}


(see the definition of the binomial coefficient if you are not familiar with this notation) and the number of elements remains the same regardless of how the argument is permuted
(i.e. the multinomial coefficient).

Also, 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 creates the permutations of 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 and thus there would be 



3
!
=
6


{\displaystyle 3!=6}

 elements in the list.

Note: Do not use functions that are not in the standard library of the programming language you use. Your file should be written so that it can be executed on the command line and by default outputs the result of 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

. If the programming language does not support polyvariadic functions pass a list as an argument.

Notation

Here are some explanatory remarks on the notation used in the task description:





{
1
,
…
,
n
}


{\displaystyle \{1,\ldots ,n\}}

 denotes the set of consecutive numbers from 



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

, e.g. 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 if 



n
=
3


{\displaystyle n=3}

.





Σ


{\displaystyle \Sigma }

 is the mathematical notation for summation, e.g. 




Σ

i
=
1


3


i
=
6


{\displaystyle \Sigma _{i=1}^{3}i=6}

 (see also [1]).








a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

 are the arguments — natural numbers — that the sought function receives.



",Python,"from itertools import combinations
 
def partitions(*args):
    def p(s, *args):
        if not args: return [[]]
        res = []
        for c in combinations(s, args[0]):
            s0 = [x for x in s if x not in c]
            for r in p(s0, *args[1:]):
                res.append([c] + r)
        return res
    s = range(sum(args))
    return p(s, *args)
 
print partitions(2, 0, 2)",Human_written,Python_from_C
http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Python,"class Animal:
    #...

class Dog(Animal):
    #...

class Lab(Dog):
    #...

class Collie(Dog):
    #...

class Cat(Animal):
    #...",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Fairshare_between_two_and_more,Fairshare between two and more,"The Thue-Morse sequence is a sequence of ones and zeros that if two people
take turns in the given order, the first persons turn for every '0' in the
sequence, the second for every '1'; then this is shown to give a fairer, more
equitable sharing of resources. (Football penalty shoot-outs for example, might
not favour the team that goes first as much if the penalty takers take turns
according to the Thue-Morse sequence and took 2^n penalties)

The Thue-Morse sequence of ones-and-zeroes can be generated by:

""When counting in binary, the digit sum modulo 2 is the Thue-Morse sequence""


Sharing fairly between two or more

Use this method:

When counting base b, the digit sum modulo b is the Thue-Morse sequence of fairer sharing between b people.


Task
Counting from zero;   using a function/method/routine to express an integer count in base b,

sum the digits modulo b to produce the next member of the Thue-Morse fairshare series for b people.



Show the first 25 terms of the fairshare sequence:

   For two people:
   For three people
   For five people
   For eleven people


Related tasks

   Non-decimal radices/Convert
   Thue-Morse


See also

   A010060, A053838, A053840: The On-Line Encyclopedia of Integer Sequences® (OEIS®)

",Python,"def turn(base, n):
    sum = 0
    n2 = n
    while n2!= 0:
        re = n2 % base
        n2 //= base
        sum += re
    return sum % base
 
def fairShare(base, count):
    print(f""Base {base:2d}:"", end="""")
    for i in range(count):
        t = turn(base, i)
        print(f"" {t:2d}"", end="""")
    print()
 
def turnCount(base, count):
    cnt = [0] * base
    for i in range(count):
        t = turn(base, i)
        cnt[t] += 1
 
    minTurn = maxTurn = portion = 0
    for i in range(base):
        num = cnt[i]
        if num > 0:
            portion += 1
        if num < minTurn:
            minTurn = num
        if num > maxTurn:
            maxTurn = num
 
    print(f""  With {base} people: "", end="""")
    if minTurn == 0:
        print(f""Only {portion} have a turn"")
    elif minTurn == maxTurn:
        print(minTurn)
    else:
        print(f""{minTurn} or {maxTurn}"")
 
def main():
    fairShare(2, 25)
    fairShare(3, 25)
    fairShare(5, 25)
    fairShare(11, 25)
 
    print(""How many times does each get a turn in 50000 iterations?"")
    turnCount(191, 50000)
    turnCount(1377, 50000)
    turnCount(49999, 50000)
    turnCount(50000, 50000)
    turnCount(50001, 50000)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",Python,"import clr
clr.AddReference(""System.Windows.Forms"")
clr.AddReference(""System.Drawing"")
from System.Windows.Forms import *
from System.ComponentModel import *
from System.Drawing import *
 
class NumberModel(INotifyPropertyChanged):
    def __init__(self):
        self._value = 0
        self.PropertyChanged = PropertyChangedEventHandler(self.OnPropertyChanged)
 
    def OnPropertyChanged(self, sender, args):
        pass
 
    def get_Value(self):
        return self._value
 
    def set_Value(self, value):
        self._value = value
        self.PropertyChanged(self, PropertyChangedEventArgs(""Value""))
 
    Value = property(get_Value, set_Value)
 
class RosettaInteractionForm(Form):
    def __init__(self):
        self.model = NumberModel()
        self.model.Value = 0
 
        tbNumber = MaskedTextBox()
        tbNumber.Mask = ""0000""
        tbNumber.ResetOnSpace = False
        tbNumber.Dock = DockStyle.Top
        tbNumber.DataBindings.Add(""Text"", self.model, ""Value"")
        self.EnableControlWhen(tbNumber, lambda value: value == 0)
 
        btIncrement = Button()
        btIncrement.Text = ""Increment""
        btIncrement.Dock = DockStyle.Bottom
        btIncrement.Click += self.Increment
        self.EnableControlWhen(btIncrement, lambda value: value < 10)
 
        btDecrement = Button()
        btDecrement.Text = ""Decrement""
        btDecrement.Dock = DockStyle.Bottom
        btDecrement.Click += self.Decrement
        self.EnableControlWhen(btDecrement, lambda value: value > 0)
 
        self.Controls.Add(tbNumber)
        self.Controls.Add(btIncrement)
        self.Controls.Add(btDecrement)
 
    def EnableControlWhen(self, ctrl, predicate):
        enabledBinding = Binding(""Enabled"", self.model, ""Value"")
        enabledBinding.Format += self.FormatEnabledBinding
        ctrl.DataBindings.Add(enabledBinding)
 
    def FormatEnabledBinding(self, sender, args):
        if args.DesiredType!= bool:
            return
        args.Value = predicate(args.Value)
 
    def Increment(self, sender, args):
        self.model.Value += 1
 
    def Decrement(self, sender, args):
        self.model.Value -= 1
 
Application.Run(RosettaInteractionForm())",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Square_but_not_cube,Square but not cube,"Task

Show the first   30   positive integers which are squares but not cubes of such integers.

Optionally, show also the first   3   positive integers which are both squares and cubes,   and mark them as such.



",Python,"import math
 
for n, count in zip(range(1, 30), range(30)):
    sq = n * n
    cr = int(math.pow(sq, 1/3))
    if cr*cr*cr!= sq:
        count += 1
        print(sq)
    else:
        print(sq, ""is square and cube"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Bitwise_operations,Bitwise operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.



",Python,"def bitwise_built_ins(width, a, b):
    mask = (1 << width) - 1
    print(f""""""\
    AND:     0b{a :0{width}b} 
           & 0b{b :0{width}b} 
           = 0b{(a & b) & mask :0{width}b}
 
    OR:      0b{a :0{width}b} 
           | 0b{b :0{width}b} 
           = 0b{(a | b) & mask :0{width}b}
 
    XOR:     0b{a :0{width}b} 
           ^ 0b{b :0{width}b} 
           = 0b{(a ^ b) & mask :0{width}b}
 
    NOT:   ~ 0b{a :0{width}b} 
           = 0b{(~a) & mask :0{width}b}
 
    SHIFTS
 
      RIGHT:   0b{a :0{width}b} >> 1
             = 0b{(a >> 1) & mask :0{width}b}      
 
      LEFT:    0b{a :0{width}b} << 1
             = 0b{(a << 1) & mask :0{width}b}      
"""""")
 
def rotr(width, a, n):
    ""Rotate a, n times to the right""
    if n < 0:
        return rotl(width, a, -n)
    elif n == 0:
        return a
    else:
        mask = (1 << width) - 1
        a, n = a & mask, n % width
        return ((a >> n)    # top moved down
                | ((a & ((1 << n) - 1))   # Bottom masked...
                   << (width - n)))  # ... then moved up    
 
def rotl(width, a, n):
    ""Rotate a, n times to the left""
    if n < 0:
        return rotr(width, a, -n)
    elif n == 0:
        return a
    else:
        mask = (1 << width) - 1
        a, n = a & mask, n % width
        return (((a << n) & mask)      # bottom shifted up and masked
                | (a >> (width - n)))  # Top moved down  
 
def asr(width, a, n):
    ""Arithmetic shift a, n times to the right. (sign preserving).""
    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)
    if n < 0:
        return  (a << -n) & mask
    elif n == 0:
        return a
    elif n >= width:
        return mask if a & top_bit_mask else 0
    else:
        a = a & mask
        if a & top_bit_mask:    # Sign bit set?
            signs = (1 << n) - 1
            return a >> n | (signs << width - n)
        else:
            return a >> n
 
 
def helper_funcs(width, a):
    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)
    aa = a | top_bit_mask  # a with top bit set
    print(f""""""\
    ROTATIONS
 
      RIGHT:   rotr({width}, 0b{a :0{width}b}, 1)
               =       0b{rotr(width, a, 1) :0{width}b}      
               rotr({width}, 0b{a :0{width}b}, 2)
               =       0b{rotr(width, a, 2) :0{width}b}      
               rotr({width}, 0b{a :0{width}b}, 4)
               =       0b{rotr(width, a, 4) :0{width}b}      
 
      LEFT:    rotl({width}, 0b{a :0{width}b}, 1)
               =       0b{rotl(width, a, 1) :0{width}b}      
               rotl({width}, 0b{a :0{width}b}, 2)
               =       0b{rotl(width, a, 2) :0{width}b}      
               rotl({width}, 0b{a :0{width}b}, 4)
               =       0b{rotl(width, a, 4) :0{width}b}    
 
    SIGN-EXTENDING ARITHMETIC SHIFT RIGHT
 
               asr({width}, 0b{a :0{width}b}, 1)
               =      0b{asr(width, a, 1) :0{width}b}      
               asr({width}, 0b{aa :0{width}b}, 1)
               =      0b{asr(width, aa, 1) :0{width}b}      
               asr({width}, 0b{a :0{width}b}, 2)
               =      0b{asr(width, a, 2) :0{width}b}      
               asr({width}, 0b{aa :0{width}b}, 2)
               =      0b{asr(width, aa, 2) :0{width}b}      
               asr({width}, 0b{a :0{width}b}, 4)
               =      0b{asr(width, a, 4) :0{width}b} 
               asr({width}, 0b{aa :0{width}b}, 4)
               =      0b{asr(width, aa, 4) :0{width}b} 
"""""")
 
if __name__ == '__main__':
    bitwise_built_ins(8, 27, 125)
    helper_funcs(8, 27)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Dot_product,Dot product,"Task

Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors.

If possible, make the vectors of arbitrary length.



As an example, compute the dot product of the vectors:

     [1,  3, -5]       and 
     [4, -2, -1]   


If implementing the dot product of two vectors directly:

   each vector must be the same length
   multiply corresponding terms from each vector
   sum the products   (to produce the answer)


Related task

   Vector products

",Python,"def dot_product(ary1, ary2):
    if len(ary1)!= len(ary2):
        raise Exception(""can't find dot product: arrays have different lengths"")
    dotprod = 0
    for i in range(len(ary1)):
        dotprod += ary1[i] * ary2[i]
    return dotprod
 
print(dot_product([1,3,-5],[4,-2,-1])) # ==> 3
print(dot_product([1,3,-5],[4,-2,-1,0])) # ==> exception",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Power_set,Power set,"A   set   is a collection (container) of certain values,
without any particular order, and no repeated values.

It corresponds with a finite set in mathematics.

A set can be implemented as an associative array (partial mapping)
in which the value of each key-value pair is ignored.

Given a set S, the power set (or powerset) of S, written P(S), or 2S, is the set of all subsets of S.



Task

By using a library or built-in set type, or by defining a set type with necessary operations, write a function with a set S as input that yields the power set 2S of S.



For example, the power set of     {1,2,3,4}     is

 {{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}, {4}, {1,4}, {2,4}, {1,2,4}, {3,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}.
For a set which contains n elements, the corresponding power set has 2n elements, including the edge cases of empty set.


The power set of the empty set is the set which contains itself (20 = 1):


 





P




{\displaystyle {\mathcal {P}}}

(



∅


{\displaystyle \varnothing }

) = { 



∅


{\displaystyle \varnothing }

 }

And the power set of the set which contains only the empty set, has two subsets, the empty set and the set which contains the empty set (21 = 2):


 





P




{\displaystyle {\mathcal {P}}}

({



∅


{\displaystyle \varnothing }

}) = { 



∅


{\displaystyle \varnothing }

, { 



∅


{\displaystyle \varnothing }

 } }


Extra credit:  Demonstrate that your language supports these last two powersets.



",Python,"def subsets(self):
    if len(self) == 0:
        return [set()]
    else:
        head = self.pop()
        tail = self
        return subsets(tail) + [set(list(i) + [head]) for i in subsets(tail)]",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Grayscale_image,Grayscale image,"Many image processing algorithms are defined for grayscale (or else monochromatic) images.



Task

Extend the data storage type defined on this page to support grayscale images.

Define two operations, one to convert a color image to a grayscale image and one for the backward conversion.

To get luminance of a color use the formula recommended by CIE:

 L  =  0.2126 × R   +   0.7152 × G   +   0.0722 × B 

When using floating-point arithmetic make sure that rounding errors would not cause run-time problems or else distorted results when calculated luminance is stored as an unsigned integer.



",Python,"typedef unsigned char luminance;
typedef luminance pixel1[1];
typedef struct {
   unsigned int width;
   unsigned int height;
   luminance *buf;
} grayimage_t;
typedef grayimage_t *grayimage;
 
grayimage alloc_grayimg(unsigned int, unsigned int);
grayimage tograyscale(image);
image tocolor(grayimage);",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",Python,"from __future__ import print_function
from prime_decomposition import primes, is_prime
from heapq import *
from itertools import islice
 
def emirp():
    largest = set()
    emirps = []
    heapify(emirps)
    for pr in primes():
        while emirps and pr > emirps[0]:
            yield heappop(emirps)
        if pr in largest:
            yield pr
        else:
            rp = int(str(pr)[::-1])
            if rp > pr and is_prime(rp):
                heappush(emirps, pr)
                largest.add(rp)
 
print('First 20:\n  ', list(islice(emirp(), 20)))
print('Between 7700 and 8000:\n  [', end='')
for pr in emirp():
    if pr >= 8000: break
    if pr >= 7700: print(pr, end=', ')
print(']')
print('10000th:\n  ', list(islice(emirp(), 10000-1, 10000)))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Knapsack_problem/Continuous,Knapsack problem/Continuous,"

A thief burgles a butcher's shop, where he can select from some items.

The thief knows the weights and prices of each items.   Because he has a knapsack with 15 kg maximal capacity, he wants to select the items such that he would have his profit maximized.   He may cut the items;   the item has a reduced price after cutting that is proportional to the original price by the ratio of masses.   That means:   half of an item has half the price of the original.



This is the item list in the butcher's shop:


 Table of potential knapsack items


 Item 
 Weight (kg) 
 Price (Value)


 beef 
 3.8 
 36


 pork 
 5.4 
 43


 ham 
 3.6 
 90


 greaves 
 2.4 
 45


 flitch 
 4.0 
 30


 brawn 
 2.5 
 56


 welt 
 3.7 
 67


 salami 
 3.0 
 95


 sausage 
 5.9 
 98


 Knapsack 
 <=15 kg 
 ?



Task

Show which items the thief carries in his knapsack so that their total weight does not exceed 15 kg, and their total value is maximized.



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/0-1


See also

   Wikipedia article:   continuous knapsack.

",Python,"# version 1.1.2
 
class Item:
    def __init__(self, name, weight, value):
        self.name = name
        self.weight = weight
        self.value = value
 
items = [
    Item(""beef"", 3.8, 36.0),
    Item(""pork"", 5.4, 43.0),
    Item(""ham"", 3.6, 90.0),
    Item(""greaves"", 2.4, 45.0),
    Item(""flitch"", 4.0, 30.0),
    Item(""brawn"", 2.5, 56.0),
    Item(""welt"", 3.7, 67.0),
    Item(""salami"", 3.0, 95.0),
    Item(""sausage"", 5.9, 98.0)
]
 
MAX_WEIGHT = 15.0
 
def main():
    # sort items by value per unit weight in descending order
    items.sort(key=lambda item: item.value / item.weight, reverse=True)
    print(""Item Chosen   Weight  Value  Percentage"")
    print(""-----------   ------ ------  ----------"")
    w = MAX_WEIGHT
    itemCount = 0
    sumValue = 0.0
    for item in items:
        itemCount += 1
        if item.weight <= w:
           sumValue += item.value
           print(f""{item.name.ljust(11)}     {item.weight:3.1f}   {item.value:5.2f}    100.00"")
        else:
           value  = round((w / item.weight * item.value * 100.0)) / 100.0
           percentage = round((w / item.weight * 10000.0)) / 100.0
           sumValue += value
           print(f""{item.name.ljust(11)}     {w:3.1f}   {value:5.2f}     {percentage:5.2f}"")
           break
        w -= item.weight
        if w == 0.0: break
    print(""-----------   ------ ------"")
    print(f""{itemCount} items        15.0  {sumValue:6.2f}"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/9_billion_names_of_God_the_integer,9 billion names of God the integer,"This task is a variation of the short story by Arthur C. Clarke.

(Solvers should be aware of the consequences of completing this task.)

In detail, to specify what is meant by a   “name”:

The integer 1 has 1 name     “1”.
The integer 2 has 2 names   “1+1”,   and   “2”.
The integer 3 has 3 names   “1+1+1”,   “2+1”,   and   “3”.
The integer 4 has 5 names   “1+1+1+1”,   “2+1+1”,   “2+2”,   “3+1”,   “4”.
The integer 5 has 7 names   “1+1+1+1+1”,   “2+1+1+1”,   “2+2+1”,   “3+1+1”,   “3+2”,   “4+1”,   “5”.


Task
Display the first 25 rows of a number triangle which begins:

                                      1
                                    1   1
                                  1   1   1 
                                1   2   1   1
                              1   2   2   1   1
                            1   3   3   2   1   1

Where row   



n


{\displaystyle n}

   corresponds to integer   



n


{\displaystyle n}

,   and each column   



C


{\displaystyle C}

   in row   



m


{\displaystyle m}

   from left to right corresponds to the number of names beginning with   



C


{\displaystyle C}

.

A function   



G
(
n
)


{\displaystyle G(n)}

   should return the sum of the   



n


{\displaystyle n}

-th   row.

Demonstrate this function by displaying:   



G
(
23
)


{\displaystyle G(23)}

,   



G
(
123
)


{\displaystyle G(123)}

,   



G
(
1234
)


{\displaystyle G(1234)}

,   and   



G
(
12345
)


{\displaystyle G(12345)}

.

Optionally note that the sum of the   



n


{\displaystyle n}

-th   row   



P
(
n
)


{\displaystyle P(n)}

   is the     integer partition function.

Demonstrate this is equivalent to   



G
(
n
)


{\displaystyle G(n)}

   by displaying:   



P
(
23
)


{\displaystyle P(23)}

,   



P
(
123
)


{\displaystyle P(123)}

,   



P
(
1234
)


{\displaystyle P(1234)}

,   and   



P
(
12345
)


{\displaystyle P(12345)}

.



Extra credit
If your environment is able, plot   



P
(
n
)


{\displaystyle P(n)}

   against   



n


{\displaystyle n}

   for   



n
=
1
…
999


{\displaystyle n=1\ldots 999}

.

Related tasks
 Partition function P

",Python,"cache = [[1]]
def cumu(n):
    for l in range(len(cache), n+1):
        r = [0]
        for x in range(1, l+1):
            r.append(r[-1] + cache[l-x][min(x, l-x)])
        cache.append(r)
    return cache[n]
 
def row(n):
    r = cumu(n)
    return [r[i+1] - r[i] for i in range(n)]
 
print ""rows:""
for x in range(1, 11): print ""%2d:""%x, row(x)
 
 
print ""\nsums:""
for x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/One-dimensional_cellular_automata,One-dimensional cellular automata,"Assume an array of cells with an initial distribution of live and dead cells,
and imaginary cells off the end of the array having fixed values.

Cells in the next generation of the array are calculated based on the value of the cell and its left and right nearest neighbours in the current generation.

If, in the following table, a live cell is represented by 1 and a dead cell by 0 then to generate the value of the cell at a particular index in the array of cellular values you use the following table:

000 -> 0  # 
001 -> 0  #
010 -> 0  # Dies without enough neighbours
011 -> 1  # Needs one neighbour to survive
100 -> 0  #
101 -> 1  # Two neighbours giving birth
110 -> 1  # Needs one neighbour to survive
111 -> 0  # Starved to death.
",Python,"import random
 
printdead, printlive = '_#'
maxgenerations = 10
cellcount = 20
offendvalue = '0'
 
universe = ''.join(random.choice('01') for i in range(cellcount))
 
neighbours2newstate = {
 '000': '0',
 '001': '0',
 '010': '0',
 '011': '1',
 '100': '0',
 '101': '1',
 '110': '1',
 '111': '0',
 }
 
for i in range(maxgenerations):
    print ""Generation %3i:  %s"" % ( i,
          universe.replace('0', printdead).replace('1', printlive) )
    universe = offendvalue + universe + offendvalue
    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))",Human_written,Python_from_C
http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response,Keyboard input/Obtain a Y or N response,"

Task

Obtain a valid   Y   or   N   response from the keyboard.

The keyboard should be flushed, so that any outstanding key-presses are removed, preventing any existing   Y   or   N   key-press from being evaluated.

The response should be obtained as soon as   Y   or   N   are pressed, and there should be no need to press an   enter   key.



",Python,"#!/usr/bin/env python
 
try:
    from msvcrt import getch
except ImportError:
    def getch():
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
 
print ""Press Y or N to continue""
while True:
    char = getch()
    if char.lower() in (""y"", ""n""):
        print char
        break",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Ludic_numbers,Ludic numbers,"Ludic numbers   are related to prime numbers as they are generated by a sieve quite like the Sieve of Eratosthenes is used to generate prime numbers.

The first ludic number is   1.

To generate succeeding ludic numbers create an array of increasing integers starting from   2.

2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
(Loop)

 Take the first member of the resultant array as the next ludic number   2.
 Remove every   2nd   indexed item from the array (including the first).
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...
 (Unrolling a few loops...)
 Take the first member of the resultant array as the next ludic number   3.
 Remove every   3rd   indexed item from the array (including the first).
3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 ...
 Take the first member of the resultant array as the next ludic number   5.
 Remove every   5th   indexed item from the array (including the first).
5 7 11 13 17 19 23 25 29 31 35 37 41 43 47 49 53 55 59 61 65 67 71 73 77 ...
 Take the first member of the resultant array as the next ludic number   7.
 Remove every   7th   indexed item from the array (including the first).
7 11 13 17 23 25 29 31 37 41 43 47 53 55 59 61 67 71 73 77 83 85 89 91 97 ...
  ... 
 Take the first member of the current array as the next ludic number   L.
 Remove every   Lth   indexed item from the array (including the first).
  ... 


Task

 Generate and show here the first 25 ludic numbers.
 How many ludic numbers are there less than or equal to 1000?
 Show the 2000..2005th ludic numbers.


Stretch goal

Show all triplets of ludic numbers < 250.

 A triplet is any three numbers     



x
,


{\displaystyle x,}

   



x
+
2
,


{\displaystyle x+2,}

   



x
+
6


{\displaystyle x+6}

      where all three numbers are also ludic numbers. 

",Python,"def Ludic(n, max):
	if max > 0 and n < 0:
		n = 2**31 - 1
	if n < 1:
		return []
	if max < 0:
		max = 2**31 - 1
	sieve = [1, 2] + [i*2 + 3 for i in range(5380)]
	if n > 2:
		k = 2
		while k < n:
			l = sieve[k]
			if l >= max:
				n = k
				break
			i = l
			l -= 1
			last = k + i - 1
			j = k + i + 1
			while j < len(sieve):
				last = k + i
				sieve[last] = sieve[j]
				if i % l == 0:
					j += 1
				i += 1
				j += 1
			if last < len(sieve) - 1:
				sieve = sieve[:last+1]
			k += 1
	if n > len(sieve):
		raise Exception(""program error"")
	return sieve[:n]
 
def has(x, v):
	for i in range(len(x)):
		if x[i] > v:
			return False
		if x[i] == v:
			return True
	return False
 
if __name__ == ""__main__"":
	print(""First 25:"", Ludic(25, -1))
	print(""Numner of Ludics below 1000:"", len(Ludic(-1, 1000)))
	print(""Ludic 2000 to 2005:"", Ludic(2005, -1)[1999:])
 
	print(""Tripples below 250:"")
	x = Ludic(-1, 250)
	for i, v in enumerate(x[:len(x)-2]):
		if has(x[i+1:], v+2) and has(x[i+2:], v+6):
			print("", (%d %d %d)"" % (v, v+2, v+6))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Hello_world/Newbie,Hello world/Newbie,"Task

Guide a new user of a language through the steps necessary
to install the programming language and selection of a text editor if needed,
to run the languages' example in the Hello world/Text task.

 Assume the language-newbie is a programmer in another language.
 Assume the language-newbie is competent in installing software for the platform.
 Assume the language-newbie can use one simple text editor for the OS/platform, (but that may not necessarily be a particular one if the installation needs a particular editor).
 Refer to, (and link to), already existing documentation as much as possible (but provide a summary here).
 Remember to state where to view the output.
 If particular IDE's or editors are required that are not standard, then point to/explain their installation too.


Note:
 If it is more natural for a language to give output via a GUI or to a file etc, then use that method of output rather than as text to a terminal/command-line, but remember to give instructions on how to view the output generated.
 You may use sub-headings if giving instructions for multiple platforms.

",Python,"print(""Hello, World!"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Averages/Pythagorean_means,Averages/Pythagorean means,"Task[edit]
Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that 



A
(

x

1


,
…
,

x

n


)
≥
G
(

x

1


,
…
,

x

n


)
≥
H
(

x

1


,
…
,

x

n


)


{\displaystyle A(x_{1},\ldots ,x_{n})\geq G(x_{1},\ldots ,x_{n})\geq H(x_{1},\ldots ,x_{n})}

 for this set of positive integers.

 The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:
 



A
(

x

1


,
…
,

x

n


)
=




x

1


+
⋯
+

x

n



n




{\displaystyle A(x_{1},\ldots ,x_{n})={\frac {x_{1}+\cdots +x_{n}}{n}}}


 The geometric mean is the 



n


{\displaystyle n}

th root of the product of the list:
 



G
(

x

1


,
…
,

x

n


)
=




x

1


⋯

x

n




n





{\displaystyle G(x_{1},\ldots ,x_{n})={\sqrt[{n}]{x_{1}\cdots x_{n}}}}


 The harmonic mean is 



n


{\displaystyle n}

 divided by the sum of the reciprocal of each item in the list:
 



H
(

x

1


,
…
,

x

n


)
=


n



1

x

1




+
⋯
+


1

x

n









{\displaystyle H(x_{1},\ldots ,x_{n})={\frac {n}{{\frac {1}{x_{1}}}+\cdots +{\frac {1}{x_{n}}}}}}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"sum = 0.0
prod = 1
recsum = 0.0
for i in range(1,11):
    sum += i
    prod *= i
    recsum += 1.0/(i)
avg = sum/10.0
gmean = prod**(0.1)
hmean = 10.0/recsum
print(""Average: {}, Geometric mean: {}, Harmonic mean: {}"".format(avg, gmean, hmean))
assert ( (avg >= gmean) and (gmean >= hmean) ), ""Incorrect calculation""",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Program_termination,Program termination,"

Task

Show the syntax for a complete stoppage of a program inside a   conditional.

This includes all threads/processes which are part of your program.

Explain the cleanup (or lack thereof) caused by the termination (allocated memory, database connections, open files, object finalizers/destructors, run-on-exit hooks, etc.).

Unless otherwise described, no special cleanup outside that provided by the operating system is provided.



",Python,"if some_condition:
    quit()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Random_numbers,Random numbers,"Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers
with a mean of   1.0   and a   standard deviation   of   0.5



Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.



Related task

   Standard deviation

",Python,">>> import random
>>> values = [random.gauss(1, .5) for i in range(1000)]
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Long_primes,Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",Python,"def sieve(limit):
    primes = []
    c = [False] * (limit + 1) # composite = true
    # no need to process even numbers
    p = 3
    while True:
        p2 = p * p
        if p2 > limit: break
        for i in range(p2, limit, 2 * p): c[i] = True
        while True:
            p += 2
            if not c[p]: break
 
    for i in range(3, limit, 2):
        if not c[i]: primes.append(i)
    return primes
 
# finds the period of the reciprocal of n
def findPeriod(n):
    r = 1
    for i in range(1, n): r = (10 * r) % n
    rr = r
    period = 0
    while True:
        r = (10 * r) % n
        period += 1
        if r == rr: break
    return period
 
primes = sieve(64000)
longPrimes = []
for prime in primes:
    if findPeriod(prime) == prime - 1:
        longPrimes.append(prime)
numbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]
count = 0
index = 0
totals = [0] * len(numbers)
for longPrime in longPrimes:
    if longPrime > numbers[index]:
        totals[index] = count
        index += 1
    count += 1
totals[-1] = count
print('The long primes up to 500 are:')
print(str(longPrimes[:totals[0]]).replace(',', ''))
print('\nThe number of long primes up to:')
for (i, total) in enumerate(totals):
    print('  %5d is %d' % (numbers[i], total))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Enumerations,Enumerations,"Task

Create an enumeration of constants with and without explicit values.



",Python,"from enum import Enum

class fruits(Enum):
    apple = 0
    banana = 1
    cherry = 2",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Zig-zag_matrix,Zig-zag matrix,"Task

Produce a zig-zag array.



A   zig-zag   array is a square arrangement of the first   N2   natural numbers,   where the

numbers increase sequentially as you zig-zag along the array's   anti-diagonals.

For a graphical representation, see   JPG zigzag   (JPG uses such arrays to encode images).



For example, given   5,   produce this array:

 0  1  5  6 14
 2  4  7 13 15
 3  8 12 16 21
 9 11 17 20 22
10 18 19 23 24



Related tasks

   Spiral matrix
   Identity matrix
   Ulam spiral (for primes)


See also

   Wiktionary entry:   anti-diagonals

",Python,"def zigzag(n):
    seq = range(0, n)
    return sorted(
        [(x, y) for x in seq for y in seq],
        key=lambda (x, y): (x + y, (x + y) % 2 == 0)
    )
 
def print_matrix(m):
    format = ""%%0%dd "" % len(str(max(max(m)))) * len(m[0])
    for row in m:
        print format % tuple(row)
 
print_matrix(zigzag(5))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Walk_a_directory/Recursively,Walk a directory/Recursively,"Task

Walk a given directory tree and print files matching a given pattern.


Note: This task is for recursive methods.   These tasks should read an entire directory tree, not a single directory.


Note: Please be careful when running any code examples found here.



Related task

   Walk a directory/Non-recursively   (read a single directory). 

",Python,"# version 1.2.0
 
import os
import re
 
def walkDirectoryRecursively(dirPath, pattern):
    d = os.path.abspath(dirPath)
    if not os.path.isdir(d):
        raise ValueError(""Directory does not exist"")
    for root, dirs, files in os.walk(d):
        for f in files:
            if re.match(pattern, f):
                yield os.path.join(root, f)
 
if __name__ == ""__main__"":
    r = re.compile(r'^v(a|f).*\.h$')  # get all C header files beginning with 'va' or 'vf'
    files = sorted(set(walkDirectoryRecursively(""/usr/include"", r)))
    for file in files:
        print(file)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",Python,"from functools import reduce
from itertools import chain
from operator import add
 
def compose(*fns):
    return lambda *x: reduce(lambda a, b: lambda c: a(b(c)), fns)(*x)
 
def inv(b):
    return not b
 
def arr_join(arr, str):
    return str.join(map(str, arr))
 
def mk_arr(l, f):
    return [f() for _ in range(l)]
 
def sum_arr(arr):
    return reduce(add, arr, 0)
 
def sum_to(val):
    return lambda arr: sum_arr(arr) == val
 
def zipper(arr):
    return lambda p, c, i: [*p, c, arr[i]] if arr[i] else [*p, c]
 
def zip(a, b):
    return reduce(zipper(b), a, [])
 
def zip_arr(arr):
    return lambda a: zip(a, arr)
 
def has_inner(v):
    return lambda arr: v in arr[1:-1]
 
def choose(even, odd):
    return lambda n: even if n % 2 == 0 else odd
 
def to_bin(f):
    return lambda arr: reduce(lambda p, c: [*p, *mk_arr(c, f(p.index(c)))], arr, [])
 
def looper(arr, max, acc=None, idx=0):
    if acc is None:
        acc = [[*arr]]
    if idx!= len(arr):
        b = looper(arr, max, acc, idx + 1)[0]
        if b[idx]!= max:
            b[idx] = b[idx] + 1
            acc.append(looper(b, max, acc, idx)[0])
    return [arr, acc]
 
def gap_perms(grp_size, num_gaps, min_val=0):
    max_val = num_gaps - grp_size * min_val + min_val
    return [] if max_val <= 0 else looper(mk_arr(grp_size, lambda: min_val), max_val)[1]
 
def test(*blocks):
    cells = sum(blocks)
    grp_size = len(blocks) + 1
    num_gaps = cells - sum(blocks)
 
    # Filter functions
    sum_to_trg = sum_to(num_gaps)
    no_inner_zero = compose(inv, has_inner(0))
 
    # Output formatting
    combine = zip_arr([*blocks])
    choices = to_bin(choose(lambda _: 0, lambda _: 1))
    output = compose(print, arr_join('', ''), choices, combine)
 
    print(f'\n{cells} cells. Blocks: {blocks}')
    for perm in filter(no_inner_zero, filter(sum_to_trg, gap_perms(grp_size, num_gaps))):
        output(perm)
 
test(2, 1)
test()
test(5)
test(1, 1, 1)
test(8)
test(2, 3, 2, 3)
test(4, 3)
test(2, 3)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Averages/Arithmetic_mean,Averages/Arithmetic mean,"Task[edit]
Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"from math import fsum
def average(x):
    return fsum(x)/float(len(x)) if x else 0
print (average([0,0,3,1,4,1,5,9,0,0]))
print (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Averages/Pythagorean_means,Averages/Pythagorean means,"Task[edit]
Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that 



A
(

x

1


,
…
,

x

n


)
≥
G
(

x

1


,
…
,

x

n


)
≥
H
(

x

1


,
…
,

x

n


)


{\displaystyle A(x_{1},\ldots ,x_{n})\geq G(x_{1},\ldots ,x_{n})\geq H(x_{1},\ldots ,x_{n})}

 for this set of positive integers.

 The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:
 



A
(

x

1


,
…
,

x

n


)
=




x

1


+
⋯
+

x

n



n




{\displaystyle A(x_{1},\ldots ,x_{n})={\frac {x_{1}+\cdots +x_{n}}{n}}}


 The geometric mean is the 



n


{\displaystyle n}

th root of the product of the list:
 



G
(

x

1


,
…
,

x

n


)
=




x

1


⋯

x

n




n





{\displaystyle G(x_{1},\ldots ,x_{n})={\sqrt[{n}]{x_{1}\cdots x_{n}}}}


 The harmonic mean is 



n


{\displaystyle n}

 divided by the sum of the reciprocal of each item in the list:
 



H
(

x

1


,
…
,

x

n


)
=


n



1

x

1




+
⋯
+


1

x

n









{\displaystyle H(x_{1},\ldots ,x_{n})={\frac {n}{{\frac {1}{x_{1}}}+\cdots +{\frac {1}{x_{n}}}}}}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"from functools import reduce
from operator import add, mul
from math import pow
 
# arithmetic_mean :: [Number] -> Number
def arithmetic_mean(ns):
    return (
        reduce( # sum
            lambda sum, n: (sum + n),
            ns,
            0
        ) / len(ns)
    )
 
# geometric_mean :: [Number] -> Number
def geometric_mean(ns):
    return pow(
        reduce( # product
            lambda product, n: (product * n),
            ns,
            1
        ),
        1 / len(ns)
    )
 
# harmonic_mean :: [Number] -> Number
def harmonic_mean(ns):
    return (
        len(ns) / reduce( # sum of inverses
            lambda invSum, n: (invSum + (1 / n)),
            ns,
            0
        )
    )
 
values = list(map(
    lambda f: f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]),
    [arithmetic_mean, geometric_mean, harmonic_mean]
))
mean = {
    ""Arithmetic"": values[0], # arithmetic
    ""Geometric"": values[1], # geometric
    ""Harmonic"": values[2] # harmonic
}
 
print(
    ""values: {0}\ntest: is A >= G >= H ? {1}"".format(
        mean,
        mean[""Arithmetic""] >= mean[""Geometric""] and
        mean[""Geometric""] >= mean[""Harmonic""]
    )
)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Python,"from turtle import *
from math import *
color(""blue"")
down()
for i in range(200):
    t = i / 20 * pi
    x = (1 + 5 * t) * cos(t)
    y = (1 + 5 * t) * sin(t)
    goto(x, y)
up()
done()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Recaman%27s_sequence,Recaman's sequence,"The Recamán's sequence generates Natural numbers.

Starting from a(0)=0, the n'th term a(n), where n>0, is the previous term minus n i.e a(n) = a(n-1) - n but only if this is both positive and has not been previousely generated.


If the conditions don't hold then a(n) = a(n-1) + n.



Task

 Generate and show here the first 15 members of the sequence.
 Find and show here, the first duplicated number in the sequence.
 Optionally: Find and show here, how many terms of the sequence are needed until all the integers 0..1000, inclusive, are generated.


References

 A005132, The On-Line Encyclopedia of Integer Sequences.
 The Slightly Spooky Recamán Sequence, Numberphile video.
 Recamán's sequence, on Wikipedia.

",Python,"// Version 1.2.60

fun main(args: Array<String>) {
    val a = mutableListOf(0)
    val used = mutableSetOf(0)
    val used1000 = mutableSetOf(0)
    var foundDup = false
    var n = 1
    while (n <= 15 ||!foundDup || used1000.size < 1001) {
        var next = a[n - 1] - n
        if (next < 1 || next in used) next += 2 * n
        val alreadyUsed = next in used
        a.add(next)
        if (!alreadyUsed) {
            used.add(next)
            if (next in 0..1000) used1000.add(next)
        }
        if (n == 14) {
            println(""The first 15 terms of the Recaman's sequence are: $a"")
        }
        if (!foundDup && alreadyUsed) {
            println(""The first duplicated term is a[$n] = $next"")
            foundDup = true
        }
        if (used1000.size == 1001) {
            println(""Terms up to a[$n] are needed to generate 0 to 1000"")
        }
        n++
    }
}",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds,Sorting algorithms/Cocktail sort with shifting bounds,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   cocktail sort   is an improvement on the   Bubble Sort.



A cocktail sort is also known as:

   cocktail shaker sort
   happy hour sort
   bidirectional bubble sort
   a bubble sort variation
   a selection sort variation
   ripple sort
   shuffle sort
   shuttle sort


The improvement is basically that values ""bubble""   (migrate)   both directions through the
array,   because on each iteration the cocktail sort   bubble sorts   once
forwards and once backwards.

After   ii   passes,   the first   ii   and the
last   ii   elements in the array are in their correct
positions,   and don't have to be checked (again).

By shortening the part of the array that is sorted each time,   the number of
comparisons can be halved.



Pseudocode for the    2nd    algorithm   (from
Wikipedia)   with an added comment and changed indentations:

function A = cocktailShakerSort(A)
% `beginIdx` and `endIdx` marks the first and last index to check.
beginIdx = 1;
endIdx = length(A) - 1;
 
    while beginIdx <= endIdx
    newBeginIdx = endIdx;
    newEndIdx = beginIdx;
        for ii = beginIdx:endIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newEndIdx = ii;
            end
        end
 
    % decreases `endIdx` because the elements after `newEndIdx` are in correct order
    endIdx = newEndIdx - 1;
 
    % (FOR  (below)  decrements the  II  index by -1.
 
        for ii = endIdx:-1:beginIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newBeginIdx = ii;
            end
        end
 
    % increases `beginIdx` because the elements before `newBeginIdx` are in correct order.
    beginIdx = newBeginIdx + 1;
    end
end
%   indicates a comment,   and   deal   indicates a   swap.



Task

Implement a   cocktail sort   and optionally show the sorted output here on this page.

See the   discussion   page for some timing comparisons.



Related task

   cocktail sort

",Python,"import java.util.*;

def cocktailSort(array):
    begin = 0
    end = len(array)
    if end == 0:
        return
    end -= 1
    while begin < end:
        new_begin = end
        new_end = begin
        for i in range(begin, end):
            if array[i] > array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                new_end = i
        end = new_end
        for i in range(end, begin, -1):
            if array[i - 1] > array[i]:
                array[i], array[i - 1] = array[i - 1], array[i]
                new_begin = i
        begin = new_begin

if __name__ == '__main__':
    array = [5, 1, -6, 12, 3, 13, 2, 4, 0, 15]
    print(""before: {}"".format(array))
    cocktailSort(array)
    print(""after: {}"".format(array))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body,Loops/Increment loop index within loop body,"Sometimes, one may need   (or want)   a loop which
its   iterator   (the index
variable)   is modified within the

loop body    in addition to the normal incrementation by the   (do)   loop structure index.



Goal

Demonstrate the best way to accomplish this.



Task

Write a loop which:

   starts the index (variable) at   42
   (at iteration time)   increments the index by unity
   if the index is prime:
   displays the count of primes found (so far) and the prime   (to the terminal)
   increments the index such that the new index is now the (old) index plus that prime
   terminates the loop when   42   primes are shown


Extra credit:   because of the primes get rather large, use commas
within the displayed primes to ease comprehension.



Show all output here.



Note

Not all programming languages allow the modification of a
loop's index.   If that is the case, then use whatever method that
is appropriate or idiomatic for that language.   Please add a note
if the loop's index isn't modifiable.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"def isPrime(n):
    for x in 2, 3:
        if not n % x:
            return n == x
    d = 5
    while d * d <= n:
        for x in 2, 4:
            if not n % d:
                return False
            d += x
    return True
 
i = 42
n = 0
while n < 42:
    if isPrime(i):
        n += 1
        print('n = {:2} {:20,}'.format(n, i))
        i += i - 1
    i += 1",Human_written,Python_from_Java
http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",Python,"import sys
with open(sys.argv[0]) as quine:
    code = raw_input(""Enter source code: "")
    if code == quine.read():
        print(""Accept"")
    else:
        print(""Reject"")",Human_written,Python_from_C
http://rosettacode.org/wiki/Palindromic_gapful_numbers,Palindromic gapful numbers,"Palindromic gapful numbers

You are encouraged to solve this task according to the task description, using any language you may know.
Numbers   (positive integers expressed in base ten)   that are (evenly) divisible by the number formed by the
first and last digit are known as   gapful numbers.


Evenly divisible   means divisible with   no   remainder.



All   one─   and two─digit   numbers have this property and are trivially excluded.   Only
numbers    ≥  100   will be considered for this Rosetta Code task.



Example

1037   is a   gapful   number because it is evenly divisible by the
number   17   which is formed by the first and last decimal digits
of    1037. 



A palindromic number is   (for this task, a positive integer expressed in base ten),   when the number is
reversed,   is the same as the original number.



Task

   Show   (nine sets)   the first   20   palindromic gapful numbers that   end   with:
   the digit   1
   the digit   2
   the digit   3
   the digit   4
   the digit   5
   the digit   6
   the digit   7
   the digit   8
   the digit   9
   Show   (nine sets, like above)   of palindromic gapful numbers:
   the last   15   palindromic gapful numbers   (out of      100)
   the last   10   palindromic gapful numbers   (out of   1,000)       {optional}


For other ways of expressing the (above) requirements, see the   discussion   page.



Note

All palindromic gapful numbers are divisible by eleven.



Related tasks

   palindrome detection.
   gapful numbers.


Also see

   The OEIS entry:   A108343 gapful numbers.

",Python,"from itertools import count
from pprint import pformat
import re
import heapq
 
 
def pal_part_gen(odd=True):
    for i in count(1):
        fwd = str(i)
        rev = fwd[::-1][1:] if odd else fwd[::-1]
        yield int(fwd + rev)
 
def pal_ordered_gen():
    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))
 
def is_gapful(x):
    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)
 
if __name__ == '__main__':
    start = 100
    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:
        print(f""\nLast {last} of the first {mx} binned-by-last digit "" 
              f""gapful numbers >= {start}"")
        bin = {i: [] for i in range(1, 10)}
        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))
        while any(len(val) < mx for val in bin.values()):
            g = next(gen)
            val = bin[g % 10]
            if len(val) < mx:
                val.append(g)
        b = {k:v[-last:] for k, v in bin.items()}
        txt = pformat(b, width=220)
        print('', re.sub(r""[{},\[\]]"", '', txt))",Human_written,Python_from_C
http://rosettacode.org/wiki/Gaussian_elimination,Gaussian elimination,"Task

Solve   Ax=b   using Gaussian elimination then backwards substitution.

A   being an   n by n   matrix.

Also,   x and b   are   n by 1   vectors.

To improve accuracy, please use partial pivoting and scaling.



See also

   the Wikipedia entry:   Gaussian elimination

",Python,"# The 'gauss' function takes two matrices, 'a' and 'b', with 'a' square, and it return the determinant of 'a' and a matrix 'x' such that a*x = b.
# If 'b' is the identity, then 'x' is the inverse of 'a'.
 
import copy
from fractions import Fraction
 
def gauss(a, b):
    a = copy.deepcopy(a)
    b = copy.deepcopy(b)
    n = len(a)
    p = len(b[0])
    det = 1
    for i in range(n - 1):
        k = i
        for j in range(i + 1, n):
            if abs(a[j][i]) > abs(a[k][i]):
                k = j
        if k != i:
            a[i], a[k] = a[k], a[i]
            b[i], b[k] = b[k], b[i]
            det = -det
 
        for j in range(i + 1, n):
            t = a[j][i]/a[i][i]
            for k in range(i + 1, n):
                a[j][k] -= t*a[i][k]
            for k in range(p):
                b[j][k] -= t*b[i][k]
 
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            t = a[i][j]
            for k in range(p):
                b[i][k] -= t*b[j][k]
        t = 1/a[i][i]
        det *= a[i][i]
        for j in range(p):
            b[i][j] *= t
    return det, b
 
def zeromat(p, q):
    return [[0]*q for i in range(p)]
 
def matmul(a, b):
    n, p = len(a), len(a[0])
    p1, q = len(b), len(b[0])
    if p != p1:
        raise ValueError(""Incompatible dimensions"")
    c = zeromat(n, q)
    for i in range(n):
        for j in range(q):
                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))
    return c
 
 
def mapmat(f, a):
    return [list(map(f, v)) for v in a]
 
def ratmat(a):
    return mapmat(Fraction, a)
 
# As an example, compute the determinant and inverse of 3x3 magic square
 
a = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]
b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
det, c = gauss(a, b)
 
det
-360.0
 
c
[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],
[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],
[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]
 
# Check product
matmul(a, c)
[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],
[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]
 
# Same with fractions, so the result is exact
 
det, c = gauss(ratmat(a), ratmat(b))
 
det
Fraction(-360, 1)
 
c
[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],
[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],
[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]
 
matmul(a, c)
[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],
[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],
[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Burrows%E2%80%93Wheeler_transform,Burrows–Wheeler transform,"

 This page uses content from Wikipedia. The original article was at Burrows–Wheeler_transform. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters.

This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding.

More importantly, the transformation is reversible, without needing to store any additional data.

The BWT is thus a ""free"" method of improving the efficiency of text compression algorithms, costing only some extra computation.



Source: Burrows–Wheeler transform
",Python,"import string
 
STX = chr(0x02)
ETX = chr(0x03)
 
def rotate(a):
    t = a[-1]
    for i in range(len(a) - 1, 0, -1):
        a[i] = a[i - 1]
    a[0] = t
 
def compare(s1, s2):
    for i in range(min(len(s1), len(s2))):
        if s1[i] < s2[i]:
            return -1
        if s2[i] < s1[i]:
            return 1
    if len(s1) < len(s2):
        return -1
    if len(s2) < len(s1):
        return 1
    return 0
 
def bwt(s):
    if any(a in (STX, ETX) for a in s):
        raise ValueError(""Input can't contain STX or ETX"")
    ss = STX + s + ETX
    table = [ss]
    for i in range(len(ss) - 1):
        rotate(ss)
        table.append(ss)
    table.sort(compare)
    return ''.join(a[-1] for a in table)
 
def ibwt(r):
    len_r = len(r)
    table = [''] * len_r
    for i in range(len_r):
        for j in range(len_r):
            table[j] = r[j] + table[j]
        table.sort(compare)
    for row in table:
        if row[-1] == ETX:
            return row[1:-1]
    return ''
 
def make_printable(s):
    return s.replace(STX, '^').replace(ETX, '|')
 
tests = [
    ""banana"",
    ""appellee"",
    ""dogwood"",
    ""TO BE OR NOT TO BE OR WANT TO BE OR NOT?"",
    ""SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES"",
    STX + ""ABC"" + ETX
]
 
for test in tests:
    print(make_printable(test))
    print("" --> "", end='')
    try:
        t = bwt(test)
        print(make_printable(t))
    except Exception as e:
        print(""ERROR: {0}"".format(e))
    r = ibwt(t)
    print("" --> {0}"".format(r))
    print()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",Python,">>> float('infinity')
inf",Human_written,Python_from_C++
http://rosettacode.org/wiki/Nim_game,Nim game,"Nim game

You are encouraged to solve this task according to the task description, using any language you may know.
Nim is a simple game where the second player ─── if they know the trick ─── will always win.



The game has only 3 rules:

   start with   12   tokens
   each player takes   1,  2,  or  3   tokens in turn
  the player who takes the last token wins.


To win every time,   the second player simply takes 4 minus the number the first player took.   So if the first player takes 1,   the second takes 3 ─── if the first player takes 2,   the second should take 2 ─── and if the first player takes 3,   the second player will take 1.



Task

Design a simple Nim game where the human player goes first, and the computer always wins. The game should enforce the rules.



",Python,"print(""Py Nim\n"")
 
def getTokens(curTokens):
	global tokens
 
	print(""How many tokens would you like to take? "", end='')
	take = int(input())
 
	if (take < 1 or take > 3):
		print(""Number must be between 1 and 3.\n"")
		getTokens(curTokens)
		return
 
	tokens = curTokens - take
	print(f'You take {take} tokens.')
	print(f'{tokens} tokens remaining.\n')
 
def compTurn(curTokens):
	global tokens
 
	take = curTokens % 4
	tokens = curTokens - take
	print (f'Computer takes {take} tokens.')
	print (f'{tokens} tokens remaining.\n')
 
 
tokens = 12
while (tokens > 0):
	getTokens(tokens)
	compTurn(tokens)
 
print(""Computer wins!"")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm,Trabb Pardo–Knuth algorithm,"The TPK algorithm is an early example of a programming chrestomathy.
It was used in Donald Knuth and Luis Trabb Pardo's Stanford tech report The Early Development of Programming Languages.
The report traces the early history of work in developing computer languages in the 1940s and 1950s, giving several translations of the algorithm.

From the wikipedia entry:

ask for 11 numbers to be read into a sequence S
reverse sequence S
for each item in sequence S
    result := call a function to do an operation
    if result overflows
        alert user
    else
        print result

The task is to implement the algorithm:

 Use the function:     



f
(
x
)
=

|

x


|


0.5


+
5

x

3




{\displaystyle f(x)=|x|^{0.5}+5x^{3}}


 The overflow condition is an answer of greater than 400.
 The 'user alert' should not stop processing of other items of the sequence.
 Print a prompt before accepting eleven, textual, numeric inputs.
 You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
 The sequence    S    may be 'implied' and so not shown explicitly.
 Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).

",Python,"def f(x):
    return x.abs() ** 0.5 + 5 * x ** 3
 
print(""Please enter 11 numbers:"")
nums = [float(input()) for _ in range(11)]
 
for n in reversed(nums):
    print(""f({0}) = {1}"".format(n, ""Overflow!"" if f(n) > 400 else f(n)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Padovan_n-step_number_sequences,Padovan n-step number sequences,"As the Fibonacci sequence expands to the Fibonacci n-step number sequences; We similarly expand the Padovan sequence to form these Padovan n-step number sequences.

The Fibonacci-like sequences can be defined like this:

   For n == 2:
       start:      1, 1
       Recurrence: R(n, x) = R(n, x-1) + R(n, x-2); for n == 2
   For n == N:
       start:      First N terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-1) + R(N, x-2) + ... R(N, x-N))

For this task we similarly define terms of the first 2..n-step Padovan sequences as:

   For n == 2:
       start:      1, 1, 1
       Recurrence: R(n, x) = R(n, x-2) + R(n, x-3); for n == 2
   For n == N:
       start:      First N + 1 terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-2) + R(N, x-3) + ... R(N, x-N-1))

The initial values of the sequences are:


 Padovan 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Values 
 OEIS Entry


 2 
 1,1,1,2,2,3,4,5,7,9,12,16,21,28,37, ... 
 A134816: 'Padovan's spiral numbers'


 3 
 1,1,1,2,3,4,6,9,13,19,28,41,60,88,129, ... 
 A000930: 'Narayana's cows sequence'


 4 
 1,1,1,2,3,5,7,11,17,26,40,61,94,144,221, ... 
 A072465: 'A Fibonacci-like model in which each pair of rabbits dies after the birth of their 4th litter'


 5 
 1,1,1,2,3,5,8,12,19,30,47,74,116,182,286, ... 
 A060961: 'Number of compositions (ordered partitions) of n into 1's, 3's and 5's'


 6 
 1,1,1,2,3,5,8,13,20,32,51,81,129,205,326, ... 
 <not found>


 7 
 1,1,1,2,3,5,8,13,21,33,53,85,136,218,349, ... 
 A117760: 'Expansion of 1/(1 - x - x^3 - x^5 - x^7)'


 8 
 1,1,1,2,3,5,8,13,21,34,54,87,140,225,362, ... 
 <not found>




Task

 Write a function to generate the first 



t


{\displaystyle t}

 terms, of the first 2..max_n Padovan 



n


{\displaystyle n}

-step number sequences as defined above.
 Use this to print and show here at least the first t=15 values of the first 2..8 



n


{\displaystyle n}

-step sequences.
 (The OEIS column in the table above should be omitted).

",Python,"def pad_like(max_n=8, t=15):
    """"""
    First t terms of the first 2..max_n-step Padovan sequences.
    """"""
    start = [[], [1, 1, 1]]     # for n=0 and n=1 (hidden).
    for n in range(2, max_n+1):
        this = start[n-1][:n+1]     # Initialise from last
        while len(this) < t:
            this.append(sum(this[i] for i in range(-2, -n - 2, -1)))
        start.append(this)
    return start[2:]
 
def pr(p):
    print('''
:::: {| style=""text-align: left;"" border=""4"" cellpadding=""2"" cellspacing=""2""
|+ Padovan <math>n</math>-step sequences
|- style=""background-color: rgb(255, 204, 255);""
! <math>n</math> !! Values
|-
          '''.strip())
    for n, seq in enumerate(p, 2):
        print(f""| {n:2} || {str(seq)[1:-1].replace(' ', '')+', ...'}\n|-"")
    print('|}')
 
if __name__ == '__main__':
    p = pad_like()
    pr(p)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Fivenum,Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",Python,"# version 1.2.21
 
def median(x, start, endInclusive):
    size = endInclusive - start + 1
    assert size > 0, ""Array slice cannot be empty""
    m = start + size // 2
    return (x[m] if size % 2 == 1 else (x[m - 1] + x[m]) / 2.0)
 
def fivenum(x):
    assert not any(map(math.isnan, x)), ""Unable to deal with arrays containing NaN""
    result = [0.0] * 5
    x.sort()
    result[0] = x[0]
    result[2] = median(x, 0, len(x) - 1)
    result[4] = x[-1]
    m = len(x) // 2
    lowerEnd = m if len(x) % 2 == 1 else m - 1
    result[1] = median(x, 0, lowerEnd)
    result[3] = median(x, m, len(x) - 1)
    return result
 
def main():
    xl = [
        [15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0],
        [36.0, 40.0, 7.0, 39.0, 41.0, 15.0],
        [
             0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,
            -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,
            -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,
             0.75775634,  0.32566578
        ]
    ]
    for x in xl:
        print(fivenum(x))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",Python,"import re
 
tp = ""string$""
t1 = ""this is a matching string""
t2 = ""this is not a matching string!""
ss = ""istyfied""
 
print ""'%s' %smatched with '%s'"" % (t1, """" if re.search(tp, t1) else ""did not "", tp)
print ""'%s' %smatched with '%s'"" % (t2, """" if re.search(tp, t2) else ""did not "", tp)
 
# change ""a[a-z]+"" into ""istifyed""?
if re.search(""a[a-z]+"", t1):
    ns = re.sub(""a[a-z]+"", ss, t1)
    print ""mod string: '%s'"" % ns
else:
    print ""the string '%s' is the same: no matching!"" % t1",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",Python,"digits = float('digits')
print(digits)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Loops/Nested,Loops/Nested,"Show a nested loop which searches a two-dimensional array filled with random numbers uniformly distributed over 



[
1
,
…
,
20
]


{\displaystyle [1,\ldots ,20]}

.

The loops iterate rows and columns of the array printing the elements until the value 



20


{\displaystyle 20}

 is met.

Specifically, this task also shows how to break out of nested loops.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"# a ""random"" 2-D array 
a = [[2, 12, 10, 4], [18, 11, 9, 3], [14, 15, 7, 17], [6, 19, 8, 13], [1, 20, 16, 5]]

for i in range(len(a)):
    print(""row "" + str(i))
    for j in range(len(a[i])):
        print("" "" + str(a[i][j]))
        if a[i][j] == 20:
            break
print(""done"")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sum_of_elements_below_main_diagonal_of_matrix,Sum of elements below main diagonal of matrix,"Task

Find and display the sum of elements that are below the main diagonal of a matrix.

The matrix should be a square matrix.



 ───   Matrix to be used:   ───


     [[1,3,7,8,10],
      [2,4,16,14,4],
      [3,1,9,18,11],
      [12,14,17,18,20],
      [7,1,3,9,5]] 


",Python,"import sys
 
class Matrix:
	def __init__(self,rows,cols):
		self.rows = rows
		self.cols = cols
		self.dataSet = [[0 for i in range(cols)] for j in range(rows)]
 
def readMatrix(dataFile):
	fp = open(dataFile,""r"")
	rosetta = Matrix(0,0)
	i = 0
	j = 0
 
	rosetta.rows,rosetta.cols = map(int,fp.readline().split())
 
	for line in fp:
		rosetta.dataSet[i] = map(int,line.split())
		i += 1
 
	fp.close()
	return rosetta
 
def printMatrix(rosetta):
	for i in range(rosetta.rows):
		print ""\n""
		for j in range(rosetta.cols):
			print ""%3d"" % rosetta.dataSet[i][j],
 
def findSum(rosetta):
	sum = 0
	for i in range(1,rosetta.rows):
		for j in range(i):
			sum += rosetta.dataSet[i][j]
 
	return sum
 
if __name__ == ""__main__"":
	if len(sys.argv)!= 2:
		print ""Usage : %s <filename>"" % sys.argv[0]
		sys.exit(1)
 
	data = readMatrix(sys.argv[1])
 
	print ""\n\nMatrix is : \n\n""
	printMatrix(data)
 
	print ""\n\nSum below main diagonal : %d"" % findSum(data)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Inheritance/Multiple,Inheritance/Multiple,"Multiple inheritance allows to specify that one  class is a subclass of several other classes.

Some languages allow multiple inheritance for arbitrary classes,   others restrict it to interfaces,   some don't allow it at all.



Task

Write two classes (or interfaces) Camera and MobilePhone,   then write a class CameraPhone which is both a Camera and a MobilePhone.

There is no need to implement any functions for those classes.



",Python,"class Camera:
  pass #functions go here...",Human_written,Python_from_Java
http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",Python,"def calcPi():
    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3
    while True:
        if 4*q+r-t < n*t:
            yield n
            nr = 10*(r-n*t)
            n  = ((10*(3*q+r))//t)-10*n
            q  *= 10
            r  = nr
        else:
            nr = (2*q+r)*l
            nn = (q*(7*k)+2+(r*l))//(t*l)
            q  *= k
            t  *= l
            l  += 2
            k += 1
            n  = nn
            r  = nr
 
import sys
pi_digits = calcPi()
i = 0
for d in pi_digits:
    sys.stdout.write(str(d))
    i += 1
    if i == 40: print(""""); i = 0",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Python,"# version 1.1.0
 
import java.awt.*
import javax.swing.*
 
class ArchimedeanSpiral : JPanel() {
    init {
        preferredSize = Dimension(640, 640)
        background = Color.white
    }
 
    private fun drawGrid(g: Graphics2D) {
        g.color = Color(0xEEEEEE)
        g.stroke = BasicStroke(2f)
        val angle = Math.toRadians(45.0)
        val w = width
        val center = w / 2
        val margin = 10
        val numRings = 8
        val spacing = (w - 2 * margin) / (numRings * 2)
 
        for (i in 0 until numRings) {
            val pos = margin + i * spacing
            val size = w - (2 * margin + i * 2 * spacing)
            g.drawOval(pos, pos, size, size)
            val ia = i * angle
            val x2 = center + (Math.cos(ia) * (w - 2 * margin) / 2).toInt()
            val y2 = center - (Math.sin(ia) * (w - 2 * margin) / 2).toInt()
            g.drawLine(center, center, x2, y2)
        }
    }
 
    private fun drawSpiral(g: Graphics2D) {
        g.stroke = BasicStroke(2f)
        g.color = Color.magenta
        val degrees = Math.toRadians(0.1)
        val center = width / 2
        val end = 360 * 2 * 10 * degrees
        val a = 0.0
        val b = 20.0
        val c = 1.0
        var theta = 0.0
        while (theta < end) {
            val r = a + b * Math.pow(theta, 1.0 / c)
            val x = r * Math.cos(theta)
            val y = r * Math.sin(theta)
            plot(g, (center + x).toInt(), (center - y).toInt())
            theta += degrees
        }
    }
 
    private fun plot(g: Graphics2D, x: Int, y: Int) {
        g.drawOval(x, y, 1, 1)
    }
 
    override fun paintComponent(gg: Graphics) {
        super.paintComponent(gg)
        val g = gg as Graphics2D
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)
        drawGrid(g)
        drawSpiral(g)
    }
}
 
fun main(args: Array<String>) {
    SwingUtilities.invokeLater {
        val f = JFrame()
        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE
        f.title = ""Archimedean Spiral""
        f.isResizable = false
        f.add(ArchimedeanSpiral(), BorderLayout.CENTER)
        f.pack()
        f.setLocationRelativeTo(null)
        f.isVisible = true
    }
}",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Ackermann_function,Ackermann function,"The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.



The Ackermann function is usually defined as follows:







A
(
m
,
n
)
=


{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.








{\displaystyle A(m,n)={\begin{cases}n+1&{\mbox{if }}m=0\\A(m-1,1)&{\mbox{if }}m>0{\mbox{ and }}n=0\\A(m-1,A(m,n-1))&{\mbox{if }}m>0{\mbox{ and }}n>0.\end{cases}}}






Its arguments are never negative and it always terminates.



Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m,n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.



See also

 Conway chained arrow notation for the Ackermann function.

",Python,"def ack1(M, N):
   return (N + 1) if M == 0 else (
      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file,Bitmap/Write a PPM file,"Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered).

(Read the definition of PPM file on Wikipedia.)



",Python,"# String masquerading as ppm file (version P3)
import io
ppmfileout = io.StringIO('')
 
def writeppmp3(self, f):
    self.writeppm(f, ppmformat='P3')
 
def writeppm(self, f, ppmformat='P6'):
    assert ppmformat in ['P3', 'P6'], 'Format wrong'
    magic = ppmformat + '\n'
    comment = '# generated from Bitmap.writeppm\n'
    maxval = max(max(max(bit) for bit in row) for row in self.map)
    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'
    if ppmformat == 'P6':
        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))
        maxval = 255
    else:
        fwrite = f.write
        numsize=len(str(maxval))
    fwrite(magic)
    fwrite(comment)
    fwrite('%i %i\n%i\n' % (self.width, self.height, maxval))
    for h in range(self.height-1, -1, -1):
        for w in range(self.width):
            r, g, b = self.get(w, h)
            if ppmformat == 'P3':
                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))
            else:
                fwrite('%c%c%c' % (r, g, b))
        if ppmformat == 'P3':
            fwrite('\n')
 
Bitmap.writeppmp3 = writeppmp3
Bitmap.writeppm = writeppm
 
# Draw something simple
bitmap = Bitmap(4, 4, black)
bitmap.fillrect(1, 0, 1, 2, white)
bitmap.set(3, 3, Colour(127, 0, 63))
# Write to the open 'file' handle
bitmap.writeppmp3(ppmfileout)
# Whats in the generated PPM file
print(ppmfileout.getvalue())
 
'''
The print statement above produces the following output :
 
P3
# generated from Bitmap.writeppmp3
4 4
255
     0   0   0     0   0   0     0   0   0   127   0  63
     0   0   0     0   0   0     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
     0   0   0   255 255 255     0   0   0     0   0   0
 
'''
 
# Write a P6 file
ppmfileout = open('tmp.ppm', 'wb')
bitmap.writeppm(ppmfileout)
ppmfileout.close()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Terminal_control/Coloured_text,Terminal control/Coloured text,"Task

Display a word in various colours on the terminal.

The system palette, or colours such as Red, Green, Blue, Magenta, Cyan, and Yellow can be used.



Optionally demonstrate:

 How the system should determine if the terminal supports colour
 Setting of the background colour
 How to cause blinking or flashing (if supported by the terminal)

",Python,"from colorama import init, Fore, Back, Style
init(autoreset=True)
 
print Fore.RED + ""FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic""
print Back.BLUE + Fore.YELLOW + ""What a cute console!""
print ""This is an %simportant%s word"" % (Style.BRIGHT, Style.NORMAL)
print Fore.YELLOW  + ""Rosetta Code!""
print Fore.CYAN    + ""Rosetta Code!""
print Fore.GREEN   + ""Rosetta Code!""
print Fore.MAGENTA + ""Rosetta Code!""
print Back.YELLOW + Fore.BLUE + Style.BRIGHT + "" "" * 40 + "" == Good Bye!""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Fibonacci_sequence,Fibonacci sequence,"The Fibonacci sequence is a sequence    Fn    of natural numbers defined recursively:

      F0 = 0 
      F1 = 1 
      Fn = Fn-1 + Fn-2, if n>1 



Task

Write a function to generate the    nth    Fibonacci number.

Solutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).

The sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:

      Fn = Fn+2 - Fn+1, if n<0   

support for negative      n      in the solution is optional.



Related tasks

   Fibonacci n-step number sequences‎
   Leonardo numbers


References

   Wikipedia, Fibonacci number
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,"from math import *
 
def analytic_fibonacci(n):
  sqrt_5 = sqrt(5);
  p = (1 + sqrt_5) / 2;
  q = 1/p;
  return int( (p**n + q**n) / sqrt_5 + 0.5 )
 
for i in range(1,31):
  print analytic_fibonacci(i),",Human_written,Python_from_C++
http://rosettacode.org/wiki/Hash_join,Hash join,"An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]
Implement the ""hash join"" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance
The ""hash join"" algorithm consists of two steps:

 Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

 The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
 Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.
 Join phase: Scan the other table, and find matching rows by looking in the multimap created before.


In pseudo-code, the algorithm could be expressed as follows:

let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

Test-case


 Input

 Output





 A =




 Age 
 Name


 27 
 Jonah


 18 
 Alan


 28 
 Glory


 18 
 Popeye


 28 
 Alan




 B =




 Character 
 Nemesis


 Jonah 
 Whales


 Jonah 
 Spiders


 Alan 
 Ghosts


 Alan 
 Zombies


 Glory 
 Buffy



 jA =

 Name (i.e. column 1)

 jB =

 Character (i.e. column 0)





 A.Age 
 A.Name 
 B.Character 
 B.Nemesis


 27 
 Jonah 
 Jonah 
 Whales


 27 
 Jonah 
 Jonah 
 Spiders


 18 
 Alan 
 Alan 
 Ghosts


 18 
 Alan 
 Alan 
 Zombies


 28 
 Glory 
 Glory 
 Buffy


 28 
 Alan 
 Alan 
 Ghosts


 28 
 Alan 
 Alan 
 Zombies


The order of the rows in the output table is not significant.

If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, ""Jonah""], [""Jonah"", ""Whales""]].



",Python,"from collections import defaultdict
 
def hashJoin(table1, index1, table2, index2):
    h = defaultdict(list)
    # hash phase
    for s in table1:
        h[s[index1]].append(s)
    # join phase
    return [(s, r) for r in table2 for s in h[r[index2]]]
 
table1 = [(27, ""Jonah""),
          (18, ""Alan""),
          (28, ""Glory""),
          (18, ""Popeye""),
          (28, ""Alan"")]
table2 = [(""Jonah"", ""Whales""),
          (""Jonah"", ""Spiders""),
          (""Alan"", ""Ghosts""),
          (""Alan"", ""Zombies""),
          (""Glory"", ""Buffy"")]
 
for row in hashJoin(table1, 1, table2, 0):
    print(row)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Conjugate_transpose,Conjugate transpose,"Suppose that a matrix 



M


{\displaystyle M}

 contains complex numbers. Then the conjugate transpose of 



M


{\displaystyle M}

 is a matrix 




M

H




{\displaystyle M^{H}}

 containing the complex conjugates of the matrix transposition of 



M


{\displaystyle M}

.

 



(

M

H



)

j
i


=



M

i
j


¯




{\displaystyle (M^{H})_{ji}={\overline {M_{ij}}}}




This means that row 



j


{\displaystyle j}

, column 



i


{\displaystyle i}

 of the conjugate transpose equals the

complex conjugate of row 



i


{\displaystyle i}

, column 



j


{\displaystyle j}

 of the original matrix.



In the next list, 



M


{\displaystyle M}

 must also be a square matrix.

 A Hermitian matrix equals its own conjugate transpose: 




M

H


=
M


{\displaystyle M^{H}=M}

.
 A normal matrix is commutative in multiplication with its conjugate transpose: 




M

H


M
=
M

M

H




{\displaystyle M^{H}M=MM^{H}}

.
 A unitary matrix has its inverse equal to its conjugate transpose: 




M

H


=

M

−
1




{\displaystyle M^{H}=M^{-1}}

. 
 This is true iff 




M

H


M
=

I

n




{\displaystyle M^{H}M=I_{n}}

 and iff 



M

M

H


=

I

n




{\displaystyle MM^{H}=I_{n}}

, where 




I

n




{\displaystyle I_{n}}

 is the identity matrix.


Task

Given some matrix of complex numbers, find its conjugate transpose.

Also determine if the matrix is a:

 Hermitian matrix,
 normal matrix, or 
 unitary matrix.


See also

 MathWorld entry: conjugate transpose
 MathWorld entry: Hermitian matrix
 MathWorld entry: normal matrix
 MathWorld entry: unitary matrix

",Python,"from numpy import matrix, array, conjugate, transpose
from numpy.linalg import det
 
# Start with some matrix.
i = 1j
matrix = matrix([[i, 0, 0],
                 [0, i, 0],
                 [0, 0, i]])
 
# Find the conjugate transpose.
conjt = conjugate(transpose(matrix))
print 'conjugate tranpose: ', conjt
 
if matrix.shape[0] == matrix.shape[1]:
  # These predicates appeared in Ruby 1.9.3.
  print 'Hermitian? ', (matrix == conjt).all()
  print'  normal? ', (matrix * conjt == conjt * matrix).all()
  print' unitary? ', (det(matrix) == 1).all()
else:
  # Matrix is not square. These predicates would
  # raise ExceptionForMatrix::ErrDimensionMismatch.
  print 'Hermitian? false'
  print'  normal? false'
  print' unitary? false'",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",Python,">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]
>>> def stoogesort(L, i=0, j=None):
	if j is None:
		j = len(L) - 1
	if L[j] < L[i]:
		L[i], L[j] = L[j], L[i]
	if j - i > 1:
		t = (j - i + 1) // 3
		stoogesort(L, i  , j-t)
		stoogesort(L, i+t, j  )
		stoogesort(L, i  , j-t)
	return L
 
>>> stoogesort(data)
[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]",Human_written,Python_from_Go
http://rosettacode.org/wiki/Mayan_numerals,Mayan numerals,"Task

Present numbers using the Mayan numbering system   (displaying the Mayan numerals in a cartouche).



Mayan numbers

Normally, Mayan numbers are written vertically   (top─to─bottom)   with the most significant
numeral at the top   (in the sense that decimal numbers are written left─to─right with the most significant
digit at the left).   This task will be using a left─to─right (horizontal) format,   mostly for familiarity and
readability,   and to conserve screen space (when showing the output) on this task page.



Mayan numerals

Mayan numerals   (a base─20 ""digit"" or glyph)   are written in two orientations,   this
task will be using the ""vertical"" format   (as displayed below).   Using the vertical format makes
it much easier to draw/construct the Mayan numerals (glyphs) with simple dots (.)
and hyphen (-);     (however, round bullets (•) and long dashes (─)
make a better presentation on Rosetta Code).



Furthermore, each Mayan numeral   (for this task)   is to be displayed as a
cartouche   (enclosed in a box)   to make it easier to parse (read);   the box may be
drawn with any suitable (ASCII or Unicode) characters that are presentable/visible in all web browsers.



Mayan numerals added to Unicode
Mayan numerals (glyphs) were added to the Unicode Standard in June of 2018   (this corresponds with
version 11.0).   But since most web browsers don't support them at this time,   this Rosetta Code
task will be constructing the glyphs with ""simple"" characters and/or ASCII art.



The ""zero"" glyph

The Mayan numbering system has the concept of   zero,   and should be shown by a glyph that represents
an upside─down (sea) shell,   or an egg.   The Greek letter theta   (Θ)   can be
used   (which more─or─less, looks like an
egg).   A   commercial at   symbol   (@)   could make a poor substitute.



Mayan glyphs (constructed)

The Mayan numbering system is
a   [vigesimal (base 20)]   positional numeral system.



The Mayan numerals   (and some random numbers)   shown in the   vertical   format would be shown as

      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║ ∙  ║                            ║    ║    ║
 1──► ║    ║                11──► ║────║                      21──► ║    ║    ║
      ║ ∙  ║                      ║────║                            ║ ∙  ║ ∙  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║ ∙∙ ║                            ║    ║    ║
 2──► ║    ║                12──► ║────║                      22──► ║    ║    ║
      ║ ∙∙ ║                      ║────║                            ║ ∙  ║ ∙∙ ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║∙∙∙ ║                            ║    ║    ║
 3──► ║    ║                13──► ║────║                      40──► ║    ║    ║
      ║∙∙∙ ║                      ║────║                            ║ ∙∙ ║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║∙∙∙∙║                            ║    ║    ║
 4──► ║    ║                14──► ║────║                      80──► ║    ║    ║
      ║∙∙∙∙║                      ║────║                            ║∙∙∙∙║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 5──► ║    ║                15──► ║────║                      90──► ║    ║────║
      ║────║                      ║────║                            ║∙∙∙∙║────║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║ ∙  ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 6──► ║ ∙  ║                16──► ║────║                     100──► ║    ║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║ ∙∙ ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 7──► ║ ∙∙ ║                17──► ║────║                     200──► ║────║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║∙∙∙ ║                            ║    ║    ║
      ║    ║                      ║────║                     300──► ║────║    ║
 8──► ║∙∙∙ ║                18──► ║────║                            ║────║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╦════╗
      ║    ║                      ║∙∙∙∙║                            ║    ║    ║    ║
      ║    ║                      ║────║                     400──► ║    ║    ║    ║
 9──► ║∙∙∙∙║                19──► ║────║                            ║    ║    ║    ║
      ║────║                      ║────║                            ║ ∙  ║ Θ  ║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╩════╝
      ╔════╗                      ╔════╦════╗                       ╔════╦════╦════╦════╗
      ║    ║                      ║    ║    ║                       ║    ║    ║    ║    ║
      ║    ║                      ║    ║    ║                       ║    ║    ║    ║    ║
10──► ║────║                20──► ║    ║    ║             16,000──► ║    ║    ║    ║    ║
      ║────║                      ║ ∙  ║ Θ  ║                       ║ ∙∙ ║ Θ  ║ Θ  ║ Θ  ║
      ╚════╝                      ╚════╩════╝                       ╚════╩════╩════╩════╝



Note that the Mayan numeral   13   in   horizontal   format would be shown as:

                                  ╔════╗
                                  ║  ││║
                                  ║ ∙││║
                            13──► ║ ∙││║        ◄─── this glyph form won't be used in this Rosetta Code task.
                                  ║ ∙││║
                                  ╚════╝



Other forms of cartouches (boxes) can be used for this task.



Task requirements

   convert the following decimal numbers to Mayan numbers:
       4,005
       8,017
   326,205
   886,205
   show a   unique   interesting/pretty/unusual/intriguing/odd/amusing/weird   Mayan number
   show all output here


Related tasks

   Roman numerals/Encode   ─── convert numeric values into Roman numerals
   Roman numerals/Decode   ─── convert Roman numerals into Arabic numbers


See also

   The Wikipedia entry:   [Mayan numerals]

",Python,"import sys
 
numbers = [int(x) for x in sys.argv[1:]]
if len(numbers) == 0:
    print
    print(""usage: %s number..."" % sys.argv[0])
    sys.exit(1)
 
def maya_print(number):
    digits5s1s = [(x // 5, x % 5) for x in map(int, bin(number)[2:])]
    print(('+----' * len(digits5s1s)) + '+')
    for row in range(3, -1, -1):
        for d5s1s in digits5s1s:
            if row < d5s1s[0]:
                print('|----', end='')
            elif row == d5s1s[0]:
                print(""|%s"" % [' @  ', '.  ', '.. ', '... ', '....'][d5s1s[1]], end='')
            else:
                print('|    ', end='')
        print('|')
    print(('+----' * len(digits5s1s)) + '+')
 
for num in numbers:
    print(num)
    maya_print(num)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Soundex,Soundex,"Soundex is an algorithm for creating indices for words based on their pronunciation.



Task

The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling   (from the   soundex   Wikipedia article).

Caution

There is a major issue in many of the implementations concerning the separation of two consonants that have the same soundex code! According to the official Rules [[1]]. So check for instance if Ashcraft is coded to A-261.

 If a vowel (A, E, I, O, U) separates two consonants that have the same soundex code, the consonant to the right of the vowel is coded. Tymczak is coded as T-522 (T, 5 for the M, 2 for the C, Z ignored (see ""Side-by-Side"" rule above), 2 for the K). Since the vowel ""A"" separates the Z and K, the K is coded.
 If ""H"" or ""W"" separate two consonants that have the same soundex code, the consonant to the right of the vowel is not coded. Example: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226.

",Python,"import re
 
def soundex(s):
    code = [0, -1,  1,  2,  3, -1,  1,  2,  0, -1,  2,  2,  4,  5,  5, -1,  1,  2,  6,  2,  3, -1,  1,  0,  2,  0,  2,  0,  0,  0,  0,  0]
    if not s:
        return ''
    out = '0000'
    out = out[:1] + s[0].upper() + out[2:]
    prev = code[ord(out[0]) & 0x1F]
    for c in s[1:]:
        if ord(c) < 0x40 or ord(c) > 0x7F:
            continue
        c = code[ord(c) & 0x1F]
        if c == prev:
            continue
        if c == -1:
            prev = 0
        elif c:
            out = out[:1] + chr(c + ord('0')) + out[2:]
            prev = c
    return out
 
names = [
    [""Ashcraft"",    ""A261""],
    [""Burroughs"",   ""B620""],
    [""Burrows"",     ""B620""],
    [""Ekzampul"",    ""E251""],
    [""Ellery"",      ""E460""],
    [""Euler"",       ""E460""],
    [""Example"",     ""E251""],
    [""Gauss"",       ""G200""],
    [""Ghosh"",       ""G200""],
    [""Gutierrez"",   ""G362""],
    [""Heilbronn"",   ""H416""],
    [""Hilbert"",     ""H416""],
    [""Jackson"",     ""J250""],
    [""Kant"",        ""K530""],
    [""Knuth"",       ""K530""],
    [""Ladd"",        ""L300""],
    [""Lee"",         ""L000""],
    [""Lissajous"",   ""L222""],
    [""Lloyd"",       ""L300""],
    [""Lukasiewicz"", ""L222""],
    [""O'Hara"",      ""O600""],
    [""Pfister"",     ""P236""],
    [""Soundex"",     ""S532""],
    [""Sownteks"",    ""S532""],
    [""Tymczak"",     ""T522""],
    [""VanDeusen"",   ""V532""],
    [""Washington"",  ""W252""],
    [""Wheaton"",     ""W350""]
]
 
for name in names:
    sdx = soundex(name[0])
    print('{0:16} {1:8} {2}'.format(name[0], sdx, 'ok' if sdx == name[1] else 'ERROR'))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Tokenize_a_string_with_escaping,Tokenize a string with escaping,"Task[edit]
Write a function or program that can split a string at each non-escaped occurrence of a separator character.

It should accept three input parameters:

   The string
   The separator character
   The escape character


It should output a list of strings.

Details
Rules for splitting:

 The fields that were separated by the separators, become the elements of the output list.
 Empty fields should be preserved, even at the start and end.


Rules for escaping:

 ""Escaped"" means preceded by an occurrence of the escape character that is not already escaped itself.
 When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).
 Each occurrence of the escape character that was used to escape something, should not become part of the output.


Test case
Demonstrate that your function satisfies the following test-case:



 Input

 Output





 string:

 one^|uno||three^^^^|four^^^|^cuatro|


 separator character:

 |


 escape character:

 ^





 one|uno


 


 three^^


 four^|cuatro


 


(Print the output list in any format you like, as long as it is it easy to see what the fields are.)


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def token_with_escape(a, escape = '^', separator = '|'):
    '''
        Issue  python -m doctest thisfile.py  to run the doctests.
 
        >>> print(token_with_escape('one^|uno||three^^^^|four^^^|^cuatro|'))
        ['one|uno', '', 'three^^', 'four^|cuatro', '']
    '''
    result = []
    token = ''
    state = 0
    for c in a:
        if state == 0:
            if c == escape:
                state = 1
            elif c == separator:
                result.append(token)
                token = ''
            else:
                token += c
        elif state == 1:
            token += c
            state = 0
    result.append(token)
    return result",Human_written,Python_from_Java
http://rosettacode.org/wiki/Spinning_rod_animation/Text,Spinning rod animation/Text,"Task

An animation with the following frames in the following order (if certain characters aren't available or can't be used correctly in the programming language, alternate characters can replace any of these frames) must animate with a delay of 0.25 seconds between each frame, with the previous frame being cleared before the next frame appears: 

   |
   /
   - or ─
   \



A stand-alone version that loops and/or a version that doesn't loop can be made. These examples can also be converted into a system used in game development which is called on a HUD or GUI element requiring it to be called each frame to output the text, and advance the frame when the frame delay has passed. You can also use alternate text such as the . animation ( . | .. | ... | .. | repeat from . ) or the logic can be updated to include a ping/pong style where the frames advance forward, reach the end and then play backwards and when they reach the beginning they start over ( technically, you'd stop one frame prior to prevent the first frame playing twice, or write it another way ).



There are many different ways you can incorporate text animations. Here are a few text ideas - each frame is in quotes. If you can think of any, add them to this page! There are 2 examples for several of these; the first is the base animation with only unique sets of characters. The second consists of the primary set from a - n and doubled, minus the first and last element ie: We only want the center. This way an animation can play forwards, and then in reverse ( ping ponging ) without having to code that feature. For the animations with 3 elements, we only add 1, the center. with 4, it becomes 6. with 10, it becomes 18.



We don't need the second option for some of the animations if they connect smoothly, when animated, back to the first element. ... doesn't connect with . cleanly - there is a large leap. The rotating pipe meets the first perfectly so it isn't necessary, etc..





   Dots - Option A requires ping / pong enabled script. Option B just adds the elements in the center.
   '.', '..', '...'
   '.', '..', '...', '..'
   Pipe - This has the uniform sideways pipe instead of a hyphen to prevent non-uniform sizing.
   '|', '/', '─', '\'
   Stars - Option A requires ping / pong enabled script. Option B just adds the elements from the center.
   '⁎', '⁑', '⁂'
   '⁎', '⁑', '⁂', '⁑'
   Clock - These need to be ordered. I haven't done this yet as the application I was testing the system in doesn't support these wingdings / icons. But this would look quite nice and you could set it up to go forward, or backward during an undo process, etc..
   '🕛', '🕧', '🕐', '🕜', '🕑', '🕝', '🕒', '🕞', '🕓', '🕟', '🕔', '🕠', '🕕', '🕖', '🕗', '🕘', '🕙', '🕚', '🕡', '🕢', '🕣', '🕤', '🕥', '🕦'
   Arrows:
   '⬍', '⬈', '➞', '⬊', '⬍', '⬋', '⬅', '⬉'
   Bird - This looks decent but may be missing something.
   '︷', '︵', '︹', '︺', '︶', '︸'
   '︷', '︵', '︹', '︺', '︶', '︸', '︶', '︺', '︹', '︵'
   Plants - This isn't quite complete
   '☘', '❀', '❁'
   '☘', '❀', '❁', '❀'
   Eclipse - From Raku Throbber post author
   '🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'

",Python,"from time import sleep
while True:
    for rod in r'\|/-':
        print(rod, end='\r')
        sleep(0.25)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Factorial,Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",Python,"import math
math.factorial(n)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Find_the_missing_permutation,Find the missing permutation,"                    ABCD
                    CABD
                    ACDB
                    DACB
                    BCDA
                    ACBD
                    ADCB
                    CDAB
                    DABC
                    BCAD
                    CADB
                    CDBA
                    CBAD
                    ABDC
                    ADBC
                    BDCA
                    DCBA
                    BACD
                    BADC
                    BDAC
                    CBDA
                    DBCA
                    DCAB

Listed above are   all-but-one   of the permutations of the symbols   A,   B,   C,   and   D,   except   for one permutation that's   not   listed.



Task

Find that missing permutation.



Methods

 Obvious method: 
        enumerate all permutations of   A,  B,  C,  and  D,  
        and then look for the missing permutation. 

 alternate method:
        Hint:  if all permutations were shown above,  how many 
        times would  A  appear in each position?     
        What is the  parity  of this number?

 another alternate method:
        Hint:  if you add up the letter values of each column, 
        does a missing letter   A,  B,  C,  and  D   from each
        column cause the total value for each column to be unique?



Related task

   Permutations)

",Python,"given = """"""ABCD
CABD
ACDB
DACB
BCDA
ACBD
ADCB
CDAB
DABC
BCAD
CADB
CDBA
CBAD
ABDC
ADBC
BDCA
DCBA
BACD
BADC
BDAC
CBDA
DBCA
DCAB"""""".split(""\n"")
 
b = [0] * len(given[0])
for i in range(len(b)):
    m = {}
    for p in given:
        m[p[i]] = m.get(p[i], 0) + 1
    for char, count in m.items():
        if count & 1:
            b[i] = char
            break
print("""".join(b))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Read_a_file_line_by_line,Read a file line by line,"Read a file one line at a time,
as opposed to reading the entire file at once.



Related tasks

 Read a file character by character
 Input loop.

",Python,"with open(""foobar.txt"") as f:
    for line in f:
        process(line)",Human_written,Python_from_C
http://rosettacode.org/wiki/Arithmetic/Rational,Arithmetic/Rational,"Task

Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.



Example

Define a new type called frac with binary operator ""//"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).

Further define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').

Define standard coercion operators for casting int to frac etc.

If space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).

Finally test the operators:
Use the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.



Related task

   Perfect Numbers

",Python,"from fractions import Fraction
 
for candidate in range(2, 2**19):
  sum = Fraction(1, candidate)
  for factor in range(2, int(candidate**0.5)+1):
    if candidate % factor == 0:
      sum += Fraction(1, factor) + Fraction(1, candidate // factor)
  if sum.denominator == 1:
    print(""Sum of recipr. factors of %d = %d exactly %s"" %
           (candidate, int(sum), ""perfect!"" if sum == 1 else """"))",Human_written,Python_from_C++
http://rosettacode.org/wiki/URL_parser,URL parser,"URLs are strings with a simple syntax:

  scheme://[username:password@]domain[:port]/path?query_string#fragment_id



Task

Parse a well-formed URL to retrieve the relevant information:   scheme, domain, path, ...



Note:   this task has nothing to do with URL encoding or URL decoding.



According to the standards, the characters:

     ! * ' ( ) ; : @ & = + $ , / ? % # [ ] 
only need to be percent-encoded   (%)   in case of possible confusion.

Also note that the path, query and fragment are case sensitive, even if the scheme and domain are not.

The way the returned information is provided (set of variables, array, structured, record, object,...)
is language-dependent and left to the programmer, but the code should be clear enough to reuse.

Extra credit is given for clear error diagnostics.

   Here is the official standard:     https://tools.ietf.org/html/rfc3986, 
   and here is a simpler   BNF:     http://www.w3.org/Addressing/URL/5_URI_BNF.html.


Test cases

According to T. Berners-Lee

foo://example.com:8042/over/there?name=ferret#nose     should parse into:

   scheme = foo
   domain = example.com
   port = :8042
   path = over/there
   query = name=ferret
   fragment = nose

urn:example:animal:ferret:nose     should parse into:

   scheme = urn
   path = example:animal:ferret:nose

other URLs that must be parsed include:

   jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true 
   ftp://ftp.is.co.za/rfc/rfc1808.txt 
   http://www.ietf.org/rfc/rfc2396.txt#header1 
   ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two 
   mailto:John.Doe@example.com 
   news:comp.infosystems.www.servers.unix 
   tel:+1-816-555-1212 
   telnet://192.0.2.16:80/ 
   urn:oasis:names:specification:docbook:dtd:xml:4.1.2 

",Python,"import urllib.parse as up # urlparse for Python v2
 
url = up.urlparse('http://user:pass@example.com:8081/path/file.html;params?query1=1#fragment')
 
print('url.scheme = ', url.scheme)
print('url.netloc = ', url.netloc)
print('url.hostname = ', url.hostname)
print('url.port = ', url.port)
print('url.path = ', url.path)
print('url.params = ', url.params)
print('url.query = ', url.query)
print('url.fragment = ', url.fragment)
print('url.username = ', url.username)
print('url.password = ', url.password)",Human_written,Python_from_Java
http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas,The Twelve Days of Christmas,"Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas.
The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"gifts = '''\
A partridge in a pear tree.
Two turtle doves
Three french hens
Four calling birds
Five golden rings
Six geese a-laying
Seven swans a-swimming
Eight maids a-milking
Nine ladies dancing
Ten lords a-leaping
Eleven pipers piping
Twelve drummers drumming'''.split('\n')
 
days = '''first second third fourth fifth
          sixth seventh eighth ninth tenth
          eleventh twelfth'''.split()
 
for n, day in enumerate(days, 1):
    g = gifts[:n][::-1]
    print(('\nOn the %s day of Christmas\nMy true love gave to me:\n' % day) +
          '\n'.join(g[:-1]) +
          (' and\n' + g[-1] if n > 1 else g[-1].capitalize()))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Jaro_similarity,Jaro similarity,"The Jaro distance is a measure of edit distance between two strings; its inverse, called the Jaro similarity, is a measure of two strings' similarity: the higher the value, the more similar the strings are. The score is normalized such that   0   equates to no similarities and   1   is an exact match.



Definition
The Jaro similarity   




d

j




{\displaystyle d_{j}}

   of two given strings   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   is

 




d

j


=

{




0



if 

m
=
0






1
3



(


m


|


s

1



|




+


m


|


s

2



|




+



m
−
t

m


)




otherwise









{\displaystyle d_{j}=\left\{{\begin{array}{l l}0&{\text{if }}m=0\\{\frac {1}{3}}\left({\frac {m}{|s_{1}|}}+{\frac {m}{|s_{2}|}}+{\frac {m-t}{m}}\right)&{\text{otherwise}}\end{array}}\right.}


Where:

 



m


{\displaystyle m}

   is the number of matching characters;
 



t


{\displaystyle t}

   is half the number of transpositions.


Two characters from   




s

1




{\displaystyle s_{1}}

   and   




s

2




{\displaystyle s_{2}}

   respectively, are considered matching only if they are the same and not farther apart than   




⌊



max
(

|


s

1



|

,

|


s

2



|

)

2


⌋

−
1


{\displaystyle \left\lfloor {\frac {\max(|s_{1}|,|s_{2}|)}{2}}\right\rfloor -1}

 characters.

Each character of   




s

1




{\displaystyle s_{1}}

   is compared with all its matching characters in   




s

2




{\displaystyle s_{2}}

. Each difference in position is half a transposition; that is, the number of transpositions is half the number of characters which are common to the two strings but occupy different positions in each one.



Example
Given the strings   




s

1




{\displaystyle s_{1}}

   DWAYNE   and   




s

2




{\displaystyle s_{2}}

   DUANE   we find:

 



m
=
4


{\displaystyle m=4}


 




|


s

1



|

=
6


{\displaystyle |s_{1}|=6}


 




|


s

2



|

=
5


{\displaystyle |s_{2}|=5}


 



t
=
0


{\displaystyle t=0}




We find a Jaro score of:

 




d

j


=


1
3



(


4
6


+


4
5


+



4
−
0

4


)

=
0.822


{\displaystyle d_{j}={\frac {1}{3}}\left({\frac {4}{6}}+{\frac {4}{5}}+{\frac {4-0}{4}}\right)=0.822}




Task
Implement the Jaro algorithm and show the similarity scores for each of the following pairs:

 (""MARTHA"", ""MARHTA"")
 (""DIXON"", ""DICKSONX"")
 (""JELLYFISH"", ""SMELLYFISH"")


 See also
 Jaro–Winkler distance on Wikipedia.

",Python,"def jaro(s, t):
    s_len = len(s)
    t_len = len(t)

    if s_len == 0 and t_len == 0:
        return 1

    match_distance = max(s_len, t_len) // 2 - 1

    s_matches = [False] * s_len
    t_matches = [False] * t_len

    matches = 0
    transpositions = 0

    for i in range(s_len):
        start = max(0, i-match_distance)
        end = min(i+match_distance+1, t_len)

        for j in range(start, end):
            if t_matches[j]:
                continue
            if s[i]!= t[j]:
                continue
            s_matches[i] = True
            t_matches[j] = True
            matches += 1
            break

    if matches == 0:
        return 0

    k = 0
    for i in range(s_len):
        if not s_matches[i]:
            continue
        while not t_matches[k]:
            k += 1
        if s[i]!= t[k]:
            transpositions += 1
        k += 1

    return (((matches / s_len) +
             (matches / t_len) +
             ((matches - transpositions/2.0) / matches)) / 3.0)

if __name__ == '__main__':
    print(jaro('MARTHA', 'MARHTA'))
    print(jaro('DIXON', 'DICKSONX'))
    print(jaro('JELLYFISH', 'SMELLYFISH'))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Mouse_position,Mouse position,"Task

Get the current location of the mouse cursor relative to the active window.

Please specify if the window may be externally created.



",Python,"import Tkinter as tk
 
def showxy(event):
    xm, ym = event.x, event.y
    str1 = ""mouse at x=%d  y=%d"" % (xm, ym)
    # show cordinates in title
    root.title(str1)
    # switch color to red if mouse enters a set location range
    x,y, delta = 100, 100, 10
    frame.config(bg='red'
                 if abs(xm - x) < delta and abs(ym - y) < delta
                 else 'yellow')
 
root = tk.Tk()
frame = tk.Frame(root, bg= 'yellow', width=300, height=200)
frame.bind(""<Motion>"", showxy)
frame.pack()
 
root.mainloop()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"from browser import document, html

def gid(id):
    return document[id]

def ce(tag, cls, parent_node):
    e = html.ELEMENT(tag)
    e.class = cls
    if parent_node:
        parent_node.append(e)
    return e

def dom_tree(id):
    gid('tree').text = """"
    gid('tree').append(mktree(gid(id), None))

def mktree(e, p):
    t = ce(""div"", ""tree"", p)
    tog = ce(""span"", ""toggle"", t)
    h = ce(""span"", ""tag"", t)

    if e.tag is None:
        h.text = ""#Text""
        txt = e.text
        if txt.length > 0 and txt.match(/\S/):
            h = ce(""div"", ""txt"", t)
            h.text = txt
        return t

    tog.text = ""−""
    tog.bind(""click"", lambda ev: clicked(tog))
    h.text = e.tag

    l = e.children
    for i in range(len(l)):
        mktree(l[i], t)
    return t

def clicked(e):
    is_on = e.text == ""−""
    e.text = ""+"" if is_on else ""−""
    e.parent.class = ""tree-hide"" if is_on else ""tree""",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sort_three_variables,Sort three variables,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort   (the values of)   three variables   (X,   Y,   and   Z)   that contain any value   (numbers and/or literals).

If that isn't possible in your language, then just sort numbers   (and note if they can be floating point, integer, or other).

I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  'lions, tigers, and'
                        y =  'bears, oh my!'
                        z =  '(from the ""Wizard of OZ"")'

After sorting, the three variables would hold:

                        x =  '(from the ""Wizard of OZ"")'
                        y =  'bears, oh my!'
                        z =  'lions, tigers, and'

For numeric value sorting, use:
I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  77444
                        y =    -12
                        z =      0

After sorting, the three variables would hold:

                        x =    -12
                        y =      0
                        z =  77444

The variables should contain some form of a number, but specify if the algorithm
used can be for floating point or integers.   Note any limitations.

The values may or may not be unique.

The method used for sorting can be any algorithm;   the goal is to use the most idiomatic in the computer programming language used.

More than one algorithm could be shown if one isn't clearly the better choice.



One algorithm could be:

                        •  store the three variables   x, y, and z
                                 into an array (or a list)   A
                         
                        •  sort  (the three elements of)  the array   A
                         
                        •  extract the three elements from the array and place them in the
                                 variables x, y, and z   in order of extraction



Another algorithm   (only for numeric values):

       x= 77444 
       y=   -12 
       z=     0      
    low= x                                          
    mid= y                                          
   high= z 
      x= min(low,  mid,  high)            /*determine the lowest value of X,Y,Z. */    
      z= max(low,  mid,  high)            /*    ""      ""  highest  ""    "" "" "" ""  */    
      y=     low + mid + high - x - z     /*    ""      ""  middle   ""    "" "" "" ""  */      



Show the results of the sort here on this page using at least the values of those shown above.



",Python,"#python2 Code for Sorting 3 values
a= raw_input(""Enter values one by one ..\n1."").strip()
b=raw_input(""2."").strip()
c=raw_input(""3."").strip()
if a>b :
   a,b = b,a 
if a>c:
   a,c = c,a 
if b>c:
   b,c = c,b 
print(str(a)+"" ""+str(b)+"" ""+str(c))",Human_written,Python_from_C
http://rosettacode.org/wiki/Totient_function,Totient function,"The   totient   function is also known as:

   Euler's totient function
   Euler's phi totient function
   phi totient function
    Φ    function   (uppercase Greek phi)
    φ     function   (lowercase Greek phi)


Definitions   (as per number theory)

The totient function:

   counts the integers up to a given positive integer   n   that are relatively prime to   n
   counts the integers   k   in the range   1 ≤ k ≤ n   for which the greatest common divisor   gcd(n,k)   is equal to   1
   counts numbers   ≤ n   and   prime to   n


If the totient number   (for N)   is one less than   N,   then   N   is prime.



Task

Create a   totient   function and:

   Find and display   (1 per line)   for the 1st   25   integers:
   the integer   (the index)
   the totient number for that integer
   indicate if that integer is prime
   Find and display the   count   of the primes up to          100
   Find and display the   count   of the primes up to       1,000
   Find and display the   count   of the primes up to     10,000
   Find and display the   count   of the primes up to   100,000     (optional)
Show all output here.



Related task

   Perfect totient numbers


Also see

   Wikipedia: Euler's totient function.
   MathWorld: totient function.
   OEIS: Euler totient function phi(n).

",Python,"from math import sqrt
from itertools import count
 
def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True
 
def phi(n):
    if is_prime(n):
        return n - 1
    res = 1
    for i in range(2, n):
        if is_prime(i) and n % i == 0:
            res *= (i - 1) * i ** (n // i - 1)
    return res
 
for n in range(1, 26):
    tot = phi(n)
    print(f""{n}\t {tot}\t {'prime' if n - tot == 1 else ''}"")
 
for u in [100, 1000, 10000, 100000]:
    print(f""Number of primes up to {u}: {sum(1 for n in range(1, u + 1) if n - phi(n) == 1)}"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Bitcoin/public_point_to_address,Bitcoin/public point to address,"Bitcoin uses a specific encoding format to encode the digest of an elliptic curve public point into a short ASCII string. The purpose of this task is to perform such a conversion.

The encoding steps are:

 take the X and Y coordinates of the given public point, and concatenate them in order to have a 64 byte-longed string ;
 add one byte prefix equal to 4 (it is a convention for this way of encoding a public point) ;
 compute the SHA-256 of this string ;
 compute the RIPEMD-160 of this SHA-256 digest ;
 compute the checksum of the concatenation of the version number digit (a single zero byte) and this RIPEMD-160 digest, as described in bitcoin/address validation ;
 Base-58 encode (see below) the concatenation of the version number (zero in this case), the ripemd digest and the checksum
The base-58 encoding is based on an alphabet of alphanumeric characters (numbers, upper case and lower case, in that order) but without the four characters 0, O, l and I.

Here is an example public point:

X = 0x50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352
Y = 0x2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6
The corresponding address should be:
16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM

Nb. The leading '1' is not significant as 1 is zero in base-58. It is however often added to the bitcoin address for various reasons. There can actually be several of them. You can ignore this and output an address without the leading 1.

Extra credit: add a verification procedure about the public point, making sure it belongs to the secp256k1 elliptic curve
",Python,"import hashlib
import base58
 
def coin_encode(x, y):
	s = '04' + x + y
	rmd = hashlib.new('ripemd160')
	rmd.update(hashlib.sha256(s.decode('hex')).digest())
	rmd.update(hashlib.sha256(rmd.digest()).digest()[:4])
	return base58.b58encode(chr(0) + rmd.digest())
 
print coin_encode(
	'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',
	'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6')",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Archimedean_spiral,Archimedean spiral,"
The Archimedean spiral is a spiral named after the Greek mathematician Archimedes.



An Archimedean spiral can be described by the equation:






r
=
a
+
b
θ


{\displaystyle \,r=a+b\theta }


with real numbers a and b.



Task
Draw an Archimedean spiral.



",Python,"from turtle import *
from math import *
color(""blue"")
down()
for i in range(200):
    t = i / 20 * pi
    x = (1 + 5 * t) * cos(t)
    y = (1 + 5 * t) * sin(t)
    goto(x, y)
up()
done()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Check_input_device_is_a_terminal,Check input device is a terminal,"Task

Demonstrate how to check whether the input device is a terminal or not.



Related task

   Check output device is a terminal

",Python,"from sys import stdin
if stdin.isatty():
    print(""Input comes from tty."")
else:
    print(""Input doesn't come from tty."")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test,Miller–Rabin primality test,"

 This page uses content from Wikipedia. The original article was at Miller–Rabin primality test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime or not.

The algorithm, as modified by Michael O. Rabin to avoid the generalized Riemann hypothesis, is a probabilistic algorithm.

The pseudocode, from Wikipedia is:

Input: n > 2, an odd integer to be tested for primality;
       k, a parameter that determines the accuracy of the test
Output: composite if n is composite, otherwise probably prime
write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1
LOOP: repeat k times:
   pick a randomly in the range [2, n − 1]
   x ← ad mod n
   if x = 1 or x = n − 1 then do next LOOP
   repeat s − 1 times:
      x ← x2 mod n
      if x = 1 then return composite
      if x = n − 1 then do next LOOP
   return composite
return probably prime

 The nature of the test involves big numbers, so the use of ""big numbers"" libraries (or similar features of the language of your choice) are suggested, but not mandatory.
 Deterministic variants of the test exist and can be implemented as extra (not mandatory to complete the task)

",Python,"import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True  
 
    for i in range(8):#number of trials 
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Draw_a_pixel,Draw a pixel,"Task

Create a window and draw a pixel in it, subject to the following:

  the window is 320 x 240
  the color of the pixel must be red (255,0,0)
  the position of the pixel is x = 100, y = 100",Python,"from PIL import Image
 
img = Image.new('RGB', (320, 240))
pixels = img.load()
pixels[100,100] = (255,0,0)
img.show()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Find_common_directory_path,Find common directory path,"Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.

Test your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:

     '/home/user1/tmp/coverage/test'
     '/home/user1/tmp/covert/operator'
     '/home/user1/tmp/coven/members'

Note: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.

If your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"public class CommonPath {
	public static String commonPath(String... paths){
		String commonPath = """";
		String[][] folders = new String[paths.length][];
		for(int i = 0; i < paths.length; i++){
			folders[i] = paths[i].split(""/""); //split on file separator
		}
		for(int j = 0; j < folders[0].length; j++){
			String thisFolder = folders[0][j]; //grab the next folder name in the first path
			boolean allMatched = true; //assume all have matched in case there are no more paths
			for(int i = 1; i < folders.length && allMatched; i++){ //look at the other paths
				if(folders[i].length < j){ //if there is no folder here
					allMatched = false; //no match
					break; //stop looking because we've gone as far as we can
				}
				//otherwise
				allMatched &= folders[i][j].equals(thisFolder); //check if it matched
			}
			if(allMatched){ //if they all matched this folder name
				commonPath += thisFolder + ""/""; //add it to the answer
			}else{//otherwise
				break;//stop looking
			}
		}
		return commonPath;
	}
 
	public static void main(String[] args){
		String[] paths = { ""/home/user1/tmp/coverage/test"",
				 ""/home/user1/tmp/covert/operator"",
				 ""/home/user1/tmp/coven/members""};
		System.out.println(commonPath(paths));
 
		String[] paths2 = { ""/hame/user1/tmp/coverage/test"",
				 ""/home/user1/tmp/covert/operator"",
				 ""/home/user1/tmp/coven/members""};
		System.out.println(commonPath(paths2));
	}
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",Python,"f = lambda x: x * x * x - 3 * x * x + 2 * x
 
step = 0.001 # Smaller step values produce more accurate and precise results
start = -1
stop = 3
 
sign = f(start) > 0
 
x = start
while x <= stop:
    value = f(x)
 
    if value == 0:
        # We hit a root
        print ""Root found at"", x
    elif (value > 0) != sign:
        # We passed a root
        print ""Root found near"", x
 
    # Update our sign
    sign = value > 0
 
    x += step",Human_written,Python_from_Java
http://rosettacode.org/wiki/Vector_products,Vector products,"A vector is defined as having three dimensions as being represented by an ordered collection of three numbers:   (X, Y, Z).

If you imagine a graph with the   x   and   y   axis being at right angles to each other and having a third,   z   axis coming out of the page, then a triplet of numbers,   (X, Y, Z)   would represent a point in the region,   and a vector from the origin to the point.

Given the vectors:

        A = (a1,  a2,  a3) 
        B = (b1,  b2,  b3) 
        C = (c1,  c2,  c3) 

then the following common vector products are defined:

 The dot product       (a scalar quantity)
  A • B = a1b1   +   a2b2   +   a3b3  
 The cross product       (a vector quantity)
  A x B = (a2b3  -   a3b2,     a3b1   -   a1b3,     a1b2   -   a2b1)  
 The scalar triple product       (a scalar quantity)
  A • (B x C) 
 The vector triple product       (a vector quantity)
  A x (B x C) 


Task

Given the three vectors:

        a = ( 3,    4,    5)
        b = ( 4,    3,    5)
        c = (-5,  -12,  -13)

 Create a named function/subroutine/method to compute the dot product of two vectors.
 Create a function to compute the cross product of two vectors.
 Optionally create a function to compute the scalar triple product of three vectors.
 Optionally create a function to compute the vector triple product of three vectors.
 Compute and display: a • b
 Compute and display: a x b
 Compute and display: a • (b x c), the scalar triple product.
 Compute and display: a x (b x c), the vector triple product.


References

   A starting page on Wolfram MathWorld is   Vector Multiplication .
   Wikipedia   dot product. 
   Wikipedia   cross product. 
   Wikipedia   triple product.


Related tasks

   Dot product
   Quaternion type

",Python,"def crossp(a, b):
    '''Cross product of two 3D vectors'''
    assert len(a) == len(b) == 3, 'For 3D vectors only'
    a1, a2, a3 = a
    b1, b2, b3 = b
    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)
 
def dotp(a,b):
    '''Dot product of two eqi-dimensioned vectors'''
    assert len(a) == len(b), 'Vector sizes must match'
    return sum(aterm * bterm for aterm,bterm in zip(a, b))
 
def scalartriplep(a, b, c):
    '''Scalar triple product of three vectors: ""a . (b x c)""'''
    return dotp(a, crossp(b, c))
 
def vectortriplep(a, b, c):
    '''Vector triple product of three vectors: ""a x (b x c)""'''
    return crossp(a, crossp(b, c))
 
if __name__ == '__main__':
    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)
    print(""a = %r;  b = %r;  c = %r"" % (a, b, c))
    print(""a . b = %r"" % dotp(a,b))
    print(""a x b = %r""  % (crossp(a,b),))
    print(""a . (b x c) = %r"" % scalartriplep(a, b, c))
    print(""a x (b x c) = %r"" % (vectortriplep(a, b, c),))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",Python,"import math
 
def main():
        degrees = [0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]
        names = ""North                 "" \
                ""North by east         "" \
                ""North-northeast       "" \
                ""Northeast by north    "" \
                ""Northeast             "" \
                ""Northeast by east     "" \
                ""East-northeast        "" \
                ""East by north         "" \
                ""East                  "" \
                ""East by south         "" \
                ""East-southeast        "" \
                ""Southeast by east     "" \
                ""Southeast             "" \
                ""Southeast by south    "" \
                ""South-southeast       "" \
                ""South by east         "" \
                ""South                 "" \
                ""South by west         "" \
                ""South-southwest       "" \
                ""Southwest by south    "" \
                ""Southwest             "" \
                ""Southwest by west     "" \
                ""West-southwest        "" \
                ""West by south         "" \
                ""West                  "" \
                ""West by north         "" \
                ""West-northwest        "" \
                ""Northwest by west     "" \
                ""Northwest             "" \
                ""Northwest by north    "" \
                ""North-northwest       "" \
                ""North by west         "" \
                ""North                 ""
        for i in range(33):
                j = math.floor(degrees[i] * 32 / 360 + 0.5)
                print(""%2d  %.22s  %6.2f"" % ((j % 32) + 1, names[(j % 32) * 22:(j % 32) * 22 + 22], degrees[i]))
 
if __name__ == ""__main__"":
        main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Bell_numbers,Bell numbers,"Bell or exponential numbers are enumerations of the number of different ways to partition a set that has exactly n elements. Each element of the sequence Bn is the number of partitions of a set of size n where order of the elements and order of the partitions are non-significant. E.G.: {a b} is the same as {b a} and {a} {b} is the same as {b} {a}.



So

B0 = 1 trivially. There is only one way to partition a set with zero elements. { }
B1 = 1 There is only one way to partition a set with one element. {a}
B2 = 2 Two elements may be partitioned in two ways. {a} {b}, {a b}
B3 = 5 Three elements may be partitioned in five ways {a} {b} {c}, {a b} {c}, {a} {b c}, {a c} {b}, {a b c}
 and so on.


A simple way to find the Bell numbers is construct a Bell triangle, also known as an Aitken's array or Peirce triangle, and read off the numbers in the first column of each row. There are other generating algorithms though, and you are free to choose the best / most appropriate for your case.



Task

Write a routine (function, generator, whatever) to generate the Bell number sequence and call the routine to show here, on this page at least the first 15 and (if your language supports big Integers) 50th elements of the sequence.

If you do use the Bell triangle method to generate the numbers, also show the first ten rows of the Bell triangle.



See also

 OEIS:A000110 Bell or exponential numbers
 OEIS:A011971 Aitken's array",Python,"def bellTriangle(n):
    tri = [None] * n
    for i in xrange(n):
        tri[i] = [0] * i
    tri[1][0] = 1
    for i in xrange(2, n):
        tri[i][0] = tri[i - 1][i - 2]
        for j in xrange(1, i):
            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]
    return tri
 
def main():
    bt = bellTriangle(51)
    print ""First fifteen and fiftieth Bell numbers:""
    for i in xrange(1, 16):
        print ""%2d: %d"" % (i, bt[i][0])
    print ""50:"", bt[50][0]
    print
    print ""The first ten rows of Bell's triangle:""
    for i in xrange(1, 11):
        print bt[i]
 
main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Population_count,Population count,"Population count

You are encouraged to solve this task according to the task description, using any language you may know.
The   population count   is the number of   1s   (ones)   in the binary representation of a non-negative integer.

Population count   is also known as:

   pop count
   popcount 
   sideways sum
   bit summation 
   Hamming weight 


For example,   5   (which is   101   in binary)   has a population count of   2.


Evil numbers   are non-negative integers that have an   even   population count.

Odious numbers     are  positive integers that have an    odd   population count.



Task

 write a function (or routine) to return the population count of a non-negative integer.
 all computation of the lists below should start with   0   (zero indexed).
 display the   pop count   of the   1st   thirty powers of   3       (30,   31,   32,   33,   34,   ∙∙∙   329).
 display the   1st   thirty     evil     numbers.
 display the   1st   thirty   odious   numbers.
 display each list of integers on one line   (which may or may not include a title),   each set of integers being shown should be properly identified.


See also
 The On-Line Encyclopedia of Integer Sequences:   A000120 population count.
 The On-Line Encyclopedia of Integer Sequences:   A000069 odious numbers.
 The On-Line Encyclopedia of Integer Sequences:   A001969 evil numbers.

",Python,"from __future__ import print_function
 
def main():
    n = 1
    for i in range(30):
        print(__builtin_popcountll(n), end=' ')
        n *= 3
    print()
 
    od = [0] * 30
    ne = 0
    no = 0
    print('evil  : ', end='')
    for n in range(60):
        if (__builtin_popcount(n) & 1) == 0:
            if ne < 30:
                print(n, end=' ')
                ne += 1
        else:
            if no < 30:
                od[no] = n
                no += 1
    print()
    print('odious: ', end='')
    for i in range(30):
        print(od[i], end=' ')
    print()
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Eban_numbers,Eban numbers,"

Definition

An   eban   number is a number that has no letter    e    in it when the number is spelled in English.

Or more literally,   spelled numbers that contain the letter   e   are banned.



The American version of spelling numbers will be used here   (as opposed to the British).

2,000,000,000   is two billion,   not   two milliard.



Only numbers less than   one sextillion   (1021)   will be considered in/for this task.

This will allow optimizations to be used.



Task

   show all eban numbers   ≤   1,000   (in a horizontal format),   and a count
   show all eban numbers between   1,000   and   4,000   (inclusive),   and a count
   show a count of all eban numbers up and including           10,000
   show a count of all eban numbers up and including         100,000
   show a count of all eban numbers up and including      1,000,000
   show a count of all eban numbers up and including    10,000,000
   show all output here.


See also

   The MathWorld entry:   eban numbers.
   The OEIS entry:   A6933, eban numbers.

",Python,"# Use inflect
 
""""""
 
  show all eban numbers <= 1,000 (in a horizontal format), and a count
  show all eban numbers between 1,000 and 4,000 (inclusive), and a count
  show a count of all eban numbers up and including 10,000
  show a count of all eban numbers up and including 100,000
  show a count of all eban numbers up and including 1,000,000
  show a count of all eban numbers up and including 10,000,000
 
""""""
 
import inflect
import time
 
before = time.perf_counter()
 
p = inflect.engine()
 
# eban numbers <= 1000
 
print(' ')
print('eban numbers up to and including 1000:')
print(' ')
 
count = 0
 
for i in range(1,1001):
    if not 'e' in p.number_to_words(i):
        print(str(i)+' ',end='')
        count += 1
 
print(' ')
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers 1000 to 4000
 
print(' ')
print('eban numbers between 1000 and 4000 (inclusive):')
print(' ')
 
count = 0
 
for i in range(1000,4001):
    if not 'e' in p.number_to_words(i):
        print(str(i)+' ',end='')
        count += 1
 
print(' ')
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 10000
 
print(' ')
print('eban numbers up to and including 10000:')
print(' ')
 
count = 0
 
for i in range(1,10001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 100000
 
print(' ')
print('eban numbers up to and including 100000:')
print(' ')
 
count = 0
 
for i in range(1,100001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 1000000
 
print(' ')
print('eban numbers up to and including 1000000:')
print(' ')
 
count = 0
 
for i in range(1,1000001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
# eban numbers up to 10000000
 
print(' ')
print('eban numbers up to and including 10000000:')
print(' ')
 
count = 0
 
for i in range(1,10000001):
    if not 'e' in p.number_to_words(i):
        count += 1
 
print(' ')
print('count = '+str(count))
print(' ')
 
after = time.perf_counter()
 
print("" "")
print(""Run time in seconds: ""+str(after - before))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"class String:
    def strip_comment(self, markers = ['#',';']):
        re = re.union(markers)
        if index = (self =~ re):
            return self[0, index].rstrip()
        else:
            return self.rstrip()
 
print('apples, pears # and bananas'.strip_comment())
str = 'apples, pears ; and bananas'
print(str.strip_comment())
str = 'apples, pears and bananas '
print(str.strip_comment())
print(str.strip_comment('and'))
print("" \t \n ;"".strip_comment())
print("""".strip_comment())",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",Python,">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
0.9999999999999999
>>> from math import fsum
>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
1.0",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/ISBN13_check_digit,ISBN13 check digit,"Task

Validate the check digit of an ISBN-13 code:

   Multiply every other digit by  3.
   Add these numbers and the other digits.
   Take the remainder of this number after division by  10.
   If it is  0,   the ISBN-13 check digit is correct.


Use the following codes for testing:

   978-1734314502       (good)
   978-1734314509         (bad)
   978-1788399081       (good)
   978-1788399083         (bad)


Show output here, on this page



See also

   for details:   13-digit ISBN method of validation.       (installs cookies.)

",Python,"n = int(input())
sum = 0
for i in range(1, n + 1):
    if i % 2 == 0:
        sum += i
    else:
        sum -= i
print(sum)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/SEDOLs,SEDOLs,"Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.



That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.



Related tasks

   Luhn test
   ISIN

",Python,"def char2value(c):
  assert c not in 'AEIOU', ""No vowels""
  return int(c, 36)
 
sedolweight = [1,3,1,7,3,9]
 
def checksum(sedol):
    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,
                  sedol, sedolweight)
               )
    return str((10 - (tmp % 10)) % 10)
 
for sedol in '''
    710889
    B0YBKJ
    406566
    B0YBLH
    228276
    B0YBKL
    557910
    B0YBKR
    585284
    B0YBKT
    '''.split():
    print sedol + checksum(sedol)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm,Parsing/RPN calculator algorithm,"Task

Create a stack-based evaluator for an expression in   reverse Polish notation (RPN)   that also shows the changes in the stack as each individual token is processed as a table.



 Assume an input of a correct, space separated, string of tokens of an RPN expression
 Test with the RPN expression generated from the   Parsing/Shunting-yard algorithm   task: 

         3 4 2 * 1 5 - 2 3 ^ ^ / + 

 Print or display the output here


Notes

    ^    means exponentiation in the expression above.
    /    means division.


See also

   Parsing/Shunting-yard algorithm for a method of generating an RPN from an infix expression.
   Several solutions to 24 game/Solve make use of RPN evaluators (although tracing how they work is not a part of that task).
   Parsing/RPN to infix conversion.
   Arithmetic evaluation.

",Python,"def op_pow(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a ** b )
def op_mul(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a * b )
def op_div(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a / b )
def op_add(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a + b )
def op_sub(stack):
    b = stack.pop(); a = stack.pop()
    stack.append( a - b )
def op_num(stack, num):
    stack.append( num )
 
ops = {
 '^': op_pow,
 '*': op_mul,
 '/': op_div,
 '+': op_add,
 '-': op_sub,
 }
 
def get_input(inp = None):
    'Inputs an expression and returns list of tokens'
 
    if inp is None:
        inp = input('expression: ')
    tokens = inp.strip().split()
    return tokens
 
def rpn_calc(tokens):
    stack = []
    table = ['TOKEN,ACTION,STACK'.split(',')]
    for token in tokens:
        if token in ops:
            action = 'Apply op to top of stack'
            ops[token](stack)
            table.append( (token, action, ' '.join(str(s) for s in stack)) )
        else:
            action = 'Push num onto top of stack'
            op_num(stack, eval(token))
            table.append( (token, action, ' '.join(str(s) for s in stack)) )
    return table
 
if __name__ == '__main__':
    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'
    print( 'For RPN expression: %r\n' % rpn )
    rp = rpn_calc(get_input(rpn))
    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]
    row = rp[0]
    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))
    for row in rp[1:]:
        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))
 
    print('\n The final output value is: %r' % rp[-1][2])",Human_written,Python_from_C
http://rosettacode.org/wiki/Currency,Currency,"Task

Show how to represent currency in a simple example, using a data type that represent exact values of dollars and cents.



Note

The IEEE 754 binary floating point representations of numbers like   2.86   and   .0765   are not exact.

For this example, data will be two items with prices in dollars and cents, a quantity for each, and a tax rate.

Use the values:

 4000000000000000 hamburgers at $5.50 each       (four quadrillion burgers)
 2 milkshakes at $2.86 each, and 
 a tax rate of 7.65%. 


(That number of hamburgers is a 4 with 15 zeros after it.   The number is contrived to exclude naïve task solutions using 64 bit floating point types.)

Compute and output (show results on this page):

 the total price before tax
 the tax
 the total with tax 


The tax value must be computed by rounding to the nearest whole cent and this exact value must be added to the total price before tax.

The output must show dollars and cents with a decimal point.

The three results displayed should be:

 22000000000000005.72
 1683000000000000.44 
 23683000000000006.16 


Dollar signs and thousands separators are optional.



",Python,"from mpmath import mpf

fp = mpf(1.23456789)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Ternary_logic,Ternary logic,"

 This page uses content from Wikipedia. The original article was at Ternary logic. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In logic, a three-valued logic (also trivalent, ternary, or trinary logic, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value.

This is contrasted with the more commonly known bivalent logics (such as classical sentential or boolean logic) which provide only for true and false.

Conceptual form and basic ideas were initially created by Łukasiewicz, Lewis and Sulski.

These were then re-formulated by Grigore Moisil in an axiomatic algebraic form, and also extended to n-valued logics in 1945.


Example Ternary Logic Operators in Truth Tables:




not a


 ¬


 True 
 False


 Maybe 
 Maybe


 False 
 True




a and b


 ∧

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 False


 False 
 False 
 False 
 False




a or b


 ∨

 True 
 Maybe 
 False


 True 
 True 
 True 
 True


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 Maybe 
 False





if a then b


 ⊃

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 True 
 Maybe 
 Maybe


 False 
 True 
 True 
 True




a is equivalent to b


 ≡

 True 
 Maybe 
 False


 True 
 True 
 Maybe 
 False


 Maybe 
 Maybe 
 Maybe 
 Maybe


 False 
 False 
 Maybe 
 True




Task

 Define a new type that emulates ternary logic by storing data trits.
 Given all the binary logic operators of the original programming language, reimplement these operators for the new Ternary logic type trit.
 Generate a sampling of results using trit variables.
 Kudos for actually thinking up a test case algorithm where ternary logic is intrinsically useful, optimises the test case algorithm and is preferable to binary logic.


Note:   Setun   (Сетунь) was a   balanced ternary   computer developed in 1958 at   Moscow State University.   The device was built under the lead of   Sergei Sobolev   and   Nikolay Brusentsov.   It was the only modern   ternary computer,   using three-valued ternary logic
",Python,"from enum import Enum
from typing import List
 
class Trit(Enum):
    FALSE = -1
    MAYBE = 0
    TRUE = 1
 
def tr_not(t: Trit) -> Trit:
    return Trit(-t.value)
 
def tr_and(s: Trit, t: Trit) -> Trit:
    if s.value < t.value:
        return s
    return t
 
def tr_or(s: Trit, t: Trit) -> Trit:
    if s.value > t.value:
        return s
    return t
 
def tr_eq(s: Trit, t: Trit) -> Trit:
    return Trit(s.value * t.value)
 
def main() -> None:
    tr_set: List[Trit] = [Trit.FALSE, Trit.MAYBE, Trit.TRUE]
 
    print(""t     not t"")
    for t in tr_set:
        print(t, tr_not(t))
 
    print(""\ns     t     s and t"")
    for s in tr_set:
        for t in tr_set:
            print(s, t, tr_and(s, t))
 
    print(""\ns     t     s or t"")
    for s in tr_set:
        for t in tr_set:
            print(s, t, tr_or(s, t))
 
    print(""\ns     t     s eq t"")
    for s in tr_set:
        for t in tr_set:
            print(s, t, tr_eq(s, t))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice,Seven-sided dice from five-sided dice,"Task

(Given an equal-probability generator of one of the integers 1 to 5
as dice5),   create dice7 that generates a pseudo-random integer from
1 to 7 in equal probability using only dice5 as a source of random
numbers,   and check the distribution for at least one million calls using the function created in   Simple Random Distribution Checker.


Implementation suggestion:
dice7 might call dice5 twice, re-call if four of the 25
combinations are given, otherwise split the other 21 combinations
into 7 groups of three, and return the group index from the rolls.

(Task adapted from an answer here)
",Python,"import random

def rand5():
    rand_max = random.randint(0, RAND_MAX) - (RAND_MAX % 5)
    while ((r = rand()) >= rand_max):
        pass
    return r / (rand_max / 5) + 1

def rand5_7():
    while ((r = rand5() * 5 + rand5()) >= 27):
        pass
    return r / 3 - 1

def main():
    print(check(rand5, 5, 1000000,.05)? ""flat\n"" : ""not flat\n"")
    print(check(rand7, 7, 1000000,.05)? ""flat\n"" : ""not flat\n"")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists,Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",Python,"import itertools
 
def cp(lsts):
    return list(itertools.product(*lsts))
 
if __name__ == '__main__':
    from pprint import pprint as pp
 
    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],
                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),
                  ((1, 2, 3), (30,), (500, 100)),
                  ((1, 2, 3), (), (500, 100))]:
        print(lists, '=>')
        pp(cp(lists), indent=2)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Law_of_cosines_-_triples,Law of cosines - triples,"The Law of cosines states that for an angle γ, (gamma) of any triangle, if the sides adjacent to the angle are A and B and the side opposite is C; then the lengths of the sides are related by this formula:

           A2 + B2 - 2ABcos(γ) = C2 

Specific angles

For an angle of of   90º   this becomes the more familiar ""Pythagoras equation"":

           A2 + B2  =  C2           

For an angle of   60º   this becomes the less familiar equation:

           A2 + B2 - AB  =  C2       

And finally for an angle of   120º   this becomes the equation:

           A2 + B2 + AB  =  C2      



Task

   Find all integer solutions (in order) to the three specific cases, distinguishing between each angle being considered.
   Restrain all sides to the integers   1..13   inclusive.
   Show how many results there are for each of the three angles mentioned above.
   Display results on this page.


Note: Triangles with the same length sides but different order are to be treated as the same.

Optional Extra credit

 How many 60° integer triples are there for sides in the range 1..10_000 where the sides are not all of the same length.


Related Task
 Pythagorean triples


See also

 Visualising Pythagoras: ultimate proofs and crazy contortions Mathlogger Video

",Python,"from itertools import permutations
from collections import defaultdict
 
def py_solution():
    grouped = defaultdict(list)
    for a, b, c in permutations(range(1, 14), 3):
        sumaabb, ab = a*a + b*b, a*b
        if c*c == sumaabb:
            grouped[90].append((a, b, c))
        elif c*c == sumaabb - ab:
            grouped[60].append((a, b, c))
        elif c*c == sumaabb + ab:
            grouped[120].append((a, b, c))
    for k, v in grouped.items():
        print(f""For an angle of {k} there are {len(v)} solutions:"")
        print(sorted(set(v)))
 
if __name__ == ""__main__"":
    py_solution()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Python,"# version 1.2.51
 
import random
 
class SOfN(n):
    def __init__(self, n):
        self.n = n
        self.sample = []
        self.i = 0
 
    def process(self, item):
        if self.i < self.n:
            self.sample.append(item)
        else:
            if random.randint(0, self.i) < self.n:
                self.sample[random.randint(0, self.n - 1)] = item
        self.i += 1
        return self.sample
 
def main():
    bin = [0] * 10
    for _ in range(100_000):
        sOfn = SOfN(3)
        for d in range(9):
            sOfn.process(d)
        for s in sOfn.process(9):
            bin[s] += 1
    print(bin)
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi,Arithmetic-geometric mean/Calculate Pi,"Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate 



π


{\displaystyle \pi }

.

With the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:





π
=



4


a
g
m

(
1
,
1

/



2



)

2




1
−

∑

n
=
1


∞



2

n
+
1


(

a

n


2


−

g

n


2


)





{\displaystyle \pi ={\frac {4\;\mathrm {agm} (1,1/{\sqrt {2}})^{2}}{1-\sum \limits _{n=1}^{\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}



This allows you to make the approximation, for any large   N:





π
≈



4


a

N


2




1
−

∑

k
=
1


N



2

k
+
1


(

a

k


2


−

g

k


2


)





{\displaystyle \pi \approx {\frac {4\;a_{N}^{2}}{1-\sum \limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}



The purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of 



π


{\displaystyle \pi }

.
",Python,"from decimal import *
 
D = Decimal
getcontext().prec = 100
a = n = D(1)
g, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)
for i in range(18):
    x = [(a + g) * half, (a * g).sqrt()]
    var = x[0] - a
    z -= var * var * n
    n += n
    a, g = x    
print(a * a / z)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/IBAN,IBAN,"

 This page uses content from Wikipedia. The original article was at IBAN. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   International Bank Account Number (IBAN)   is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.

The IBAN consists of up to 34 alphanumeric characters:

   first the two-letter ISO 3166-1 alpha-2 country code, 
   then two check digits, and 
   finally a country-specific Basic Bank Account Number (BBAN). 


The check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.



Task

Validate the following fictitious IBAN:    GB82 WEST 1234 5698 7654 32 



Details of the algorithm can be found on the Wikipedia page.



",Python,"import re
 
_country2length = dict(
    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,
    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,
    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,
    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,
    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,
    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,
    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,
    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 )
 
def valid_iban(iban):
    # Ensure upper alphanumeric input.
    iban = iban.replace(' ','').replace('\t','')
    if not re.match(r'^[\dA-Z]+$', iban): 
        return False
    # Validate country code against expected length.
    if len(iban) != _country2length[iban[:2]]:
        return False
    # Shift and convert.
    iban = iban[4:] + iban[:4]
    digits = int(''.join(str(int(ch, 36)) for ch in iban)) #BASE 36: 0..9,A..Z -> 0..35
    return digits % 97 == 1
 
if __name__ == '__main__':
    for account in [""GB82 WEST 1234 5698 7654 32"", ""GB82 TEST 1234 5698 7654 32""]:
        print('%s validation is: %s' % (account, valid_iban(account)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Substring,Substring,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Display a substring:

   starting from   n   characters in and of   m   length;
   starting from   n   characters in,   up to the end of the string;
   whole string minus the last character;
   starting from a known   character   within the string and of   m   length;
   starting from a known   substring   within the string and of   m   length.


If the program uses UTF-8 or UTF-16,   it must work on any valid Unicode code point,
whether in the   Basic Multilingual Plane   or above it.

The program must reference logical characters (code points),   not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> s = 'abcdefgh'
>>> n, m, char, chars = 2, 3, 'd', 'cd'
>>> # starting from n=2 characters in and m=3 in length;
>>> s[n-1:n+m-1]
'bcd'
>>> # starting from n characters in, up to the end of the string;
>>> s[n-1:]
'bcdefgh'
>>> # whole string minus last character;
>>> s[:-1]
'abcdefg'
>>> # starting from a known character char=""d"" within the string and of m length;
>>> indx = s.index(char)
>>> s[indx:indx+m]
'def'
>>> # starting from a known substring chars=""cd"" within the string and of m length. 
>>> indx = s.index(chars)
>>> s[indx:indx+m]
'cde'
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Hickerson_series_of_almost_integers,Hickerson series of almost integers,"The following function,   due to D. Hickerson,   is said to generate ""Almost integers"" by the

""Almost Integer"" page of Wolfram MathWorld,   (December 31 2013).   (See formula numbered   51.)



The function is:           



h
(
n
)
=



n
!


2
(
ln
⁡

2


)

n
+
1







{\displaystyle h(n)={\operatorname {n} ! \over 2(\ln {2})^{n+1}}}





It is said to produce ""almost integers"" for   n   between   1   and   17.
The purpose of the task is to verify this assertion.

Assume that an ""almost integer"" has either a nine or a zero as its first digit after the decimal point of its decimal string representation



Task

Calculate all values of the function checking and stating which are ""almost integers"".

Note: Use extended/arbitrary precision numbers in your calculation if necessary to ensure you have adequate precision of results as for example:

               h(18) = 3385534663256845326.39...


",Python,"# version 1.1.4
 
import math
 
def almost_integer(n):
    a = math.log(2, math.e) ** (n + 1) * 2
    f = n
    for nn in range(2, n):
        f *= nn
    b = f / a
    c = int(b * 10) % 10
    return c in (0, 9)
 
if __name__ == '__main__':
    for n in range(1, 18):
        print(f""{n:2d} is almost integer: {almost_integer(n)}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sequence:_nth_number_with_exactly_n_divisors,Sequence: nth number with exactly n divisors,"Calculate the sequence where each term an is the nth that has n divisors.

Task
Show here, on this page, at least the first 15 terms of the sequence.

See also
OEIS:A073916
Related tasks
Sequence: smallest number greater than previous term with exactly n divisors
Sequence: smallest number with exactly n divisors",Python,"def divisors(n):
    divs = [1]
    for ii in range(2, int(n ** 0.5) + 3):
        if n % ii == 0:
            divs.append(ii)
            divs.append(int(n / ii))
    divs.append(n)
    return list(set(divs))
 
 
def is_prime(n):
    return len(divisors(n)) == 2
 
 
def primes():
    ii = 1
    while True:
        ii += 1
        if is_prime(ii):
            yield ii
 
 
def prime(n):
    generator = primes()
    for ii in range(n - 1):
        generator.__next__()
    return generator.__next__()
 
 
def n_divisors(n):
    ii = 0
    while True:
        ii += 1
        if len(divisors(ii)) == n:
            yield ii
 
 
def sequence(max_n=None):
    if max_n is not None:
        for ii in range(1, max_n + 1):
            if is_prime(ii):
                yield prime(ii) ** (ii - 1)
            else:
                generator = n_divisors(ii)
                for jj, out in zip(range(ii - 1), generator):
                    pass
                yield generator.__next__()
    else:
        ii = 1
        while True:
            ii += 1
            if is_prime(ii):
                yield prime(ii) ** (ii - 1)
            else:
                generator = n_divisors(ii)
                for jj, out in zip(range(ii - 1), generator):
                    pass
                yield generator.__next__()
 
 
if __name__ == '__main__':
    for item in sequence(15):
        print(item)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Peaceful_chess_queen_armies,Peaceful chess queen armies,"In chess, a queen attacks positions from where it is, in straight lines up-down and left-right as well as on both its diagonals. It attacks only pieces not of its own colour.






⇖
⇑
⇗



⇐
⇐
♛
⇒
⇒



⇙
⇓
⇘



⇙

⇓

⇘




⇓






The goal of Peaceful chess queen armies is to arrange m black queens and m white queens on an n-by-n square grid, (the board), so that no queen attacks another of a different colour.



Task

 Create a routine to represent two-colour queens on a 2-D board. (Alternating black/white background colours, Unicode chess pieces and other embellishments are not necessary, but may be used at your discretion).
 Create a routine to generate at least one solution to placing m equal numbers of black and white queens on an n square board.
 Display here results for the m=4, n=5 case.


References

 Peaceably Coexisting Armies of Queens (Pdf) by Robert A. Bosch. Optima, the Mathematical Programming Socity newsletter, issue 62.
 A250000 OEIS

",Python,"class Position:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y
 
    def __str__(self):
        return '(%d, %d)' % (self.x, self.y)
 
    def __repr__(self):
        return self.__str__()
 
def isAttacking(queen, pos):
    return queen.x == pos.x or \
           queen.y == pos.y or \
           abs(queen.x - pos.x) == abs(queen.y - pos.y)
 
def place(m, n, blackQueens, whiteQueens):
    if m == 0:
        return True
    placingBlack = True
    for i in range(n):
        for j in range(n):
            try:
                pos = Position(i, j)
                for queen in blackQueens:
                    if pos == queen or (not placingBlack and isAttacking(queen, pos)):
                        raise Exception()
                for queen in whiteQueens:
                    if pos == queen or (placingBlack and isAttacking(queen, pos)):
                        raise Exception()
                if placingBlack:
                    blackQueens.append(pos)
                    placingBlack = False
                else:
                    whiteQueens.append(pos)
                    if place(m - 1, n, blackQueens, whiteQueens):
                        return True
                    blackQueens.pop()
                    whiteQueens.pop()
                    placingBlack = True
            except:
                pass
    if not placingBlack:
        blackQueens.pop()
    return False
 
def printBoard(n, blackQueens, whiteQueens):
    # initialize the board
    board = [[''for j in range(n)] for i in range(n)]
    for i in range(n):
        for j in range(n):
            if i % 2 == j % 2:
                board[i][j] = '•'
            else:
                board[i][j] = '◦'
 
    # insert the queens
    for queen in blackQueens:
        board[queen.y][queen.x] = 'B'
    for queen in whiteQueens:
        board[queen.y][queen.x] = 'W'
 
    # print the board
    for row in board:
        for cell in row:
            print(cell, end=' ')
        print()
    print()
 
nms = [
    [2, 1],
    [3, 1], [3, 2],
    [4, 1], [4, 2], [4, 3],
    [5, 1], [5, 2], [5, 3], [5, 4], [5, 5],
    [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6],
    [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7]
]
for nm in nms:
    m = nm[1]
    n = nm[0]
    print('%d black and %d white queens on a %d x %d board:' % (m, m, n, n))
 
    blackQueens = []
    whiteQueens = []
    if place(m, n, blackQueens, whiteQueens):
        printBoard(n, blackQueens, whiteQueens)
    else:
        print('No solution exists.')
    print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Zero_to_the_zero_power,Zero to the zero power,"Some computer programming languages are not exactly consistent   (with other computer programming languages)  

when   raising zero to the zeroth power:     00



Task

Show the results of raising   zero   to the   zeroth   power.



If your computer language objects to      0**0      or      0^0      at compile time,   you may also try something like:

           x = 0
           y = 0
           z = x**y
           say  'z='  z


Show the result here.

And of course use any symbols or notation that is supported in your computer programming language for exponentiation.



See also

 The Wiki entry: Zero to the power of zero. 
 The Wiki entry: History of differing points of view.
 The MathWorld™ entry: exponent laws.
 Also, in the above MathWorld™ entry, see formula (9): 




x

0


=
1


{\displaystyle x^{0}=1}

.
 The OEIS entry: The special case of zero to the zeroth power

",Python,"from decimal import Decimal
from fractions import Fraction
from itertools import product
 
zeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]
for i, j in product(zeroes, repeat=2):
    try:
        ans = i**j
    except:
        ans = '<Exception raised>'
    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')",Human_written,Python_from_C#
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"# version 1.1.3
 
def binomial(n, k):
    if n < k: return 0
    if n == 0 or k == 0: return 1
    num = 1
    for i in range(k + 1, n + 1): num *= i
    den = 1
    for i in range(2, n - k + 1): den *= i
    return num // den
 
def pascalUpperTriangular(n):
    return [[binomial(j, i) for j in range(n)] for i in range(n)]
 
def pascalLowerTriangular(n):
    return [[binomial(i, j) for j in range(n)] for i in range(n)]
 
def pascalSymmetric(n):
    return [[binomial(i + j, i) for j in range(n)] for i in range(n)]
 
def printMatrix(title, m):
    n = len(m)
    print(title)
    print(""["", end="""")
    for i in range(n):
        if i > 0: print("" "", end="""")
        print(m[i], end="""")
        if i < n - 1: print("","", end="""")
        else: print(""]\n"")
 
def main():
    printMatrix(""Pascal upper-triangular matrix"", pascalUpperTriangular(5))
    printMatrix(""Pascal lower-triangular matrix"", pascalLowerTriangular(5))
    printMatrix(""Pascal symmetric matrix"", pascalSymmetric(5))
 
if __name__ == ""__main__"": main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Twin_primes,Twin primes,"Twin primes are pairs of natural numbers   (P1  and  P2)   that satisfy the following:

     P1   and   P2   are primes
     P1  +  2   =   P2


Task

Write a program that displays the number of pairs of twin primes that can be found under a user-specified number

(P1 < user-specified number & P2 < user-specified number).



Extension

 Find all twin prime pairs under 100000, 10000000 and 1000000000.
 What is the time complexity of the program? Are there ways to reduce computation time?


Examples

> Search Size: 100
> 8 twin prime pairs.

> Search Size: 1000
> 35 twin prime pairs.



Also see

   The OEIS entry: A001097: Twin primes. 
   The OEIS entry: A167874: The number of distinct primes < 10^n which are members of twin-prime pairs. 
   The OEIS entry: A077800: List of twin primes {p, p+2}, with repetition. 
   The OEIS entry: A007508: Number of twin prime pairs below 10^n. 

",Python,"primes = [2, 3, 5, 7, 11, 13, 17, 19]
 
 
def count_twin_primes(limit: int) -> int:
    global primes
    if limit > primes[-1]:
        ram_limit = primes[-1] + 90000000 - len(primes)
        reasonable_limit = min(limit, primes[-1] ** 2, ram_limit) - 1
 
        while reasonable_limit < limit:
            ram_limit = primes[-1] + 90000000 - len(primes)
            if ram_limit > primes[-1]:
                reasonable_limit = min(limit, primes[-1] ** 2, ram_limit)
            else:
                reasonable_limit = min(limit, primes[-1] ** 2)
 
            sieve = list({x for prime in primes for x in
                          range(primes[-1] + prime - (primes[-1] % prime), reasonable_limit, prime)})
            primes += [x - 1 for i, x in enumerate(sieve) if i and x - 1 != sieve[i - 1] and x - 1 < limit]
 
    count = len([(x, y) for (x, y) in zip(primes, primes[1:]) if x + 2 == y])
 
    return count
 
 
def test(limit: int):
    count = count_twin_primes(limit)
    print(f""Number of twin prime pairs less than {limit} is {count}\n"")
 
 
test(10)
test(100)
test(1000)
test(10000)
test(100000)
test(1000000)
test(10000000)
test(100000000)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Python,"def max_combine(xs):
    return int(''.join(sorted(map(str, xs), key=lambda x: x[::-1])))

print(max_combine([1, 34, 3, 98, 9, 76, 45, 4]))
print(max_combine([54, 546, 548, 60]))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/URL_decoding,URL decoding,"This task   (the reverse of   URL encoding   and distinct from   URL parser)   is to provide a function
or mechanism to convert an URL-encoded string into its original unencoded form.



Test cases

   The encoded string   ""http%3A%2F%2Ffoo%20bar%2F""   should be reverted to the unencoded form   ""http://foo bar/"".
   The encoded string   ""google.com/search?q=%60Abdu%27l-Bah%C3%A1""   should revert to the unencoded form   ""google.com/search?q=`Abdu'l-Bahá"".

",Python,"import string
import Poco.URI
import sys
 
encoded = ""http%3A%2F%2Ffoo%20bar%2F""
decoded = """"
Poco.URI.decode(encoded, decoded)
print encoded, ""is decoded:"", decoded, ""!""",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",Python,"import random
 
class Prize:
    def __init__(self, name):
        self.name = name
 
    def __eq__(self, other):
        return self.name == other.name
 
    def __repr__(self):
        return self.name
 
Goat = Prize(""Goat"")
Car = Prize(""Car"")
 
GAMES = 3_000_000
switch_wins = 0
 
for _ in range(GAMES):
    doors = [Goat, Goat, Goat]
    doors[random.randint(0, 2)] = Car
 
    # You only lose by switching if you pick the car the first time
    if random.choice(doors)!= Car:
        switch_wins += 1
 
print(f""I played the game {GAMES} times and won {switch_wins} times ({switch_wins / GAMES * 100}%)."")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Interactive_programming_(repl),Interactive programming (repl),"Many language implementations come with an interactive mode.

This is a command-line interpreter that reads lines from the user and evaluates these lines as statements or expressions.

An interactive mode may also be known as a command mode,   a read-eval-print loop (REPL),   or a shell.



Task

Show how to start this mode.

Then, as a small example of its use, interactively create a function of two strings and a separator that returns the strings separated by two concatenated instances of the separator   (the 3rd argument).



Example

             f('Rosetta',  'Code',  ':')   

should return

             'Rosetta::Code'               



Note

This task is   not   about creating your own interactive mode.



",Python,">>> def f(s1, s2, sep):
...     return s1 + sep + sep + s2
... 
>>> f(""Rosetta"", ""Code"", "":"")
'Rosetta::Code'",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Iterated_digits_squaring,Iterated digits squaring,"If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:

15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89
7 -> 49 -> 97 -> 130 -> 10 -> 1
An example in Python:

>>> step = lambda x: sum(int(d) ** 2 for d in str(x))
>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))
>>> [iterate(x) for x in xrange(1, 20)]
[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]


Task

 Count how many number chains for integers 1 <= n < 100_000_000 end with a value 89.
Or, for much less credit - (showing that your algorithm and/or language is slow):

 Count how many number chains for integers 1 <= n < 1_000_000 end with a value 89.
This problem derives from the Project Euler problem 92.

For a quick algorithm for this task see the talk page



Related tasks

 Combinations with repetitions
 Digital root
 Digital root/Multiplicative digital root

",Python,"from math import ceil, log10, factorial
 
def next_step(x):
    result = 0
    while x > 0:
        result += (x % 10) ** 2
        x /= 10
    return result
 
def check(number):
    candidate = 0
    for n in number:
        candidate = candidate * 10 + n
 
    while candidate != 89 and candidate != 1:
        candidate = next_step(candidate)
 
    if candidate == 89:
        digits_count = [0] * 10
        for d in number:
            digits_count[d] += 1
 
        result = factorial(len(number))
        for c in digits_count:
            result /= factorial(c)
        return result
 
    return 0
 
def main():
    limit = 100000000
    cache_size = int(ceil(log10(limit)))
    assert 10 ** cache_size == limit
 
    number = [0] * cache_size
    result = 0
    i = cache_size - 1
 
    while True:
        if i == 0 and number[i] == 9:
            break
        if i == cache_size - 1 and number[i] < 9:
            number[i] += 1
            result += check(number)
        elif number[i] == 9:
            i -= 1
        else:
            number[i] += 1
            for j in xrange(i + 1, cache_size):
                number[j] = number[i]
            i = cache_size - 1
            result += check(number)
 
    print result
 
main()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Bitmap/Read_a_PPM_file,Bitmap/Read a PPM file,"Using the data storage type defined on this page for raster images, read an image from a PPM file (binary P6 prefered).
(Read the definition of PPM file on Wikipedia.)

Task: Use write ppm file solution and grayscale image solution with this one in order to convert a color image to grayscale one.
",Python,"# With help from http://netpbm.sourceforge.net/doc/ppm.html
 
# String masquerading as ppm file (version P3)
import io
 
ppmtxt = '''P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
'''
 
 
def tokenize(f):
    for line in f:
        if line[0] != '#':
            for t in line.split():
                yield t
 
def ppmp3tobitmap(f):
    t = tokenize(f)
    nexttoken = lambda : next(t)
    assert 'P3' == nexttoken(), 'Wrong filetype'
    width, height, maxval = (int(nexttoken()) for i in range(3))
    bitmap = Bitmap(width, height, Colour(0, 0, 0))
    for h in range(height-1, -1, -1):
        for w in range(0, width):
            bitmap.set(w, h, Colour( *(int(nexttoken()) for i in range(3))))
 
    return bitmap
 
print('Original Colour PPM file')
print(ppmtxt)
ppmfile = io.StringIO(ppmtxt)
bitmap = ppmp3tobitmap(ppmfile)
print('Grey PPM:')
bitmap.togreyscale()
ppmfileout = io.StringIO('')
bitmap.writeppmp3(ppmfileout)
print(ppmfileout.getvalue())
 
 
'''
The print statements above produce the following output:
 
Original Colour PPM file
P3
# feep.ppm
4 4
15
 0  0  0    0  0  0    0  0  0   15  0 15
 0  0  0    0 15  7    0  0  0    0  0  0
 0  0  0    0  0  0    0 15  7    0  0  0
15  0 15    0  0  0    0  0  0    0  0  0
 
Grey PPM:
P3
# generated from Bitmap.writeppmp3
4 4
11
    0  0  0    0  0  0    0  0  0    4  4  4
    0  0  0   11 11 11    0  0  0    0  0  0
    0  0  0    0  0  0   11 11 11    0  0  0
    4  4  4    0  0  0    0  0  0    0  0  0
 
'''",Human_written,Python_from_C
http://rosettacode.org/wiki/Undefined_values,Undefined values,"
",Python,"# Check to see whether a name is defined
try: name
except NameError: print ""name is undefined at first check""
 
# Create a name, giving it a string value
name = ""Chocolate""
 
# Check to see whether the name is defined now.
try: name
except NameError: print ""name is undefined at second check""
 
# Remove the definition of the name.
del name
 
# Check to see whether it is defined after the explicit removal.
try: name
except NameError: print ""name is undefined at third check""
 
# Recreate the name, giving it a value of 42
name = 42
 
# Check to see whether the name is defined now.
try: name
except NameError: print ""name is undefined at fourth check""
 
# Because most of the output is conditional, this serves as
# a clear indicator that the program has run to completion.
print ""Done""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Hello_world/Web_server,Hello world/Web server,"The browser is the new GUI !



Task

Serve our standard text   Goodbye, World!   to   http://localhost:8080/   so that it can be viewed with a web browser.

The provided solution must start or implement a server that accepts multiple client connections and serves text as requested.

Note that starting a web browser or opening a new window with this URL
is not part of the task.

Additionally, it is permissible to serve the provided page as a plain text file (there is no requirement to serve properly formatted HTML here).

The browser will generally do the right thing with simple text like this.



",Python,"from wsgiref.simple_server import make_server
 
def app(environ, start_response):
    start_response('200 OK', [('Content-Type','text/html')])
    yield b""<h1>Goodbye, World!</h1>""
 
server = make_server('127.0.0.1', 8080, app)
server.serve_forever()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Binary_digits,Binary digits,"Task

Create and display the sequence of binary digits for a given   non-negative integer.

   The decimal value      5   should produce an output of               101
   The decimal value     50   should produce an output of            110010
   The decimal value   9000   should produce an output of    10001100101000

The results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used.

The output produced should consist just of the binary digits of each number followed by a   newline.

There should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.



",Python,">>> for i in range(16): print('{0:b}'.format(i))
 
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111",Human_written,Python_from_C++
http://rosettacode.org/wiki/Go_Fish,Go Fish,"Write a program to let the user play Go Fish against a computer opponent. Use the following rules:

 Each player is dealt nine cards to start with.
 On their turn, a player asks their opponent for a given rank (such as threes or kings). A player must already have at least one card of a given rank to ask for more.
 If the opponent has any cards of the named rank, they must hand over all such cards, and the requester can ask again.
 If the opponent has no cards of the named rank, the requester draws a card and ends their turn.
 A book is a collection of every card of a given rank. Whenever a player completes a book, they may remove it from their hand.
 If at any time a player's hand is empty, they may immediately draw a new card, so long as any new cards remain in the deck.
 The game ends when every book is complete. The player with the most books wins.
The game's AI need not be terribly smart, but it should use at least some strategy. That is, it shouldn't choose legal moves entirely at random.

You may want to use code from Playing Cards.

Related tasks:

 Playing cards
 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Poker hand_analyser

",Python,"Red [
    Title:  ""Go Fish""
    Author: ""gltewalt""
]
 
chand: []   ;-- c and p = computer and player
cguesses: []
phand: []
cbooks: 0
pbooks: 0
gf: {
    ***************
    *   GO FISH   *
    ***************
}
pip: [""a"" ""2"" ""3"" ""4"" ""5"" ""6"" ""7"" ""8"" ""9"" ""10"" ""j"" ""q"" ""k""] ;-- suits are not relevant
pile: []    ;-- where discarded cards go
 
;---------------------
;  Helper functions  -                                           
;---------------------
 
clear-screen: does [
    ""clears the console""
    call/console either system/platform = 'Linux [""clear""][""cls""]
]
 
clear-and-show: func [duration str][
    {
        Poor persons animation. 
        Blips message to screen after a pause of duration length.
 
    }
    clear-screen
    print str 
    wait duration 
    clear-screen
]
 
deal-cards: func [num hand][ 
    loop num [
        append hand rejoin [trim/all form take deck]
    ] 
]
 
find-in: func [blk str][
    ""Finds a string value in a block. Series in series.""
    foreach i blk [if find i str [return i]]
]
 
go-fish: func [num hand][
    either not empty? deck [
        deal-cards num hand
    ][
        append hand rejoin [trim/all form take pile]    ;-- take from pile if deck is empty
    ]
]
 
guess-from: func [hand guessed][
    {
        Randomly picks from hand minus guessed.
 
        Simulates a person asking for different cards on
        their next turn if their previous guess resulted
        in a Go Fish.
    }
    random/seed now/time
    either any [empty? guessed empty? exclude hand guessed][
        random/only hand 
    ][
        random/only exclude hand guessed
    ]
]
 
make-deck: function [] [
    ""make-deck and shuffle from https://rosettacode.org/wiki/Playing_cards#Red""
     new-deck: make block! 52
     foreach p pip [loop 4 [append/only new-deck p]]
     return new-deck
]
 
show-cards: does [
    clear-and-show 0 """"
    print [newline ""Player cards:"" newline sort phand newline]
    print [""Computer books:"" cbooks]
    print [""Player books:"" pbooks newline]
]
 
shuffle: function [deck [block!]] [deck: random deck]
 
;------------- end of helper functions -----------------
 
check-for-books: func [
    {
        Checks for a book in a players hand.
        Increments the players book score, and
        discards the book from the players hand
    }
    hand ""from or to hand""
    kind ""rank of cards""
    /local 
        c ""collected""
][
    c: collect [
        forall hand [keep find hand/1 kind]
    ]
    remove-each i c [none = i] 
    if 4 = length? c [
        either hand = phand [pbooks: pbooks + 1][cbooks: cbooks + 1]
        remove-each i hand [if find/only c i [i]]   ;-- remove book from hand
        forall c [append pile c/1]  ;-- append discarded book to the pile
    ]
]
 
transfer-cards: func [
    ""Transfers cards from player to player""
    fhand ""from hand""
    thand ""to hand""
    kind ""rank of cards""
    /local 
        c ""collected""
][
    c: collect [forall fhand [keep find fhand/1 kind]]
    remove-each i c [none = i]  ;-- remove none values from collected
    forall c [append thand c/1] ;-- append remaining values to ""to hand""
    remove-each i fhand [if find/only c i [i]] ;-- remove those values from ""from hand""
]
 
computer-turn: func [
    fhand ""from hand""
    thand ""to hand""
    kind  ""rank of cards""
    /local 
        a 
][
    a: ask rejoin [""Do you have any "" kind "" s? ""]
    if a = ""x"" [halt]
    either any [a = ""y"" a = ""yes""][
        check-for-books thand kind
        transfer-cards fhand thand kind
        show-cards
        computer-turn fhand thand guess-from thand cguesses
    ][  
        clear-and-show 0.4 gf 
        go-fish 1 thand   
        append cguesses kind 
    ]
]
 
player-turn: func [
    fhand ""from hand""
    thand ""to hand""
    kind  ""rank of cards""
    /local
        p 
][
    if empty? fhand [go-fish 3 fhand]
 
    if none? find-in thand kind [   ;-- player has to hold rank asked for
        clear-and-show 1.0 
        ""You have to have that rank in your hand to ask for it.^/Computers turn...""
        exit
    ]
 
    either find-in fhand kind [
        check-for-books thand kind
        transfer-cards fhand thand kind 
        show-cards
        if find-in thand kind [ 
            p: ask ""Your guess: ""
            either p = ""x"" [halt][player-turn fhand thand p]
            check-for-books thand p 
        ]
    ][
        clear-and-show 0.4 gf 
        go-fish 1 thand 
    ]
]
 
game-round: has [c p][
    print {
          -------------------
          -  COMPUTER TURN  -
          -------------------
          }
 
    if empty? chand [  ; computer has no more cards? fish 3 cards.
        go-fish 3 chand
        show-cards
    ]
    computer-turn phand chand c: guess-from chand cguesses
    check-for-books chand c
    show-cards
 
    print {
          -------------------
          -   PLAYER TURN   -
          -------------------
          }
 
    if empty? phand [   ;-- player has no more cards? fish 3 cards.
        go-fish 3 phand
        show-cards
    ]
    p: ask ""Your guess: ""
    either p = ""x"" [halt][player-turn chand phand find-in phand p]
    check-for-books phand p 
    show-cards
]
 
main: does [
    deck: shuffle make-deck
    deal-cards 9 chand
    deal-cards 9 phand
    show-cards
    while [cbooks + pbooks < 13][
        game-round  
    ]
    clear-and-show 0 """"
    print ""GAME OVER"" 
    print [newline ""Computer books:"" cbooks newline ""Player books:"" pbooks]
]
 
main",Human_written,Python_from_Go
http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number,Continued fraction/Arithmetic/Construct from rational number,"Continued fraction arithmetic
The purpose of this task is to write a function 





r
2
c
f


(

i
n
t



{\displaystyle {\mathit {r2cf}}(\mathrm {int} }

 




N

1


,

i
n
t



{\displaystyle N_{1},\mathrm {int} }

 




N

2


)


{\displaystyle N_{2})}

, or 





r
2
c
f


(

F
r
a
c
t
i
o
n



{\displaystyle {\mathit {r2cf}}(\mathrm {Fraction} }

 



N
)


{\displaystyle N)}

, which will output a continued fraction assuming:






N

1




{\displaystyle N_{1}}

 is the numerator





N

2




{\displaystyle N_{2}}

 is the denominator
The function should output its results one digit at a time each time it is called, in a manner sometimes described as lazy evaluation.

To achieve this it must determine: the integer part; and remainder part, of 




N

1




{\displaystyle N_{1}}

 divided by 




N

2




{\displaystyle N_{2}}

. It then sets 




N

1




{\displaystyle N_{1}}

 to 




N

2




{\displaystyle N_{2}}

 and 




N

2




{\displaystyle N_{2}}

 to the determined remainder part. It then outputs the determined integer part. It does this until 




a
b
s

(

N

2


)


{\displaystyle \mathrm {abs} (N_{2})}

 is zero.

Demonstrate the function by outputing the continued fraction for:

 1/2
 3
 23/8
 13/11
 22/7
 -151/77






2




{\displaystyle {\sqrt {2}}}

 should approach 



[
1
;
2
,
2
,
2
,
2
,
…
]


{\displaystyle [1;2,2,2,2,\ldots ]}

 try ever closer rational approximations until boredom gets the better of you:

 14142,10000
 141421,100000
 1414214,1000000
 14142136,10000000
Try :

 31,10
 314,100
 3142,1000
 31428,10000
 314285,100000
 3142857,1000000
 31428571,10000000
 314285714,100000000
Observe how this rational number behaves differently to 





2




{\displaystyle {\sqrt {2}}}

 and convince yourself that, in the same way as 



3.7


{\displaystyle 3.7}

 may be represented as 



3.70


{\displaystyle 3.70}

 when an extra decimal place is required, 



[
3
;
7
]


{\displaystyle [3;7]}

 may be represented as 



[
3
;
7
,
∞
]


{\displaystyle [3;7,\infty ]}

 when an extra term is required.
",Python,"class fraction:
	def __init__(self,num,den):
		self.num = num
		self.den = den
 
examples = [fraction(1,2), fraction(3,1), fraction(23,8), fraction(13,11), fraction(22,7), fraction(-151,77)]
sqrt2 = [fraction(14142,10000), fraction(141421,100000), fraction(1414214,1000000), fraction(14142136,10000000)]
pi = [fraction(31,10), fraction(314,100), fraction(3142,1000), fraction(31428,10000), fraction(314285,100000), fraction(3142857,1000000), fraction(31428571,10000000), fraction(314285714,100000000)]
 
def r2cf(numerator,denominator):
	quotient=0
	temp=0
 
	if(denominator!= 0):
		quotient = numerator / denominator
 
		temp = numerator
 
		numerator = denominator
		denominator = temp % denominator
 
	return quotient
 
def main():
	i=0
 
	print(""Running the examples :"")
 
	for i in range(0,len(examples)):
		print(""\nFor N = %d, D = %d :"" % (examples[i].num,examples[i].den))
 
		while(examples[i].den!= 0):
			print("" %d "" % r2cf(examples[i].num,examples[i].den))
 
	print(""\n\nRunning for %c2 :"" % 251) # 251 is the ASCII code for the square root symbol
 
	for i in range(0,len(sqrt2)):
		print(""\nFor N = %d, D = %d :"" % (sqrt2[i].num,sqrt2[i].den))
 
		while(sqrt2[i].den!= 0):
			print("" %d "" % r2cf(sqrt2[i].num,sqrt2[i].den))
 
	print(""\n\nRunning for %c :"" % 227) # 227 is the ASCII code for Pi's symbol
 
	for i in range(0,len(pi)):
		print(""\nFor N = %d, D = %d :"" % (pi[i].num,pi[i].den))
 
		while(pi[i].den!= 0):
			print("" %d "" % r2cf(pi[i].num,pi[i].den))
 
 
 
	return 0
 
main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Self_numbers,Self numbers,"A number n is a self number if there is no number g such that g + the sum of g's digits = n. So 18 is not a self number because 9+9=18, 43 is not a self number because 35+5+3=43.


The task is:

 Display the first 50 self numbers;
 I believe that the 100000000th self number is 1022727208. You should either confirm or dispute my conjecture.

224036583-1 is a Mersenne prime, claimed to also be a self number. Extra credit to anyone proving it.


See also
 
OEIS: A003052 - Self numbers or Colombian numbers
Wikipedia: Self numbers",Python,"import time
 
def sieve(sv):
    n = 0
    s = [0] * 8
    for a in range(2):
        for b in range(10):
            s[0] = a + b
            for c in range(10):
                s[1] = s[0] + c
                for d in range(10):
                    s[2] = s[1] + d
                    for e in range(10):
                        s[3] = s[2] + e
                        for f in range(10):
                            s[4] = s[3] + f
                            for g in range(10):
                                s[5] = s[4] + g
                                for h in range(10):
                                    s[6] = s[5] + h
                                    for i in range(10):
                                        s[7] = s[6] + i
                                        for j in range(10):
                                            sv[s[7] + j + n] = True
                                            n += 1
 
if __name__ == '__main__':
    count = 0
    begin = time.clock()
    sv = [False] * (2 * 10**9 + 9 * 9 + 1)
    sieve(sv)
    print(""The first 50 self numbers are:"")
    for i in range(len(sv)):
        if not sv[i]:
            count += 1
            if count <= 50:
                print(i, end=' ')
            if count == 100 * 10**6:
                print(""\n\nThe 100 millionth self number is"", i)
                break
    print(""Took"", time.clock() - begin, ""seconds."")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/De_Bruijn_sequences,de Bruijn sequences,"The sequences are named after the Dutch mathematician   Nicolaas Govert de Bruijn.



A note on Dutch capitalization:   Nicolaas' last name is   de Bruijn,   the   de   isn't normally capitalized
unless it's the first word in a sentence.   Rosetta Code (more or less by default or by fiat) requires the first word in the task name to be
capitalized.



In combinatorial mathematics,   a   de Bruijn sequence   of order    n    on
a    size-k    alphabet (computer science)    A    is a cyclic sequence in which every
possible    length-n    string (computer science, formal theory)   on    A    occurs
exactly once as a contiguous substring.

Such a sequence is denoted by    B(k, n)    and has
length   kn,   which is also the number of distinct substrings of
length   n   on   A;    

de Bruijn sequences are therefore optimally short.

There are:

                         (k!)k(n-1)   ÷   kn

distinct de Bruijn sequences    B(k, n). 



Task

For this Rosetta Code task,   a   de Bruijn   sequence is to be generated that can be used to shorten a brute-force attack on
a   PIN-like   code lock that does not have an ""enter""
key and accepts the last    n    digits entered.



Note:   automated teller machines (ATMs)   used to work like
this,   but their software has been updated to not allow a brute-force attack.



Example

A   digital door lock   with a 4-digit code would
have B (10, 4) solutions,   with a length of   10,000   (digits).

Therefore, only at most     10,000 + 3     (as the solutions are cyclic or wrap-around)   presses are needed to
open the lock.

Trying all 4-digit codes separately would require   4 × 10,000   or   40,000   presses.



Task requirements

   Generate a de Bruijn sequence for a 4-digit (decimal) PIN code.
   Show the length of the generated de Bruijn sequence.
   (There are many possible de Bruijn sequences that solve this task,   one solution is shown on the discussion page).
   Show the first and last   130   digits of the de Bruijn sequence.
   Verify that all four-digit (decimal)   1,000   PIN codes are contained within the de Bruijn sequence.
   0000, 0001, 0002, 0003,   ...   9996, 9997, 9998, 9999   (note the leading zeros).
   Reverse the de Bruijn sequence.
   Again, perform the (above) verification test.
   Replace the 4,444th digit with a period (.) in the original de Bruijn sequence.
   Perform the verification test (again).   There should be four PIN codes missing.


(The last requirement is to ensure that the verification tests performs correctly.   The verification processes should list
any and all missing PIN codes.)

Show all output here, on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

   Wikipedia entry:   de Bruijn sequence.
   MathWorld entry:   de Bruijn sequence.
   An  OEIS  entry:   A166315 lexicographically earliest binary de Bruijn sequences, B(2,n)     --- Not B(10,4),   but possibly relevant.

",Python,"# from https://en.wikipedia.org/wiki/De_Bruijn_sequence
 
def de_bruijn(k, n):
    """"""
    de Bruijn sequence for alphabet k
    and subsequences of length n.
    """"""
    try:
        # let's see if k can be cast to an integer;
        # if so, make our alphabet a list
        _ = int(k)
        alphabet = list(map(str, range(k)))
 
    except (ValueError, TypeError):
        alphabet = k
        k = len(k)
 
    a = [0] * k * n
    sequence = []
 
    def db(t, p):
        if t > n:
            if n % p == 0:
                sequence.extend(a[1:p + 1])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            for j in range(a[t - p] + 1, k):
                a[t] = j
                db(t + 1, t)
    db(1, 1)
    return """".join(alphabet[i] for i in sequence)
 
def validate(db):
    """"""
 
    Check that all 10,000 combinations of 0-9 are present in 
    De Bruijn string db.
 
    Validating the reversed deBruijn sequence:
      No errors found
 
    Validating the overlaid deBruijn sequence:
      4 errors found:
        PIN number 1459 missing
        PIN number 4591 missing
        PIN number 5814 missing
        PIN number 8145 missing
 
    """"""
 
    dbwithwrap = db+db[0:3]
 
    digits = '0123456789'
 
    errorstrings = []
 
    for d1 in digits:
        for d2 in digits:
            for d3 in digits:
                for d4 in digits:
                    teststring = d1+d2+d3+d4
                    if teststring not in dbwithwrap:
                        errorstrings.append(teststring)
 
    if len(errorstrings) > 0:
        print(""  ""+str(len(errorstrings))+"" errors found:"")
        for e in errorstrings:
            print(""  PIN number ""+e+""  missing"")
    else:
        print(""  No errors found"")
 
db = de_bruijn(10, 4)
 
print("" "")
print(""The length of the de Bruijn sequence is "", str(len(db)))
print("" "")
print(""The first 130 digits of the de Bruijn sequence are: ""+db[0:130])
print("" "")
print(""The last 130 digits of the de Bruijn sequence are: ""+db[-130:])
print("" "")
print(""Validating the deBruijn sequence:"")
validate(db)
dbreversed = db[::-1]
print("" "")
print(""Validating the reversed deBruijn sequence:"")
validate(dbreversed)
dboverlaid = db[0:4443]+'.'+db[4444:]
print("" "")
print(""Validating the overlaid deBruijn sequence:"")
validate(dboverlaid)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Sum_and_product_of_an_array,Sum and product of an array,"Task

Compute the sum and product of an array of integers.



",Python,"import operator
arg = [1, 2, 3, 4, 5]
sum = reduce(operator.add, arg, 0)
prod = reduce(operator.mul, arg, 1)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/First-class_functions,First-class functions,"A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

 Create new functions from preexisting functions at run-time
 Store functions in collections
 Use functions as arguments to other functions
 Use functions as return values of other functions


Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections ""A"" and ""B"". These names are only used in the preceding paragraph for clarity.)



Related task
 
First-class Numbers
",Python,"from typing import Callable, List
 
def compose(f: Callable[[float], float], g: Callable[[float], float]) -> Callable[[float], float]:
    return lambda x: g(f(x))
 
def main():
    cube      = lambda x: x ** 3
    cube_root = lambda x: x ** (1.0 / 3.0)
 
    flist  : List[Callable[[float], float]] = [cube    , lambda x: x.sin(), lambda x: x.cos() ]
    invlist: List[Callable[[float], float]] = [cube_root, lambda x: x.asin(), lambda x: x.acos()]
 
    result = [compose(f, i)(0.5) for f, i in zip(flist, invlist)]
 
    print(result)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",Python,"str = ""你好""
str.include?(""好"") # => true",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",Python,"def shell(seq):
    inc = len(seq) // 2
    while inc:
        for i, el in enumerate(seq[inc:], inc):
            while i >= inc and seq[i - inc] > el:
                seq[i] = seq[i - inc]
                i -= inc
            seq[i] = el
        inc = 1 if inc == 2 else inc * 5 // 11",Human_written,Python_from_Java
http://rosettacode.org/wiki/Copy_a_string,Copy a string,"This task is about copying a string.



Task

Where it is relevant, distinguish between copying the contents of a string
versus making an additional reference to an existing string.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> src = ""hello""
>>> a = src
>>> b = src[:]
>>> import copy
>>> c = copy.copy(src)
>>> d = copy.deepcopy(src)
>>> src is a is b is c is d
True",Human_written,Python_from_C#
http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously,Loop over multiple arrays simultaneously,"Task

Loop over multiple arrays   (or lists or tuples or whatever they're called in
your language)   and display the    i th    element of each.

Use your language's   ""for each""   loop if it has one, otherwise iterate
through the collection in order with some other loop.



For this example, loop over the arrays:

    (a,b,c)
    (A,B,C) 
    (1,2,3) 

to produce the output:

    aA1
    bB2
    cC3



If possible, also describe what happens when the arrays are of different lengths.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"ls = ['a', 'b', 'c']
us = ['A', 'B', 'C']
ns = [1, 2, 3]
 
lIt = 0
uIt = 0
nIt = 0
while lIt < len(ls) and uIt < len(us) and nIt < len(ns):
    print ls[lIt], us[uIt], ns[nIt]
    lIt += 1
    uIt += 1
    nIt += 1",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Look-and-say_sequence,Look-and-say sequence,"The   Look and say sequence   is a recursively defined sequence of numbers studied most notably by   John Conway.



The   look-and-say sequence   is also known as the   Morris Number Sequence,   after cryptographer Robert Morris,   and the puzzle   What is the next number in the sequence 1,   11,   21,   1211,   111221?   is sometimes referred to as the Cuckoo's Egg,   from a description of Morris in Clifford Stoll's book   The Cuckoo's Egg.


Sequence Definition

 Take a decimal number
 Look at the number, visually grouping consecutive runs of the same digit.
 Say the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.
 This becomes the next number of the sequence.

An example:

 Starting with the number 1,   you have one 1 which produces 11
 Starting with 11,   you have two 1's.   I.E.:   21
 Starting with 21,   you have one 2, then one 1.   I.E.:   (12)(11) which becomes 1211
 Starting with 1211,   you have one 1, one 2, then two 1's.   I.E.:   (11)(12)(21) which becomes 111221


Task

Write a program to generate successive members of the look-and-say sequence.



Related tasks

   Fours is the number of letters in the ...
   Number names
   Self-describing numbers
   Self-referential sequence
   Spelling of ordinal numbers


See also

   Look-and-Say Numbers (feat John Conway), A Numberphile Video.
   This task is related to, and an application of, the Run-length encoding task.
   Sequence A005150 on The On-Line Encyclopedia of Integer Sequences.

",Python,"import sys

def main():
    a = ""1""
    b = """"
    while True:
        print(a)
        len = 0
        cnt = 1
        for i in range(len(a)):
            if a[i] == a[i+1]:
                cnt += 1
            else:
                b += str(cnt) + a[i]
                cnt = 1
        a = b
        b = """"

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Long_primes,Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",Python,"from itertools import count
 
def primes(lim):
    flags = [False] * (lim + 1)
    j = 2
    for d in count(3, 2):
        if d * d > lim:
            break
        if not flags[j]:
            yield j
            for k in range(j * j, lim + 1, j):
                flags[k] = True
        j += 1
    for j in range(j, lim + 1):
        if not flags[j]:
            yield j
 
def main():
    primes_gen = primes(64000)
    next(primes_gen)
    primes_gen = (p for p in primes_gen if period(p) == p - 1)
    print(' '.join(str(p) for p in primes_gen))
    count = 0
    limit = 500
    for prime in primes_gen:
        if prime > limit:
            print(f'There are {count} long primes below {limit}')
            limit *= 2
        count += 1
 
def period(n):
    r = 1
    for i in range(n + 1):
        r = (10 * r) % n
    rr = r
    for period in count(1):
        r = (10 * r) % n
        if r == rr:
            return period
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Dutch_national_flag_problem,Dutch national flag problem,"
The Dutch national flag is composed of three coloured bands in the order:

   red     (top)
   then white,   and
   lastly blue   (at the bottom). 


The problem posed by Edsger Dijkstra is:

Given a number of red, blue and white balls in random order, arrange them in the order of the colours in the Dutch national flag.
When the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...



Task
 Generate a randomized order of balls ensuring that they are not in the order of the Dutch national flag.
 Sort the balls in a way idiomatic to your language.
 Check the sorted balls are in the order of the Dutch national flag.


C.f.

 Dutch national flag problem
 Probabilistic analysis of algorithms for the Dutch national flag problem by Wei-Mei Chen. (pdf)

",Python,"import random
 
def is_sorted(list):
    state = ""Red""
    for current in list:
        if current[0] < state:
            return False
        if current[0] > state:
            state = current[0]
    return True
 
colors = []
for _ in range(10):
    r = random.randint(0, 2)
    if r == 0:
        colors.append((""Red"", 1))
    elif r == 1:
        colors.append((""White"", 2))
    elif r == 2:
        colors.append((""Blue"", 3))
 
while is_sorted(colors):
    random.shuffle(colors)
 
print(""Before: {}"".format(colors))
colors.sort(key=lambda x: x[0])
print(""After:  {}"".format(colors))
if not is_sorted(colors):
    print(""Oops, did not sort colors correctly!"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Old_lady_swallowed_a_fly,Old lady swallowed a fly,"Task

Present a program which emits the lyrics to the song   I Knew an Old Lady Who Swallowed a Fly,   taking advantage of the repetitive structure of the song's lyrics. 

This song has multiple versions with slightly different lyrics, so all these programs might not emit identical output.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.1.3
 
animals = [""fly"", ""spider"", ""bird"", ""cat"",""dog"", ""goat"", ""cow"", ""horse""]
 
phrases = [
    """",
    ""That wriggled and jiggled and tickled inside her"",
    ""How absurd to swallow a bird"",
    ""Fancy that to swallow a cat"",
    ""What a hog, to swallow a dog"",
    ""She just opened her throat and swallowed a goat"",
    ""I don't know how she swallowed a cow"",
    ""\n ...She's dead of course""
]
 
def sing():
    for i in range(0, 8):
       print(""There was an old lady who swallowed a {0};"".format(animals[i]))
       if i > 0: print(""{0}!"".format(phrases[i]))
       if i == 7: return
       print()                  
       if i > 0:
           for j in range(i, 0, -1):
               print(""  She swallowed the {0} to catch the {1}{2}"".format(animals[j], animals[j - 1], "";"" if j < 3 else "",""))
               if j == 2: print(""  {0}!"".format(phrases[1]))               
       print(""  I don't know why she swallowed a fly - Perhaps she'll die!\n"")
 
if __name__ == ""__main__"":
    sing()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Topological_sort,Topological sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon.

The compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on.

A tool exists that extracts library dependencies.



Task

Write a function that will return a valid compile order of VHDL libraries from their dependencies.

 Assume library names are single words. 
 Items mentioned as only dependents, (sic), have no dependents of their own, but their order of compiling must be given.
 Any self dependencies should be ignored. 
 Any un-orderable dependencies should be flagged.


Use the following data as an example:

LIBRARY          LIBRARY DEPENDENCIES
=======          ====================
des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
dw01             ieee dw01 dware gtech
dw02             ieee dw02 dware
dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
dw04             dw04 ieee dw01 dware gtech
dw05             dw05 ieee dware
dw06             dw06 ieee dware
dw07             ieee dware
dware            ieee dware
gtech            ieee gtech
ramlib           std ieee
std_cell_lib     ieee std_cell_lib
synopsys


Note: the above data would be un-orderable if, for example, dw04 is added to the list of dependencies of dw01.



C.f.

   Topological sort/Extracted top item.


There are two popular algorithms for topological sorting:

   Kahn's 1962 topological sort [1] 
   depth-first search [2] [3]

",Python,"import java.util.*;
 
public class TwoSum {
 
    public static void main(String[] args) {
        nums = [2, 7, 11, 15]
        target = 9
 
        print(twoSum(nums, target))
    }
 
    def twoSum(nums, target):
        map = {}
 
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in map:
                return [map[complement], i]
            map[nums[i]] = i
        raise Exception(""No two sum solution"")
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Square-free_integers,Square-free integers,"Task

Write a function to test if a number is   square-free.



A   square-free   is an integer which is divisible by no perfect square other
than   1   (unity).

For this task, only positive square-free numbers will be used.



Show here (on this page) all square-free integers (in a horizontal format) that are between:

   1   ───►   145     (inclusive)
   1 trillion   ───►   1 trillion + 145     (inclusive)


(One trillion = 1,000,000,000,000)



Show here (on this page) the count of square-free integers from:

   1   ───►   one hundred     (inclusive)
   1   ───►   one thousand     (inclusive)
   1   ───►   ten thousand     (inclusive)
   1   ───►   one hundred thousand     (inclusive)
   1   ───►   one million     (inclusive)


See also

   the Wikipedia entry:   square-free integer

",Python,"def square_free(n):
    if n & 3 == 0:
        return False
    p = 3
    while p * p <= n:
        count = 0
        while n % p == 0:
            count += 1
            if count > 1:
                return False
            n //= p
        p += 2
    return True
 
def print_square_free_numbers(from, to):
    print(""Square-free numbers between {} and {}:"".format(from, to))
    line = """"
    for i in range(from, to + 1):
        if square_free(i):
            if line:
                line += "" ""
            line += str(i)
            if len(line) >= 80:
                print(line)
                line = """"
    if line:
        print(line)
 
def print_square_free_count(from, to):
    count = 0
    for i in range(from, to + 1):
        if square_free(i):
            count += 1
    print(""Number of square-free numbers between {} and {}: {}"".format(from, to, count))
 
print_square_free_numbers(1, 145)
print_square_free_numbers(1000000000000, 1000000000145)
n = 100
while n <= 1000000:
    print_square_free_count(1, n)
    n *= 10",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Average_loop_length,Average loop length,"Let f be a uniformly-randomly chosen mapping from the numbers 1..N to the numbers 1..N (note: not necessarily a permutation of 1..N; the mapping could produce a number in more than one way or not at all). At some point, the sequence 1, f(1), f(f(1))... will contain a repetition, a number that occurring for the second time in the sequence.



Task

Write a program or a script that estimates, for each N, the average length until the first such repetition.

Also calculate this expected length using an analytical formula, and optionally compare the simulated result with the theoretical one.



This problem comes from the end of Donald Knuth's Christmas tree lecture 2011.

Example of expected output:

 N    average    analytical    (error)
===  =========  ============  =========
  1     1.0000        1.0000  (  0.00%)
  2     1.4992        1.5000  (  0.05%)
  3     1.8784        1.8889  (  0.56%)
  4     2.2316        2.2188  (  0.58%)
  5     2.4982        2.5104  (  0.49%)
  6     2.7897        2.7747  (  0.54%)
  7     3.0153        3.0181  (  0.09%)
  8     3.2429        3.2450  (  0.07%)
  9     3.4536        3.4583  (  0.14%)
 10     3.6649        3.6602  (  0.13%)
 11     3.8091        3.8524  (  1.12%)
 12     3.9986        4.0361  (  0.93%)
 13     4.2074        4.2123  (  0.12%)
 14     4.3711        4.3820  (  0.25%)
 15     4.5275        4.5458  (  0.40%)
 16     4.6755        4.7043  (  0.61%)
 17     4.8877        4.8579  (  0.61%)
 18     4.9951        5.0071  (  0.24%)
 19     5.1312        5.1522  (  0.41%)
 20     5.2699        5.2936  (  0.45%)

",Python,"from __future__ import division # Only necessary for Python 2.X
from math import factorial
from random import randrange
 
MAX_N = 20
TIMES = 1000000
 
def analytical(n):
	return sum(factorial(n) / pow(n, i) / factorial(n -i) for i in range(1, n+1))
 
def test(n, times):
    count = 0
    for i in range(times):
        x, bits = 1, 0
        while not (bits & x):
            count += 1
            bits |= x
            x = 1 << randrange(n)
    return count / times
 
if __name__ == '__main__':
    print("" n\tavg\texp.\tdiff\n-------------------------------"")
    for n in range(1, MAX_N+1):
        avg = test(n, TIMES)
        theory = analytical(n)
        diff = (avg / theory - 1) * 100
        print(""%2d %8.4f %8.4f %6.3f%%"" % (n, avg, theory, diff))",Human_written,Python_from_Ruby
"http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications","Abundant, deficient and perfect number classifications","These define three classifications of positive integers based on their   proper divisors.

Let   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.

   if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
   if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
   if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).



Example

6   has proper divisors of   1,   2,   and   3.

1 + 2 + 3 = 6,   so   6   is classed as a perfect number.



Task

Calculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.

Show the results here.



Related tasks

   Aliquot sequence classifications.   (The whole series from which this task is a subset.)
   Proper divisors
   Amicable pairs

",Python,">>> from proper_divisors import proper_divs
>>> from collections import Counter
>>> 
>>> rangemax = 20000
>>> 
>>> def pdsum(n):
...     return sum(proper_divs(n))
... 
>>> def classify(n, p):
...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'
... 
>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))
>>> classes.most_common()
[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Elementary_cellular_automaton/Random_Number_Generator,Elementary cellular automaton/Random Number Generator,"Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.

Steven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.

The purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.

You can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.

For extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.

Reference

 Cellular automata: Is Rule 30 random? (PDF).

",Python,"from elementary_cellular_automaton import eca, eca_wrap
 
def rule30bytes(lencells=100):
    cells = '1' + '0' * (lencells - 1)
    gen = eca(cells, 30)
    while True:
        yield int(''.join(next(gen)[0] for i in range(8)), 2)
 
if __name__ == '__main__':
    print([b for i,b in zip(range(10), rule30bytes())])",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",Python,">>> import time
>>> time.asctime(time.gmtime(0))
'Thu Jan  1 00:00:00 1970'
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Zhang-Suen_thinning_algorithm,Zhang-Suen thinning algorithm,"This is an algorithm used to thin a black and white i.e. one bit per pixel images.

For example, with an input image of:

                                                           
 #################                   #############         
 ##################               ################         
 ###################            ##################         
 ########     #######          ###################         
   ######     #######         #######       ######         
   ######     #######        #######                       
   #################         #######                       
   ################          #######                       
   #################         #######                       
   ######     #######        #######                       
   ######     #######        #######                       
   ######     #######         #######       ######         
 ########     #######          ###################         
 ########     ####### ######    ################## ######  
 ########     ####### ######      ################ ######  
 ########     ####### ######         ############# ######  
                                                           
It produces the thinned output:

                                                           
                                                           
    # ##########                       #######             
     ##        #                   ####       #            
     #          #                 ##                       
     #          #                #                         
     #          #                #                         
     #          #                #                         
     ############               #                          
     #          #               #                          
     #          #                #                         
     #          #                #                         
     #          #                #                         
     #                            ##                       
     #                             ############            
                       ###                          ###    
                                                           
                                                           
Algorithm

Assume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes.

The algorithm operates on all black pixels P1 that can have eight neighbours.

The neighbours are, in order, arranged as:


   P9      P2      P3   
   P8      P1      P4   
   P7      P6      P5   



Obviously the boundary pixels of the image cannot have the full eight neighbours.

 Define 



A
(
P
1
)


{\displaystyle A(P1)}

 = the number of transitions from white to black, (0 -> 1) in the sequence P2,P3,P4,P5,P6,P7,P8,P9,P2. (Note the extra P2 at the end - it is circular).
 Define 



B
(
P
1
)


{\displaystyle B(P1)}

 = The number of black pixel neighbours of P1. ( = sum(P2 .. P9) )


Step 1

All pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.

 (0) The pixel is black and has eight neighbours
 (1) 



2
<=
B
(
P
1
)
<=
6


{\displaystyle 2<=B(P1)<=6}


 (2) A(P1) = 1
 (3) At least one of P2 and P4 and P6 is white
 (4) At least one of P4 and P6 and P8 is white
After iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.



Step 2

All pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.

 (0) The pixel is black and has eight neighbours
 (1) 



2
<=
B
(
P
1
)
<=
6


{\displaystyle 2<=B(P1)<=6}


 (2) A(P1) = 1
 (3) At least one of P2 and P4 and P8 is white
 (4) At least one of P2 and P6 and P8 is white
After iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.



Iteration

If any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.



Task

 Write a routine to perform Zhang-Suen thinning on an image matrix of ones and zeroes.
 Use the routine to thin the following image and show the output here on this page as either a matrix of ones and zeroes, an image, or an ASCII-art image of space/non-space characters. 
          00000000000000000000000000000000
          01111111110000000111111110000000
          01110001111000001111001111000000
          01110000111000001110000111000000
          01110001111000001110000000000000
          01111111110000001110000000000000
          01110111100000001110000111000000
          01110011110011101111001111011100
          01110001111011100111111110011100
          00000000000000000000000000000000



Reference

 Zhang-Suen Thinning Algorithm, Java Implementation by Nayef Reza.
 ""Character Recognition Systems: A Guide for Students and Practitioners"" By Mohamed Cheriet, Nawwaf Kharma, Cheng-Lin Liu, Ching Suen

",Python,"#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    int rows, columns;
    char blank, image;
    int i, j;

    scanf(""%d %d"", &rows, &columns);
    scanf("" %c %c"", &blank, &image);

    for (i = 0; i < rows; i++) {
        for (j = 0; j < columns; j++) {
            if ((i + j) % 2 == 0) {
                printf(""%c"", blank);
            } else {
                printf(""%c"", image);
            }
        }
        printf(""\n"");
    }

    return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",Python,"print(""""""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
"""""")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort,Sorting algorithms/Sleep sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.
",Python,"import threading
import time
import sys

def sleep_sort_and_print(nums):
    done_signal = threading.Event()
    for num in nums:
        t = threading.Thread(target=lambda: done_signal.wait() or time.sleep(num) or print(num))
        t.start()
    done_signal.set()

if __name__ == '__main__':
    nums = [int(arg) for arg in sys.argv[1:]]
    sleep_sort_and_print(nums)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Super-d_numbers,Super-d numbers,"A super-d number is a positive, decimal (base ten) integer   n   such that   d × nd   has at least   d   consecutive digits   d   where

   2 ≤ d ≤ 9

For instance, 753 is a super-3 number because 3 × 7533 = 1280873331.


Super-d   numbers are also shown on   MathWorld™   as   super-d    or   super-d.



Task

 Write a function/procedure/routine to find super-d numbers.
 For   d=2   through   d=6,   use the routine to show the first   10   super-d numbers.


Extra credit

 Show the first   10   super-7, super-8, and/or super-9 numbers   (optional).


See also

   Wolfram MathWorld - Super-d Number.
   OEIS: A014569 - Super-3 Numbers.

",Python,"from itertools import islice, count
 
def superd(d):
    if d != int(d) or not 2 <= d <= 9:
        raise ValueError(""argument must be integer from 2 to 9 inclusive"")
    tofind = str(d) * d
    for n in count(2):
        if tofind in str(d * n ** d):
            yield n
 
if __name__ == '__main__':
    for d in range(2, 9):
        print(f""{d}:"", ', '.join(str(n) for n in islice(superd(d), 10)))",Human_written,Python_from_C
http://rosettacode.org/wiki/Aliquot_sequence_classifications,Aliquot sequence classifications,"An aliquot sequence of a positive integer K is defined recursively as the first member
being K and subsequent members being the sum of the Proper divisors of the previous term.

 If the terms eventually reach 0 then the series for K is said to terminate.

There are several classifications for non termination:
 If the second term is K then all future terms are also K and so the sequence repeats from the first term with period 1 and K is called perfect.
 If the third term would be repeating K then the sequence repeats with period 2 and K is called amicable.
 If the Nth term would be repeating K for the first time, with N > 3 then the sequence repeats with period N - 1 and K is called sociable.

Perfect, amicable and sociable numbers eventually repeat the original number K; there are other repetitions...
 Some K have a sequence that eventually forms a periodic repetition of period 1 but of a number other than K, for example 95 which forms the sequence 95, 25, 6, 6, 6, ... such K are called aspiring.
 K that have a sequence that eventually forms a periodic repetition of period >= 2 but of a number other than K, for example 562 which forms the sequence 562, 284, 220, 284, 220, ... such K are called cyclic.

And finally:
 Some K form aliquot sequences that are not known to be either terminating or periodic; these K are to be called non-terminating. 
For the purposes of this task, K is to be classed as non-terminating if it has not been otherwise classed after generating 16 terms or if any term of the sequence is greater than 2**47 = 140,737,488,355,328. 


Task

 Create routine(s) to generate the aliquot sequence of a positive integer enough to classify it according to the classifications given above.
 Use it to display the classification and sequences of the numbers one to ten inclusive.
 Use it to show the classification and sequences of the following integers, in order:
 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488, and optionally 15355717786080.
Show all output on this page.



Related tasks

   Abundant, deficient and perfect number classifications. (Classifications from only the first two members of the whole sequence).
   Proper divisors
   Amicable pairs

",Python,"import math
import sys
 
threshold = 1 << 47
 
def indexOf(s, search):
    for i, e in enumerate(s):
        if e == search:
            return i
    return -1
 
def contains(s, search):
    return indexOf(s, search) > -1
 
def maxOf(i1, i2):
    if i1 > i2:
        return i1
    return i2
 
def sumProperDivisors(n):
    if n < 2:
        return 0
    sqrt = int(math.sqrt(n))
    sum = 1
    for i in range(2, sqrt + 1):
        if n % i!= 0:
            continue
        sum += i + n // i
    if sqrt * sqrt == n:
        sum -= sqrt
    return sum
 
def classifySequence(k):
    if k == 0:
        raise ValueError(""Argument must be positive."")
    last = k
    seq = [k]
    while True:
        last = sumProperDivisors(last)
        seq.append(last)
        n = len(seq)
        aliquot = """"
        if last == 0:
            aliquot = ""Terminating""
        elif n == 2 and last == k:
            aliquot = ""Perfect""
        elif n == 3 and last == k:
            aliquot = ""Amicable""
        elif n >= 4 and last == k:
            aliquot = ""Sociable[%d]"" % (n - 1)
        elif last == seq[n - 2]:
            aliquot = ""Aspiring""
        elif contains(seq[1 : maxOf(1, n - 2)], last):
            aliquot = ""Cyclic[%d]"" % (n - 1 - indexOf(seq, last))
        elif n == 16 or last > threshold:
            aliquot = ""Non-Terminating""
        if aliquot!= """":
            return seq, aliquot
 
def joinWithCommas(seq):
    res = str(seq)
    res = res.replace("" "", "", "")
    return res
 
if __name__ == ""__main__"":
    print(""Aliquot classifications - periods for Sociable/Cyclic in square brackets:\n"")
    for k in range(1, 11):
        seq, aliquot = classifySequence(k)
        print(""%2d: %-15s %s"" % (k, aliquot, joinWithCommas(seq)))
    print()
 
    s = [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]
    for k in s:
        seq, aliquot = classifySequence(k)
        print(""%7d: %-15s %s"" % (k, aliquot, joinWithCommas(seq)))
    print()
 
    k = 15355717786080
    seq, aliquot = classifySequence(k)
    print(""%d: %-15s %s"" % (k, aliquot, joinWithCommas(seq)))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Python,"width = int(raw_input(""Width of myarray: ""))
height = int(raw_input(""Height of Array: ""))
myarray = [[0] * width for i in range(height)]
myarray[0][0] = 3.5
print (myarray[0][0])",Human_written,Python_from_C#
http://rosettacode.org/wiki/Happy_numbers,Happy numbers,"From Wikipedia, the free encyclopedia:

 A happy number is defined by the following process:
 Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals   1   (where it will stay),   or it loops endlessly in a cycle which does not include   1.   


 Those numbers for which this process end in   1   are       happy   numbers,   
 while   those numbers   that   do   not   end in   1   are   unhappy   numbers. 


Task

Find and print the first   8   happy numbers.

Display an example of your output here on this page.



See also

   The OEIS entry:   The     happy numbers:   A007770
   The OEIS entry:   The unhappy numbers;   A031177

",Python,"def main():
	for i in range(10):
		print i,
	print
 
if __name__ == '__main__':
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",Python,"majors   = 'north east south west'.split()
majors   *= 2 # no need for modulo later
quarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')
quarter2 = [p.replace('NE','EN') for p in quarter1]
 
def degrees2compasspoint(d):
    d = (d % 360) + 360/64
    majorindex, minor = divmod(d, 90.)
    majorindex = int(majorindex)
    minorindex  = int( (minor*4) // 45 )
    p1, p2 = majors[majorindex: majorindex+2]
    if p1 in {'north', 'south'}:
        q = quarter1
    else:
        q = quarter2
    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()
 
if __name__ == '__main__':
    for i in range(33):
        d = i * 11.25
        m = i % 3
        if   m == 1: d += 5.62
        elif m == 2: d -= 5.62
        n = i % 32 + 1
        print( '%2i %-18s %7.2f°' % (n, degrees2compasspoint(d), d) )",Human_written,Python_from_C++
http://rosettacode.org/wiki/Animation,Animation,"
Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.



Task

Create a window containing the string ""Hello World! "" (the trailing space is significant).

Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front.

When the user clicks on the (windowed) text, it should reverse its direction.



",Python,"#!/usr/bin/env python3
import sys
 
from PyQt5.QtCore import QBasicTimer, Qt
from PyQt5.QtGui import QFont
from PyQt5.QtWidgets import QApplication, QLabel
 
 
class Marquee(QLabel):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.right_to_left_direction = True
        self.initUI()
        self.timer = QBasicTimer()
        self.timer.start(80, self)
 
    def initUI(self):
        self.setWindowFlags(Qt.FramelessWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setText(""Hello World! "")
        self.setFont(QFont(None, 50, QFont.Bold))
        # make more irritating for the authenticity with <marquee> element
        self.setStyleSheet(""QLabel {color: cyan; }"")
 
    def timerEvent(self, event):
        i = 1 if self.right_to_left_direction else -1
        self.setText(self.text()[i:] + self.text()[:i])  # rotate
 
    def mouseReleaseEvent(self, event):  # change direction on mouse release
        self.right_to_left_direction = not self.right_to_left_direction
 
    def keyPressEvent(self, event):  # exit on Esc
        if event.key() == Qt.Key_Escape:
            self.close()
 
 
app = QApplication(sys.argv)
w = Marquee()
# center widget on the screen
w.adjustSize()  # update w.rect() now
w.move(QApplication.instance().desktop().screen().rect().center()
       - w.rect().center())
w.show()
sys.exit(app.exec())",Human_written,Python_from_C
http://rosettacode.org/wiki/Monte_Carlo_methods,Monte Carlo methods,"A Monte Carlo Simulation is a way of approximating the value of a function
where calculating the actual value is difficult or impossible. 

It uses random sampling to define constraints on the value
and then makes a sort of ""best guess.""

A simple Monte Carlo Simulation can be used to calculate the value for 



π


{\displaystyle \pi }

.

If you had a circle and a square where the length of a side of the square
was the same as the diameter of the circle, the ratio of the area of the circle
to the area of the square would be 



π

/

4


{\displaystyle \pi /4}

.

So, if you put this circle inside the square and select many random points
inside the square, the number of points inside the circle
divided by the number of points inside the square and the circle
would be approximately 



π

/

4


{\displaystyle \pi /4}

.



Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number 



π


{\displaystyle \pi }

 is not built-in,
we give 



π


{\displaystyle \pi }

 as a number of digits:

            3.141592653589793238462643383280


",Python,">>> import random, math
>>> throws = 1000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1520000000000001
>>> throws = 1000000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1396359999999999
>>> throws = 100000000
>>> 4.0 * sum(math.hypot(*[random.random()*2-1
	                 for q in [0,1]]) < 1
              for p in xrange(throws)) / float(throws)
3.1415666400000002",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort,Sorting algorithms/Merge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The   merge sort   is a recursive sort of order    n*log(n). 

It is notable for having a worst case and average complexity of    O(n*log(n)),    and a best case complexity of    O(n)    (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements   (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its   divide and conquer   description.



Task

Write a function to sort a collection of integers using the merge sort.



The merge sort algorithm comes in two parts:

   a sort function     and 
   a merge function 

The functions in pseudocode look like this:

function mergesort(m)
   var list left, right, result
   if length(m) ≤ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ≤ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ≤ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result



See also

   the Wikipedia entry:    merge sort


Note:   better performance can be expected if, rather than recursing until    length(m) ≤ 1,    an insertion sort is used for    length(m)    smaller than some threshold larger than   1.   However, this complicates the example code, so it is not shown here.



",Python,"from heapq import merge
 
def merge_sort(m):
    if len(m) <= 1:
        return m
 
    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]
 
    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))",Human_written,Python_from_C
http://rosettacode.org/wiki/Associative_array/Iteration,Associative array/Iteration,"Show how to iterate over the key-value pairs of an associative array, and print each pair out.

Also show how to iterate just over the keys, or the values, if there is a separate way to do that in your language.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"myDict = { ""hello"": 13,
	   ""world"": 31,
	   ""!""    : 71 }
 
# iterating over key-value pairs:
for key, value in myDict.items():
    print (""key = %s, value = %s"" % (key, value))
 
# iterating over keys:
for key in myDict:
    print (""key = %s"" % key)
# (is a shortcut for:)
for key in myDict.keys():
    print (""key = %s"" % key)
 
# iterating over values:
for value in myDict.values():
    print (""value = %s"" % value)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Mutual_recursion,Mutual recursion,"Two functions are said to be mutually recursive if the first calls the second,
and in turn the second calls the first.

Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:










F
(
0
)



=
1
 
;
 
M
(
0
)
=
0




F
(
n
)



=
n
−
M
(
F
(
n
−
1
)
)
,

n
>
0




M
(
n
)



=
n
−
F
(
M
(
n
−
1
)
)
,

n
>
0.






{\displaystyle {\begin{aligned}F(0)&=1\ ;\ M(0)=0\\F(n)&=n-M(F(n-1)),\quad n>0\\M(n)&=n-F(M(n-1)),\quad n>0.\end{aligned}}}





(If a language does not allow for a solution using mutually recursive functions
then state this rather than give a solution by other means).



",Python,"def F(n): return 1 if n == 0 else n - M(F(n-1))
def M(n): return 0 if n == 0 else n - F(M(n-1))
 
print ([ F(n) for n in range(20) ])
print ([ M(n) for n in range(20) ])",Human_written,Python_from_Go
http://rosettacode.org/wiki/Logical_operations,Logical operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Write a function that takes two logical (boolean) values, and outputs the result of ""and"" and ""or"" on both arguments as well as ""not"" on the first arguments.

If the programming language doesn't provide a separate type for logical values, use the type most commonly used for that purpose.

If the language supports additional logical operations on booleans such as XOR, list them as well.



",Python,"def logic(a, b):
    print('a and b:', a and b)
    print('a or b:', a or b)
    print('not a:', not a)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Josephus_problem,Josephus problem,"Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.

An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

,
removing every 



k


{\displaystyle k}

-th prisoner and killing him.

As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >

For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.



Task

Given any   



n
,
k
>
0


{\displaystyle n,k>0}

,   find out which prisoner will be the final survivor.

In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).

Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.

Which number was he?



Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free,

and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.

Provide a way to calculate which prisoner is at any given position on the killing sequence.



Notes

 You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way. This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

. However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
 If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
 An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.

",Python,"import sys
n = int(sys.argv[1]) if len(sys.argv) > 1 else 41
k = int(sys.argv[2]) if len(sys.argv) > 2 else 3
 
prisoners = range(n)
while len(prisoners) > 1:
    prisoners = prisoners[k-1:] + prisoners[:k-1]
    prisoners.pop(0)
print prisoners[0]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Spinning_rod_animation/Text,Spinning rod animation/Text,"Task

An animation with the following frames in the following order (if certain characters aren't available or can't be used correctly in the programming language, alternate characters can replace any of these frames) must animate with a delay of 0.25 seconds between each frame, with the previous frame being cleared before the next frame appears: 

   |
   /
   - or ─
   \



A stand-alone version that loops and/or a version that doesn't loop can be made. These examples can also be converted into a system used in game development which is called on a HUD or GUI element requiring it to be called each frame to output the text, and advance the frame when the frame delay has passed. You can also use alternate text such as the . animation ( . | .. | ... | .. | repeat from . ) or the logic can be updated to include a ping/pong style where the frames advance forward, reach the end and then play backwards and when they reach the beginning they start over ( technically, you'd stop one frame prior to prevent the first frame playing twice, or write it another way ).



There are many different ways you can incorporate text animations. Here are a few text ideas - each frame is in quotes. If you can think of any, add them to this page! There are 2 examples for several of these; the first is the base animation with only unique sets of characters. The second consists of the primary set from a - n and doubled, minus the first and last element ie: We only want the center. This way an animation can play forwards, and then in reverse ( ping ponging ) without having to code that feature. For the animations with 3 elements, we only add 1, the center. with 4, it becomes 6. with 10, it becomes 18.



We don't need the second option for some of the animations if they connect smoothly, when animated, back to the first element. ... doesn't connect with . cleanly - there is a large leap. The rotating pipe meets the first perfectly so it isn't necessary, etc..





   Dots - Option A requires ping / pong enabled script. Option B just adds the elements in the center.
   '.', '..', '...'
   '.', '..', '...', '..'
   Pipe - This has the uniform sideways pipe instead of a hyphen to prevent non-uniform sizing.
   '|', '/', '─', '\'
   Stars - Option A requires ping / pong enabled script. Option B just adds the elements from the center.
   '⁎', '⁑', '⁂'
   '⁎', '⁑', '⁂', '⁑'
   Clock - These need to be ordered. I haven't done this yet as the application I was testing the system in doesn't support these wingdings / icons. But this would look quite nice and you could set it up to go forward, or backward during an undo process, etc..
   '🕛', '🕧', '🕐', '🕜', '🕑', '🕝', '🕒', '🕞', '🕓', '🕟', '🕔', '🕠', '🕕', '🕖', '🕗', '🕘', '🕙', '🕚', '🕡', '🕢', '🕣', '🕤', '🕥', '🕦'
   Arrows:
   '⬍', '⬈', '➞', '⬊', '⬍', '⬋', '⬅', '⬉'
   Bird - This looks decent but may be missing something.
   '︷', '︵', '︹', '︺', '︶', '︸'
   '︷', '︵', '︹', '︺', '︶', '︸', '︶', '︺', '︹', '︵'
   Plants - This isn't quite complete
   '☘', '❀', '❁'
   '☘', '❀', '❁', '❀'
   Eclipse - From Raku Throbber post author
   '🌑', '🌒', '🌓', '🌔', '🌕', '🌖', '🌗', '🌘'

",Python,"from time import sleep
while True:
    for rod in r'\|/-':
        print(rod, end='\r')
        sleep(0.25)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Cuban_primes,Cuban primes,"The name   cuban   has nothing to do with   Cuba  (the country),   but has to do with the
fact that cubes   (3rd powers)   play a role in its definition.



Some definitions of cuban primes

   primes which are the difference of two consecutive cubes.
   primes of the form:   (n+1)3 - n3.
   primes of the form:   n3 - (n-1)3.
   primes   p   such that   n2(p+n)   is a cube for some   n>0.
   primes   p   such that   4p = 1 + 3n2.


Cuban primes were named in 1923 by Allan Joseph Champneys Cunningham.



Task requirements

   show the first   200   cuban primes   (in a multi─line horizontal format).
   show the   100,000th   cuban prime.
   show all cuban primes with commas   (if appropriate).
   show all output here.


Note that   cuban prime   isn't capitalized   (as it doesn't refer to the nation of Cuba).



Also see

   Wikipedia entry:     cuban prime.
   MathWorld entry:   cuban prime.
   The OEIS entry:     A002407.     The   100,000th   cuban prime can be verified in the   2nd   example   on this OEIS web page.

",Python,"import datetime
import math
 
primes = [ 3, 5 ]
 
cutOff = 200
 
bigUn =  100_000
chunks = 50
little = bigUn / chunks
 
tn = "" cuban prime""
print (""The first {:,}{}s:"".format(cutOff, tn))
 
c = 0
showEach = True
u = 0
v = 1
st = datetime.datetime.now()
 
for i in range(1, int(math.pow(2,20))):
	found = False
	u += 6
	v += u
	mx = int(math.sqrt(v))
 
	for item in primes:
		if (item > mx):
			break
		if (v % item == 0):
			found = True
			break
 
	if (found == 0):
		c += 1
		if (showEach):
			z = primes[-1]
			while (z <= v - 2):
				z += 2
 
				fnd = False
				for item in primes:
					if (item > mx):
						break
					if (z % item == 0):
						fnd = True
						break
 
				if (not fnd):
					primes.append(z)
 
			primes.append(v)
			print(""{:>11,}"".format(v), end='')
 
			if (c % 10 == 0):
				print("""");
			if (c == cutOff):
				showEach = False
				print (""Progress to the {:,}th {}:"".format(bigUn, tn), end='')
		if (c % little == 0):
			print('.', end='')
		if (c == bigUn):
			break
 
print("""");
print (""The {:,}th{} is {:,}"".format(c, tn, v))
print(""Computation time was {} seconds"".format((datetime.datetime.now() - st).seconds))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Gray_code,Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",Python,"# version 1.0.6
 
class Gray:
    def encode(self, n):
        return n ^ (n >> 1)
 
    def decode(self, n):
        p = n
        nn = n
        while nn!= 0:
            nn = nn >> 1
            p = p ^ nn
        return p
 
if __name__ == '__main__':
    g = Gray()
    print(""Number\tBinary\tGray\tDecoded"")
    for i in range(32):
        print(f""{i}\t{bin(i)}\t{bin(g.encode(i))}\t{g.decode(g.encode(i))}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation,Horner's rule for polynomial evaluation,"A fast scheme for evaluating a polynomial such as:

 



−
19
+
7
x
−
4

x

2


+
6

x

3





{\displaystyle -19+7x-4x^{2}+6x^{3}\,}


when

 



x
=
3



{\displaystyle x=3\;}

.
is to arrange the computation as follows:

 



(
(
(
(
0
)
x
+
6
)
x
+
(
−
4
)
)
x
+
7
)
x
+
(
−
19
)



{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\;}


And compute the result from the innermost brackets outwards as in this pseudocode:

coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.
Cf. Formal power series
",Python,">>> def horner(coeffs, x):
	acc = 0
	for c in reversed(coeffs):
		acc = acc * x + c
	return acc
 
>>> horner( (-19, 7, -4, 6), 3)
128",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Matrix_transposition,Matrix transposition,"Transpose an arbitrarily sized rectangular Matrix.



",Python,"import numpy as np
m = np.array([[1, 1, 1, 1],
              [2, 4, 8, 16],
              [3, 9, 27, 81],
              [4, 16, 64, 256],
              [5, 25, 125, 625]])
ans = np.zeros((m.shape[1], m.shape[0]))
for rows in range(m.shape[0]):
    for cols in range(m.shape[1]):
        ans[cols][rows] = m[rows][cols]
print(ans)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",Python,"'''Hilbert curve'''
 
from itertools import (chain, islice)
 
 
# hilbertCurve :: Int -> SVG String
def hilbertCurve(n):
    '''An SVG string representing a
       Hilbert curve of degree n.
    '''
    w = 1024
    return svgFromPoints(w)(
        hilbertPoints(w)(
            hilbertTree(n)
        )
    )
 
 
# hilbertTree :: Int -> Tree Char
def hilbertTree(n):
    '''Nth application of a rule to a seedling tree.'''
 
    # rule :: Dict Char [Char]
    rule = {
        'a': ['d', 'a', 'a', 'b'],
        'b': ['c', 'b', 'b', 'a'],
        'c': ['b', 'c', 'c', 'd'],
        'd': ['a', 'd', 'd', 'c']
    }
 
    # go :: Tree Char -> Tree Char
    def go(tree):
        c = tree['root']
        xs = tree['nest']
        return Node(c)(
            map(go, xs) if xs else map(
                flip(Node)([]),
                rule[c]
            )
        )
    seed = Node('a')([])
    return list(islice(
        iterate(go)(seed), n
    ))[-1] if 0 < n else seed
 
 
# hilbertPoints :: Int -> Tree Char -> [(Int, Int)]
def hilbertPoints(w):
    '''Serialization of a tree to a list of points
       bounded by a square of side w.
    '''
 
    # vectors :: Dict Char [(Int, Int)]
    vectors = {
        'a': [(-1, 1), (-1, -1), (1, -1), (1, 1)],
        'b': [(1, -1), (-1, -1), (-1, 1), (1, 1)],
        'c': [(1, -1), (1, 1), (-1, 1), (-1, -1)],
        'd': [(-1, 1), (1, 1), (1, -1), (-1, -1)]
    }
 
    # points :: Int -> ((Int, Int), Tree Char) -> [(Int, Int)]
    def points(d):
        '''Size -> Centre of a Hilbert subtree -> All subtree points
        '''
        def go(xy, tree):
            r = d // 2
 
            def deltas(v):
                return (
                    xy[0] + (r * v[0]),
                    xy[1] + (r * v[1])
                )
            centres = map(deltas, vectors[tree['root']])
            return chain.from_iterable(
                map(points(r), centres, tree['nest'])
            ) if tree['nest'] else centres
        return go
 
    d = w // 2
    return lambda tree: list(points(d)((d, d), tree))
 
 
# svgFromPoints :: Int -> [(Int, Int)] -> SVG String
def svgFromPoints(w):
    '''Width of square canvas -> Point list -> SVG string'''
 
    def go(xys):
        def points(xy):
            return str(xy[0]) + ' ' + str(xy[1])
        xs = ' '.join(map(points, xys))
        return '\n'.join(
            ['<svg xmlns=""http://www.w3.org/2000/svg""',
             f'width=""512"" height=""512"" viewBox=""5 5 {w} {w}"">',
             f'<path d=""M{xs}"" ',
             'stroke-width=""2"" stroke=""red"" fill=""transparent""/>',
             '</svg>'
             ]
        )
    return go
 
 
# ------------------------- TEST --------------------------
def main():
    '''Testing generation of the SVG for a Hilbert curve'''
    print(
        hilbertCurve(6)
    )
 
 
# ------------------- GENERIC FUNCTIONS -------------------
 
# Node :: a -> [Tree a] -> Tree a
def Node(v):
    '''Contructor for a Tree node which connects a
       value of some kind to a list of zero or
       more child trees.'''
    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}
 
 
# flip :: (a -> b -> c) -> b -> a -> c
def flip(f):
    '''The (curried or uncurried) function f with its
       arguments reversed.
    '''
    return lambda a: lambda b: f(b)(a)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
#  TEST ---------------------------------------------------
if __name__ == '__main__':
    main()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Loops/Break,Loops/Break,"Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive).

If a number is 10, stop the loop after printing it, and do not generate any further numbers.

Otherwise, generate and print a second random number before restarting the loop.

If the number 10 is never generated as the first number in a loop, loop forever.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges

",Python,"from random import randrange
 
while True:
    a = randrange(20)
    print(a)
    if a == 10:
        break
    b = randrange(20)
    print(b)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Approximate_equality,Approximate equality,"Sometimes, when testing whether the solution to a task (for example, here on Rosetta Code) is correct, the
difference in floating point calculations between different language implementations becomes significant.

For example, a difference between 32 bit and 64 bit floating point calculations may appear by
about the 8th significant digit in base 10 arithmetic.



Task

Create a function which returns true if two floating point numbers are approximately equal.



The function should allow for differences in the magnitude of numbers, so that, for example,

100000000000000.01   may be approximately equal to   100000000000000.011,

even though   100.01   is not approximately equal to   100.011.

If the language has such a feature in its standard library, this may be used instead of a custom function.

Show the function results with comparisons on the following pairs of values:

     100000000000000.01,   100000000000000.011     (note: should return true)
     100.01,   100.011                                                     (note: should return false)
     10000000000000.001 / 10000.0,   1000000000.0000001000
     0.001,   0.0010000001
     0.000000000000000000000101,   0.0
      sqrt(2) * sqrt(2),    2.0
     -sqrt(2) * sqrt(2),   -2.0
     3.14159265358979323846,   3.14159265358979324


Answers should be true for the first example and false in the second, so that just rounding the numbers to a fixed number of decimals should not be enough. Otherwise answers may vary and still be correct. See the Python code for one type of solution.



",Python,"def approx_equals(value, other, epsilon):
    return abs(value - other) < epsilon

def test(a, b):
    epsilon = 1e-18
    print(f""{a}, {b} => {approx_equals(a, b, epsilon)}"")

def main():
    test(100000000000000.01, 100000000000000.011)
    test(100.01, 100.011)
    test(10000000000000.001 / 10000.0, 1000000000.0000001000)
    test(0.001, 0.0010000001)
    test(0.000000000000000000000101, 0.0)
    test(math.sqrt(2.0) * math.sqrt(2.0), 2.0)
    test(-math.sqrt(2.0) * math.sqrt(2.0), -2.0)
    test(3.14159265358979323846, 3.14159265358979324)

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
from collections import defaultdict
 
def get_frequencies(items):
    dictionary = defaultdict(int)
    for item in items:
        dictionary[item] += 1
    return dictionary
 
if __name__ == '__main__':
    file = sys.argv[1]
    if file:
        with open(file) as f:
            text = f.read()
            for entry in get_frequencies(text).items():
                print('{0}: {1}'.format(entry[0], entry[1]))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Roman_numerals/Encode,Roman numerals/Encode,"Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.



In Roman numerals:

 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
 2008 is written as 2000=MM, 8=VIII; or MMVIII
 1666 uses each Roman symbol in descending order: MDCLXVI

",Python,"class RN:
    class Numeral:
        def __init__(self, weight):
            self.weight = weight

    I = Numeral(1)
    IV = Numeral(4)
    V = Numeral(5)
    IX = Numeral(9)
    X = Numeral(10)
    XL = Numeral(40)
    L = Numeral(50)
    XC = Numeral(90)
    C = Numeral(100)
    CD = Numeral(400)
    D = Numeral(500)
    CM = Numeral(900)
    M = Numeral(1000)

    @staticmethod
    def roman(n):
        if n <= 0:
            raise ValueError()

        buf = []
        values = [RN.I, RN.IV, RN.V, RN.IX, RN.X, RN.XL, RN.L, RN.XC, RN.C, RN.CD, RN.D, RN.CM, RN.M]
        for i in range(len(values) - 1, -1, -1):
            while n >= values[i].weight:
                buf.append(values[i])
                n -= values[i].weight
        return ''.join(str(x) for x in buf)

    @staticmethod
    def test(n):
        print(n, '=', RN.roman(n))

if __name__ == '__main__':
    RN.test(1999)
    RN.test(25)
    RN.test(944)
    RN.test(0)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Associative_array/Merging,Associative array/Merging,"Task

Define two associative arrays, where one represents the following ""base"" data:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 12.75


 ""color"" 
 ""yellow""

And the other represents ""update"" data:





 Key 
 Value


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974

Merge these into a new associative array that contains every key found in either of the source ones. Each key should map to the value in the second (update) table if that exists, or else to the value in the first (base) table. If possible, do this in a way that does not mutate the original two associative arrays. Obviously this should be done in a way that would work for any data, not just the specific data given here, but in this example the result should be:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974


",Python,"base = {""name"":""Rocket Skates"", ""price"":12.75, ""color"":""yellow""}
update = {""price"":15.25, ""color"":""red"", ""year"":1974}
 
result = {**base, **update}
 
print(result)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Floyd-Warshall_algorithm,Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",Python,"import sys
import math
 
class Edge:
    def __init__(self, sourceVertex, destVertex, edgeWeight):
        self.sourceVertex = sourceVertex
        self.destVertex = destVertex
        self.edgeWeight = edgeWeight
 
class Graph:
    def __init__(self, vertices, edges, edgeMatrix):
        self.vertices = vertices
        self.edges = edges
        self.edgeMatrix = edgeMatrix
 
def loadGraph(fileName):
    fp = open(fileName, ""r"")
 
    G = Graph(0, 0, [])
 
    G.vertices, G.edges = map(int, fp.readline().split())
 
    for i in range(G.edges):
        G.edgeMatrix.append(Edge(0, 0, 0))
        G.edgeMatrix[i].sourceVertex, G.edgeMatrix[i].destVertex, G.edgeMatrix[i].edgeWeight = map(int, fp.readline().split())
 
    fp.close()
 
    return G
 
def floydWarshall(g):
    processWeights = [[0 for i in range(g.vertices)] for j in range(g.vertices)]
    processedVertices = [[0 for i in range(g.vertices)] for j in range(g.vertices)]
 
    for i in range(g.vertices):
        for j in range(g.vertices):
            processWeights[i][j] = math.inf
            processedVertices[i][j] = (i!= j) and (j + 1) or 0
 
    for i in range(g.edges):
        processWeights[g.edgeMatrix[i].sourceVertex - 1][g.edgeMatrix[i].destVertex - 1] = g.edgeMatrix[i].edgeWeight
 
    for i in range(g.vertices):
        for j in range(g.vertices):
            for k in range(g.vertices):
                if processWeights[j][i] + processWeights[i][k] < processWeights[j][k]:
                    processWeights[j][k] = processWeights[j][i] + processWeights[i][k]
                    processedVertices[j][k] = processedVertices[j][i]
 
    print(""pair    dist   path"")
    for i in range(g.vertices):
        for j in range(g.vertices):
            if i!= j:
                print(""%d -> %d %3d %5d"" % (i + 1, j + 1, processWeights[i][j], i + 1), end = """")
                k = i + 1
                while k!= j + 1:
                    k = processedVertices[k - 1][j]
                    print(""->%d"" % k, end = """")
                print()
 
if __name__ == ""__main__"":
    if len(sys.argv)!= 2:
        print(""Usage: %s <file containing graph data>"" % sys.argv[0])
    else:
        floydWarshall(loadGraph(sys.argv[1]))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Call_a_function,Call a function,"Task

Demonstrate the different syntax and semantics provided for calling a function.



This may include:

   Calling a function that requires no arguments
   Calling a function with a fixed number of arguments
   Calling a function with optional arguments
   Calling a function with a variable number of arguments
   Calling a function with named arguments
   Using a function in statement context
   Using a function in first-class context within an expression
   Obtaining the return value of a function
   Distinguishing built-in functions and user-defined functions
   Distinguishing subroutines and functions
   Stating whether arguments are passed by value or by reference
   Is partial application possible and how


This task is not about defining functions.



",Python,"def no_args():
    pass
# call
no_args()
 
def fixed_args(x, y):
    print('x=%r, y=%r' % (x, y))
# call
fixed_args(1, 2)        # x=1, y=2
 
## Can also called them using the parameter names, in either order:
fixed_args(y=2, x=1)
 
## Can also ""apply"" fixed_args() to a sequence:
myargs=(1,2) # tuple
fixed_args(*myargs)
 
def opt_args(x=1):
    print(x)
# calls
opt_args()              # 1
opt_args(3.141)         # 3.141
 
def var_args(*v):
    print(v)
# calls	
var_args(1, 2, 3)       # (1, 2, 3)
var_args(1, (2,3))      # (1, (2, 3))
var_args()              # ()
 
## Named arguments
fixed_args(y=2, x=1)    # x=1, y=2
 
## As a statement
if 1:
    no_args()
 
## First-class within an expression
assert no_args() is None
 
def return_something():
    return 1
x = return_something()
 
def is_builtin(x):
	print(x.__name__ in dir(__builtins__))
# calls
is_builtin(pow)         # True
is_builtin(is_builtin)  # False
 
# Very liberal function definition
 
def takes_anything(*args, **kwargs):
    for each in args:
        print(each)
    for key, value in sorted(kwargs.items()):
        print(""%s:%s"" % (key, value))
    # Passing those to another, wrapped, function:
    wrapped_fn(*args, **kwargs)
    # (Function being wrapped can have any parameter list
    # ... that doesn't have to match this prototype)
 
## A subroutine is merely a function that has no explicit
## return statement and will return None.
 
## Python uses ""Call by Object Reference"".
## See, for example, http://www.python-course.eu/passing_arguments.php
 
## For partial function application see:
##   http://rosettacode.org/wiki/Partial_function_application#Python",Human_written,Python_from_C++
http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Python,"#include <iostream>
 
int main()
{
  # read values
  dim1, dim2 = input().split()
  dim1 = int(dim1)
  dim2 = int(dim2)
 
  # create array
  array_data = [0.0]*(dim1*dim2)
  array = [0]*dim1
  for i in range(dim1):
    array[i] = array_data[dim2*i:dim2*(i+1)]
 
  # write element
  array[0][0] = 3.5
 
  # output element
  print(array[0][0])
 
  # get rid of array
  del array
  del array_data
 
  return 0
}",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Terminal_control/Inverse_video,Terminal control/Inverse video,"Task

Display a word in inverse video   (or reverse video)   followed by a word in normal video.



",Python,"#include <stdio.h>
 
int main()
{
	printf(""\033[7mReversed\033[m Normal\n"");
 
	return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"import os
 
lp0 = os.open(""/dev/lp0"", os.O_WRONLY)
 
os.write(lp0, ""Hello World!\n"")
 
os.close(lp0)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Natural_sorting,Natural sorting,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Natural sorting is the sorting of text that does more than rely on the
order of individual characters codes to make the finding of
individual strings easier for a human reader.

There is no ""one true way"" to do this, but for the purpose of this task 'natural' orderings might include:

1. Ignore leading, trailing and multiple adjacent spaces
2. Make all whitespace characters equivalent.
3. Sorting without regard to case.
4. Sorting numeric portions of strings in numeric order.
 That is split the string into fields on numeric boundaries, then sort on each field, with the rightmost fields being the most significant, and numeric fields of integers treated as numbers.
 foo9.txt before foo10.txt
 As well as ... x9y99 before x9y100, before x10y0
 ... (for any number of groups of integers in a string).
5. Title sorts: without regard to a leading, very common, word such
 as 'The' in ""The thirty-nine steps"".
6. Sort letters without regard to accents.
7. Sort ligatures as separate letters.
8. Replacements:
 Sort German eszett or scharfes S (ß)       as   ss
 Sort ſ, LATIN SMALL LETTER LONG S     as   s
 Sort ʒ, LATIN SMALL LETTER EZH           as   s
  ∙∙∙ 
Task Description
 Implement the first four of the eight given features in a natural sorting routine/function/method...
 Test each feature implemented separately with an ordered list of test strings from the   Sample inputs   section below,   and make sure your naturally sorted output is in the same order as other language outputs such as    Python. 
 Print and display your output.
 For extra credit implement more than the first four.


Note:   it is not necessary to have individual control of which features are active in the natural sorting routine at any time.



Sample input

• Ignoring leading spaces.                       Text strings:   ['ignore leading spaces:  2-2',
                                                                  'ignore leading spaces:  2-1', 
                                                                  'ignore leading spaces:  2+0',
                                                                  'ignore leading spaces:  2+1']

• Ignoring multiple adjacent spaces (MAS).       Text strings:   ['ignore MAS spaces:  2-2', 
                                                                  'ignore MAS spaces:  2-1', 
                                                                  'ignore MAS spaces:  2+0', 
                                                                  'ignore MAS spaces:  2+1']

• Equivalent whitespace characters.              Text strings:   ['Equiv.  spaces:     3-3', 
                                                                  'Equiv. \rspaces:    3-2', 
                                                                  'Equiv. \x0cspaces:  3-1', 
                                                                  'Equiv. \x0bspaces:  3+0', 
                                                                  'Equiv. \nspaces:    3+1', 
                                                                  'Equiv. \tspaces:    3+2']

• Case Independent sort.                         Text strings:   ['cASE INDEPENDENT:  3-2', 
                                                                  'caSE INDEPENDENT:  3-1', 
                                                                  'casE INDEPENDENT:  3+0', 
                                                                  'case INDEPENDENT:  3+1']
  
• Numeric fields as numerics.                    Text strings:   ['foo100bar99baz0.txt', 
                                                                  'foo100bar10baz0.txt', 
                                                                  'foo1000bar99baz10.txt', 
                                                                  'foo1000bar99baz9.txt']

• Title sorts.                                   Text strings:   ['The Wind in the Willows', 
                                                                  'The 40th step more', 
                                                                  'The 39 steps', 
                                                                  'Wanda']

• Equivalent accented characters (and case).     Text strings:   [u'Equiv. \xfd accents:  2-2', 
                                                                  u'Equiv. \xdd accents:  2-1', 
                                                                  u'Equiv.  y accents:    2+0', 
                                                                  u'Equiv.  Y accents:    2+1']

• Separated ligatures.                           Text strings:   [u'\u0132 ligatured ij', 
                                                                   'no ligature']

• Character replacements.                        Text strings:   [u'Start with an \u0292:  2-2', 
                                                                  u'Start with an \u017f:  2-1', 
                                                                  u'Start with an \xdf:    2+0', 
                                                                  u'Start with an  s:      2+1']




",Python,"ar.sort(key=lambda str: str.lower().replace(""the "", """").replace(""a "", """").replace(""an "", """").lstrip().replace("" "", """"))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",Python,"compose = lambda f, g: lambda x: f( g(x) )",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Simulate_input/Mouse,Simulate input/Mouse,,Python,"import autopilot
import random
import time
import math
 
TWO_PI = math.pi * 2.0
 
# Moves the mouse in a sine wave across the screen.
def sine_mouse_wave():
    screen_size = autopilot.screen.size()
    scoped_height = screen_size.height / 2.0 - 10.0 # Stay in screen bounds.
    for x in range(screen_size.width):
        y = int(scoped_height * math.sin((TWO_PI * x) / screen_size.width) + scoped_height)
        duration = random.randint(1, 3)
        autopilot.mouse.move_to(autopilot.geometry.Point(x, y))
        time.sleep(duration / 1000.0)
 
sine_mouse_wave()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Factors_of_an_integer,Factors of an integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Compute the   factors   of a positive integer.

These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.

(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).

Note that every prime number has two factors:   1   and itself.



Related tasks

   count in factors
   prime decomposition
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division
   sequence: smallest number greater than previous term with exactly n divisors

",Python,"def Main():
    while True:
        print(""Number:"")
        p = 0
        while True:
            try:
                p = int(input())
                break
            except:
                pass
        print(""For 1 through "" + str(int(math.sqrt(p))) + """")
        for x in range(1, int(math.sqrt(p)) + 1):
            if p % x == 0:
                print(""Found: "" + str(x) + "". "" + str(p) + "" / "" + str(x) + "" = "" + str(int(p / x)))
        print(""Done."")

if __name__ == '__main__':
    Main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle,Catalan numbers/Pascal's triangle,"Task

Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.



See

   Catalan Numbers and the Pascal Triangle.     This method enables calculation of Catalan Numbers using only addition and subtraction.
   Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition.
   Sequence A000108 on OEIS has a lot of information on Catalan Numbers.
Related Tasks

Pascal's triangle
",Python,"n=15
t=[0]*17
t[1]=1
for i in range(1,n+1):
	j=i
	while j>0:
		t[j]=t[j]+t[j-1]
		j=j-1
	t[i+1]=t[i]
	j=i+1
	while j>0:
		t[j]=t[j]+t[j-1]
		j=j-1
	print(t[i+1]-t[i],end="" "")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",Python,"import sys

def main():
    # a numeric literal with decimal point is a double
    double1 = 2.5
    # an 'f' of 'F' suffix means the literal is a flaot 
    float1 = 2.5
    # an 'l' or 'L' suffix means a long double
    longdouble1 = 2.5
    # a number after an 'e' or 'E' is the base 10 exponent
    double2 = 2.5e-3
    float2 = 2.5e3
    # a '0x' prefix means the literal is hexadecimal. the 'p' is base 2 the exponent
    double3 = 0x1p4
    float3 = 0xbeefp-8
    print(""\ndouble1: "", double1)
    print(""float1: "", float1)
    print(""longdouble1: "", longdouble1)
    print(""double2: "", double2)
    print(""float2: "", float2)
    print(""double3: "", double3)
    print(""float3: "", float3)
    print(""\n"")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Brownian_tree,Brownian tree,"Brownian tree

You are encouraged to solve this task according to the task description, using any language you may know.



Task

Generate and draw a   Brownian Tree.



A Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.

 The initial ""seed"" is placed somewhere within the field. Where is not particularly important; it could be randomized, or it could be a fixed point.
 Particles are injected into the field, and are individually given a (typically random) motion pattern.
 When a particle collides with the seed or tree, its position is fixed, and it's considered to be part of the tree.

Because of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. 


",Python,"import random
import sys
from PIL import Image
 
w = 400
h = 300
n = 15000
frost = 255
 
g = Image.new('L', (w, h))
 
def main():
    g.putpixel((w/3, h/3), frost)
generate:
    for a in range(n):
        # generate random position for new particle
        rp = (random.randint(0, w-1), random.randint(0, h-1))
        if g.getpixel(rp) == frost:
            # position is already set.  find a nearby free position.
            while True:
                rp = (rp[0] + random.randint(-1, 1), rp[1] + random.randint(-1, 1))
                # execpt if we run out of bounds, consider the particle lost.
                if not (0 <= rp[0] < w and 0 <= rp[1] < h):
                    continue generate
                if g.getpixel(rp)!= frost:
                    break
        else:
            # else particle is in free space.  let it wander
            # until it touches tree
            while not hasNeighbor(rp):
                rp = (rp[0] + random.randint(-1, 1), rp[1] + random.randint(-1, 1))
                # but again, if it wanders out of bounds consider it lost.
                if not (0 <= rp[0] < w and 0 <= rp[1] < h):
                    continue generate
        # x, y now specify a free position toucing the tree.
        g.putpixel(rp, frost)
        a += 1
        # progress indicator
        if a % 100 == 0:
            sys.stdout.write(str(a) + "" of "" + str(n) + ""\n"")
    g.save(""tree.png"")
 
def hasNeighbor(p):
    for n in ((-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)):
        o = (p[0] + n[0], p[1] + n[1])
        if 0 <= o[0] < w and 0 <= o[1] < h and g.getpixel(o) == frost:
            return True
    return False
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Multisplit,Multisplit,"It is often necessary to split a string into pieces
based on several different (potentially multi-character) separator strings,
while still retaining the information about which separators were present in the input.

This is particularly useful when doing small parsing tasks. 

The task is to write code to demonstrate this.

The function (or procedure or method, as appropriate) should
take an input string and an ordered collection of separators.

The order of the separators is significant: 

The delimiter order represents priority in matching, with the first defined delimiter having the highest priority.
In cases where there would be an ambiguity as to
which separator to use at a particular point
(e.g., because one separator is a prefix of another)
the separator with the highest priority should be used.
Delimiters can be reused and the output from the function should be an ordered sequence of substrings.

Test your code using the input string “a!===b=!=c” and the separators “==”, “!=” and “=”.

For these inputs the string should be parsed as ""a"" (!=) """" (==) ""b"" (=) """" (!=) ""c"", where matched delimiters are shown in parentheses, and separated strings are quoted, so our resulting output is ""a"", empty string, ""b"", empty string, ""c"".
Note that the quotation marks are shown for clarity and do not form part of the output.

Extra Credit: provide information that indicates which separator was matched at each separation point and where in the input string that separator was matched.
",Python,"# version 1.0.7
 
input = ""a!===b=!=c""
delimiters = [""=="", ""!="", ""=""]
output = input.split(*delimiters)
for i in range(len(output)):
    if output[i] == """":
        output[i] = ""empty string""
    else:
        output[i] = ""\"""" + output[i] + ""\""""
print(""The splits are:"")         
print(output)
 
# now find positions of matched delimiters
matches = []
index = 0 
while index < len(input):
    matched = False
    for d in delimiters:
        if input[index:index+len(d)] == d:
            matches.append((d, index))
            index += len(d)
            matched = True
            break
    if not matched:
        index += 1
print(""\nThe delimiters matched and the indices at which they occur are:"")
print(matches)
 
# now find positions of matched delimiters
matches2 = []
index2 = 0 
while index2 < len(input):
    matched2 = False
    for d in delimiters:
        if input[index2:index2+len(d)] == d:
            matches2.append((d, index2))
            index2 += len(d)
            matched2 = True
            break
    if not matched2:
        index2 += 1
print(""\nThe delimiters matched and the indices at which they occur are:"")
print(matches2)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number,Validate International Securities Identification Number,"An International Securities Identification Number (ISIN) is a unique international identifier for a financial security such as a stock or bond.



Task

Write a function or program that takes a string as input, and checks whether it is a valid ISIN.

It is only valid if it has the correct format,   and   the embedded checksum is correct.

Demonstrate that your code passes the test-cases listed below.



Details

The format of an ISIN is as follows:


┌───────────── a 2-character ISO country code (A-Z)
│ ┌─────────── a 9-character security code (A-Z, 0-9)
│ │        ┌── a checksum digit (0-9)
AU0000XVGZA3



For this task, you may assume that any 2-character alphabetic sequence is a valid country code.

The checksum can be validated as follows:

 Replace letters with digits, by converting each character from base 36 to base 10, e.g. AU0000XVGZA3 →1030000033311635103.
 Perform the Luhn test on this base-10 number.
There is a separate task for this test: Luhn test of credit card numbers.
You don't have to replicate the implementation of this test here   ───   you can just call the existing function from that task.   (Add a comment stating if you did this.)


Test cases



 ISIN

 Validity

 Comment


 US0378331005 
 valid 



 US0373831005 
 not valid 
 The transposition typo is caught by the checksum constraint.


 U50378331005 
 not valid 
 The substitution typo is caught by the format constraint.


 US03378331005 
 not valid 
 The duplication typo is caught by the format constraint.


 AU0000XVGZA3 
 valid 



 AU0000VXGZA3 
 valid 
 Unfortunately, not all transposition typos are caught by the checksum constraint.


 FR0000988040 
 valid 


(The comments are just informational.   Your function should simply return a Boolean result.   See #Raku for a reference solution.)



Related task:

 Luhn test of credit card numbers


Also see

 Interactive online ISIN validator
 Wikipedia article: International Securities Identification Number

",Python,"import re
 
def is_valid_isin(isin):
    return isin_regex.match(isin) and luhn_test(digitize(isin))
 
isin_regex = re.compile(""^[A-Z]{2}[A-Z0-9]{9}\\d$"")
 
def digitize(isin):
    return """".join(str(digit_value(c)) for c in isin)
 
def luhn_test(number):
    return sum(summand(int(d), i) for i, d in enumerate(reversed(number))) % 10 == 0
 
def summand(digit, i):
    return digit + (i % 2) * (digit - digit // 5 * 9)
 
def digit_value(c):
    return int(c) if c.isdigit() else ord(c) - ord('A') + 10
 
if __name__ == ""__main__"":
    isins = [
        ""US0378331005"",
        ""US0373831005"",
        ""U50378331005"",
        ""US03378331005"",
        ""AU0000XVGZA3"",
        ""AU0000VXGZA3"",
        ""FR0000988040""
    ]
 
    for isin in isins:
        valid_or_not = ""valid"" if is_valid_isin(isin) else ""not valid""
        print(f""{isin} is {valid_or_not}"")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/String_matching,String matching,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Given two strings, demonstrate the following three types of string matching:

   Determining if the first string starts with second string
   Determining if the first string contains the second string at any location
   Determining if the first string ends with the second string


Optional requirements:

   Print the location of the match for part 2
   Handle multiple occurrences of a string for part 2.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"""abcd"".startswith(""ab"") #returns true
""abcd"".endswith(""zn"") #returns false
""abab"".find(""bb"") #returns -1
""abab"".find(""ab"") #returns 0
""abab"".find(""ab"",2) #returns 2",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Attractive_numbers,Attractive numbers,"A number is an   attractive number   if the number of its prime factors (whether distinct or not) is also prime.



Example

The number   20,   whose prime decomposition is   2 × 2 × 5,   is an   attractive number   because the number of its prime factors   (3)   is also prime.



Task

Show sequence items up to   120.



Reference

   The OEIS entry:   A063989: Numbers with a prime number of prime divisors.

",Python,"from sympy import sieve # library for primes
 
def get_pfct(n): 
	i = 2; factors = []
	while i * i <= n:
		if n % i:
			i += 1
		else:
			n //= i
			factors.append(i)
	if n > 1:
		factors.append(n)
	return len(factors) 
 
sieve.extend(110) # first 110 primes...
primes=sieve._list
 
pool=[]
 
for each in xrange(0,121):
	pool.append(get_pfct(each))
 
for i,each in enumerate(pool):
	if each in primes:
		print i,",Human_written,Python_from_Go
http://rosettacode.org/wiki/Test_a_function,Test a function,"

Task

Using a well-known testing-specific library/module/suite for your language, write some tests for your language's entry in Palindrome.

If your language does not have a testing specific library well known to the language's community then state this or omit the language.


",Python,"def palindrome?(s):
    return s == s.reverse()
 
import unittest
class MyTests(unittest.TestCase):
    def test_palindrome_ok(self):
        self.assertTrue(palindrome?(""aba""))
 
    def test_palindrome_nok(self):
        self.assertEqual(False, palindrome?(""ab""))
 
    def test_object_without_reverse(self):
        self.assertRaises(NoMethodError, palindrome?, 42)
 
    def test_wrong_number_args(self):
        self.assertRaises(ArgumentError, palindrome?, ""a"", ""b"")
 
    def test_show_failing_test(self):
        self.assertTrue(palindrome?(""ab""), ""this test case fails on purpose"")
 
if __name__ == '__main__':
    unittest.main()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"# Julia Operators in Order of Preference
#--------------------------------------------
#Syntax 				.	followed by	::
#Exponentiation			^
#Fractions			//
#Multiplication			* /	% & \
#Bitshifts			<< >> >>>
#Addition			+ - | ⊻
#Syntax				:..	followed by	|>
#Comparisons			> < >= <= == ===	!=	!== <:
#Control flow			&&	followed by	||	followed by	?
#Assignments			= += -= *= /= //= \= ^= ÷=	%= |= &= ⊻= <<= >>= >>>=

#Operator precedence can be checked within Julia with the Base.operator_precedence function:

#julia> Base.operator_precedence(:>=), Base.operator_precedence(:&&), Base.operator_precedence(:(=))
#(6, 4, 1)

#Julia Associativity of Operators
#---------------------------------------------
#Assignment (=, etc.), conditional (a	? b	: c), -> arrows, lazy OR/AND (&& ||), 
#power operators, and unary operators are right associative. All others are 
#left associative.",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Luhn test of credit card numbers,"The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

 Reverse the order of the digits in the number.
 Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
 Taking the second, fourth ... and every other even digit in the reversed digits:
 Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
 Sum the partial sums of the even digits to form s2
 If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.


For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and

use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



Related tasks

   SEDOL
   ISIN

",Python,">>> def luhn(n):
	r = [int(ch) for ch in str(n)][::-1]
	return (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0
 
>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):
	print(n, luhn(n))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Longest_common_substring,Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",Python,"import sys

def lcs(a, b):
    lengths = [[0 for j in range(len(b)+1)] for i in range(len(a)+1)]
    # row 0 and column 0 are initialized to 0 already
    for i, x in enumerate(a):
        for j, y in enumerate(b):
            if x == y:
                lengths[i+1][j+1] = lengths[i][j] + 1
            else:
                lengths[i+1][j+1] = 0
    # read the substring out from the matrix
    result = """"
    greatestLength = 0
    for i in range(len(a)):
        for j in range(len(b)):
            if lengths[i+1][j+1] > greatestLength:
                greatestLength = lengths[i+1][j+1]
                result = a[i-greatestLength+1:i+1]
    return result

if __name__ == ""__main__"":
    print(lcs(""thisisatest"", ""testing123testing""))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Hostname,Hostname,"Task

Find the name of the host on which the routine is running.



",Python,"import os
 
print(os.uname()[1])",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort,Sorting algorithms/Bead sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of positive integers using the Bead Sort Algorithm.

A   bead sort   is also known as a   gravity sort.



Algorithm has   O(S),   where   S   is the sum of the integers in the input set:   Each bead is moved individually.

This is the case when bead sort is implemented without a mechanism to assist in finding empty spaces below the beads, such as in software implementations.



",Python,"#!/bin/python3
from itertools import zip_longest
 
# This is wrong, it works only on specific examples
def beadsort(l):
    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))
 
 
# Demonstration code:
print(beadsort([5,3,1,7,4,1,1]))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Forest_fire,Forest fire,"

 This page uses content from Wikipedia. The original article was at Forest-fire model. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Drossel and Schwabl definition of the forest-fire model.



It is basically a 2D   cellular automaton   where each cell can be in three distinct states (empty, tree and burning) and evolves according to the following rules (as given by Wikipedia)

 A burning cell turns into an empty cell
 A tree will burn if at least one neighbor is burning
 A tree ignites with probability   f    even if no neighbor is burning
 An empty space fills with a tree with probability    p 

Neighborhood is the   Moore neighborhood;   boundary conditions are so that on the boundary the cells are always empty (""fixed"" boundary condition).

At the beginning, populate the lattice with empty and tree cells according to a specific probability (e.g. a cell has the probability 0.5 to be a tree). Then, let the system evolve.

Task's requirements do not include graphical display or the ability to change parameters (probabilities    p    and    f )   through a graphical or command line interface.



Related tasks

   See   Conway's Game of Life 
   See   Wireworld.

",Python,"'''
Forest-Fire Cellular automation
 See: http://en.wikipedia.org/wiki/Forest-fire_model
'''
 
L = 15
# d = 2 # Fixed
initial_trees = 0.55
p = 0.01
f = 0.001
 
try:
    raw_input
except:
    raw_input = input
 
import random
 
 
tree, burning, space = 'TB.'
hood = ((-1,-1), (-1,0), (-1,1),
        (0,-1),          (0, 1),
        (1,-1),  (1,0),  (1,1))
 
def initialise():
    grid = {(x,y): (tree if random.random()<= initial_trees else space)
            for x in range(L)
            for y in range(L) }
    return grid
 
def gprint(grid):
    txt = '\n'.join(''.join(grid[(x,y)] for x in range(L))
                    for y in range(L))
    print(txt)
 
def quickprint(grid):
    t = b = 0
    ll = L * L
    for x in range(L):
        for y in range(L):
            if grid[(x,y)] in (tree, burning):
                t += 1
                if grid[(x,y)] == burning:
                    b += 1
    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'
          + ' (%6.3f%%, %6.3f%%)')
          % (ll, t, b, 100. * t / ll, 100. * b / ll))
 
 
def gnew(grid):
    newgrid = {}
    for x in range(L):
        for y in range(L):
            if grid[(x,y)] == burning:
                newgrid[(x,y)] = space
            elif grid[(x,y)] == space:
                newgrid[(x,y)] = tree if random.random()<= p else space
            elif grid[(x,y)] == tree:
                newgrid[(x,y)] = (burning
                                   if any(grid.get((x+dx,y+dy),space) == burning
                                            for dx,dy in hood)
                                        or random.random()<= f 
                                   else tree)
    return newgrid
 
if __name__ == '__main__':
    grid = initialise()
    iter = 0
    while True:
        quickprint(grid)
        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()
        if inp:
            if inp[0] == 'p':
                gprint(grid)
            elif inp.isdigit():
                for i in range(int(inp)):
                    iter +=1
                    grid = gnew(grid)
                    quickprint(grid)
            elif inp[0] == 'q':
                break
        grid = gnew(grid)
        iter +=1",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",Python,"def nonoblocks(blocks, cells):
    if not blocks or blocks[0] == 0:
        yield [(0, 0)]
    else:
        assert sum(blocks) + len(blocks)-1 <= cells, \
            'Those blocks will not fit in those cells'
        blength, brest = blocks[0], blocks[1:]      # Deal with the first block of length
        minspace4rest = sum(1+b for b in brest)     # The other blocks need space
        # Slide the start position from left to max RH index allowing for other blocks.
        for bpos in range(0, cells - minspace4rest - blength + 1):
            if not brest:
                # No other blocks to the right so just yield this one.
                yield [(bpos, blength)]
            else:
                # More blocks to the right so create a *sub-problem* of placing
                # the brest blocks in the cells one space to the right of the RHS of 
                # this block.
                offset = bpos + blength +1
                nonoargs = (brest, cells - offset)  # Pre-compute arguments to nonoargs
                # recursive call to nonoblocks yields multiple sub-positions
                for subpos in nonoblocks(*nonoargs):
                    # Remove the offset from sub block positions
                    rest = [(offset + bp, bl) for bp, bl in subpos]
                    # Yield this block plus sub blocks positions
                    vec = [(bpos, blength)] + rest
                    yield vec
 
def pblock(vec, cells):
    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'
    vector = ['_'] * cells
    for ch, (bp, bl) in enumerate(vec, ord('A')):
        for i in range(bp, bp + bl):
            vector[i] = chr(ch) if vector[i] == '_' else'?'
    return '|' + '|'.join(vector) + '|'
 
 
if __name__ == '__main__':
    for blocks, cells in (
            ([2, 1], 5),
            ([], 5),
            ([8], 10),
            ([2, 3, 2, 3], 15),
           # ([4, 3], 10),
           # ([2, 1], 5),
           # ([3, 1], 10),
            ([2, 3], 5),
            ):
        print('\nConfiguration:\n    %s # %i cells and %r blocks' % (pblock([], cells), cells, blocks))        
        print('  Possibilities:')
        for i, vector in enumerate(nonoblocks(blocks, cells)):
            print('   ', pblock(vector, cells))
        print('  A total of %i Possible configurations.' % (i+1))",Human_written,Python_from_C
http://rosettacode.org/wiki/XML/DOM_serialization,XML/DOM serialization,"Create a simple DOM and having it serialize to:

 <?xml version=""1.0"" ?>
 <root>
     <element>
         Some text here
     </element>
 </root>
",Python,"from xml.dom.minidom import getDOMImplementation
 
dom = getDOMImplementation()
document = dom.createDocument(None, ""root"", None)
 
topElement = document.documentElement
firstElement = document.createElement(""element"")
topElement.appendChild(firstElement)
textNode = document.createTextNode(""Some text here"")
firstElement.appendChild(textNode)
 
xmlString = document.toprettyxml("" "" * 4)",Human_written,Python_from_C
http://rosettacode.org/wiki/Word_frequency,Word frequency,"Task

Given a text file and an integer   n,   print/display the   n   most
common words in the file   (and the number of their occurrences)   in decreasing frequency.



For the purposes of this task:

   A word is a sequence of one or more contiguous letters.
   You are free to define what a   letter   is. 
   Underscores, accented letters, apostrophes, hyphens, and other special characters can be handled at your discretion.
   You may treat a compound word like   well-dressed   as either one word or two. 
   The word   it's   could also be one or two words as you see fit. 
   You may also choose not to support non US-ASCII characters. 
   Assume words will not span multiple lines.
   Don't worry about normalization of word spelling differences. 
   Treat   color   and   colour   as two distinct words.
   Uppercase letters are considered equivalent to their lowercase counterparts.
   Words of equal frequency can be listed in any order.
   Feel free to explicitly state the thoughts behind the program decisions.


Show example output using Les Misérables from Project Gutenberg as the text file input and display the top   10   most used words.



History

This task was originally taken from programming pearls from Communications of the ACM June 1986 Volume 29 Number 6
where this problem is solved by Donald Knuth using literate programming and then critiqued by Doug McIlroy,
demonstrating solving the problem in a 6 line Unix shell script (provided as an example below).



References

McIlroy's program



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
from collections import Counter
from mmap import mmap
from typing import List, Tuple
 
def get_top_words(filename: str, count: int) -> List[Tuple[str, int]]:
    with open(filename, ""r"") as f:
        text = mmap(f.fileno(), 0, access=mmap.ACCESS_READ)
    words = re.findall(r""\w+"", text.decode(""utf-8""))
    word_counts = Counter(words)
    return word_counts.most_common(count)
 
if __name__ == ""__main__"":
    import sys
    if len(sys.argv)!= 2:
        print(f""usage: {sys.argv[0]} file"")
        sys.exit(1)
    print(get_top_words(sys.argv[1], 10))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Read_entire_file,Read entire file,"Task

Load the entire contents of some text file as a single string variable.

If applicable, discuss: encoding selection, the possibility of memory-mapping.

Of course, in practice one should avoid reading an entire file at once
if the file is large and the task can be accomplished incrementally instead
(in which case check File IO);
this is for those cases where having the entire file is actually what is wanted.



",Python,"import sys
import os
 
def main():
  fh = open(""readentirefile.py"", ""rb"")
  if fh!= None:
    s = os.fstat(fh.fileno()).st_size
    buffer = fh.read(s)
    fh.close()
    fh = None
 
    # do something, e.g.
    sys.stdout.write(buffer)
 
    buffer = None
  return 0
 
if __name__ == ""__main__"":
  sys.exit(main())",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",Python,"from PIL import Image
 
if __name__ == ""__main__"":
	w, h, zoom = 800,600,1
	bitmap = Image.new(""RGB"", (w, h), ""white"")
	pix = bitmap.load()
 
	cX, cY = -0.7, 0.27015
	moveX, moveY = 0.0, 0.0
	maxIter = 255
 
	for x in range(w):
		for y in range(h):
			zx = 1.5*(x - w/2)/(0.5*zoom*w) + moveX
			zy = 1.0*(y - h/2)/(0.5*zoom*h) + moveY
			i = maxIter
			while zx*zx + zy*zy < 4 and i > 1:
				tmp = zx*zx - zy*zy + cX
				zy,zx = 2.0*zx*zy + cY, tmp
				i -= 1
			# convert byte to RGB (3 bytes), kinda magic to get nice colors
			pix[x][y] = (i << 21) + (i << 10) + i*8
 
	bitmap.show()",Human_written,Python_from_C
http://rosettacode.org/wiki/Xiaolin_Wu%27s_line_algorithm,Xiaolin Wu's line algorithm,"Task

Implement the   Xiaolin Wu's line algorithm   described in Wikipedia.



This algorithm draws anti-aliased lines.



Related task

   See   Bresenham's line algorithm   for aliased lines.

",Python,"def ipart(x):
    return int(math.floor(x))
 
def round(x):
    return int(ipart(x +.5))
 
def fpart(x):
    return x - ipart(x)
 
def rfpart(x):
    return 1 - fpart(x)
 
def aa_line(x1, y1, x2, y2):
    # straight translation of WP pseudocode
    dx = x2 - x1
    dy = y2 - y1
    ax = abs(dx)
    ay = abs(dy)
    # plot function set here to handle the two cases of slope
    if ax < ay:
        x1, y1 = y1, x1
        x2, y2 = y2, x2
        dx, dy = dy, dx
        def plot(x, y, c):
            g.set_px(y, x, int(c * 65535))
    else:
        def plot(x, y, c):
            g.set_px(x, y, int(c * 65535))
    if x2 < x1:
        x1, x2 = x2, x1
        y1, y2 = y2, y1
    gradient = dy / dx
 
    # handle first endpoint
    xend = round(x1)
    yend = y1 + gradient * (xend - x1)
    xgap = rfpart(x1 +.5)
    xpxl1 = int(xend) # this will be used in the main loop
    ypxl1 = int(ipart(yend))
    plot(xpxl1, ypxl1, rfpart(yend) * xgap)
    plot(xpxl1, ypxl1 + 1, fpart(yend) * xgap)
    intery = yend + gradient # first y-intersection for the main loop
 
    # handle second endpoint
    xend = round(x2)
    yend = y2 + gradient * (xend - x2)
    xgap = fpart(x2 + 0.5)
    xpxl2 = int(xend) # this will be used in the main loop
    ypxl2 = int(ipart(yend))
    plot(xpxl2, ypxl2, rfpart(yend) * xgap)
    plot(xpxl2, ypxl2 + 1, fpart(yend) * xgap)
 
    # main loop
    for x in range(xpxl1 + 1, xpxl2):
        plot(x, int(ipart(intery)), rfpart(intery))
        plot(x, int(ipart(intery)) + 1, fpart(intery))
        intery = intery + gradient",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/24_game,24 game,"The 24 Game tests one's mental arithmetic.



Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

 Only the following operators/functions are allowed: multiplication, division, addition, subtraction
 Division should use floating point or rational arithmetic, etc, to preserve remainders.
 Brackets are allowed, if using an infix expression evaluator.
 Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
 The order of the digits when given does not have to be preserved.


Notes
 The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
 The task is not for the program to generate the expression, or test whether an expression is even possible.


Related tasks
 24 game/Solve


Reference
 The 24 Game on h2g2.

",Python,"'''
 The 24 Game
 
 Given any four digits in the range 1 to 9, which may have repetitions,
 Using just the +, -, *, and / operators; and the possible use of
 brackets, (), show how to make an answer of 24.
 
 An answer of ""q"" will quit the game.
 An answer of ""!"" will generate a new set of four digits.
 Otherwise you are repeatedly asked for an expression until it evaluates to 24
 
 Note: you cannot form multiple digit numbers from the supplied digits,
 so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.
 
'''
 
from __future__ import division, print_function
import random, ast, re
import sys
 
if sys.version_info[0] < 3: input = raw_input
 
def choose4():
    'four random digits >0 as characters'
    return [str(random.randint(1,9)) for i in range(4)]
 
def welcome(digits):
    print (__doc__)
    print (""Your four digits: "" + ' '.join(digits))
 
def check(answer, digits):
    allowed = set('() +-*/\t'+''.join(digits))
    ok = all(ch in allowed for ch in answer) and \
         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \
         and not re.search('\d\d', answer)
    if ok:
        try:
            ast.parse(answer)
        except:
            ok = False
    return ok
 
def main():    
    digits = choose4()
    welcome(digits)
    trial = 0
    answer = ''
    chk = ans = False
    while not (chk and ans == 24):
        trial +=1
        answer = input(""Expression %i: "" % trial)
        chk = check(answer, digits)
        if answer.lower() == 'q':
            break
        if answer == '!':
            digits = choose4()
            print (""New digits:"", ' '.join(digits))
            continue
        if not chk:
            print (""The input '%s' was wonky!"" % answer)
        else:
            ans = eval(answer)
            print ("" = "", ans)
            if ans == 24:
                print (""Thats right!"")
    print (""Thank you and goodbye"")   
 
if __name__ == '__main__': main()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Word_wrap,Word wrap,"Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column.



Basic task

The basic task is to wrap a paragraph of text in a simple way in your language.

If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.

Show your routine working on a sample of text at two different wrap columns.



Extra credit

Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you must reference documentation indicating that the algorithm
is something better than a simple minimum length algorithm.

If you have both basic and extra credit solutions, show an example where
the two algorithms give different results.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> import textwrap
>>> help(textwrap.fill)
Help on function fill in module textwrap:
 
fill(text, width=70, **kwargs)
    Fill a single paragraph of text, returning a new string.
 
    Reformat the single paragraph in 'text' to fit in lines of no more
    than 'width' columns, and return a new string containing the entire
    wrapped paragraph.  As with wrap(), tabs are expanded and other
    whitespace characters converted to space.  See TextWrapper class for
    available keyword args to customize wrapping behaviour.
 
>>> txt = '''\
Reformat the single paragraph in 'text' to fit in lines of no more
than 'width' columns, and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are expanded and other
whitespace characters converted to space.  See TextWrapper class for
available keyword args to customize wrapping behaviour.'''
>>> print(textwrap.fill(txt, width=75))
Reformat the single paragraph in 'text' to fit in lines of no more than
'width' columns, and return a new string containing the entire wrapped
paragraph.  As with wrap(), tabs are expanded and other whitespace
characters converted to space.  See TextWrapper class for available keyword
args to customize wrapping behaviour.
>>> print(textwrap.fill(txt, width=45))
Reformat the single paragraph in 'text' to
fit in lines of no more than 'width' columns,
and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are
expanded and other whitespace characters
converted to space.  See TextWrapper class
for available keyword args to customize
wrapping behaviour.
>>> print(textwrap.fill(txt, width=85))
Reformat the single paragraph in 'text' to fit in lines of no more than 'width'
columns, and return a new string containing the entire wrapped paragraph.  As with
wrap(), tabs are expanded and other whitespace characters converted to space.  See
TextWrapper class for available keyword args to customize wrapping behaviour.
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sequence_of_non-squares,Sequence of non-squares,"Task

Show that the following remarkable formula gives the sequence of non-square natural numbers:

            n + floor(1/2 + sqrt(n)) 

 Print out the values for    n    in the range   1   to   22
 Show that no squares occur for    n    less than one million


This is sequence   A000037   in the OEIS database.



",Python,"def f(n):
    return n + int(0.5 + n ** 0.5)
 
def is_sqr(n):
    a = int(n ** 0.5)
    return n == a * a or n == (a+1) * (a+1) or n == (a-1) * (a-1)
 
print(list(map(f, range(1, 23))))
count = sum(1 for n in range(1, 1_000_000) if is_sqr(f(n)))
print(f""{count} unexpected squares found"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X,Isqrt (integer square root) of X,"Sometimes a function is needed to find the integer square root of   X,   where   X   can be a
real non─negative number.

Often   X   is actually a non─negative integer.

For the purposes of this task,   X   can be an integer or a real number,   but if it
simplifies things in your computer programming language,   assume it's an integer.



One of the most common uses of   Isqrt   is in the division of an integer by all factors   (or
primes)   up to the   
√ X     of that
integer,   either to find the factors of that integer,   or to determine primality.



An alternative method for finding the   Isqrt   of a number is to
calculate:        floor( sqrt(X) ) 

   where   sqrt    is the   square root   function for non─negative real numbers,   and
   where   floor   is the   floor   function for real numbers.


If the hardware supports the computation of (real) square roots,   the above method might be a faster method for
small numbers that don't have very many significant (decimal) digits.

However, floating point arithmetic is limited in the number of   (binary or decimal)   digits that it can support.



Pseudo─code using quadratic residue

For this task, the integer square root of a non─negative number will be computed using a version
of   quadratic residue,   which has the advantage that no   floating point   calculations are
used,   only integer arithmetic.

Furthermore, the two divisions can be performed by bit shifting,   and the one multiplication can also be be performed by bit shifting or additions.

The disadvantage is the limitation of the size of the largest integer that a particular computer programming language can support.



Pseudo─code of a procedure for finding the integer square root of   X       (all variables are integers):

         q ◄── 1                                /*initialize  Q  to unity.  */
                                  /*find a power of 4 that's greater than X.*/
                  perform  while q <= x         /*perform while  Q <= X.    */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/
                                                /*Q  is now greater than  X.*/
         z ◄── x                                /*set  Z  to the value of X.*/
         r ◄── 0                                /*initialize  R  to zero.   */
                  perform  while q > 1          /*perform while  Q > unity. */
                  q ◄── q ÷ 4                   /*integer divide by  four.  */
                  t ◄── z - r - q               /*compute value of  T.      */
                  r ◄── r ÷ 2                   /*integer divide by  two.   */
                  if t >= 0  then do            
                                  z ◄── t       /*set  Z  to value of  T.   */
                                  r ◄── r + q   /*compute new value of  R.  */
                                  end
                  end  /*perform*/
                                                /*R  is now the  Isqrt(X).  */

         /* Sidenote: Also, Z is now the remainder after square root (i.e.  */
         /*           R^2 + Z = X, so if Z = 0 then X is a perfect square). */

Another version for the (above)   1st   perform   is:

                  perform  until q > X          /*perform until  Q > X.     */
                  q ◄── q * 4                   /*multiply  Q  by  four.    */
                  end  /*perform*/



Integer square roots of some values:

Isqrt( 0)  is   0               Isqrt(60)  is  7                Isqrt( 99)  is   9
Isqrt( 1)  is   1               Isqrt(61)  is  7                Isqrt(100)  is  10
Isqrt( 2)  is   1               Isqrt(62)  is  7                Isqrt(102)  is  10
Isqrt( 3)  is   1               Isqrt(63)  is  7
Isqrt( 4)  is   2               Isqrt(64)  is  8                Isqet(120)  is  10
Isqrt( 5)  is   2               Isqrt(65)  is  8                Isqrt(121)  is  11
Isqrt( 6)  is   2               Isqrt(66)  is  8                Isqrt(122)  is  11
Isqrt( 7)  is   2               Isqrt(67)  is  8
Isqrt( 8)  is   2               Isqrt(68)  is  8                Isqrt(143)  is  11
Isqrt( 9)  is   3               Isqrt(69)  is  8                Isqrt(144)  is  12
Isqrt(10)  is   3               Isqrt(70)  is  8                Isqrt(145)  is  12



Task

Compute and show all output here   (on this page)   for:

   the Isqrt of the     integers     from     0 ───► 65    (inclusive), shown in a horizontal format.
   the Isqrt of the   odd powers  from   71 ───► 773   (inclusive), shown in a   vertical   format.
   use commas in the displaying of larger numbers.


You can show more numbers for the 2nd requirement if the displays fits on one screen on Rosetta Code.

If your computer programming language only supports smaller integers,   show what you can.



Related tasks

   sequence of non-squares
   integer roots
   square root by hand

",Python,"def isqrt ( x ):
    q = 1
    while q <= x : 
        q *= 4
    z,r = x,0
    while q > 1 :
        q  /= 4
        t,r = z-r-q,r/2
        if t >= 0 :
            z,r = t,r+q
    return r 
 
print ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))
print '\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Humble_numbers,Humble numbers,"Humble numbers are positive integers which have   no   prime factors    >    7.



Humble numbers are also called   7-smooth numbers,   and sometimes called   highly composite,

although this conflicts with another meaning of   highly composite numbers.



Another way to express the above is:

  humble  =  2i × 3j × 5k × 7m 

           where     i, j, k, m ≥ 0 



Task

   show the first   50   humble numbers   (in a horizontal list)
   show the number of humble numbers that have   x   decimal digits for all   x's   up to   n   (inclusive).
   show   (as many as feasible or reasonable for above)   on separate lines
   show all output here on this page


Related tasks

   Hamming numbers


References

   Wikipedia: Smooth numbers, see the 2nd paragraph.
   OEIS A002473: humble numbers
   University of Ulm, The first 5842 terms of humble numbers

",Python,"from __future__ import print_function
import sys
 
def isHumble(i):
    if i <= 1:
        return True
    if i % 2 == 0:
        return isHumble(i / 2)
    if i % 3 == 0:
        return isHumble(i / 3)
    if i % 5 == 0:
        return isHumble(i / 5)
    if i % 7 == 0:
        return isHumble(i / 7)
    return False
 
def toString(n):
    return str(n)
 
limit = sys.maxsize
humble = {}
count = 0
num = 1
 
while count < limit:
    if isHumble(num):
        str = toString(num)
        len = len(str)
        it = humble.get(len)
        if it is not None:
            humble[len] += 1
        else:
            humble[len] = 1
        if count < 50:
            print(num, end=' ')
        count += 1
    num += 1
print()
 
print(""Of the first"", count, ""humble numbers:"")
num = 1
while num < len(humble) - 1:
    c = humble.get(num)
    if c is not None:
        print(c, ""have"", num, ""digits"")
        num += 1
    else:
        break",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Polyspiral,Polyspiral,"A Polyspiral is a spiral made of multiple line segments, whereby each segment is larger (or smaller) than the previous one by a given amount. Each segment also changes direction at a given angle.



Task
Animate a series of polyspirals, by drawing a complete spiral then incrementing the angle, and (after clearing the background) drawing the next, and so on. Every spiral will be a frame of the animation. The animation may stop as it goes full circle or continue indefinitely. The given input values may be varied.

If animation is not practical in your programming environment, you may show a single frame instead.



Pseudo code
    set incr to 0.0

    // animation loop
    WHILE true 

        incr = (incr + 0.05) MOD 360
        x = width / 2
        y = height / 2
        length = 5
        angle = incr

        // spiral loop
        FOR 1 TO 150
            drawline
            change direction by angle
            length = length + 3
            angle = (angle + incr) MOD 360
        ENDFOR
    


",Python,"import math
 
import pygame
from pygame.locals import *
 
pygame.init()
screen = pygame.display.set_mode((1024, 600))
 
pygame.display.set_caption(""Polyspiral"")
 
incr = 0
 
running = True
 
while running:
	pygame.time.Clock().tick(60)
	for event in pygame.event.get():
		if event.type==QUIT:
			running = False
			break
 
	incr = (incr + 0.05) % 360
	x1 = pygame.display.Info().current_w / 2
	y1 = pygame.display.Info().current_h / 2
	length = 5
	angle = incr
 
	screen.fill((255,255,255))
 
	for i in range(1,151):
		x2 = x1 + math.cos(angle) * length
		y2 = y1 + math.sin(angle) * length
		pygame.draw.line(screen, (255,0,0), (x1, y1), (x2, y2), 1)
		# pygame.draw.aaline(screen, (255,0,0), (x1, y1), (x2, y2)) # Anti-Aliased
		x1, y1 = x2, y2
		length += 3
		angle = (angle + incr) % 360
 
	pygame.display.flip()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string,Strip control codes and extended characters from a string,"Task

Strip control codes and extended characters from a string.



The solution should demonstrate how to achieve each of the following results:

   a string with control codes stripped (but extended characters not stripped)
   a string with control codes and extended characters stripped


In ASCII, the control codes have decimal codes 0 through to 31 and 127.

On an ASCII based system, if the control codes are stripped, the resultant string would have all of its characters within the range of 32 to 126 decimal on the ASCII table.

On a non-ASCII based system, we consider characters that do not have a corresponding glyph on the ASCII table (within the ASCII range of 32 to 126 decimal) to be an extended character for the purpose of this task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms  (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def strip(s):
    return ''.join(filter(lambda x: 31 < ord(x) < 127, s))

strip('\ba\x00b\n\rc\fd\xc3')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/File_modification_time,File modification time,"Task

Get and set the modification time of a file.



",Python,"import os
import time
 
filename = ""input.txt""
 
try:
    foo = os.stat(filename)
except OSError as e:
    print(e)
    exit(1)
mtime = foo.st_mtime # seconds since the epoch
 
new_times = (foo.st_atime, time.time()) # keep atime unchanged, set mtime to current time
try:
    os.utime(filename, new_times)
except OSError as e:
    print(e)
    exit(1)
 
exit(0)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Documentation,Documentation,"

See also

 Related task: Comments
 Related task: Here_document

",Python,"class Doc(object):
   """"""
   This is a class docstring. Traditionally triple-quoted strings are used because
   they can span multiple lines and you can include quotation marks without escaping.
   """"""
   def method(self, num):
      """"""This is a method docstring.""""""
      pass",Human_written,Python_from_Go
http://rosettacode.org/wiki/Balanced_brackets,Balanced brackets,"Task:

 Generate a string with   N   opening brackets   [   and with   N   closing brackets   ],   in some arbitrary order. 
 Determine whether the generated string is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.


Examples

   (empty)      OK
   []           OK   
   [][]         OK   
   [[][]]       OK 
   ][         NOT OK
   ][][       NOT OK
   []][[]     NOT OK


",Python,"import random
 
def is_balanced(s):
    if s == """":
        return True
    count_left = 0  # number of left brackets so far unmatched
    for c in s:
        if c == '[':
            count_left += 1
        elif count_left > 0:
            count_left -= 1
        else:
            return False
    return count_left == 0
 
print(""Checking examples in task description:"")
brackets = ["""", ""[]"", ""]["", ""[][]"", ""][]["", ""[[][]]"", ""[]][[]""]
for b in brackets:
    print(b if b!= """" else ""(empty)"", end=""\t  "")
    print(""OK"" if is_balanced(b) else ""NOT OK"")
print()
 
print(""Checking 7 random strings of brackets of length 8:"")
r = random.Random()
for _ in range(7):
    s = """".join(random.choice(""[]"") for _ in range(8))
    print(s, end=""  "")
    print(""OK"" if is_balanced(s) else ""NOT OK"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",Python,"import string, sys
if sys.version_info[0] < 3:
    input = raw_input
 
def ispangram(sentence, alphabet=string.ascii_lowercase):
    alphaset = set(alphabet)
    return alphaset <= set(sentence.lower())
 
print ( ispangram(input('Sentence: ')) )",Human_written,Python_from_C#
http://rosettacode.org/wiki/Bulls_and_cows,Bulls and cows,"Bulls and Cows


Task

Create a four digit random number from the digits   1   to   9,   without duplication.

The program should:

   ask for guesses to this number
   reject guesses that are malformed
   print the score for the guess


The score is computed as:

 The player wins if the guess is the same as the randomly chosen number, and the program ends.
 A score of one bull is accumulated for each digit in the guess that equals the corresponding digit in the randomly chosen initial number.
 A score of one cow is accumulated for each digit in the guess that also appears in the randomly chosen number, but in the wrong position.


Related tasks

   Bulls and cows/Player
   Guess the number
   Guess the number/With Feedback
   Mastermind

",Python,"from random import randint
from curses import *
 
MAX_NUM_TRIES = 72
LINE_BEGIN = 7
LAST_LINE = 18
 
yp = LINE_BEGIN
xp = 0
 
number = [0, 0, 0, 0]
guess = [0, 0, 0, 0]
 
def mvaddstrf(y, x, fmt, *args):
    buf = fmt % args
    move(y, x)
    clrtoeol()
    addstr(buf)
 
def ask_for_a_number():
    i = 0
    symbols = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    move(5, 0)
    clrtoeol()
    addstr(""Enter four digits: "")
    while i < 4:
        c = getch()
        if (c >= ord('1')) and (c <= ord('9')) and (symbols[c - ord('1')]!= 0):
            addch(c)
            symbols[c - ord('1')] = 0
            guess[i] = c
            i += 1
 
def choose_the_number():
    i = 0
    j = 0
    symbols = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    while i < 4:
        j = randint(0, 8)
        if symbols[j]!= 0:
            number[i] = symbols[j]
            symbols[j] = 0
            i += 1",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Fairshare_between_two_and_more,Fairshare between two and more,"The Thue-Morse sequence is a sequence of ones and zeros that if two people
take turns in the given order, the first persons turn for every '0' in the
sequence, the second for every '1'; then this is shown to give a fairer, more
equitable sharing of resources. (Football penalty shoot-outs for example, might
not favour the team that goes first as much if the penalty takers take turns
according to the Thue-Morse sequence and took 2^n penalties)

The Thue-Morse sequence of ones-and-zeroes can be generated by:

""When counting in binary, the digit sum modulo 2 is the Thue-Morse sequence""


Sharing fairly between two or more

Use this method:

When counting base b, the digit sum modulo b is the Thue-Morse sequence of fairer sharing between b people.


Task
Counting from zero;   using a function/method/routine to express an integer count in base b,

sum the digits modulo b to produce the next member of the Thue-Morse fairshare series for b people.



Show the first 25 terms of the fairshare sequence:

   For two people:
   For three people
   For five people
   For eleven people


Related tasks

   Non-decimal radices/Convert
   Thue-Morse


See also

   A010060, A053838, A053840: The On-Line Encyclopedia of Integer Sequences® (OEIS®)

",Python,"import math
import random
import sys
import time
 
def fairshare(n, base):
    res = [0] * n
    for i in range(n):
        j = i
        sum = 0
        while j > 0:
            sum += j % base
            j //= base
        res[i] = sum % base
    return res
 
def turns(n, fss):
    m = {}
    for fs in fss:
        m[fs] = m.get(fs, 0) + 1
    m2 = {}
    for v in m.values():
        m2[v] = m2.get(v, 0) + 1
    res = []
    sum = 0
    for k, v in m2.items():
        sum += v
        res.append(k)
    if sum!= n:
        return ""only %d have a turn"" % sum
    res.sort()
    return "" or "".join(map(str, res))
 
if __name__ == ""__main__"":
    for base in [2, 3, 5, 11]:
        print(""%2d : %2d"" % (base, fairshare(25, base)))
    print(""\nHow many times does each get a turn in 50000 iterations?"")
    for base in [191, 1377, 49999, 50000, 50001]:
        t = turns(base, fairshare(50000, base))
        print(""  With %d people: %s"" % (base, t))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Equilibrium_index,Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",Python,"def eqindex2Pass(data):
    ""Two pass""
    suml, sumr, ddelayed = 0, sum(data), 0
    for i, d in enumerate(data):
        suml += ddelayed
        sumr -= d
        ddelayed = d
        if suml == sumr:
            yield i",Human_written,Python_from_Go
http://rosettacode.org/wiki/Greatest_common_divisor,Greatest common divisor,"Greatest common divisor

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Find the greatest common divisor   (GCD)   of two integers.


Greatest common divisor   is also known as   greatest common factor (gcf)   and   greatest common measure.



Related task

   least common multiple.


See also

   MathWorld entry:   greatest common divisor.
   Wikipedia entry:     greatest common divisor.

",Python,from fractions import gcd,Human_written,Python_from_Java
http://rosettacode.org/wiki/Kaprekar_numbers,Kaprekar numbers,"A positive integer is a Kaprekar number if:

 It is   1     (unity)
 The decimal representation of its square may be split once into two parts consisting of positive integers which sum to the original number. 

Note that a split resulting in a part consisting purely of 0s is not valid,
as 0 is not considered positive.



Example Kaprekar numbers

 



2223


{\displaystyle 2223}

 is a Kaprekar number, as 



2223
∗
2223
=
4941729


{\displaystyle 2223*2223=4941729}

, 



4941729


{\displaystyle 4941729}

 may be split to 



494


{\displaystyle 494}

 and 



1729


{\displaystyle 1729}

, and 



494
+
1729
=
2223


{\displaystyle 494+1729=2223}

.
 The series of Kaprekar numbers is known as A006886, and begins as 



1
,
9
,
45
,
55
,
.
.
.


{\displaystyle 1,9,45,55,...}

.


Example process

10000 (1002) splitting from left to right:

 The first split is [1, 0000], and is invalid; the 0000 element consists entirely of 0s, and 0 is not considered positive.
 Slight optimization opportunity: When splitting from left to right, once the right part consists entirely of 0s, no further testing is needed; all further splits would also be invalid.


Task

Generate and show all Kaprekar numbers less than 10,000.



Extra credit

Optionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.



Extra extra credit

The concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);
if you can, show that Kaprekar numbers exist in other bases too.



For this purpose, do the following:

 Find all Kaprekar numbers for base 17 between 1 and 1,000,000 (one million);
 Display each of them in base 10 representation;
 Optionally, using base 17 representation (use letters 'a' to 'g' for digits 10(10) to 16(10)), display each of the numbers, its square, and where to split the square. 


225   d4  a52g  a5 + 2g


Reference

 The Kaprekar Numbers by Douglas E. Iannucci (2000). PDF version


Related task

   Casting out nines

",Python,"import sys
 
def split_at(s, idx):
    return s[:idx], s[idx:]
 
def get_kaprekar_parts(n, sqr_str, base):
    for j in range(len(sqr_str) // 2 + 1):
        first, second = map(int, split_at(sqr_str, j), base)
        if first + second == n:
            return first, second
    return None
 
def main():
    base = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    count = 0
    max = 1000000
    for i in range(1, max + 1):
        s = str(i * i, base)
        p = get_kaprekar_parts(i, s, base)
        if p:
            print(""%6d\t%6s\t%12s\t%7s + %7s"" % (i, str(i, base), s, p[0], p[1]))
            count += 1
    print(""%d Kaprekar numbers < %d (base 10) in base %d"" % (count, max, base))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/CRC-32,CRC-32,"

Task

Demonstrate a method of deriving the Cyclic Redundancy Check from within the language.



The result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.

Algorithms are described on Computation of CRC in Wikipedia.
This variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.

For the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:

 The quick brown fox jumps over the lazy dog

",Python,">>> s = 'The quick brown fox jumps over the lazy dog'
>>> import zlib
>>> hex(zlib.crc32(s))
'0x414fa339'
 
>>> import binascii
>>> hex(binascii.crc32(s))
'0x414fa339'",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Simple_database,Simple database,"Task

Write a simple tool to track a small set of data.

The tool should have a command-line interface to enter at least two different values.

The entered data should be stored in a structured format and saved to disk.

It does not matter what kind of data is being tracked.   It could be a collection (CDs, coins, baseball cards, books), a diary, an electronic organizer (birthdays/anniversaries/phone numbers/addresses), etc.



You should track the following details:

 A description of the item. (e.g., title, name)
 A category or tag (genre, topic, relationship such as “friend” or “family”)
 A date (either the date when the entry was made or some other date that is meaningful, like the birthday); the date may be generated or entered manually
 Other optional fields


The command should support the following Command-line arguments to run:

 Add a new entry
 Print the latest entry
 Print the latest entry for each category
 Print all entries sorted by a date


The category may be realized as a tag or as structure (by making all entries in that category subitems)

The file format on disk should be human readable, but it need not be standardized.   A natively available format that doesn't need an external library is preferred.   Avoid developing your own format if you can use an already existing one.   If there is no existing format available, pick one of:

   JSON
   S-Expressions
   YAML
   others


Related task

   Take notes on the command line 

",Python,"#!/usr/bin/python3
 
'''\
Simple database for: http://rosettacode.org/wiki/Simple_database
 
'''
 
import argparse
from argparse import Namespace
import datetime
import shlex
 
 
def parse_args():
    'Set up, parse, and return arguments'
 
    parser = argparse.ArgumentParser(epilog=globals()['__doc__'])
 
    parser.add_argument('command', choices='add pl plc pa'.split(),
                        help='''\
add: Add a new entry
pl:  Print the latest entry
plc: Print the latest entry for each category/tag
pa:  Print all entries sorted by a date''')
    parser.add_argument('-d', '--description',
                        help='A description of the item. (e.g., title, name)')
    parser.add_argument('-t', '--tag',
                        help=('''A category or tag (genre, topic, relationship '''
                              '''such as “friend” or “family”)'''))
    parser.add_argument('-f', '--field', nargs=2, action='append', 
                        help='Other optional fields with value (can be repeated)')
 
    return parser
 
def do_add(args, dbname):
    'Add a new entry'
    if args.description is None:
        args.description = ''
    if args.tag is None:
        args.tag = ''
    del args.command
    print('Writing record to %s' % dbname)
    with open(dbname, 'a') as db:
        db.write('%r\n' % args)
 
def do_pl(args, dbname):
    'Print the latest entry'
    print('Getting last record from %s' % dbname)
    with open(dbname, 'r') as db:
        for line in db: pass
    record = eval(line)
    del record._date
    print(str(record))
 
def do_plc(args, dbname):
    'Print the latest entry for each category/tag'
    print('Getting latest record for each tag from %s' % dbname)
    with open(dbname, 'r') as db:
        records = [eval(line) for line in db]
    tags = set(record.tag for record in records)
    records.reverse()
    for record in records:
        if record.tag in tags:
            del record._date
            print(str(record))
            tags.discard(record.tag)
            if not tags: break
 
def do_pa(args, dbname):
    'Print all entries sorted by a date'
    print('Getting all records by date from %s' % dbname)
    with open(dbname, 'r') as db:
        records = [eval(line) for line in db]
    for record in records:
        del record._date
        print(str(record))
 
def test():
    import time
    parser = parse_args()
    for cmdline in [
                    """"""-d Book -f title 'Windy places' -f type hardback --tag DISCOUNT add"""""",
                    """"""-d Book -f title 'RC spammers'  -f type paperback -t   DISCOUNT add"""""",
                    """"""-d Book -f title 'Splat it' -f type hardback -f special 'first edition' -t PREMIUM add"""""",
                    """"""pl"""""",
                    """"""plc"""""",
                    ]:
        args = parser.parse_args(shlex.split(cmdline))
        now = datetime.datetime.utcnow()
        args._date = now.isoformat()
        do_command[args.command](args, dbname)
        time.sleep(0.5)
 
 
 
do_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)
dbname = '_simple_db_db.py'
 
 
if __name__ == '__main__':
    if 0:
        test()
    else:
        parser = parse_args()
        args = parser.parse_args()
        now = datetime.datetime.utcnow()
        args._date = now.isoformat()
        do_command[args.command](args, dbname)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Word_wrap,Word wrap,"Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column.



Basic task

The basic task is to wrap a paragraph of text in a simple way in your language.

If there is a way to do this that is built-in, trivial, or provided in a standard library, show that. Otherwise implement the minimum length greedy algorithm from Wikipedia.

Show your routine working on a sample of text at two different wrap columns.



Extra credit

Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.
If your language provides this, you get easy extra credit,
but you must reference documentation indicating that the algorithm
is something better than a simple minimum length algorithm.

If you have both basic and extra credit solutions, show an example where
the two algorithms give different results.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> import textwrap
>>> help(textwrap.fill)
Help on function fill in module textwrap:
 
fill(text, width=70, **kwargs)
    Fill a single paragraph of text, returning a new string.
 
    Reformat the single paragraph in 'text' to fit in lines of no more
    than 'width' columns, and return a new string containing the entire
    wrapped paragraph.  As with wrap(), tabs are expanded and other
    whitespace characters converted to space.  See TextWrapper class for
    available keyword args to customize wrapping behaviour.
 
>>> txt = '''\
Reformat the single paragraph in 'text' to fit in lines of no more
than 'width' columns, and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are expanded and other
whitespace characters converted to space.  See TextWrapper class for
available keyword args to customize wrapping behaviour.'''
>>> print(textwrap.fill(txt, width=75))
Reformat the single paragraph in 'text' to fit in lines of no more than
'width' columns, and return a new string containing the entire wrapped
paragraph.  As with wrap(), tabs are expanded and other whitespace
characters converted to space.  See TextWrapper class for available keyword
args to customize wrapping behaviour.
>>> print(textwrap.fill(txt, width=45))
Reformat the single paragraph in 'text' to
fit in lines of no more than 'width' columns,
and return a new string containing the entire
wrapped paragraph.  As with wrap(), tabs are
expanded and other whitespace characters
converted to space.  See TextWrapper class
for available keyword args to customize
wrapping behaviour.
>>> print(textwrap.fill(txt, width=85))
Reformat the single paragraph in 'text' to fit in lines of no more than 'width'
columns, and return a new string containing the entire wrapped paragraph.  As with
wrap(), tabs are expanded and other whitespace characters converted to space.  See
TextWrapper class for available keyword args to customize wrapping behaviour.
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Runge-Kutta_method,Runge-Kutta method,"Given the example Differential equation:






y
′

(
t
)
=
t
×


y
(
t
)




{\displaystyle y'(t)=t\times {\sqrt {y(t)}}}


With initial condition:






t

0


=
0


{\displaystyle t_{0}=0}

 and 




y

0


=
y
(

t

0


)
=
y
(
0
)
=
1


{\displaystyle y_{0}=y(t_{0})=y(0)=1}


This equation has an exact solution:





y
(
t
)
=



1
16



(

t

2


+
4

)

2




{\displaystyle y(t)={\tfrac {1}{16}}(t^{2}+4)^{2}}




Task
Demonstrate the commonly used explicit   fourth-order Runge–Kutta method   to solve the above differential equation.

 Solve the given differential equation over the range 



t
=
0
…
10


{\displaystyle t=0\ldots 10}

 with a step value of 



δ
t
=
0.1


{\displaystyle \delta t=0.1}

 (101 total points, the first being given)
 Print the calculated values of 



y


{\displaystyle y}

 at whole numbered 



t


{\displaystyle t}

's (



0.0
,
1.0
,
…
10.0


{\displaystyle 0.0,1.0,\ldots 10.0}

) along with error as compared to the exact solution.


Method summary
Starting with a given 




y

n




{\displaystyle y_{n}}

 and 




t

n




{\displaystyle t_{n}}

 calculate:





δ

y

1


=
δ
t
×

y
′

(

t

n


,

y

n


)



{\displaystyle \delta y_{1}=\delta t\times y'(t_{n},y_{n})\quad }






δ

y

2


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

1


)


{\displaystyle \delta y_{2}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{1})}






δ

y

3


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

2


)


{\displaystyle \delta y_{3}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{2})}






δ

y

4


=
δ
t
×

y
′

(

t

n


+
δ
t
,

y

n


+
δ

y

3


)



{\displaystyle \delta y_{4}=\delta t\times y'(t_{n}+\delta t,y_{n}+\delta y_{3})\quad }


then:






y

n
+
1


=

y

n


+



1
6



(
δ

y

1


+
2
δ

y

2


+
2
δ

y

3


+
δ

y

4


)


{\displaystyle y_{n+1}=y_{n}+{\tfrac {1}{6}}(\delta y_{1}+2\delta y_{2}+2\delta y_{3}+\delta y_{4})}







t

n
+
1


=

t

n


+
δ
t



{\displaystyle t_{n+1}=t_{n}+\delta t\quad }



",Python,"from math import sqrt
 
def rk4(f, x0, y0, x1, n):
    vx = [0] * (n + 1)
    vy = [0] * (n + 1)
    h = (x1 - x0) / float(n)
    vx[0] = x = x0
    vy[0] = y = y0
    for i in range(1, n + 1):
        k1 = h * f(x, y)
        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)
        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)
        k4 = h * f(x + h, y + k3)
        vx[i] = x = x0 + i * h
        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6
    return vx, vy
 
def f(x, y):
    return x * sqrt(y)
 
vx, vy = rk4(f, 0, 1, 10, 100)
for x, y in list(zip(vx, vy))[::10]:
    print(""%4.1f %10.5f %+12.4e"" % (x, y, y - (4 + x * x)**2 / 16))
 
 0.0    1.00000  +0.0000e+00
 1.0    1.56250  -1.4572e-07
 2.0    4.00000  -9.1948e-07
 3.0   10.56250  -2.9096e-06
 4.0   24.99999  -6.2349e-06
 5.0   52.56249  -1.0820e-05
 6.0   99.99998  -1.6595e-05
 7.0  175.56248  -2.3518e-05
 8.0  288.99997  -3.1565e-05
 9.0  451.56246  -4.0723e-05
10.0  675.99995  -5.0983e-05",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/GUI_component_interaction,GUI component interaction,"

Almost every application needs to communicate with the user in some way.
Therefore, a substantial part of the code deals with the interaction
of program logic with GUI components.

Typically, the following is needed:

 put values into input fields under program control
 read and check input from the user
 pop up dialogs to query the user for further information


Task

For a minimal ""application"", write a program that presents a form with three components to the user:

 a numeric input field (""Value"") 
 a button (""increment"")
 a button (""random"")


The field is initialized to zero.

The user may manually enter a new value into the field,
or increment its value with the ""increment"" button.

Entering a non-numeric value should be either impossible,
or issue an error message.

Pressing the ""random"" button presents a confirmation dialog,
and resets the field's value to a random value if the answer is ""Yes"".

(This task may be regarded as an extension of the task Simple windowed application).


",Python,"#include <iostream>
#include <fstream>
#include <string>

using namespace std;

class FileInteraction {
public:
    FileInteraction(string filename);
    ~FileInteraction();
    void write(string text);
    string read();

private:
    string filename;
    ofstream file;
};

FileInteraction::FileInteraction(string filename) {
    this->filename = filename;
    file.open(filename);
}

FileInteraction::~FileInteraction() {
    file.close();
}

void FileInteraction::write(string text) {
    file << text;
}

string FileInteraction::read() {
    string text;
    ifstream file(filename);
    getline(file, text);
    return text;
}",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Water_collected_between_towers,Water collected between towers,"Task

In a two-dimensional world, we begin with any bar-chart (or row of close-packed 'towers', each of unit width), and then it rains,
completely filling all convex enclosures in the chart with water.



9               ██           9               ██    
8               ██           8               ██    
7     ██        ██           7     ██≈≈≈≈≈≈≈≈██    
6     ██  ██    ██           6     ██≈≈██≈≈≈≈██    
5 ██  ██  ██  ████           5 ██≈≈██≈≈██≈≈████    
4 ██  ██  ████████           4 ██≈≈██≈≈████████    
3 ██████  ████████           3 ██████≈≈████████    
2 ████████████████  ██       2 ████████████████≈≈██
1 ████████████████████       1 ████████████████████


In the example above, a bar chart representing the values [5, 3, 7, 2, 6, 4, 5, 9, 1, 2] has filled, collecting 14 units of water.

Write a function, in your language, from a given array of heights, to the number of water units that can be held in this way, by a corresponding bar chart.

Calculate the number of water units that could be collected by bar charts representing each of the following seven series:

   [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]


See, also:

 Four Solutions to a Trivial Problem – a Google Tech Talk by Guy Steele
 Water collected between towers on Stack Overflow, from which the example above is taken)
 An interesting Haskell solution, using the Tardis monad, by Phil Freeman in a Github gist.

",Python,"def maxl(hm):
    res = [0] * len(hm)
    max = 1
    for i in range(0,len(hm)):
        if hm[i] > max:
            max = hm[i]
        res[i] = max
    return res
def maxr(hm):
    res = [0] * len(hm)
    max = 1
    for i in range(len(hm) - 1,0,-1):
        if hm[i] > max:
            max = hm[i]
        res[i] = max
    return res
def min(a,b):
    res = [0] * len(a)
    for i in range(0,len(a)):
        if a[i] >= b[i]:
            res[i] = b[i]
        else:
            res[i] = a[i]
    return res
def diff(hm, min):
    res = [0] * len(hm)
    for i in range(0,len(hm)):
        if min[i] > hm[i]:
            res[i] = min[i] - hm[i]
    return res
def sum(a):
    res = 0
    for i in range(0,len(a)):
        res += a[i]
    return res
def waterCollected(hm):
    maxr = maxr(hm)
    maxl = maxl(hm)
    min = min(maxr,maxl)
    diff = diff(hm,min)
    sum = sum(diff)
    return sum
print(waterCollected([1, 5, 3, 7, 2]))
print(waterCollected([5, 3, 7, 2, 6, 4, 5, 9, 1, 2]))
print(waterCollected([2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1]))
print(waterCollected([5, 5, 5, 5]))
print(waterCollected([5, 6, 7, 8]))
print(waterCollected([8, 7, 7, 6]))
print(waterCollected([6, 7, 10, 7, 6]))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Nonoblock,Nonoblock,"Nonoblock is a chip off the old Nonogram puzzle.



Given

 The number of cells in a row.
 The size of each, (space separated), connected block of cells to fit in the row, in left-to right order.


Task
 
 show all possible positions. 
 show the number of positions of the blocks for the following cases within the row. 
 show all output on this page. 
 use a ""neat"" diagram of the block positions.


Enumerate the following configurations

   5   cells   and   [2, 1]   blocks
   5   cells   and   []   blocks   (no blocks)
   10   cells   and   [8]   blocks
   15   cells   and   [2, 3, 2, 3]   blocks
   5   cells   and   [2, 3]   blocks   (should give some indication of this not being possible)


Example

Given a row of five cells and a block of two cells followed by a block of one cell - in that order, the example could be shown as:

   |_|_|_|_|_| # 5 cells and [2, 1] blocks

And would expand to the following 3 possible rows of block positions:

   |A|A|_|B|_|
   |A|A|_|_|B|
   |_|A|A|_|B|



Note how the sets of blocks are always separated by a space.

Note also that it is not necessary for each block to have a separate letter.
Output approximating

This:

                       |#|#|_|#|_|
                       |#|#|_|_|#|
                       |_|#|#|_|#|

This would also work:

                       ##.#.
                       ##..#
                      .##.#



An algorithm

 Find the minimum space to the right that is needed to legally hold all but the leftmost block of cells (with a space between blocks remember).
 The leftmost cell can legitimately be placed in all positions from the LHS up to a RH position that allows enough room for the rest of the blocks.
 for each position of the LH block recursively compute the position of the rest of the blocks in the remaining space to the right of the current placement of the LH block.
(This is the algorithm used in the Nonoblock#Python solution).



Reference

 The blog post Nonogram puzzle solver (part 1) Inspired this task and donated its Nonoblock#Python solution.

",Python,"def printBlock(data, le):
    a = list(data)
    sumBytes = 0
    for b in a:
        sumBytes += int(b) - 48
    print(""\nblocks %c, cells %d\n"" % (a, le))
    if le - sumBytes <= 0:
        print(""No solution"")
        return
    prep = []
    for b in a:
        prep.append(""1"" * (int(b) - 48))
    for r in genSequence(prep, le - sumBytes + 1):
        print(r[1:])
 
def genSequence(ones, numZeros):
    if len(ones) == 0:
        return [""0"" * numZeros]
    result = []
    for x in range(1, numZeros - len(ones) + 2):
        skipOne = ones[1:]
        for tail in genSequence(skipOne, numZeros - x):
            result.append(""0"" * x + ones[0] + tail)
    return result
 
printBlock(""21"", 5)
printBlock("""", 5)
printBlock(""8"", 10)
printBlock(""2323"", 15)
printBlock(""23"", 5)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",Python,">>> def flatten(lst):
	return sum( ([x] if not isinstance(x, list) else flatten(x)
		     for x in lst), [] )
 
>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
>>> flatten(lst)
[1, 2, 3, 4, 5, 6, 7, 8]",Human_written,Python_from_C
http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",Python,"from PIL import Image
 
if __name__ == ""__main__"":
	w, h, zoom = 800,600,1
	bitmap = Image.new(""RGB"", (w, h), ""white"")
	pix = bitmap.load()
 
	cX, cY = -0.7, 0.27015
	moveX, moveY = 0.0, 0.0
	maxIter = 255
 
	for x in range(w):
		for y in range(h):
			zx = 1.5*(x - w/2)/(0.5*zoom*w) + moveX
			zy = 1.0*(y - h/2)/(0.5*zoom*h) + moveY
			i = maxIter
			while zx*zx + zy*zy < 4 and i > 1:
				tmp = zx*zx - zy*zy + cX
				zy,zx = 2.0*zx*zy + cY, tmp
				i -= 1
			# convert byte to RGB (3 bytes), kinda magic to get nice colors
			pix[x][y] = (i << 21) + (i << 10) + i*8
 
	bitmap.show()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Equilibrium_index,Equilibrium index,"An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.



For example, in a sequence   



A


{\displaystyle A}

:

   




A

0


=
−
7


{\displaystyle A_{0}=-7}


   




A

1


=
1


{\displaystyle A_{1}=1}


   




A

2


=
5


{\displaystyle A_{2}=5}


   




A

3


=
2


{\displaystyle A_{3}=2}


   




A

4


=
−
4


{\displaystyle A_{4}=-4}


   




A

5


=
3


{\displaystyle A_{5}=3}


   




A

6


=
0


{\displaystyle A_{6}=0}


3   is an equilibrium index, because:

   




A

0


+

A

1


+

A

2


=

A

4


+

A

5


+

A

6




{\displaystyle A_{0}+A_{1}+A_{2}=A_{4}+A_{5}+A_{6}}


6   is also an equilibrium index, because:

   




A

0


+

A

1


+

A

2


+

A

3


+

A

4


+

A

5


=
0


{\displaystyle A_{0}+A_{1}+A_{2}+A_{3}+A_{4}+A_{5}=0}


(sum of zero elements is zero)

7   is not an equilibrium index, because it is not a valid index of sequence 



A


{\displaystyle A}

.



Task;
Write a function that, given a sequence, returns its equilibrium indices (if any).

Assume that the sequence may be very long.



",Python,"from itertools import accumulate
from operator import add
 
def equilibrium(data):
    left = 0
    right = sum(data)
    result = []
 
    for index, value in enumerate(data):
        right -= value
        if left == right:
            result.append(index)
        left += value
    return result
 
if __name__ == '__main__':
    data = [-7, 1, 5, 2, -4, 3, 0]
    print(*equilibrium(data))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Atomic_updates,Atomic updates,"

Task

Define a data type consisting of a fixed number of 'buckets', each containing a nonnegative integer value, which supports operations to:

 get the current value of any bucket
 remove a specified amount from one specified bucket and add it to another, preserving the total of all bucket values, and clamping the transferred amount to ensure the values remain non-negative

In order to exercise this data type, create one set of buckets, and start three concurrent tasks:

 As often as possible, pick two buckets and make their values closer to equal.
 As often as possible, pick two buckets and arbitrarily redistribute their values.
 At whatever rate is convenient, display (by any means) the total value and, optionally, the individual values of each bucket.


The display task need not be explicit; use of e.g. a debugger or trace tool is acceptable provided it is simple to set up to provide the display.


This task is intended as an exercise in atomic operations.   The sum of the bucket values must be preserved even if the two tasks attempt to perform transfers simultaneously, and a straightforward solution is to ensure that at any time, only one transfer is actually occurring — that the transfer operation is atomic.



",Python,"from __future__ import with_statement # required for Python 2.5
import threading
import random
import time
 
terminate = threading.Event()
 
class Buckets:
    def __init__(self, nbuckets):
        self.nbuckets = nbuckets
        self.values = [random.randrange(10) for i in range(nbuckets)]
        self.lock = threading.Lock()
 
    def __getitem__(self, i):
        return self.values[i]
 
    def transfer(self, src, dst, amount):
        with self.lock:
            amount = min(amount, self.values[src])
            self.values[src] -= amount
            self.values[dst] += amount
 
    def snapshot(self):
        # copy of the current state (synchronized)
        with self.lock:
            return self.values[:]
 
def randomize(buckets):
    nbuckets = buckets.nbuckets
    while not terminate.isSet():
        src = random.randrange(nbuckets)
        dst = random.randrange(nbuckets)
        if dst!=src:
            amount = random.randrange(20)
            buckets.transfer(src, dst, amount)
 
def equalize(buckets):
    nbuckets = buckets.nbuckets
    while not terminate.isSet():
        src = random.randrange(nbuckets)
        dst = random.randrange(nbuckets)
        if dst!=src:
            amount = (buckets[src] - buckets[dst]) // 2
            if amount>=0: buckets.transfer(src, dst, amount)
            else: buckets.transfer(dst, src, -amount)
 
def print_state(buckets):
    snapshot = buckets.snapshot()
    for value in snapshot:
        print '%2d' % value,
    print '=', sum(snapshot)
 
# create 15 buckets
buckets = Buckets(15)
 
# the randomize thread
t1 = threading.Thread(target=randomize, args=[buckets])
t1.start()
 
# the equalize thread
t2 = threading.Thread(target=equalize, args=[buckets])
t2.start()
 
# main thread, display
try:
    while True:
        print_state(buckets)
        time.sleep(1)
except KeyboardInterrupt: # ^C to finish
    terminate.set()
 
# wait until all worker threads finish
t1.join()
t2.join()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Range_expansion,Range expansion,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).



Task

Expand the range description:

  -6,-3--1,3-5,7-11,14,15,17-20 

Note that the second element above,
is the range from minus 3 to minus 1. 



Related task

   Range extraction

",Python,"import re
import sys

input = ""-6,-3--1,3-5,7-11,14,15,17-20""

print(""range:"", input)
r = []
last = None
for part in re.split(r"","", input):
    if ""-"" not in part:
        n = int(part)
        if len(r) > 0:
            if last == n:
                print(""duplicate value:"", n)
                sys.exit(1)
            elif last > n:
                print(""values not ordered:"", last, "">"", n)
                sys.exit(1)
        r.append(n)
        last = n
    else:
        n1, n2 = map(int, part.split(""-""))
        if n2 < n1 + 2:
            print(""invalid range:"", part)
            sys.exit(1)
        if len(r) > 0:
            if last == n1:
                print(""duplicate value:"", n1)
                sys.exit(1)
            elif last > n1:
                print(""values not ordered:"", last, "">"", n1)
                sys.exit(1)
        r.extend(range(n1, n2 + 1))
        last = n2
print(""expanded:"", r)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Pseudo-random_numbers/Combined_recursive_generator_MRG32k3a,Pseudo-random numbers/Combined recursive generator MRG32k3a,"MRG32k3a Combined recursive generator (pseudo-code)

   /* Constants */
   /* First generator */
   a1 = [0, 1403580, -810728]
   m1 = 2**32 - 209
   /* Second Generator */
   a2 = [527612, 0, -1370589]
   m2 = 2**32 - 22853
    
   d = m1 + 1
   
   class MRG32k3a
       x1 = [0, 0, 0]  /* list of three last values of gen #1 */
       x2 = [0, 0, 0]  /* list of three last values of gen #2 */
       
       method seed(u64 seed_state)
           assert seed_state in range >0 and < d 
           x1 = [seed_state, 0, 0]
           x2 = [seed_state, 0, 0]
       end method
           
       method next_int()
           x1i = (a1[0]*x1[0] + a1[1]*x1[1] + a1[2]*x1[2]) mod m1
           x2i = (a2[0]*x2[0] + a2[1]*x2[1] + a2[2]*x2[2]) mod m2
           x1 = [x1i, x1[0], x1[1]]    /* Keep last three */
           x2 = [x2i, x2[0], x2[1]]    /* Keep last three */
           z = (x1i - x2i) % m1
           answer = (z + 1)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / d
       end method
       
   end class


MRG32k3a Use:
   random_gen = instance MRG32k3a
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 1459213977 */
   print(random_gen.next_int())   /* 2827710106 */
   print(random_gen.next_int())   /* 4245671317 */
   print(random_gen.next_int())   /* 3877608661 */
   print(random_gen.next_int())   /* 2595287583 */
   
       

Task
 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers generated with the seed `1234567`
are as shown above

 Show that for an initial seed of '987654321' the counts of 100_000
repetitions of

   floor(random_gen.next_float() * 5)

Is as follows:

   0: 20002, 1: 20060, 2: 19948, 3: 20059, 4: 19931

 Show your output here, on this page.

",Python,"import math
 
def mod(x, y):
    m = x % y
    return m if m >= 0 else m + y if y > 0 else m - y
 
class RNG:
    # first generator
    a1 = [0, 1403580, -810728]
    m1 = (1 << 32) - 209
    x1 = [0, 0, 0]
 
    # second generator
    a2 = [527612, 0, -1370589]
    m2 = (1 << 32) - 22853
    x2 = [0, 0, 0]
 
    d = m1 + 1
 
    def seed(self, state):
        self.x1 = [state, 0, 0]
        self.x2 = [state, 0, 0]
 
    def next_int(self):
        x1i = mod(self.a1[0] * self.x1[0] + self.a1[1] * self.x1[1] + self.a1[2] * self.x1[2], self.m1)
        x2i = mod(self.a2[0] * self.x2[0] + self.a2[1] * self.x2[1] + self.a2[2] * self.x2[2], self.m2)
        z = mod(x1i - x2i, self.m1)
 
        # keep last three values of the first generator
        self.x1 = [x1i, self.x1[0], self.x1[1]]
        # keep last three values of the second generator
        self.x2 = [x2i, self.x2[0], self.x2[1]]
 
        return z + 1
 
    def next_float(self):
        return self.next_int() / self.d
 
if __name__ == '__main__':
    rng = RNG()
 
    rng.seed(1234567)
    print(rng.next_int())
    print(rng.next_int())
    print(rng.next_int())
    print(rng.next_int())
    print(rng.next_int())
    print()
 
    counts = [0] * 5
    rng.seed(987654321)
    for _ in range(100_000):
        v = math.floor(rng.next_float() * 5)
        counts[v] += 1
    for iv in enumerate(counts):
        print(f'{iv[0]}: {iv[1]}')",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sort_numbers_lexicographically,Sort numbers lexicographically,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Given an integer   n,   return   1──►n   (inclusive)   in lexicographical order.



Show all output here on this page.



Example

Given   13,

return:   [1,10,11,12,13,2,3,4,5,6,7,8,9].
",Python,"n=13
print(sorted(range(1,n+1), key=str))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",Python,"from System import *
from System.Drawing import *
from System.Windows.Forms import *

class Form1(Form):
    def __init__(self):
        self.InitializeComponent()
        self.Paint += self.Form1_Paint

    def InitializeComponent(self):
        self.SuspendLayout()
        # 
        # Form1
        # 
        self.ClientSize = Size(284, 262)
        self.Name = ""Form1""
        self.Text = ""Form1""
        self.ResumeLayout(False)

    def Form1_Paint(self, sender, e):
        g = e.Graphics
        g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias
        self.DrawTaijitu(g, Point(50, 50), 200, True)
        self.DrawTaijitu(g, Point(10, 10), 60, True)

    def DrawTaijitu(self, g, pt, width, hasOutline):
        g.FillPie(Brushes.Black, pt.X, pt.Y, width, width, 90, 180)
        g.FillPie(Brushes.White, pt.X, pt.Y, width, width, 270, 180)
        headSize = Convert.ToSingle(width * 0.5)
        headXPosition = Convert.ToSingle(pt.X + (width * 0.25))
        g.FillEllipse(Brushes.Black, headXPosition, Convert.ToSingle(pt.Y), headSize, headSize)
        g.FillEllipse(Brushes.White, headXPosition, Convert.ToSingle(pt.Y + (width * 0.5)), headSize, headSize)
        headBlobSize = Convert.ToSingle(width * 0.125)
        headBlobXPosition = Convert.ToSingle(pt.X + (width * 0.4375))
        g.FillEllipse(Brushes.White, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.1875)), headBlobSize, headBlobSize)
        g.FillEllipse(Brushes.Black, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.6875)), headBlobSize, headBlobSize)
        if hasOutline: g.DrawEllipse(Pens.Black, pt.X, pt.Y, width, width)

Application.Run(Form1())",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",Python,"import os
 
class PasswordRecord:
    def __init__(self, account, password, UID, GID, fullname, office, extension, homephone, email, directory, shell):
        self.account = account
        self.password = 
        self.UID = UID
        self.GID = GID
        self.fullname = fullname
        self.office = office
        self.extension = extension
        self.homephone = homephone
        self.email = email
        self.directory = directory
        self.shell = shell
    def __str__(self):
        gecos = "","".join([self.fullname, self.office, self.extension, self.homephone, self.email])
        return "":"".join([self.account, self.password, str(self.UID), str(self.GID), gecos, self.directory, self.shell])
 
jsmith = PasswordRecord(""jsmith"", ""x"", 1001, 1000, """", ""Room 1007"", ""(234)555-8917"", ""(234)555-0077"", """", ""/home/jsmith"", ""/bin/bash"")
jdoe = PasswordRecord(""jdoe"", ""x"", 1002, 1000, """", ""Room 1004"", ""(234)555-8914"", ""(234)555-0044"", """", ""/home/jdoe"", ""/bin/bash"")
xyz = PasswordRecord(""xyz"", ""x"", 1003, 1000, ""X Yz"", ""Room 1003"", ""(234)555-8913"", ""(234)555-0033"", """", ""/home/xyz"", ""/bin/bash"")
 
# Write these records out in the typical system format.
with open(""passwd.txt"", ""w"") as f:
    f.write(str(jsmith) + ""\n"")
    f.write(str(jdoe) + ""\n"")
 
# Append a new record to the file and close the file again.
with open(""passwd.txt"", ""a"") as f:
    f.write(str(xyz) + ""\n"")
 
# Open the file and demonstrate the new record has indeed written to the end.
with open(""passwd.txt"", ""r"") as f:
    lines = f.readlines()
    print(""Appended record: "" + lines[2])",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Quickselect_algorithm,Quickselect algorithm,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Use the quickselect algorithm on the vector

 [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
To show the first, second, third, ... up to the tenth largest member of the vector, in order, here on this page.

 Note: Quicksort has a separate task. 

",Python,"import random
 
def partition(vector, left, right, pivotIndex):
    pivotValue = vector[pivotIndex]
    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  # Move pivot to end
    storeIndex = left
    for i in range(left, right):
        if vector[i] < pivotValue:
            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]
            storeIndex += 1
    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  # Move pivot to its final place
    return storeIndex
 
def _select(vector, left, right, k):
    ""Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.""
    while True:
        pivotIndex = random.randint(left, right)     # select pivotIndex between left and right
        pivotNewIndex = partition(vector, left, right, pivotIndex)
        pivotDist = pivotNewIndex - left
        if pivotDist == k:
            return vector[pivotNewIndex]
        elif k < pivotDist:
            right = pivotNewIndex - 1
        else:
            k -= pivotDist + 1
            left = pivotNewIndex + 1
 
def select(vector, k, left=None, right=None):
    """"""\
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    """"""
    if left is None:
        left = 0
    lv1 = len(vector) - 1
    if right is None:
        right = lv1
    assert vector and k >= 0, ""Either null vector or k < 0 ""
    assert 0 <= left <= lv1, ""left is out of range""
    assert left <= right <= lv1, ""right is out of range""
    return _select(vector, left, right, k)
 
if __name__ == '__main__':
    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
    print([select(v, i) for i in range(10)])",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Entropy,Entropy,"Task

Calculate the Shannon entropy   H   of a given input string.

Given the discrete random variable 



X


{\displaystyle X}

 that is a string of 



N


{\displaystyle N}

 ""symbols"" (total characters) consisting of 



n


{\displaystyle n}

 different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :






H

2


(
X
)
=
−

∑

i
=
1


n





c
o
u
n

t

i



N



log

2


⁡

(



c
o
u
n

t

i



N


)



{\displaystyle H_{2}(X)=-\sum _{i=1}^{n}{\frac {count_{i}}{N}}\log _{2}\left({\frac {count_{i}}{N}}\right)}


where 



c
o
u
n

t

i




{\displaystyle count_{i}}

 is the count of character 




n

i




{\displaystyle n_{i}}

.

For this task, use X=""1223334444"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.

This coding problem calculates the ""specific"" or ""intensive"" entropy that finds its parallel in physics with ""specific entropy"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the ""information"" content of a file. It comes from Boltzmann's H-theorem where 



S
=

k

B


N
H


{\displaystyle S=k_{B}NH}

 where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a ""per molecule"" basis.

The ""total"", ""absolute"", or ""extensive"" information entropy is





S
=

H

2


N


{\displaystyle S=H_{2}N}

 bits
This is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of ""information"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have 



S
=
N

log

2


⁡
(
16
)


{\displaystyle S=N\log _{2}(16)}

 bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.

The H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much ""order"" was in the data.

Two other ""entropies"" are useful:

Normalized specific entropy:






H

n


=




H

2


∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle H_{n}={\frac {H_{2}*\log(2)}{\log(n)}}}

 
which varies from 0 to 1 and it has units of ""entropy/symbol"" or just 1/symbol. For this example, Hn<\sub>= 0.923.

Normalized total (extensive) entropy:






S

n


=




H

2


N
∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle S_{n}={\frac {H_{2}N*\log(2)}{\log(n)}}}


which varies from 0 to N and does not have units. It is simply the ""entropy"", but it needs to be called ""total normalized extensive entropy"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\sub>= 9.23.

Shannon himself is the reason his ""entropy/symbol"" H function is very confusingly called ""entropy"". That's like calling a function that returns a speed a ""meter"". See section 1.7 of his classic A Mathematical Theory of Communication and search on ""per symbol"" and ""units"" to see he always stated his entropy H has units of ""bits/symbol"" or ""entropy/symbol"" or ""information/symbol"". So it is legitimate to say entropy NH is ""information"".

In keeping with Landauer's limit, the physics entropy generated from erasing N bits is 



S
=

H

2


N

k

B


ln
⁡
(
2
)


{\displaystyle S=H_{2}Nk_{B}\ln(2)}

 if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.

Related tasks

 Fibonacci_word
 Entropy/Narcissist

",Python,"import math
import collections
 
def getShannonEntropy(s):
    n = 0
    occ = collections.defaultdict(int)
 
    for c in s:
        occ[c] += 1
        n += 1
 
    e = 0.0
    for cx, p in occ.items():
        p = p / n
        e += p * math.log(p, 2)
    return -e
 
if __name__ == ""__main__"":
    sstr = [
        ""1223334444"",
        ""1223334444555555555"", 
        ""122333"", 
        ""1227774444"",
        ""aaBBcccDDDD"",
        ""1234567890abcdefghijklmnopqrstuvwxyz"",
        ""Rosetta Code"",
    ]
 
    for ss in sstr:
        entropy = getShannonEntropy(ss)
        print(""Shannon entropy of %40s: %.12f"" % (""\"""" + ss + ""\"""", entropy))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order,Magic squares of doubly even order,"A magic square is an   N×N  square matrix whose numbers consist of consecutive numbers arranged so that the sum of each row and column,   and   both diagonals are equal to the same sum   (which is called the magic number or magic constant).

A magic square of doubly even order has a size that is a multiple of four   (e.g.     4, 8, 12).

This means that the subsquares also have an even size, which plays a role in the construction.



1
2
62
61
60
59
7
8


9
10
54
53
52
51
15
16


48
47
19
20
21
22
42
41


40
39
27
28
29
30
34
33


32
31
35
36
37
38
26
25


24
23
43
44
45
46
18
17


49
50
14
13
12
11
55
56


57
58
6
5
4
3
63
64



Task
Create a magic square of   8 × 8.



Related tasks
 Magic squares of odd order
 Magic squares of singly even order



See also

 Doubly Even Magic Squares (1728.org)

",Python,"def MagicSquareDoublyEven(order):
    sq = [range(1+n*order,order + (n*order)+1) for n in range(order) ]
    n1 = order/4
    for r in range(n1):
        r1 = sq[r][n1:-n1]
        r2 = sq[order -r - 1][n1:-n1]
        r1.reverse()
        r2.reverse()
        sq[r][n1:-n1] = r2
        sq[order -r - 1][n1:-n1] = r1
    for r in range(n1, order-n1):
        r1 = sq[r][:n1]
        r2 = sq[order -r - 1][order-n1:]
        r1.reverse()
        r2.reverse()
        sq[r][:n1] = r2
        sq[order -r - 1][order-n1:] = r1
    return sq
 
def printsq(s):
    n = len(s)
    bl = len(str(n**2))+1
    for i in range(n):
        print ''.join( [ (""%""+str(bl)+""s"")%(str(x)) for x in s[i]] )
    print ""\nMagic constant = %d""%sum(s[0])
 
printsq(MagicSquareDoublyEven(8))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Fibonacci_word,Fibonacci word,"The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:

    Define   F_Word1   as   1
    Define   F_Word2   as   0
    Form     F_Word3   as   F_Word2     concatenated with   F_Word1    i.e.:   01
    Form     F_Wordn   as   F_Wordn-1   concatenated with   F_wordn-2



Task

Perform the above steps for     n = 37.

You may display the first few but not the larger values of   n.

{Doing so will get the task's author into trouble with them what be (again!).} 

Instead, create a table for   F_Words   1   to   37   which shows:

   The number of characters in the word
   The word's Entropy


Related tasks
 
   Fibonacci word/fractal
   Entropy
   Entropy/Narcissist

",Python,"import math
import sys
 
def main():
    print_heading()
    first_string = ""1""
    n = 1
    print_line(n, first_string)
    second_string = ""0""
    n += 1
    print_line(n, second_string)
    while n < 37:
        result_string = first_string + second_string
        first_string = second_string
        second_string = result_string
        n += 1
        print_line(n, result_string)
 
def print_line(n, result):
    print(""{0:5d} {1:12d}  {2:16.12f}"".format(n, len(result), get_entropy(result)))
 
def get_entropy(result):
    frequencies = {}
    for c in result:
        if c in frequencies:
            frequencies[c] += 1
        else:
            frequencies[c] = 1
 
    length = len(result)
    entropy = 0
    for key, value in frequencies.items():
        freq = value / length
        entropy += freq * math.log(freq, 2)
 
    return -entropy
 
def print_heading():
    print(""{0:5s} {1:12s}  {2:16s}"".format(""N"", ""Length"", ""Entropy""))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Break_OO_privacy,Break OO privacy,"Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.
The intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.
The intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.

Note that cheating on your type system is almost universally regarded
as unidiomatic at best, and poor programming practice at worst.
Nonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.
",Python,">>> class MyClassName:
	__private = 123
	non_private = __private * 2
 
 
>>> mine = MyClassName()
>>> mine.non_private
246
>>> mine.__private
Traceback (most recent call last):
  File ""<pyshell#23>"", line 1, in <module>
    mine.__private
AttributeError: 'MyClassName' object has no attribute '__private'
>>> mine._MyClassName__private
123
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Order_two_numerical_lists,Order two numerical lists,"sorting

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Write a function that orders two lists or arrays filled with numbers.
The function should accept two lists as arguments and return true if the first list should be ordered before the second, and false otherwise.

The order is determined by lexicographic order: Comparing the first element of each list.
If the first elements are equal, then the second elements should be compared, and so on, until one of the list has no more elements.
If the first list runs out of elements the result is true.
If the second list or both run out of elements the result is false.

Note: further clarification of lexicographical ordering is expounded on the talk page here and here.
",Python,">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]
False",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort,Sorting algorithms/Gnome sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Gnome sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Gnome sort is a sorting algorithm which is similar to Insertion sort, except that moving an element to its proper place is accomplished by a series of swaps, as in Bubble Sort.

The pseudocode for the algorithm is:

function gnomeSort(a[0..size-1])
    i := 1
    j := 2
    while i < size do
        if a[i-1] <= a[i] then
            // for descending sort, use >= for comparison
            i := j
            j := j + 1 
        else
            swap a[i-1] and a[i]
            i := i - 1
            if i = 0 then
                i := j
                j := j + 1
            endif
        endif
    done



Task

Implement the Gnome sort in your language to sort an array (or list) of numbers.



",Python,"def gnomeSort(a):
    def moveBack(i):
        for i in range(i, 0, -1):
            if a[i-1] > a[i]:
                t = a[i]
                a[i] = a[i-1]
                a[i-1] = t
            else:
                break
    for i in range(1, len(a)):
        if a[i-1] > a[i]:
            moveBack(i)
    return a",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Window_creation,Window creation,"Display a GUI window. The window need not have any contents, but should respond to requests to be closed.
",Python,"from javax.swing import JFrame

def main():
    w = JFrame(""Title"")
    w.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)
    w.setSize(800, 600)
    w.setVisible(True)

if __name__ == '__main__':
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Fibonacci_word/fractal,Fibonacci word/fractal,"
The Fibonacci word may be represented as a fractal as described here:


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)



For F_wordm start with F_wordCharn=1
Draw a segment forward
If current F_wordChar is 0
Turn left if n is even
Turn right if n is odd
next n and iterate until end of F_word


Task

Create and display a fractal similar to Fig 1.


(Clicking on the above website   (hal.archives-ouvertes.fr)    will leave a cookie.)
",Python,"import java.awt.*;
import javax.swing.*;
 
public class FibonacciWordFractal extends JPanel {
    String wordFractal;
 
    FibonacciWordFractal(int n) {
        setPreferredSize(new Dimension(450, 620));
        setBackground(Color.white);
        wordFractal = wordFractal(n);
    }
 
    public String wordFractal(int n) {
        if (n < 2)
            return n == 1? ""1"" : """";
 
        # we should really reserve fib n space here
        StringBuilder f1 = new StringBuilder(""1"");
        StringBuilder f2 = new StringBuilder(""0"");
 
        for (n = n - 2; n > 0; n--) {
            String tmp = f2.toString();
            f2.append(f1);
 
            f1.setLength(0);
            f1.append(tmp);
        }
 
        return f2.toString();
    }
 
    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {
        for (int n = 0; n < wordFractal.length(); n++) {
            g.drawLine(x, y, x + dx, y + dy);
            x += dx;
            y += dy;
            if (wordFractal.charAt(n) == '0') {
                int tx = dx;
                dx = (n % 2 == 0)? -dy : dy;
                dy = (n % 2 == 0)? tx : -tx;
            }
        }
    }
 
    @Override
    public void paintComponent(Graphics gg) {
        super.paintComponent(gg);
        Graphics2D g = (Graphics2D) gg;
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);
 
        drawWordFractal(g, 20, 20, 1, 0);
    }
 
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame f = new JFrame();
            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            f.setTitle(""Fibonacci Word Fractal"");
            f.setResizable(false);
            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);
            f.pack();
            f.setLocationRelativeTo(null);
            f.setVisible(true);
        });
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Dining_philosophers,Dining philosophers,"The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.

Five philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.

It can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.

There are many solutions of the problem, program at least one, and explain how the deadlock is prevented.
",Python,"import random
import time
from threading import Thread, Condition
 
# Number of philosophers is simply the length of this list.
# It is not otherwise fixed in the program.
PH = [""Aristotle"", ""Kant"", ""Spinoza"", ""Marx"", ""Russell""]
 
HUNGER = 3  # number of times each philosopher eats
THINK = 0.1  # mean think time
EAT = 0.1  # mean eat time
 
done = Condition()
 
# This solution uses channels to implement synchronization.
# Sent over channels are ""forks.""
class Fork(object):
    def __init__(self):
        self.lock = Condition()
        self.lock.acquire()
 
# A fork object in the program models a physical fork in the simulation.
# A separate channel represents each fork place.  Two philosophers
# have access to each fork.  The channels are buffered with capacity = 1,
# representing a place for a single fork.
 
# Goroutine for philosopher actions.  An instance is run for each
# philosopher.  Instances run concurrently.
def philosopher(ph_name, dominant_hand, other_hand):
    print(ph_name, ""seated"")
    # each philosopher goroutine has a random number generator,
    # seeded with a hash of the philosopher's name.
    rg = random.Random(hash(ph_name))
    # utility function to sleep for a randomized nominal time
    def r_sleep(t):
        time.sleep(t/2 + rg.random() * t)
    for h in range(HUNGER):
        print(ph_name, ""hungry"")
        with dominant_hand.lock:
            dominant_hand.lock.wait()
        with other_hand.lock:
            other_hand.lock.wait()
        print(ph_name, ""eating"")
        r_sleep(EAT)
        with dominant_hand.lock:
            dominant_hand.lock.notify()
        with other_hand.lock:
            other_hand.lock.notify()
        print(ph_name, ""thinking"")
        r_sleep(THINK)
    print(ph_name, ""satisfied"")
    with done:
        done.notify()
    print(ph_name, ""left the table"")
 
def main():
    print(""table empty"")
    # Create fork channels and start philosopher goroutines,
    # supplying each goroutine with the appropriate channels
    place0 = Fork()
    place_left = place0
    for i in range(1, len(PH)):
        place_right = Fork()
        Thread(target=philosopher, args=(PH[i], place_left, place_right)).start()
        place_left = place_right
    # Make one philosopher left handed by reversing fork place
    # supplied to philosopher's dominant hand.
    # This makes precedence acyclic, preventing deadlock.
    Thread(target=philosopher, args=(PH[0], place0, place_left)).start()
    # they are all now busy eating
    with done:
        done.wait(len(PH))
    print(""table empty"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/FASTA_format,FASTA format,"In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.



Task

Write a program that reads a FASTA file such as:

>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED


Output:
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.



",Python,"import io
 
FASTA='''\
>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED'''
 
infile = io.StringIO(FASTA)
 
def fasta_parse(infile):
    key = ''
    for line in infile:
        if line.startswith('>'):
            if key:
                yield key, val
            key, val = line[1:].rstrip().split()[0], ''
        elif key:
            val += line.rstrip()
    if key:
        yield key, val
 
print('\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Averages/Mean_time_of_day,Averages/Mean time of day,"Task[edit]
A particular activity of bats occurs at these times of the day:

23:00:17, 23:40:20, 00:12:45, 00:17:19
Using the idea that there are twenty-four hours in a day,
which is analogous to there being 360 degrees in a circle,
map times of day to and from angles;
and using the ideas of Averages/Mean angle
compute and show the average time of the nocturnal activity
to an accuracy of one second of time.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,"import math

def meanAngle(angles):
    len = len(angles)
    sinSum = 0.0
    for i in range(len):
        sinSum += math.sin(angles[i] * math.pi / 180.0)

    cosSum = 0.0
    for i in range(len):
        cosSum += math.cos(angles[i] * math.pi / 180.0)

    return math.atan2(sinSum / len, cosSum / len) * 180.0 / math.pi

def timeToSecs(t):
    hours = int(t[0:2])
    mins  = int(t[3:5])
    secs  = int(t[6:8])
    return 3600 * hours + 60 * mins + secs

def timeToDegrees(t):
    return timeToSecs(t) / 240.0

def degreesToTime(d):
    if d < 0.0:
        d += 360.0
    secs  = int(d * 240.0)
    hours = secs / 3600
    mins  = secs % 3600
    secs = mins % 60
    mins /= 60
    return ""%2d:%2d:%2d"" % (hours, mins, secs)

if __name__ == ""__main__"":
    tm = [""23:00:17"", ""23:40:20"", ""00:12:45"", ""00:17:19""]
    angles = [timeToDegrees(t) for t in tm]
    mean = meanAngle(angles)
    print(""Average time is : "" + degreesToTime(mean))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sequence:_smallest_number_with_exactly_n_divisors,Sequence: smallest number with exactly n divisors,"Calculate the sequence where each term   an   is the smallest natural number that has exactly   n   divisors.



Task
Show here, on this page, at least the first  15  terms of the sequence.



Related tasks

 Sequence: smallest number greater than previous term with exactly n divisors
 Sequence: nth number with exactly n divisors‎‎


See also

 OEIS:A005179

",Python,"import math
 
MAX = 15
 
def count_divisors(n):
    count = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if i == n / i:
                count += 1
            else:
                count += 2
    return count
 
def main():
    seq = [0] * MAX
    print(""The first"", MAX, ""terms of the sequence are:"")
    for i in range(1, MAX + 1):
        k = count_divisors(i)
        if k <= MAX and seq[k - 1] == 0:
            seq[k - 1] = i
    for i in range(MAX):
        print(seq[i], end="" "")
    print()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Range_expansion,Range expansion,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).



Task

Expand the range description:

  -6,-3--1,3-5,7-11,14,15,17-20 

Note that the second element above,
is the range from minus 3 to minus 1. 



Related task

   Range extraction

",Python,"import re
 
def parse_number_list_with_ranges(s):
    """"""
    Parse a list of numbers with ranges.
    """"""
    # the list always has to start with a number
    for number in re.findall(r'-?\d+', s):
        yield int(number)
        m = re.match(r'(-?\d+)-(-?\d+)', s)
        if m:
            number2 = int(m.group(2))
            if number2 < number:
                return False
            while number < number2:
                yield int(number)
                number += 1
            s = s[m.end():]
        else:
            return s.strip() == ''
 
if __name__ == '__main__':
    example = ""-6,-3--1,3-5,7-11,14,15,17-20""
    for number in parse_number_list_with_ranges(example):
        print number",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/N%27th,N'th,"Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix.



Example

Returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th



Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs:
0..25, 250..265, 1000..1025


Note: apostrophes are now optional to allow correct apostrophe-less English.



",Python,"_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']
 
def nth(n):
    return ""%i'%s"" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')
 
if __name__ == '__main__':
    for j in range(0,1001, 250):
        print(' '.join(nth(i) for i in list(range(j, j+25))))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers,Sort a list of object identifiers,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Object identifiers (OID)


Task

Show how to sort a list of OIDs, in their natural sort order.

Details
 An OID consists of one or more non-negative integers in base 10, separated by dots. It starts and ends with a number.
 Their natural sort order is lexicographical with regard to the dot-separated fields, using numeric comparison between fields.
Test case


 Input (list of strings)

 Output (list of strings)



1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11150.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11150.3.4.0



1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11150.3.4.0
1.3.6.1.4.1.11150.3.4.0.1


Related tasks
 Natural sorting
 Sort using a custom comparator
",Python,"data = [
    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',
    '1.3.6.1.4.1.11.2.17.5.2.0.79',
    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',
    '1.3.6.1.4.1.11150.3.4.0.1',
    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',
    '1.3.6.1.4.1.11150.3.4.0'
]
 
for s in sorted(data, key=lambda x: list(map(int, x.split('.')))):
    print(s)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Jensen%27s_Device,Jensen's Device,"Jensen's Device

You are encouraged to solve this task according to the task description, using any language you may know.
This task is an exercise in call by name.

Jensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.

The following program was proposed to illustrate the technique. It computes the 100th harmonic number:

begin
   integer i;
   real procedure sum (i, lo, hi, term);
      value lo, hi;
      integer i, lo, hi;
      real term;
      comment term is passed by-name, and so is i;
   begin
      real temp;
      temp := 0;
      for i := lo step 1 until hi do
         temp := temp + term;
      sum := temp
   end;
   comment note the correspondence between the mathematical notation and the call to sum;
   print (sum (i, 1, 100, 1/i))
end

The above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.

Moreover, the first parameter to sum, representing the ""bound"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.
(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)

Donald Knuth later proposed the Man or Boy Test as a more rigorous exercise.



",Python,"class Ref(object):
    def __init__(self, value=None):
        self.value = value
 
def harmonic_sum(i, lo, hi, term):
    # term is passed by-name, and so is i
    temp = 0
    i.value = lo
    while i.value <= hi:  # Python ""for"" loop creates a distinct which
        temp += term() # would not be shared with the passed ""i""
        i.value += 1   # Here the actual passed ""i"" is incremented.
    return temp
 
i = Ref()
 
# note the correspondence between the mathematical notation and the
# call to sum it's almost as good as sum(1/i for i in range(1,101))
print harmonic_sum(i, 1, 100, lambda: 1.0/i.value)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pascal%27s_triangle,Pascal's triangle,"Pascal's triangle is an arithmetic and geometric figure often associated with the name of Blaise Pascal, but also studied centuries earlier in India, Persia, China and elsewhere.

Its first few rows look like this: 

    1
   1 1
  1 2 1
 1 3 3 1 

where each element of each row is either 1 or the sum of the two elements right above it.

For example, the next row of the triangle would be:

   1   (since the first element of each row doesn't have two elements above it)
   4   (1 + 3)
   6   (3 + 3)
   4   (3 + 1)
   1   (since the last element of each row doesn't have two elements above it) 
So the triangle now looks like this: 

    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1 

Each row    n    (starting with row   0   at the top) shows the coefficients of the binomial expansion of    (x + y)n. 



Task

Write a function that prints out the first    n    rows of the triangle   (with    f(1)    yielding the row consisting of only the element 1).

This can be done either by summing elements from the previous rows or using a binary coefficient or combination function.

Behavior for    n ≤ 0    does not need to be uniform, but should be noted.



See also

 Evaluate binomial coefficients

",Python,"def pascal(n):
   """"""Prints out n rows of Pascal's triangle.
   It returns False for failure and True for success.""""""
   row = [1]
   k = [0]
   for x in range(max(n,0)):
      print row
      row=[l+r for l,r in zip(row+k,k+row)]
   return n>=1",Human_written,Python_from_Go
http://rosettacode.org/wiki/Calendar,Calendar,"Create a routine that will generate a text calendar for any year.
Test the calendar by generating a calendar for the year 1969, on a device of the time.
Choose one of the following devices:

 A line printer with a width of 132 characters.
 An IBM 3278 model 4 terminal (80×43 display with accented characters). Target formatting the months of the year to fit nicely across the 80 character width screen. Restrict number of lines in test output to 43.


(Ideally, the program will generate well-formatted calendars for any page width from 20 characters up.)

Kudos (κῦδος) for routines that also transition from Julian to Gregorian calendar.

This task is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

For further Kudos see task CALENDAR, where all code is to be in UPPERCASE.

For economy of size, do not actually include Snoopy generation in either the code or the output, instead just output a place-holder.



Related task

   Five weekends

",Python,"import datetime
import sys
 
pageWidth = 80
 
def printCal(year):
	thisDate = datetime.date(year, 1, 1)
	dayArr = [[[0 for i in range(6)] for j in range(7)] for k in range(12)]
	month, lastMonth, weekInMonth, dayInMonth = 0, 0, 0, 1
	while thisDate.year == year:
		if month!= lastMonth:
			weekInMonth = 0
			dayInMonth = 1
		weekday = thisDate.weekday()
		if weekday == 0 and dayInMonth > 1:
			weekInMonth += 1
		dayArr[month][weekday][weekInMonth] = thisDate.day
		lastMonth = month
		dayInMonth += 1
		thisDate += datetime.timedelta(days=1)
		month = thisDate.month
	centre = pageWidth/2
	print(""%""+str(centre)+""s\n\n"" % ""[SNOOPY]"")
	centre = pageWidth/2-2
	print(""%""+str(centre)+""d\n\n"" % year)
	months = ["" January "", "" February"", ""  March  "", ""  April  "", ""   May   "", ""   June  "", ""   July  "", ""  August "", ""September"", "" October "", "" November"", "" December""]
	days = [""Su"", ""Mo"", ""Tu"", ""We"", ""Th"", ""Fr"", ""Sa""]
	for qtr in range(4):
		for monthInQtr in range(3):
			sys.stdout.write(""      %s           "" % months[qtr*3+monthInQtr])
		print()
		for monthInQtr in range(3):
			for day in range(7):
				sys.stdout.write("" %s"" % days[day])
			sys.stdout.write(""     "")
		print()
		for weekInMonth in range(6):
			for monthInQtr in range(3):
				for day in range(7):
					if dayArr[qtr*3+monthInQtr][day][weekInMonth] == 0:
						sys.stdout.write(""   "")
					else:
						sys.stdout.write(""%3d"" % dayArr[qtr*3+monthInQtr][day][weekInMonth])
				sys.stdout.write(""     "")
			print()
		print()
 
printCal(1969)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Random_numbers,Random numbers,"Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers
with a mean of   1.0   and a   standard deviation   of   0.5



Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.



Related task

   Standard deviation

",Python,">>> import random
>>> values = [random.gauss(1, .5) for i in range(1000)]
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Solve_the_no_connection_puzzle,Solve the no connection puzzle,"You are given a box with eight holes labelled   A-to-H,   connected by fifteen straight lines in the pattern as shown below:

             A   B
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         C───D───E───F
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             G   H

You are also given eight pegs numbered   1-to-8.



Objective

Place the eight pegs in the holes so that the (absolute) difference between any two numbers connected by any line is greater than one.



Example

In this attempt:

             4   7
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         8───1───6───2
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             3   5

Note that   7   and   6   are connected and have a difference of   1,   so it is   not   a solution.



Task
Produce and show here   one   solution to the puzzle.



Related tasks

   A* search algorithm
   Solve a Holy Knight's tour
   Knight's tour
   N-queens problem
   Solve a Hidato puzzle
   Solve a Holy Knight's tour
   Solve a Hopido puzzle
   Solve a Numbrix puzzle
   4-rings or 4-squares puzzle


See also
No Connection Puzzle (youtube).



",Python,"import itertools
 
connections = [
    [0, 2], [0, 3], [0, 4], # A to C,D,E
    [1, 3], [1, 4], [1, 5], # B to D,E,F
    [6, 2], [6, 3], [6, 4], # G to C,D,E
    [7, 3], [7, 4], [7, 5], # H to D,E,F
    [2, 3], [3, 4], [4, 5], # C-D, D-E, E-F
]
 
pegs = [1, 2, 3, 4, 5, 6, 7, 8]
num = 0
 
def valid():
    for i in range(len(connections)):
        if abs(pegs[connections[i][0]] - pegs[connections[i][1]]) == 1:
            return False
    return True
 
def swap(a, b):
    t = a
    a = b
    b = t
 
def printSolution():
    print(""----- %d -----"" % num)
    print(""  %d %d"" % (pegs[0], pegs[1]))
    print(""%d %d %d %d"" % (pegs[2], pegs[3], pegs[4], pegs[5]))
    print(""  %d %d"" % (pegs[6], pegs[7]))
    print(""\n"")
 
def solution(le, ri):
    if le == ri:
        if valid():
            printSolution()
    else:
        for i in range(le, ri):
            swap(pegs[le], pegs[i])
            solution(le + 1, ri)
            swap(pegs[le], pegs[i])
 
solution(0, len(pegs) - 1)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Associative_array/Creation,Associative array/Creation,"Task

The goal is to create an associative array (also known as a dictionary, map, or hash).



Related tasks:

 Associative arrays/Iteration
 Hash from two arrays


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"hash={}
hash[666]='devil'
hash[777]  # => None
hash[666]  # => 'devil'",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Idiomatically_determine_all_the_characters_that_can_be_used_for_symbols,Idiomatically determine all the characters that can be used for symbols,"Idiomatically determine all the characters that can be used for symbols.
The word symbols is meant things like names of variables, procedures (i.e., named fragments of programs, functions, subroutines, routines), statement labels, events or conditions, and in general, anything a computer programmer can choose to name, but not being restricted to this list. Identifiers might be another name for symbols.

The method should find the characters regardless of the hardware architecture that is being used (ASCII, EBCDIC, or other).

Task requirements
Display the set of all the characters that can be used for symbols which can be used (allowed) by the computer program.
You may want to mention what hardware architecture is being used, and if applicable, the operating system.

Note that most languages have additional restrictions on what characters can't be used for the first character of a variable or statement label, for instance. These type of restrictions needn't be addressed here (but can be mentioned).

See also
 Idiomatically determine all the lowercase and uppercase letters.

",Python,"[ $ ""0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrS""
  $ QsTtUuVvWwXxYyZz()[]{}<>~=+-*/^\|_.,:;?!'""`%@&#$Q 
  join ] constant                                     is tokenchars (   --> $ )
 
( The first non-whitespace character after the word $
  (pronounced ""string"") is deemed to be the delimiter
  for the string that follows it. In the first string 
  the conventional character "" is used, so cannot
  appear as a character in that string. In the second 
  string all the reasonable delimiters are used, so Q
  is used as the delimiter.
 
  As it is not possible to make a string that uses all
  the characters, two strings are concatenated (join)
  to make the string during compilation. (Which is why
  $ ""0...S"" $ Qs...$Q join is nested (inside [ ... ])
  and followed by the word constant, which causes the 
  nest to be evaluated during compilation.)
 
  Regardless of operating system, Quackery only knows 
  the characters in the string tokenchars, plus space
  and carriage return.
 
  The characters in tokenchars are in QACSFOT order
  (the Quackery Arbitrary Character Sequence For 
   Ordered Text) which it uses for string comparison,
   but the valid tokens (which is all of them) will
   be printed by alltokens in the order native to the 
   operating system. (In this instance, Unicode.)     )
 
[ tokenchars find 
  tokenchars found ]                                  is validtoken ( c --> b )
 
[ 256 times 
  [ i^ validtoken if [ i^ emit ] ] ]                  is alltokens  (   -->   )
 
alltokens",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Forward_difference,Forward difference,"Task

Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.



The first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.

List   B   should have one fewer element as a result.

The second-order forward difference of   A   will be:

tdefmodule Diff do
	def forward(arr,i\\1) do
		forward(arr,[],i)
	end

	def forward([_|[]],diffs,i) do
		if i == 1 do
			IO.inspect diffs
		else 
			forward(diffs,[],i-1)
		end
	end

	def forward([val1|[val2|vals]],diffs,i) do
		forward([val2|vals],diffs++[val2-val1],i) 
	end
end 

The same as the first-order forward difference of   B.

That new list will have two fewer elements than   A   and one less than   B.

The goal of this task is to repeat this process up to the desired order.

For a more formal description, see the related   Mathworld article.



Algorithmic options

 Iterate through all previous forward differences and re-calculate a new array each time.
 Use this formula (from Wikipedia):


 




Δ

n


[
f
]
(
x
)
=

∑

k
=
0


n





(


n
k


)



(
−
1

)

n
−
k


f
(
x
+
k
)


{\displaystyle \Delta ^{n}[f](x)=\sum _{k=0}^{n}{n \choose k}(-1)^{n-k}f(x+k)}




 (Pascal's Triangle   may be useful for this option.)

",Python,"def dif(s):
    return [y - x for x, y in zip(s, s[1:])]

def difn(s, n):
    for i in range(n):
        s = dif(s)
    return s",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Copy_a_string,Copy a string,"This task is about copying a string.



Task

Where it is relevant, distinguish between copying the contents of a string
versus making an additional reference to an existing string.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"src = ""Hello""
dst = src",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Linear_congruential_generator,Linear congruential generator,"The linear congruential generator is a very simple example of a random number generator.

All linear congruential generators use this formula:

 




r

n
+
1


=
a
×

r

n


+
c


(
mod

m
)



{\displaystyle r_{n+1}=a\times r_{n}+c{\pmod {m}}}




Where:

 




r

0




{\displaystyle r_{0}}

 is a seed.
 




r

1




{\displaystyle r_{1}}

, 




r

2




{\displaystyle r_{2}}

, 




r

3




{\displaystyle r_{3}}

, ..., are the random numbers.
 



a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.


If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

.

LCG numbers have poor quality. 




r

n




{\displaystyle r_{n}}

 and 




r

n
+
1




{\displaystyle r_{n+1}}

 are not independent, as true random numbers would be. Anyone who knows 




r

n




{\displaystyle r_{n}}

 can predict 




r

n
+
1




{\displaystyle r_{n+1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r

0




{\displaystyle r_{0}}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes 



s
t
a
t

e

0




{\displaystyle state_{0}}

. The random sequence is 



r
a
n

d

1




{\displaystyle rand_{1}}

, 



r
a
n

d

2




{\displaystyle rand_{2}}

 and so on.



BSD formula

 



s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e

n


+
12345


(
mod


2

31


)



{\displaystyle state_{n+1}=1103515245\times state_{n}+12345{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n




{\displaystyle rand_{n}=state_{n}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 2147483647.


Microsoft formula

 



s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}=214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.


The BSD formula was so awful that FreeBSD switched to a different formula.

More info is at Random number generator (included)#C.



",Python,"import random
 
class BsdLcg:
    def __init__(self, seed):
        self.state = seed
 
    def next_u32(self):
        self.state = (self.state * 1103515245 + 12345) % (1 << 31)
        return self.state
 
class MsLcg:
    def __init__(self, seed):
        self.state = seed
 
    def next_u32(self):
        self.state = (self.state * 214013 + 2531011) % (1 << 31)
        return self.state >> 16
 
def main():
    print(""~~~ BSD ~~~"")
    bsd = BsdLcg(0)
    for _ in range(10):
        print(bsd.next_u32())
 
    print(""~~~ MS ~~~"")
    ms = MsLcg(0)
    for _ in range(10):
        print(ms.next_u32())
 
    print(""~~~ Others ~~~"")
    print(random.choices(range(1 << 32), k=5))
    print(random.choice([True, False]))
    print("""".join(random.choices(string.ascii_letters, k=15)))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/User_input/Text,User input/Text,"User input/Text is part of Short Circuit's Console Program Basics selection.
Task
 
Input a string and the integer   75000   from the text console.

See also: User input/Graphical
",Python,"string = raw_input(""Input a string: "")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Hash_join,Hash join,"An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.

Task[edit]
Implement the ""hash join"" algorithm, and demonstrate that it passes the test-case listed below.

You should represent the tables as data structures that feel natural in your programming language.

Guidance
The ""hash join"" algorithm consists of two steps:

 Hash phase: Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.

 The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.
 Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.
 Join phase: Scan the other table, and find matching rows by looking in the multimap created before.


In pseudo-code, the algorithm could be expressed as follows:

let A = the first input table (or ideally, the larger one)
let B = the second input table (or ideally, the smaller one)
let jA = the join column ID of table A
let jB = the join column ID of table B
let MB = a multimap for mapping from single values to multiple rows of table B (starts out empty)
let C = the output table (starts out empty)

for each row b in table B:
   place b in multimap MB under key b(jB)

for each row a in table A:
   for each row b in multimap MB under key a(jA):
      let c = the concatenation of row a and row b
      place row c in table C

Test-case


 Input

 Output





 A =




 Age 
 Name


 27 
 Jonah


 18 
 Alan


 28 
 Glory


 18 
 Popeye


 28 
 Alan




 B =




 Character 
 Nemesis


 Jonah 
 Whales


 Jonah 
 Spiders


 Alan 
 Ghosts


 Alan 
 Zombies


 Glory 
 Buffy



 jA =

 Name (i.e. column 1)

 jB =

 Character (i.e. column 0)





 A.Age 
 A.Name 
 B.Character 
 B.Nemesis


 27 
 Jonah 
 Jonah 
 Whales


 27 
 Jonah 
 Jonah 
 Spiders


 18 
 Alan 
 Alan 
 Ghosts


 18 
 Alan 
 Alan 
 Zombies


 28 
 Glory 
 Glory 
 Buffy


 28 
 Alan 
 Alan 
 Ghosts


 28 
 Alan 
 Alan 
 Zombies


The order of the rows in the output table is not significant.

If you're using numerically indexed arrays to represent table rows (rather than referring to columns by name), you could represent the output rows in the form [[27, ""Jonah""], [""Jonah"", ""Whales""]].



",Python,"from collections import defaultdict
 
tab1 = [
# Age  Name
  [""27"", ""Jonah""]
, [""18"", ""Alan""]
, [""28"", ""Glory""]
, [""18"", ""Popeye""]
, [""28"", ""Alan""]
]
 
tab2 = [
# Character  Nemesis
  [""Jonah"", ""Whales""]
, [""Jonah"", ""Spiders""]
, [""Alan"", ""Ghosts""]
, [""Alan"", ""Zombies""]
, [""Glory"", ""Buffy""]
]
 
def Join(a, columna, b, columnb):
  hashmap = defaultdict(list)
  # hash
  for i, row in enumerate(a):
    hashmap[row[columna]].append(i)
  # map
  result = []
  for i, row in enumerate(b):
    for j in hashmap[row[columnb]]:
      result.append(a[j] + b[i])
  return result
 
print(""Table A: "")
for i, row in enumerate(tab1):
  print(i, row)
 
print(""Table B: "")
for i, row in enumerate(tab1):
  print(i, row)
 
tab3 = Join(tab1, 1, tab2, 0)
print(""Joined tables: "")
for i, row in enumerate(tab3):
  print(i, row)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Dynamic_variable_names,Dynamic variable names,"Task

Create a variable with a user-defined name.

The variable name should not be written in the program text, but should be taken from the user dynamically.



See also
   Eval in environment is a similar task.

",Python,">>> name = raw_input(""Enter a variable name: "")
Enter a variable name: X
>>> globals()[name] = 42
>>> X
42",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",Python,"def shell(a):
	increment = a.length / 2
	while increment > 0:
		for i in range(increment, a.length):
			j = i
			temp = a[i]
			while j >= increment and a[j - increment] > temp:
				a[j] = a[j - increment]
				j = j - increment
			a[j] = temp
		if increment == 2:
			increment = 1
		else:
			increment *= (5.0 / 11)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Word_frequency,Word frequency,"Task

Given a text file and an integer   n,   print/display the   n   most
common words in the file   (and the number of their occurrences)   in decreasing frequency.



For the purposes of this task:

   A word is a sequence of one or more contiguous letters.
   You are free to define what a   letter   is. 
   Underscores, accented letters, apostrophes, hyphens, and other special characters can be handled at your discretion.
   You may treat a compound word like   well-dressed   as either one word or two. 
   The word   it's   could also be one or two words as you see fit. 
   You may also choose not to support non US-ASCII characters. 
   Assume words will not span multiple lines.
   Don't worry about normalization of word spelling differences. 
   Treat   color   and   colour   as two distinct words.
   Uppercase letters are considered equivalent to their lowercase counterparts.
   Words of equal frequency can be listed in any order.
   Feel free to explicitly state the thoughts behind the program decisions.


Show example output using Les Misérables from Project Gutenberg as the text file input and display the top   10   most used words.



History

This task was originally taken from programming pearls from Communications of the ACM June 1986 Volume 29 Number 6
where this problem is solved by Donald Knuth using literate programming and then critiqued by Doug McIlroy,
demonstrating solving the problem in a 6 line Unix shell script (provided as an example below).



References

McIlroy's program



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
import re
from collections import Counter
 
head = int(sys.argv[1]) if len(sys.argv) > 1 else 10
with open(sys.argv[2]) if len(sys.argv) > 2 else sys.stdin as f:
    counts = Counter(re.findall(r'[a-z]+', f.read().lower()))
for word, count in counts.most_common(head):
    print(word, count)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes,Safe primes and unsafe primes,"Definitions

   A   safe prime   is a prime   p   and where   (p-1)/2   is also prime.
   The corresponding prime  (p-1)/2   is known as a   Sophie Germain   prime.
   An   unsafe prime   is a prime   p   and where   (p-1)/2   isn't   a prime.
   An   unsafe prime   is a prime that   isn't   a   safe   prime.


Task

   Find and display (on one line) the first   35   safe primes.
   Find and display the   count   of the safe primes below   1,000,000.
   Find and display the   count   of the safe primes below 10,000,000.
   Find and display (on one line) the first   40   unsafe primes.
   Find and display the   count   of the unsafe primes below   1,000,000.
   Find and display the   count   of the unsafe primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   strong and weak primes.


Also see

   The OEIS article:     safe   primes.
   The OEIS article:   unsafe primes.

",Python,"primes =[]
sp =[]
usp=[]
n = 10000000
if 2<n:
    primes.append(2)
for i in range(3,n+1,2):
    for j in primes:
        if(j>i/2) or (j==primes[-1]):
            primes.append(i)
            if((i-1)/2) in primes:
                sp.append(i)
                break
            else:
                usp.append(i)
                break
        if (i%j==0):
            break
 
print('First 35 safe primes are:\n' , sp[:35])
print('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')
print('There are '+str(len(sp))+' safe primes below 10,000,000')
print('First 40 unsafe primes:\n',usp[:40])
print('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')
print('There are '+str(len(usp))+' safe primes below 10,000,000')",Human_written,Python_from_C
http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"for i in range(16):
    for j in range(32+i, 127+1, 16):
        if j == 32:
            k = 'Spc'
        elif j == 127:
            k = 'Del'
        else:
            k = chr(j)
        print(""%3d : %-3s"" % (j,k), end="""")
    print()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Loops/Break,Loops/Break,"Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive).

If a number is 10, stop the loop after printing it, and do not generate any further numbers.

Otherwise, generate and print a second random number before restarting the loop.

If the number 10 is never generated as the first number in a loop, loop forever.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges

",Python,"array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in range(len(array)):
    print(array[i])",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible,Determine if a string is collapsible,"Determine if a character string is   collapsible.

And if so,   collapse the string   (by removing   immediately repeated   characters).



If a character string has   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



An   immediately repeated   character is any character that is   immediately   followed by an
identical character (or characters).   Another word choice could've been   duplicated character,   but that
might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around November 2019)   PL/I   BIF:   collapse.}



Examples

In the following character string:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   t,   e, and   l   are repeated characters,   indicated
by underscores (above),   even though they (those characters) appear elsewhere in the character string.



So, after collapsing the string, the result would be:

 The beter the 4-whel drive, the further you'l be from help when ya get stuck! 





Another example:
In the following character string:

 headmistressship 



The ""collapsed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to
locate   repeated   characters and   collapse   (delete)   them from the character
string.   The character string can be processed from either direction.



Show all output here, on this page:

   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

 string
 number
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗   ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║
   5    ║                                                    --- Harry S Truman  ║   ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import groupby
 
def collapser(txt):
    return ''.join(item for item, grp in groupby(txt))
 
if __name__ == '__main__':
    strings = [
            """",
            '""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ',
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                   ---  Harry S Truman  "",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""aardvark"",
            ""😍😀🙌💃😍😍😍🙌"",
            ]
    for txt in strings:
        this = ""Original""
        print(f""\n{this:14} Size: {len(txt)} «««{txt}»»»"" )
        this = ""Collapsed""
        sqz = collapser(txt)
        print(f""{this:>14} Size: {len(sqz)} «««{sqz}»»»"" )",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Forward_difference,Forward difference,"Task

Provide code that produces a list of numbers which is the   nth  order forward difference, given a non-negative integer (specifying the order) and a list of numbers.



The first-order forward difference of a list of numbers   A   is a new list   B,   where   Bn = An+1 - An.

List   B   should have one fewer element as a result.

The second-order forward difference of   A   will be:

tdefmodule Diff do
	def forward(arr,i\\1) do
		forward(arr,[],i)
	end

	def forward([_|[]],diffs,i) do
		if i == 1 do
			IO.inspect diffs
		else 
			forward(diffs,[],i-1)
		end
	end

	def forward([val1|[val2|vals]],diffs,i) do
		forward([val2|vals],diffs++[val2-val1],i) 
	end
end 

The same as the first-order forward difference of   B.

That new list will have two fewer elements than   A   and one less than   B.

The goal of this task is to repeat this process up to the desired order.

For a more formal description, see the related   Mathworld article.



Algorithmic options

 Iterate through all previous forward differences and re-calculate a new array each time.
 Use this formula (from Wikipedia):


 




Δ

n


[
f
]
(
x
)
=

∑

k
=
0


n





(


n
k


)



(
−
1

)

n
−
k


f
(
x
+
k
)


{\displaystyle \Delta ^{n}[f](x)=\sum _{k=0}^{n}{n \choose k}(-1)^{n-k}f(x+k)}




 (Pascal's Triangle   may be useful for this option.)

",Python,">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]
>>> # or, dif = lambda s: [x-y for x,y in zip(s[1:],s)]
>>> difn = lambda s, n: difn(dif(s), n-1) if n else s
 
>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]
>>> difn(s, 0)
[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]
>>> difn(s, 1)
[-43, 11, -29, -7, 10, 23, -50, 50, 18]
>>> difn(s, 2)
[54, -40, 22, 17, 13, -73, 100, -32]
 
>>> from pprint import pprint
>>> pprint( [difn(s, i) for i in xrange(10)] )
[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],
 [-43, 11, -29, -7, 10, 23, -50, 50, 18],
 [54, -40, 22, 17, 13, -73, 100, -32],
 [-94, 62, -5, -4, -86, 173, -132],
 [156, -67, 1, -82, 259, -305],
 [-223, 68, -83, 341, -564],
 [291, -151, 424, -905],
 [-442, 575, -1329],
 [1017, -1904],
 [-2921]]",Human_written,Python_from_C#
http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm,Parsing/RPN calculator algorithm,"Task

Create a stack-based evaluator for an expression in   reverse Polish notation (RPN)   that also shows the changes in the stack as each individual token is processed as a table.



 Assume an input of a correct, space separated, string of tokens of an RPN expression
 Test with the RPN expression generated from the   Parsing/Shunting-yard algorithm   task: 

         3 4 2 * 1 5 - 2 3 ^ ^ / + 

 Print or display the output here


Notes

    ^    means exponentiation in the expression above.
    /    means division.


See also

   Parsing/Shunting-yard algorithm for a method of generating an RPN from an infix expression.
   Several solutions to 24 game/Solve make use of RPN evaluators (although tracing how they work is not a part of that task).
   Parsing/RPN to infix conversion.
   Arithmetic evaluation.

",Python,"e = '3 4 2 * 1 5 - 2 3 ^ ^ / +'
s = []
tokens = e.split(' ')
for t in tokens:
    n = float(t)
    if not math.isnan(n):
        s.append(n)
    else:
        if len(s) < 2:
            raise Exception(f'{t}: {s}: insufficient operands.')
        o2 = s.pop()
        o1 = s.pop()
        if t == '+':
            s.append(o1 + o2)
        elif t == '-':
            s.append(o1 - o2)
        elif t == '*':
            s.append(o1 * o2)
        elif t == '/':
            s.append(o1 / o2)
        elif t == '^':
            s.append(math.pow(o1, o2))
        else:
            raise Exception(f'Unrecognized operator: [{t}]')
        print(f'{t}: {s}')
 
if len(s) > 1:
    raise Exception(f'{s}: insufficient operators.')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Non-decimal_radices/Output,Non-decimal radices/Output,"Programming languages often have built-in routines to convert a non-negative integer for printing in different number bases. Such common number bases might include binary, Octal and Hexadecimal.



Task

Print a small range of integers in some different bases, as supported by standard routines of your programming language.



Note

This is distinct from Number base conversion as a user-defined conversion function is not asked for.)

The reverse operation is Common number base parsing.



",Python,"for n in range(34):
  print "" %3o %2d %2X"" % (n, n, n)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Fractran,Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",Python,"from fractions import Fraction
 
def fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'
                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'
                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):
    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]
 
    n = Fraction(n)
    while True:
        yield n.numerator
        for f in flist:
            if (n * f).denominator == 1:
                break
        else:
            break
        n *= f
 
if __name__ == '__main__':
    n, m = 2, 15
    print('First %i members of fractran(%i):\n  ' % (m, n) +
          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Metaprogramming,Metaprogramming,"Name and briefly demonstrate any support your language has for metaprogramming. Your demonstration may take the form of cross-references to other tasks on Rosetta Code. When possible, provide links to relevant documentation.

For the purposes of this task, ""support for metaprogramming"" means any way the user can effectively modify the language's syntax that's built into the language (like Lisp macros) or that's conventionally used with the language (like the C preprocessor). Such facilities need not be very powerful: even user-defined infix operators count. On the other hand, in general, neither operator overloading nor eval count. The task author acknowledges that what qualifies as metaprogramming is largely a judgment call.
",Python,"from macropy.core.macros import *
from macropy.core.quotes import macros, q, ast, u
 
macros = Macros()
 
@macros.expr
def expand(tree, **kw):
    addition = 10
    return q[lambda x: x * ast[tree] + u[addition]]",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Real_constants_and_functions,Real constants and functions,"Task

Show how to use the following math constants and functions in your language   (if not available, note it):

   e   (base of the natural logarithm)
   



π


{\displaystyle \pi }


   square root
   logarithm   (any base allowed)
   exponential   (ex )
   absolute value   (a.k.a. ""magnitude"")
   floor   (largest integer less than or equal to this number--not the same as truncate or int)
   ceiling   (smallest integer not less than this number--not the same as round up)
   power   (xy )


Related task

   Trigonometric Functions

",Python,"x.bit_length() #number of bits
bin(x) #binary representation
oct(x) #octal representation
hex(x) #hexadecimal representation",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def is_prime(n):
    if n < 0:
        n = -n
    if n == 2:
        return True
    if n < 2 or n % 2 == 0:
        return False
    for i in range(3, int(n**0.5)+1, 2):
        if n % i == 0:
            return False
    return True",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Delegates,Delegates,"A delegate is a helper object used by another object. The delegator may send the delegate certain messages, and provide a default implementation when there is no delegate or the delegate does not respond to a message. This pattern is heavily used in Cocoa framework on Mac OS X. See also wp:Delegation pattern.

Objects responsibilities:

Delegator:

 Keep an optional delegate instance.
 Implement ""operation"" method, returning the delegate ""thing"" if the delegate respond to ""thing"", or the string ""default implementation"".
Delegate:

 Implement ""thing"" and return the string ""delegate implementation""
Show how objects are created and used. First, without a delegate, then with a delegate that does not implement ""thing"", and last with a delegate that implements ""thing"".
",Python,"class Delegator:
    def __init__(self):
        self.delegate = None
        self.operation = lambda: self.delegate.thing() if self.delegate and hasattr(self.delegate, 'thing') else 'default implementation'
 
class Delegate:
    def thing(self):
        return 'Delegate Implementation'
 
def testDelegator():
    a = Delegator()
    print(a.operation())
 
    a.delegate = 'A delegate may be any object'
    print(a.operation())
 
    a.delegate = Delegate()
    print(a.operation())
 
if __name__ == '__main__':
    testDelegator()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/DNS_query,DNS query,"DNS is an internet service that maps domain names, like rosettacode.org, to IP addresses, like 66.220.0.231.

Use DNS to resolve www.kame.net to both IPv4 and IPv6 addresses. Print these addresses.



",Python,">>> import socket
>>> socket.getaddrinfo(""www.kame.net"", None, socket.AF_UNSPEC, socket.SOCK_DGRAM)
[(<AddressFamily.AF_INET: 2>, <SocketKind.SOCK_DGRAM: 2>, 17, '', ('172.16.31.10', 0)), (<AddressFamily.AF_INET6: 10>, <SocketKind.SOCK_DGRAM: 2>, 0, '', ('fc00:e968:6179::de52:7100', 0, 0, 0))]
>>> [x[4][0] for x in socket.getaddrinfo(""www.kame.net"", None, socket.AF_UNSPEC, socket.SOCK_DGRAM)]
['172.16.31.10', 'fc00:e968:6179::de52:7100']",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Quadratic,Bitmap/Bézier curves/Quadratic,"Using the data storage type defined on this page for raster images, and the draw_line function defined in this one, draw a quadratic bezier curve
(definition on Wikipedia).
",Python,"def cubic(p1, p2, p3, segs):
    i = 0
    t = 0
    u = 0
    prev = 0
    pt = 0
    i = 1
    while i <= segs + 1:
        t = (i - 1.0) / segs
        u = 1 - t
        pt = prev
        u ** 2 * p1 + 2 * t * u * p2 + t ** 2 * p3
        if i > 1:
            PxlLine(floor(prev[1, 1]), floor(prev[1, 2]), floor(pt[1, 1]), floor(pt[1, 2]))
        i = i + 1",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",Python,"from itertools import count
from math import sqrt
 
def is_prime(n):
    if n == 2 or n == 3 or n == 5 or n == 7 or n == 11 or n == 13:
        return True
    if n % 2 == 0 or n % 3 == 0 or n % 5 == 0 or n % 7 == 0 or n % 11 == 0 or n % 13 == 0:
        return False
    root = int(sqrt(n)) + 1
    for i in range(17, root, 2):
        if n % i == 0:
            return False
    return True
 
def is_emirp(n):
    aux = n
    rev_prime = 0
    while aux > 0:
        rev_prime = rev_prime * 10 + aux % 10
        aux //= 10
    if n == rev_prime:
        return False
    return is_prime(rev_prime)
 
def calculate():
    count = 1
    vec1 = []
    vec2 = []
    emirp_10_000 = 0
 
    for i in count():
        if is_emirp(i):
            if count < 21:
                vec1.append(i)
            if i > 7700 and i < 8000:
                vec2.append(i)
            if count == 10000:
                emirp_10_000 = i
                break
            count += 1
 
    return vec1, vec2, emirp_10_000
 
if __name__ == ""__main__"":
    vec1, vec2, emirp_10_000 = calculate()
 
    print(""First 20 emirp-s : {}"".format(vec1))
    print(""Emirps-s between 7700 and 8000 : {}"".format(vec2))
    print(""10.000-th emirp : {}"".format(emirp_10_000))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Holidays_related_to_Easter,Holidays related to Easter,"Task

Calculate the dates of:

   Easter
   Ascension Thursday
   Pentecost
   Trinity Sunday
   Corpus Christi feast (for Catholic)
   All Saints' Sunday (for Orthodox)


As an example, calculate for the first year of each century from;

   years     400   to   2100 CE   and for 
   years   2010   to   2020 CE.
Note

From the year 325 CE on,   Easter Sunday   has been defined as the first Sunday after the first full moon on or after the day of the March equinox. However, the actual astronomical values for the moments of the full moon and equinox are not used. Instead, approximations are used, the first one being that the equinox is assumed to fall on March 21st every year. The tracking of the moon phases is similarly done with relatively straightforward arithmetic (compared to the sort required for astronomical accuracy) which amounts to maintaining a lunisolar calendar in parallel to our standard purely-solar one.

When Pope Gregory reformed the Catholic calendar in 1582 CE, the drifting of Easter with respect to the seasons was the driving motivation, and the rules for determining it (called the computus) were altered to correct that drift. Catholic nations adopted both the new calendar and the new computus right away, while Western Protestant nations adopted them more gradually over the next 350 years or so. Eventually, even nations dominated by the Eastern Orthodox church adopted a similar calendar reform (the Revised Julian calendar), so pretty much the whole world agrees on what day it is for civil purposes. But the Eastern churches never adopted the corresponding Easter rule changes; they still use the original Julian calendar and computus to determine the date of what is known in the West as ""Orthodox Easter"". Therefore, your output should indicate which computus was used to calculate the dates and, at least for historical dates where the calendar can't be assumed or is location-dependent, which calendar those dates are given in.

You may find algorithms on the Computus Wikipedia page. Some of the results:

In the year 400 CE, Easter Sunday was April 1st (in the contemporary Julian calendar), making Ascension Thursday May 10th and Pentecost May 20th. It is ahistorical to give a date so far back for either Trinity Sunday or Corpus Christi, neither of which were observed until centuries later, but they would have been May 27th and 31st. If you extend the modern civil calendar back that far, those days are instead assigned the subsequent dates: Easter on April 2nd, Ascension on May 11th, Pentecost on May 21st.

Skipping forward to the year 2100 CE, assuming the rules don't change between now and then, the Western churches will observe Easter on March 28, Ascension Thursday May 6th, Pentecost May 16th, Trinity Sunday May 23rd and Corpus Christi May 27th. Heading East, the Orthodox rules place Easter on April 18 in the original Julian calendar; the corresponding civil date is May 2nd. That puts the Ascension on June 10th and Pentecost June 20th. Orthodox Trinity Sunday is the same day as Pentecost, but they observe All Saints' Sunday the following week, June 27th. Corpus Christi is a purely Catholic date that has no Orthodox version.

Test values of Easter dates



 Year

 Orthodox

 Catholic

 Calendar


400

01 Apr

 —

Jul.


800

19 Apr

 —

Jul.


1200

09 Apr

 —

Jul.


2000

30 Apr

23 Apr

Gr.


2020

19 Apr

12 Apr

Gr.


",Python,"import datetime
from collections import OrderedDict
 
_holidayOffsets = OrderedDict([
    (""Easter"", 0),
    (""Ascension"", 39),
    (""Pentecost"", 49),
    (""Trinity"", 56),
    (""Corpus"", 60),
])
 
def main():
    print(""Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:"")
    for year in range(400, 2100, 100):
        outputHolidays(year)
 
    print()
    print(""Christian holidays, related to Easter, for years from 2010 to 2020 CE:"")
    for year in range(2010, 2021):
        outputHolidays(year)
 
def outputHolidays(year):
    easter = calculateEaster(year)
    holidays = [
        ""{0}: {1:%a} {1:%d} {1:%b}"".format(holiday, easter + datetime.timedelta(days=offset))
        for holiday, offset in _holidayOffsets.items()
    ]
    print(""{0:4} {1}"".format(year, "", "".join(holidays)))
 
def calculateEaster(year):
    a = year % 19
    b = year // 100
    c = year % 100
    d = b // 4
    e = b % 4
    f = (b + 8) // 25
    g = (b - f + 1) // 3
    h = (19 * a + b - d - g + 15) % 30
    i = c // 4
    k = c % 4
    l = (32 + 2 * e + 2 * i - h - k) % 7
    m = (a + 11 * h + 22 * l) // 451
    numerator = h + l - 7 * m + 114
    month = numerator // 31
    day = (numerator % 31) + 1
    return datetime.date(year, month, day)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Animate_a_pendulum,Animate a pendulum,"
One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display.

The classic such physical system is a simple gravity pendulum.



Task

Create a simple physical model of a pendulum and animate it.



",Python,"from tkinter import *
import math
 
root = Tk()
root.title(""Pendulum Animation"")
canvas = Canvas(root, width=320, height=200)
canvas.create_line(0,25,320,25, tags='plate', width=2, fill='grey50')
canvas.create_oval(155,20,165,30, tags='pivot', outline="""", fill='grey50')
canvas.create_line(1,1,1,1, tags='rod', width=3, fill='black')
canvas.create_oval(1,1,2,2, tags='bob', outline='black', fill='yellow')
canvas.tag_raise('pivot')
canvas.pack(fill=BOTH, expand=True)
 
Theta = 45.0
dTheta = 0.0
length = 150
homeX = 160
homeY = 25
 
def show_pendulum():
    angle = Theta * math.pi / 180
    x = homeX + length * math.sin(angle)
    y = homeY + length * math.cos(angle)
    canvas.coords('rod', homeX, homeY, x, y)
    canvas.coords('bob', x-15, y-15, x+15, y+15)
 
def recompute_angle():
    scaling = 3000.0 / (length ** 2)
    # first estimate
    firstDDTheta = -math.sin(Theta * math.pi / 180) * scaling
    midDTheta = dTheta + firstDDTheta
    midTheta = Theta + (dTheta + midDTheta)/2
    # second estimate
    midDDTheta = -math.sin(midTheta * math.pi / 180) * scaling
    midDTheta = dTheta + (firstDDTheta + midDDTheta)/2
    midTheta = Theta + (dTheta + midDTheta)/2
    # again, first
    midDDTheta = -math.sin(midTheta * math.pi / 180) * scaling
    lastDTheta = midDTheta + midDDTheta
    lastTheta = midTheta + (midDTheta + lastDTheta)/2
    # again, second
    lastDDTheta = -math.sin(lastTheta * math.pi/180) * scaling
    lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2
    lastTheta = midTheta + (midDTheta + lastDTheta)/2
    # Now put the values back in our globals
    dTheta  = lastDTheta
    Theta = lastTheta
 
def animate():
    recompute_angle()
    show_pendulum()
    root.after(15, animate)
 
show_pendulum()
root.after(500, animate)
 
root.mainloop()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import collections, sys
 
def filecharcount(openfile):
    return sorted(collections.Counter(c for l in openfile for c in l).items())
 
f = open(sys.argv[1])
print(filecharcount(f))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Burrows%E2%80%93Wheeler_transform,Burrows–Wheeler transform,"

 This page uses content from Wikipedia. The original article was at Burrows–Wheeler_transform. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Burrows–Wheeler transform (BWT, also called block-sorting compression) rearranges a character string into runs of similar characters.

This is useful for compression, since it tends to be easy to compress a string that has runs of repeated characters by techniques such as move-to-front transform and run-length encoding.

More importantly, the transformation is reversible, without needing to store any additional data.

The BWT is thus a ""free"" method of improving the efficiency of text compression algorithms, costing only some extra computation.



Source: Burrows–Wheeler transform
",Python,"def bwt(s):
    """"""Apply Burrows-Wheeler transform to input string.""""""
    assert ""\002"" not in s and ""\003"" not in s, ""Input string cannot contain STX and ETX characters""
    s = ""\002"" + s + ""\003""  # Add start and end of text marker
    table = sorted(s[i:] + s[:i] for i in range(len(s)))  # Table of rotations of string
    last_column = [row[-1:] for row in table]  # Last characters of each row
    return """".join(last_column)  # Convert list of characters into string
 
 
def ibwt(r):
    """"""Apply inverse Burrows-Wheeler transform.""""""
    table = [""""] * len(r)  # Make empty table
    for i in range(len(r)):
        table = sorted(r[i] + table[i] for i in range(len(r)))  # Add a column of r
    s = [row for row in table if row.endswith(""\003"")][0]  # Find the correct row (ending in ETX)
    return s.rstrip(""\003"").strip(""\002"")  # Get rid of start and end markers",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Probabilistic_choice,Probabilistic choice,"Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
Related task

 Random number generator (device)

",Python,"import random
import math
 
def rand_idx(p, n):
	s = random.random()
	for i in range(n - 1):
		s -= p[i]
		if s < 0:
			return i
	return n - 1
 
LEN = 8
N = 1000000
names = [""aleph"", ""beth"", ""gimel"", ""daleth"", ""he"", ""waw"", ""zayin"", ""heth""]
p = [1./5, 1./6, 1./7, 1./8, 1./9, 1./10, 1./11, 1e300]
count = [0] * LEN
 
for i in range(N):
	count[rand_idx(p, LEN)] += 1
 
print ""  Name  Count    Ratio Expected""
for i in range(LEN):
	s = sum(p[:i])
	print ""%6s%7d %7.4f%% %7.4f%%"" % (names[i], count[i], count[i] / float(N) * 100, (i < LEN - 1 and p[i] or 1 - s) * 100)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string,Strip control codes and extended characters from a string,"Task

Strip control codes and extended characters from a string.



The solution should demonstrate how to achieve each of the following results:

   a string with control codes stripped (but extended characters not stripped)
   a string with control codes and extended characters stripped


In ASCII, the control codes have decimal codes 0 through to 31 and 127.

On an ASCII based system, if the control codes are stripped, the resultant string would have all of its characters within the range of 32 to 126 decimal on the ASCII table.

On a non-ASCII based system, we consider characters that do not have a corresponding glyph on the ASCII table (within the ASCII range of 32 to 126 decimal) to be an extended character for the purpose of this task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms  (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
import sys
import random
 
MAXBUF = 256  # limit
STR_SZ = 100  # string size
 
# function prototypes
def ascii(c):
    return ascii_check(c, 32, 126)
 
def ascii_ext(c):
    return ascii_check(c, 128, 255)
 
def ascii_check(c, min, max):
    if c >= min and c <= max:
        return True
    return False
 
def strip(str, n, ext):
    buffer = ['\0'] * MAXBUF
 
    i = 0  # source index
    j = 0  # dest   index
 
    max = n if n < MAXBUF else MAXBUF - 1  # limit size
 
    while i < max:
        if (ext and ascii_ext(str[i])) or ascii(str[i]):  # check
            buffer[j] = str[i]  # assign
            j += 1
        i += 1
 
    str = ['\0'] * max  # wipe string
 
    i = 0  # reset count
 
    while i < j:
        str[i] = buffer[i]  # copy back
        i += 1
 
    str[j] = '\0'  # terminate properly
 
    return str
 
# try it out
def main():
    seed = 134529  # RNG seed value
 
    # variables and storage
    badstring = ['\0'] * STR_SZ
    bs_2 = ['\0'] * STR_SZ
 
    goodstring = None
    goodstring_ext = None
 
    i = 0
 
    random.seed(seed)  # seed RNG
 
    print ""Original:\t"",
 
    # generate a random string
    for i in range(STR_SZ):
        badstring[i] = chr(random.randint(0, 255))
        sys.stdout.write(badstring[i])
    print
 
    bs_2 = badstring[:]  # copy string
 
    goodstring_ext = strip(badstring, STR_SZ, True)  # remove non-extended and non-ascii
 
    print ""\nEXT:\t%s"" % goodstring_ext
 
    goodstring = strip(bs_2, STR_SZ, False)  # remove all non-ascii
 
    print ""\nASCII:\t%s"" % goodstring
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Flipping_bits_game,Flipping bits game,"The game

Given an   N×N   square array of zeroes or ones in an initial configuration,   and a target configuration of zeroes and ones.



The game is to transform one to the other in as few moves as possible by inverting whole numbered rows or whole lettered
columns at once   (as one move).

In an inversion.   any  1  becomes  0,   and any  0  becomes  1  for that whole row or column.



Task

Create a program to score for the Flipping bits game.

 The game should create an original random target configuration and a starting configuration.
 Ensure that the starting position is never the target position.
 The target position must be guaranteed as reachable from the starting position.   (One possible way to do this is to generate the start position by legal flips from a random target position.   The flips will always be reversible back to the target from the given start position).
 The number of moves taken so far should be shown.


Show an example of a short game here, on this page, for a   3×3   array of bits.



",Python,"def numOfRows(board):
    return len(board)
def numOfCols(board):
    return len(board[0])
def boardToString(board):
    # First the top-header
    header ='  '
    for c in range(numOfCols(board)):
        header += str(c) +''
    # Then the side-header + board
    sideboard = []
    for r in range(numOfRows(board)):
        sideboard.append(str(r) +'[' +''.join(board[r]) + ']')
    return header + '\n' + '\n'.join(sideboard)
def flipRow(board, row):
    for c in range(numOfCols(board)):
        board[row][c] = 1 - board[row][c]
def flipCol(board, col):
    for r in range(numOfRows(board)):
        board[r][col] = 1 - board[r][col]
def playFlippingBitsGame(rows, cols):
    rows = rows | 3
    cols = cols | 3
    targetBoard = []
    manipulatedBoard = []
    # Randomly generate two identical boards.
    for r in range(rows):
        targetBoard.append([])
        manipulatedBoard.append([])
        for c in range(cols):
            targetBoard[r].append(str(int(math.floor(math.random() * 2))))
            manipulatedBoard[r].append(targetBoard[r][c])
    # Naive-scramble one of the boards.
    while boardToString(targetBoard) == boardToString(manipulatedBoard):
        scrambles = rows * cols
        while scrambles > 0:
            scrambles -= 1
            if 0 == int(math.floor(math.random() * 2)):
                flipRow(manipulatedBoard, int(math.floor(math.random() * rows)))
            else:
                flipCol(manipulatedBoard, int(math.floor(math.random() * cols)))
    # Get the user to solve.
    alert(
        'Try to match both boards.\n' +
        'Enter `r<num>` or `c<num>` to manipulate a row or col or enter `q` to quit.'
        )
    input = ''
    letter = ''
    num = 0
    moves = 0
    while boardToString(targetBoard)!= boardToString(manipulatedBoard) and input!= 'q':
        input = prompt(
            'Target:\n' + boardToString(targetBoard) +
            '\n\n\n' +
            'Board:\n' + boardToString(manipulatedBoard)
            )
        try:
            letter = input[0]
            num = int(input[1:])
            if letter == 'q':
                break
            if (letter!= 'r' and letter!= 'c') or (letter == 'r' and num >= rows) or (letter == 'c' and num >= cols):
                raise Exception('')
            if letter == 'r':
                flipRow(manipulatedBoard, num)
            else:
                flipCol(manipulatedBoard, num)
            moves += 1
        except Exception:
            alert('Uh-oh, there seems to have been an input error')
    if input == 'q':
        alert('~~ Thanks for playing ~~')
    else:
        alert('Completed in'+ str(moves) +'moves.')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Command-line_arguments,Command-line arguments,"Command-line arguments is part of Short Circuit's Console Program Basics selection.
Scripted main
See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

myprogram -c ""alpha beta"" -h ""gamma""
",Python,"import sys
program_name = sys.argv[0]
arguments = sys.argv[1:]
count = len(arguments)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Pernicious_numbers,Pernicious numbers,"A   pernicious number   is a positive integer whose   population count   is a prime.

The   population count   is the number of   ones   in the binary representation of a non-negative integer.



Example
22   (which is   10110   in binary)   has a population count of   3,   which is prime,   and therefore

22   is a pernicious number.



Task
 display the first   25   pernicious numbers   (in decimal).
 display all pernicious numbers between   888,888,877   and   888,888,888   (inclusive).
 display each list of integers on one line   (which may or may not include a title).


See also
 Sequence   A052294 pernicious numbers on The On-Line Encyclopedia of Integer Sequences.
 Rosetta Code entry   population count, evil numbers, odious numbers.

",Python,"def pernicious(w):
    ff = 1 << 32 - 1
    mask1 = ff / 3
    mask3 = ff / 5
    maskf = ff / 17
    maskp = ff / 255
    w -= w >> 1 & mask1
    w = w & mask3 + w >> 2 & mask3
    w = (w + w >> 4) & maskf
    return 0xa08a28ac >> (w * maskp >> 24) & 1!= 0
 
for i, n in enumerate(range(1, 1000000000)):
    if pernicious(n):
        print(n)
        i += 1
        if i == 25:
            break
 
for n in range(888888877, 888888888):
    if pernicious(n):
        print(n)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",Python,"def main():
    print(""Hello world!"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Rep-string,Rep-string,"Given a series of ones and zeroes in a string, define a repeated string or rep-string as a string which is created by repeating a substring of the first N characters of the string truncated on the right to the length of the input string, and in which the substring appears repeated at least twice in the original.

For example, the string 10011001100 is a rep-string as the leftmost four characters of 1001 are repeated three times and truncated on the right to give the original string.

Note that the requirement for having the repeat occur two or more times means that the repeating unit is never longer than half the length of the input string.



Task

 Write a function/subroutine/method/... that takes a string and returns an indication of if it is a rep-string and the repeated string.   (Either the string that is repeated, or the number of repeated characters would suffice). 
 There may be multiple sub-strings that make a string a rep-string - in that case an indication of all, or the longest, or the shortest would suffice.
 Use the function to indicate the repeating substring if any, in the following:

1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1


 Show your output on this page.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
def is_repstring(teststring):
    regex = r""^(.+)\1+(.*)$""
    match = re.search(regex, teststring)
    if match:
        firstbracket = match.group(1)
        secondbracket = match.group(2)
        if len(firstbracket) >= len(secondbracket) and firstbracket.find(secondbracket)!= -1:
            return firstbracket
    return None
 
teststrings = [""1001110011"", ""1110111011"", ""0010010010"", ""1010101010"", ""1111111111"", ""0100101101"", ""0100100"", ""101"", ""11"", ""00"", ""1""]
for myString in teststrings:
    theRep = is_repstring(myString)
    if theRep:
        print(myString, ""is a rep string! Here is a repeating string:"")
        print(theRep)
    else:
        print(myString, ""is no rep string!"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Summarize_and_say_sequence,Summarize and say sequence,"There are several ways to generate a self-referential sequence. One very common one (the Look-and-say sequence) is to start with a positive integer, then generate the next term by concatenating enumerated groups of adjacent alike digits:

       0, 10, 1110, 3110, 132110, 1113122110, 311311222110 ...

The terms generated grow in length geometrically and never converge.

Another way to generate a self-referential sequence is to summarize the previous term.

Count how many of each alike digit there is, then concatenate the sum and digit for each of the sorted enumerated digits. Note that the first five terms are the same as for the previous sequence.

       0, 10, 1110, 3110, 132110, 13123110, 23124110 ... 

Sort the digits largest to smallest. Do not include counts of digits that do not appear in the previous term.

Depending on the seed value, series generated this way always either converge to a stable value or to a short cyclical pattern. (For our purposes, I'll use converge to mean an element matches a previously seen element.) The sequence shown, with a seed value of 0, converges to a stable value of 1433223110 after 11 iterations. The seed value that converges most quickly is 22. It goes stable after the first element. (The next element is 22, which has been seen before.)



Task

Find all the positive integer seed values under 1000000, for the above convergent self-referential sequence, that takes the largest number of iterations before converging. Then print out the number of iterations and the sequence they return. Note that different permutations of the digits of the seed will yield the same sequence. For this task, assume leading zeros are not permitted.

Seed Value(s): 9009 9090 9900

Iterations: 21 

Sequence: (same for all three seeds except for first element)
9009
2920
192210
19222110
19323110
1923123110
1923224110
191413323110
191433125110
19151423125110
19251413226110
1916151413325110
1916251423127110
191716151413326110
191726151423128110
19181716151413327110
19182716151423129110
29181716151413328110
19281716151423228110
19281716151413427110
19182716152413228110

Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Spelling of ordinal numbers



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Also see

   The On-Line Encyclopedia of Integer Sequences.

",Python,"from itertools import groupby, permutations
 
def A036058(number):
    return ''.join( str(len(list(g))) + k
                    for k,g in groupby(sorted(str(number), reverse=True)) )
 
def A036058_length(numberstring='0', printit=False):
    iterations, last_three, queue_index = 1, ([None] * 3), 0
 
    def A036058(number):
        # rely on external reverse-sort of digits of number
        return ''.join( str(len(list(g))) + k
                        for k,g in groupby(number) )
 
    while True:
        if printit:
            print(""  %2i %s"" % (iterations, numberstring))
        numberstring = ''.join(sorted(numberstring, reverse=True))
        if numberstring in last_three:
            break
        assert iterations < 1000000
        last_three[queue_index], numberstring = numberstring, A036058(numberstring)
        iterations += 1
        queue_index +=1
        queue_index %=3
    return iterations
 
def max_A036058_length( start_range=range(11) ):
    already_done = set()
    max_len = (-1, [])
    for n in start_range:
        sn = str(n)
        sns = tuple(sorted(sn, reverse=True))
        if sns not in already_done:
            already_done.add(sns)
            size = A036058_length(sns)
            if size > max_len[0]:
                max_len = (size, [n])
            elif size == max_len[0]:
                max_len[1].append(n)
    return max_len
 
lenmax, starts = max_A036058_length( range(1000000) )
 
# Expand
allstarts = []
for n in starts:
    allstarts += [int(''.join(x))
                  for x in set(k
                               for k in permutations(str(n), 4)
                               if k[0] != '0')]
allstarts = [x for x in sorted(allstarts) if x < 1000000]
 
print ( '''\
The longest length, followed by the number(s) with the longest sequence length
for starting sequence numbers below 1000000 are:
  Iterations = %i and sequence-starts = %s.''' % (lenmax, allstarts)   )
 
print ( '''
Note that only the first of any sequences with the same digits is printed below.
(The others will differ only in their first term)''' )
 
for n in starts:
    print()
    A036058_length(str(n), printit=True)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Unbias_a_random_generator,Unbias a random generator,"




P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}







P

0




{\displaystyle P_{0}}







P

0




{\displaystyle P_{0}}







P

1




{\displaystyle P_{1}}




Task details

 Use your language's random number generator to create a function/method/subroutine/... randN that returns a one or a zero, but with one occurring, on average, 1 out of N times, where N is an integer from the range 3 to 6 inclusive.
 Create a function unbiased that uses only randN as its source of randomness to become an unbiased generator of random ones and zeroes.
 For N over its range, generate and show counts of the outputs of randN and unbiased(randN).


The actual unbiasing should be done by generating two numbers at a time from randN and only returning a 1 or 0 if they are different. As long as you always return the first number or always return the second number, the probabilities discussed above should take over the biased probability of randN.

This task is an implementation of Von Neumann debiasing, first described in a 1951 paper.



",Python,"import random
def biased(n):
    return random.randint(1, n) == 1
def unbiased(n):
    flip1 = biased(n)
    flip2 = biased(n)
    while flip1 == flip2:
        flip1 = biased(n)
        flip2 = biased(n)
    return flip1
if __name__ == ""__main__"":
    for n in range(3, 7):
        biasedZero = 0
        biasedOne = 0
        unbiasedZero = 0
        unbiasedOne = 0
        for i in range(100000):
            if biased(n):
                biasedOne += 1
            else:
                biasedZero += 1
            if unbiased(n):
                unbiasedOne += 1
            else:
                unbiasedZero += 1
        print(""(N = "" + str(n) + "")"")
        print(""Biased:"")
        print(""   0 = "" + str(biasedZero) + ""; "" + str(biasedZero / 1000.0) + ""%"")
        print(""   1 = "" + str(biasedOne) + ""; "" + str(biasedOne / 1000.0) + ""%"")
        print(""Unbiased:"")
        print(""   0 = "" + str(unbiasedZero) + ""; "" + str(unbiasedZero / 1000.0) + ""%"")
        print(""   1 = "" + str(unbiasedOne) + ""; "" + str(unbiasedOne / 1000.0) + ""%"")
        print("""")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Conditional_structures,Conditional structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Task

List the conditional structures offered by a programming language. See Wikipedia: conditionals for descriptions.

Common conditional structures include if-then-else and switch.

Less common are arithmetic if, ternary operator and Hash-based conditionals.

Arithmetic if allows tight control over computed gotos, which optimizers have a hard time to figure out.


",Python,"if x == 0:
    foo()
elif x == 1:
    bar()
elif x == 2:
    baz()
else:
    boz()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Anti-primes,Anti-primes,"The anti-primes
(or highly composite numbers, sequence A002182 in the OEIS)
are the natural numbers with more factors than any smaller than itself.



Task

Generate and show here, the first twenty anti-primes.



Related tasks

   Factors of an integer
   Sieve of Eratosthenes

",Python,"from itertools import chain, count, cycle, islice, accumulate
 
def factors(n):
    def prime_powers(n):
        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):
            if c*c > n: break
            if n%c: continue
            d,p = (), c
            while not n%c:
                n,p,d = n//c, p*c, d+(p,)
            yield d
        if n > 1: yield n,
 
    r = [1]
    for e in prime_powers(n):
        r += [a*b for a in r for b in e]
    return r
 
def antiprimes():
    mx = 0
    yield 1
    for c in count(2,2):
        if c >= 58: break
        ln = len(factors(c))
        if ln > mx:
            yield c
            mx = ln
    for c in count(60,30):
        ln = len(factors(c))
        if ln > mx:
            yield c
            mx = ln  
 
if __name__ == '__main__':
    print(*islice(antiprimes(), 40)))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",Python,"print ""Hello world!""",Human_written,Python_from_Java
http://rosettacode.org/wiki/MD4,MD4,"Find the MD4 message digest of a string of octets.
Use the ASCII encoded string “Rosetta Code” (without quotes).
You may either call an MD4 library, or implement MD4 in your language.

MD4 is an obsolete hash function that computes a 128-bit message digest that sometimes appears in obsolete protocols.

RFC 1320 specifies the MD4 algorithm. RFC 6150 declares that MD4 is obsolete.
",Python,"import hashlib
 
print(hashlib.new('md4', 'Rosetta Code'.encode('utf-16le')).hexdigest())",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",Python,">>> import bisect
>>> _cin  = [.06, .11, .16, .21, .26, .31, .36, .41, .46, .51, .56, .61, .66, .71, .76, .81, .86, .91, .96, 1.01]
>>> _cout = [.10, .18, .26, .32, .38, .44, .50, .54, .58, .62, .66, .70, .74, .78, .82, .86, .90, .94, .98, 1.00]
>>> def pricerounder(pricein):
	return _cout[ bisect.bisect_right(_cin, pricein) ]",Human_written,Python_from_C#
http://rosettacode.org/wiki/Metronome,Metronome,"
The task is to implement a   metronome.

The metronome should be capable of producing high and low audio beats, accompanied by a visual beat indicator, and the beat pattern and tempo should be configurable.

For the purpose of this task, it is acceptable to play sound files for production of the beat notes, and an external player may be used.

However, the playing of the sounds should not interfere with the timing of the metronome.

The visual indicator can simply be a blinking red or green area of the screen (depending on whether a high or low beat is being produced), and the metronome can be implemented using a terminal display, or optionally, a graphical display, depending on the language capabilities.

If the language has no facility to output sound, then it is permissible for this to implemented using just the visual indicator.



",Python,"# version 1.1.2
 
def metronome(bpm, bpb, maxBeats=float('inf')):
    delay = 60_000 / bpm
    beats = 0
    while beats < maxBeats:
        time.sleep(delay / 1000)
        if beats % bpb == 0:
            print(""\nTICK "", end="""")
        else:
            print(""tick "", end="""")
        beats += 1
    print()
 
metronome(120, 4, 20) # limit to 20 beats",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Elementary_cellular_automaton/Infinite_length,Elementary cellular automaton/Infinite length,"The purpose of this task is to create a version of an Elementary cellular automaton whose number of cells is only limited by the memory size of the computer.

To be precise, consider the state of the automaton to be made of an infinite number of cells, but with a bounded support. In other words, to describe the state of the automaton, you need a finite number of adjacent cells, along with their individual state, and you then consider that the individual state of each of all other cells is the negation of the closest individual cell among the previously defined finite number of cells.

Examples:

1        ->   ..., 0, 0,      1,      0, 0, ...
0, 1     ->   ..., 1, 1,   0, 1,      0, 0, ...
1, 0, 1  ->   ..., 0, 0,   1, 0, 1,   0, 0, ...

More complex methods can be imagined, provided it is possible to somehow encode the infinite sections. But for this task we will stick to this simple version.
",Python,"# version 1.1.51
 
def evolve(l, rule):
    print("" Rule #"" + str(rule) + "":"")
    cells = ""*""
    for x in range(0, l):
        addNoCells(cells)
        width = 40 + (len(cells) >> 1)
        print(cells.rjust(width))
        cells = step(cells, rule)
 
def step(cells, rule):
    newCells = """"
    for i in range(0, len(cells) - 2):
        bin = 0
        b = 2
        for n in range(i, i + 3):
            bin += (1 if cells[n] == '*' else 0) << b
            b = b >> 1
        a = '*' if (rule & (1 << bin))!= 0 else '.'
        newCells += a
    return newCells
 
def addNoCells(s):
    l = '.' if s[0] == '*' else '*'
    r = '.' if s[len(s) - 1] == '*' else '*'
    for i in range(0, 2):
        s = l + s
        s += r
 
def main():
    evolve(35, 90)
    print()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",Python,"from __future__ import print_function
 
def getDifference(b1, b2):
	r = (b2 - b1) % 360.0
	# Python modulus has same sign as divisor, which is positive here,
	# so no need to consider negative case
	if r >= 180.0:
		r -= 360.0
	return r
 
if __name__ == ""__main__"":
	print (""Input in -180 to +180 range"")
	print (getDifference(20.0, 45.0))
	print (getDifference(-45.0, 45.0))
	print (getDifference(-85.0, 90.0))
	print (getDifference(-95.0, 90.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(29.4803, -88.6381))
	print (getDifference(-78.3251, -159.036))
 
	print (""Input in wider range"")
	print (getDifference(-70099.74233810938, 29840.67437876723))
	print (getDifference(-165313.6666297357, 33693.9894517456))
	print (getDifference(1174.8380510598456, -154146.66490124757))
	print (getDifference(60175.77306795546, 42213.07192354373))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  untitled.py
#  
#  Copyright 2016  <>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#  
#  
import sys

verbose = 0

def COND(a, b):
	def c(s):
		return b
	return c

# BEGIN problem specific setup
N_FLOORS = 5
TOP = N_FLOORS - 1
solution = [0] * N_FLOORS
occupied = [0] * N_FLOORS

baker = 0
cooper = 1
fletcher = 2
miller = 3
smith = 4
phantom_of_the_opera = 5

names = [""baker"", ""cooper"", ""fletcher"", ""miller"", ""smith""]

c0 = COND(None, solution[baker]!= TOP)
c1 = COND(None, solution[cooper]!= 0)
c2 = COND(None, solution[fletcher]!= 0 and solution[fletcher]!= TOP)
c3 = COND(None, solution[miller] > solution[cooper])
c4 = COND(None, abs(solution[smith] - solution[fletcher])!= 1)
c5 = COND(None, abs(solution[cooper] - solution[fletcher])!= 1)
N_CONDITIONS = 6

cond = [c0, c1, c2, c3, c4, c5]

# END of problem specific setup

def solve(person):
	i = 0
	j = 0
	if person == phantom_of_the_opera:
		# check condition
		for i in range(N_CONDITIONS):
			if cond[i](solution):
				continue
			if verbose:
				for j in range(N_FLOORS):
					print(""%d %s"" % (solution[j], names[j]))
				print(""cond %d bad"" % i)
				print("""")
			return 0
		print(""Found arrangement:"")
		for i in range(N_FLOORS):
			print(""%d %s"" % (solution[i], names[i]))
		return 1
	for i in range(N_FLOORS):
		if occupied[i]:
			continue
		solution[person] = i
		occupied[i] = 1
		if solve(person + 1):
			return 1
		occupied[i] = 0
	return 0

def main(args):
	global verbose
	verbose = 0
	if not solve(0):
		print(""Nobody lives anywhere"")
	return 0

if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously,Loop over multiple arrays simultaneously,"Task

Loop over multiple arrays   (or lists or tuples or whatever they're called in
your language)   and display the    i th    element of each.

Use your language's   ""for each""   loop if it has one, otherwise iterate
through the collection in order with some other loop.



For this example, loop over the arrays:

    (a,b,c)
    (A,B,C) 
    (1,2,3) 

to produce the output:

    aA1
    bB2
    cC3



If possible, also describe what happens when the arrays are of different lengths.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,">>> print ( '\n'.join(''.join(x) for x in 
zip('abc', 'ABC', '123')) )
aA1
bB2
cC3
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Tree_traversal,Tree traversal,"Task

Implement a binary tree where each node carries an integer,   and implement:

   pre-order,
   in-order, 
   post-order,     and 
   level-order   traversal. 


Use those traversals to output the following tree:

         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9

The correct output should look like this:

preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9



See also

   Wikipedia article:   Tree traversal.

",Python,"class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

    def iter_preorder(self, visit):
        if self is None:
            return
        visit(self.value)
        self.left.iter_preorder(visit)
        self.right.iter_preorder(visit)

    def iter_inorder(self, visit):
        if self is None:
            return
        self.left.iter_inorder(visit)
        visit(self.value)
        self.right.iter_inorder(visit)

    def iter_postorder(self, visit):
        if self is None:
            return
        self.left.iter_postorder(visit)
        self.right.iter_postorder(visit)
        visit(self.value)

    def iter_levelorder(self, visit):
        if self is None:
            return
        queue = [self]
        while queue:
            node = queue.pop(0)
            visit(node.value)
            if node.left is not None:
                queue.append(node.left)
            if node.right is not None:
                queue.append(node.right)

def visitor(value):
    print(value, end=' ')

tree = Node(1,
    Node(2,
        Node(4,
            Node(7),
            None),
        Node(5)),
    Node(3,
        Node(6,
            Node(8),
            Node(9)),
        None))
print(""preorder:    "", end='')
tree.iter_preorder(visitor)
print()
print(""inorder:     "", end='')
tree.iter_inorder(visitor)
print()
print(""postorder:   "", end='')
tree.iter_postorder(visitor)
print()
print(""level-order: "", end='')
tree.iter_levelorder(visitor)
print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Test_integerness,Test integerness,"Mathematically,

 the integers Z are included in the rational numbers Q,
 which are included in the real numbers R,
 which can be generalized to the complex numbers C.


This means that each of those larger sets, and the data types used to represent them, include some integers.

Task[edit]
Given a rational, real, or complex number of any type, test whether it is mathematically an integer.

Your code should handle all numeric data types commonly used in your programming language.

Discuss any limitations of your code.

Definition
For the purposes of this task, integerness means that a number could theoretically be represented as an integer at no loss of precision (given an infinitely wide integer type).

In other words:



 Set

 Common representation

 C++ type

 Considered an integer...


 rational numbers Q

 fraction

 std::ratio

 ...if its denominator is 1 (in reduced form)


 real numbers Z
(approximated)

 fixed-point



 ...if it has no non-zero digits after the decimal point


 floating-point

 float, double

 ...if the number of significant decimal places of its mantissa isn't greater than its exponent


 complex numbers C

 pair of real numbers

 std::complex

 ...if its real part is considered an integer and its imaginary part is zero

Extra credit
Optionally, make your code accept a tolerance parameter for fuzzy testing. The tolerance is the maximum amount by which the number may differ from the nearest integer, to still be considered an integer.

This is useful in practice, because when dealing with approximate numeric types (such as floating point), there may already be round-off errors from previous calculations. For example, a float value of 0.9999999998 might actually be intended to represent the integer 1.

Test cases


 Input

 Output

 Comment


 Type

 Value

 exact

 tolerance = 0.00001


 decimal

 25.000000

 true




 24.999999

 false

 true




 25.000100

 false




 floating-point

 -2.1e120

 true

 This one is tricky, because in most languages it is too large to fit into a native integer type.
It is, nonetheless, mathematically an integer, and your code should identify it as such.


 -5e-2

 false




 NaN

 false




 Inf

 false

 This one is debatable. If your code considers it an integer, that's okay too.


 complex

 5.0+0.0i

 true




 5-5i

 false



(The types and notations shown in these tables are merely examples – you should use the native data types and number literals of your programming language and standard library. Use a different set of test-cases, if this one doesn't demonstrate all relevant behavior.)

",Python,">>> def isint(f): 
    return complex(f).imag == 0 and complex(f).real.is_integer()
 
>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]
[True, True, True, False, False, False]
 
>>> # Test cases
...
>>> isint(25.000000)
True
>>> isint(24.999999)
False
>>> isint(25.000100)
False
>>> isint(-2.1e120)
True
>>> isint(-5e-2)
False
>>> isint(float('nan'))
False
>>> isint(float('inf'))
False
>>> isint(5.0+0.0j)
True
>>> isint(5-5j)
False",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Voronoi_diagram,Voronoi diagram,"A Voronoi diagram is a diagram consisting of a number of sites.

Each Voronoi site s also has a Voronoi cell consisting of all points closest to s.



Task

Demonstrate how to generate and display a Voroni diagram.



See algo K-means++ clustering.



",Python,"from PIL import Image
import random
import math
 
def generate_voronoi_diagram(width, height, num_cells):
	image = Image.new(""RGB"", (width, height))
	putpixel = image.putpixel
	imgx, imgy = image.size
	nx = []
	ny = []
	nr = []
	ng = []
	nb = []
	for i in range(num_cells):
		nx.append(random.randrange(imgx))
		ny.append(random.randrange(imgy))
		nr.append(random.randrange(256))
		ng.append(random.randrange(256))
		nb.append(random.randrange(256))
	for y in range(imgy):
		for x in range(imgx):
			dmin = math.hypot(imgx-1, imgy-1)
			j = -1
			for i in range(num_cells):
				d = math.hypot(nx[i]-x, ny[i]-y)
				if d < dmin:
					dmin = d
					j = i
			putpixel((x, y), (nr[j], ng[j], nb[j]))
	image.save(""VoronoiDiagram.png"", ""PNG"")
        image.show()
 
generate_voronoi_diagram(500, 500, 25)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Non-decimal_radices/Convert,Non-decimal radices/Convert,"Number base conversion is when you express a stored integer in an integer base, such as in octal (base 8) or binary (base 2). It also is involved when you take a string representing a number in a given base and convert it to the stored integer form. Normally, a stored integer is in binary, but that's typically invisible to the user, who normally enters or sees stored integers as decimal.



Task

Write a function (or identify the built-in function) which is passed a non-negative integer to convert, and another integer representing the base.

It should return a string containing the digits of the resulting number, without leading zeros except for the number   0   itself.

For the digits beyond 9, one should use the lowercase English alphabet, where the digit   a = 9+1,   b = a+1,   etc.

For example:   the decimal number   26   expressed in base   16   would be   1a.

Write a second function which is passed a string and an integer base, and it returns an integer representing that string interpreted in that base.

The programs may be limited by the word size or other such constraint of a given language. There is no need to do error checking for negatives, bases less than 2, or inappropriate digits.



",Python,"i = int('1a',16)  # returns the integer 26",Human_written,Python_from_C++
http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Python,"class Animal:
  pass #functions go here...
 
class Dog(Animal):
  pass #functions go here...
 
class Cat(Animal):
  pass #functions go here...
 
class Lab(Dog):
  pass #functions go here...
 
class Collie(Dog):
  pass #functions go here...",Human_written,Python_from_C++
http://rosettacode.org/wiki/Dice_game_probabilities,Dice game probabilities,"Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.

They roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?

Later the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?

This task was adapted from the Project Euler Problem n.205:
https://projecteuler.net/problem=205
",Python,"from itertools import product
 
def gen_dict(n_faces, n_dice):
    counts = [0] * ((n_faces + 1) * n_dice)
    for t in product(range(1, n_faces + 1), repeat=n_dice):
        counts[sum(t)] += 1
    return counts, n_faces ** n_dice
 
def beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):
    c1, p1 = gen_dict(n_sides1, n_dice1)
    c2, p2 = gen_dict(n_sides2, n_dice2)
    p12 = float(p1 * p2)
 
    return sum(p[1] * q[1] / p12
               for p, q in product(enumerate(c1), enumerate(c2))
               if p[0] > q[0])
 
print beating_probability(4, 9, 6, 6)
print beating_probability(10, 5, 7, 6)",Human_written,Python_from_C
http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string,Strip control codes and extended characters from a string,"Task

Strip control codes and extended characters from a string.



The solution should demonstrate how to achieve each of the following results:

   a string with control codes stripped (but extended characters not stripped)
   a string with control codes and extended characters stripped


In ASCII, the control codes have decimal codes 0 through to 31 and 127.

On an ASCII based system, if the control codes are stripped, the resultant string would have all of its characters within the range of 32 to 126 decimal on the ASCII table.

On a non-ASCII based system, we consider characters that do not have a corresponding glyph on the ASCII table (within the ASCII range of 32 to 126 decimal) to be an extended character for the purpose of this task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms  (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"stripped = lambda s: """".join(i for i in s if 31 < ord(i) < 127)
 
print(stripped(""\ba\x00b\n\rc\fd\xc3""))",Human_written,Python_from_Java
"http://rosettacode.org/wiki/Abbreviations,_simple","Abbreviations, simple","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



For this task, the following   command table   will be used:

   add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   a command is followed by an optional number, which indicates the minimum abbreviation
   A valid abbreviation is a word that has:
   at least the minimum length of the word's minimum number in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTER 3
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTER 3
   The   3   indicates that any abbreviation for   ALTER   must be at least three characters
   Any word longer than five characters can't be an abbreviation for   ALTER
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   overlay 1
   if there isn't a number after the command,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"command_table_text = """"""add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1""""""
 
user_words = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
 
def find_abbreviations_length(command_table_text):
    """""" find the minimal abbreviation length for each word.
        a word that does not have minimum abbreviation length specified
        gets it's full lengths as the minimum.
    """"""
    command_table = dict()
    input_iter = iter(command_table_text.split())
 
    word = None
    try:
        while True:
            if word is None:
                word = next(input_iter)
            abbr_len = next(input_iter, len(word))
            try:
                command_table[word] = int(abbr_len)
                word = None
            except ValueError:
                command_table[word] = len(word)
                word = abbr_len
    except StopIteration:
        pass
    return command_table
 
 
def find_abbreviations(command_table):
    """""" for each command insert all possible abbreviations""""""
    abbreviations = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations
 
 
def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, ""*error*"") for user_word in user_words]
    return "" "".join(commands)
 
 
command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)
 
full_words = parse_user_string(user_words, abbreviations_table)
 
print(""user words:"", user_words)
print(""full words:"", full_words)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Inverted_index,Inverted index,"An Inverted Index is a data structure used to create full text search.



Task

Given a set of text files, implement a program to create an inverted index.

Also create a user interface to do a search using that inverted index which returns a list of files that contain the query term / terms.

The search index can be in memory.



",Python,"import os
import re
import sys
 
# inverted index representation
index = {} # ints index into indexed
indexed = []
 
class doc:
    def __init__(self, file, title):
        self.file = file
        self.title = title
 
def main():
    # initialize representation
    index = {}
 
    # build index
    if indexDir(""docs""):
        # run user interface
        ui()
 
def indexDir(dir):
    df = os.open(dir)
    fis = os.listdir(df)
    if len(fis) == 0:
        return False
    indexed = 0
    for fi in fis:
        if not os.path.isdir(fi):
            if indexFile(dir + ""/"" + fi):
                indexed += 1
    return True
 
def indexFile(fn):
    f = open(fn)
 
    # register new file
    x = len(indexed)
    indexed.append(doc(fn, fn))
    pdoc = indexed[x]
 
    # scan lines
    lines = 0
    for line in f:
        if lines < 20 and re.match(""Title:"", line):
            # in a real program you would write code
            # to skip the Gutenberg document header
            # and not index it.
            pdoc.title = line[7:]
        # index line of text in b
        # again, in a real program you would write a much
        # nicer word splitter.
    wordLoop:
        for bword in re.split(r""\s+"", line):
            bword = re.sub(r""[\.,-~?!\""'`;:()<>[]{}\\|/=_+*&^%$#@]"", """", bword)
            if len(bword) > 0:
                word = bword
                dl = index[word]
                for d in dl:
                    if d == x:
                        continue wordLoop
                index[word] = append(dl, x)
    return True
 
def ui():
    print len(index), ""words indexed in"", len(indexed), ""files""
    print ""enter single words to search for""
    print ""enter a blank line when done""
    word = """"
    while word!= """":
        word = raw_input(""search word: "")
        if word == """":
            return
        switch dl := index[word]:
            case 0:
                print ""no match""
            case 1:
                print ""one match:""
                print ""   "", indexed[dl[0]].file, indexed[dl[0]].title
            default:
                print len(dl), ""matches:""
                for d in dl:
                    print ""   "", indexed[d].file, indexed[d].title
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists,Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",Python,"import itertools

def cartesian_product(*sequences):
    return itertools.product(*sequences)

def main():
    empty = []
    list1 = [1, 2]
    list2 = [3, 4]
    list3 = [1776, 1789]
    list4 = [7, 12]
    list5 = [4, 14, 23]
    list6 = [0, 1]
    list7 = [1, 2, 3]
    list8 = [30]
    list9 = [500, 100]

    for sequence_list in [
        [list1, list2],
        [list2, list1],
        [list1, empty],
        [empty, list1],
        [list3, list4, list5, list6],
        [list7, list8, list9],
        [list7, empty, list9],
    ]:
        cart = [f""({', '.join(map(str, tuple))})"" for tuple in cartesian_product(*sequence_list)]
        print(f""{{{', '.join(cart)}}}"")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible,Determine if a string is collapsible,"Determine if a character string is   collapsible.

And if so,   collapse the string   (by removing   immediately repeated   characters).



If a character string has   immediately repeated   character(s),   the repeated characters are to be
deleted (removed),   but not the primary (1st) character(s).



An   immediately repeated   character is any character that is   immediately   followed by an
identical character (or characters).   Another word choice could've been   duplicated character,   but that
might have ruled out   (to some readers)   triplicated characters   ···   or more.



{This Rosetta Code task was inspired by a newly introduced   (as of around November 2019)   PL/I   BIF:   collapse.}



Examples

In the following character string:



 The better the 4-wheel drive, the further you'll be from help when ya get stuck! 



Only the 2nd   t,   e, and   l   are repeated characters,   indicated
by underscores (above),   even though they (those characters) appear elsewhere in the character string.



So, after collapsing the string, the result would be:

 The beter the 4-whel drive, the further you'l be from help when ya get stuck! 





Another example:
In the following character string:

 headmistressship 



The ""collapsed"" string would be:

 headmistreship 



Task

Write a subroutine/function/procedure/routine···   to
locate   repeated   characters and   collapse   (delete)   them from the character
string.   The character string can be processed from either direction.



Show all output here, on this page:

   the   original string and its length
   the resultant string and its length
   the above strings should be ""bracketed"" with   <<<   and   >>>   (to delineate blanks)
   «««Guillemets may be used instead for ""bracketing"" for the more artistic programmers,   shown used here»»»


Use (at least) the following five strings,   all strings are length seventy-two (characters, including blanks),   except
the 1st string:

 string
 number
        ╔╗
   1    ║╚═══════════════════════════════════════════════════════════════════════╗   ◄■■■■■■  a null string  (length zero)
   2    ║""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ║
   3    ║..1111111111111111111111111111111111111111111111111111111111111117777888║
   4    ║I never give 'em hell, I just tell the truth, and they think it's hell. ║
   5    ║                                                    --- Harry S Truman  ║   ◄■■■■■■  has many repeated blanks
        ╚════════════════════════════════════════════════════════════════════════╝


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import groupby
 
def collapser(txt):
    return ''.join(item for item, grp in groupby(txt))
 
if __name__ == '__main__':
    strings = [
            """",
            '""If I were two-faced, would I be wearing this one?"" --- Abraham Lincoln ',
            ""..1111111111111111111111111111111111111111111111111111111111111117777888"",
            ""I never give 'em hell, I just tell the truth, and they think it's hell. "",
            ""                                                   ---  Harry S Truman  "",
            ""The better the 4-wheel drive, the further you'll be from help when ya get stuck!"",
            ""headmistressship"",
            ""aardvark"",
            ""😍😀🙌💃😍😍😍🙌"",
            ]
    for txt in strings:
        this = ""Original""
        print(f""\n{this:14} Size: {len(txt)} «««{txt}»»»"" )
        this = ""Collapsed""
        sqz = collapser(txt)
        print(f""{this:>14} Size: {len(sqz)} «««{sqz}»»»"" )",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",Python,"from __future__ import print_function
from string import ascii_lowercase
 
SYMBOLTABLE = list(ascii_lowercase)
 
def move2front_encode(strng, symboltable):
    sequence, pad = [], symboltable[::]
    for char in strng:
        indx = pad.index(char)
        sequence.append(indx)
        pad = [pad.pop(indx)] + pad
    return sequence
 
def move2front_decode(sequence, symboltable):
    chars, pad = [], symboltable[::]
    for indx in sequence:
        char = pad[indx]
        chars.append(char)
        pad = [pad.pop(indx)] + pad
    return ''.join(chars)
 
if __name__ == '__main__':
    for s in ['broood', 'bananaaa', 'hiphophiphop']:
        encode = move2front_encode(s, SYMBOLTABLE)
        print('%14r encodes to %r' % (s, encode), end=', ')
        decode = move2front_decode(encode, SYMBOLTABLE)
        print('which decodes back to %r' % decode)
        assert s == decode, 'Whoops!'",Human_written,Python_from_Java
http://rosettacode.org/wiki/Best_shuffle,Best shuffle,"Task

Shuffle the characters of a string in such a way that as many of the character values are in a different position as possible.

A shuffle that produces a randomized result among the best choices is to be preferred. A deterministic approach that produces the same sequence every time is acceptable as an alternative.

Display the result as follows:

original string, shuffled string, (score) 

The score gives the number of positions whose character value did not change.



Example

tree, eetr, (0)



Test cases

abracadabra
seesaw
elk
grrrrrr
up
a



Related tasks
   Anagrams/Deranged anagrams
   Permutations/Derangements



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def best_shuffle(s):
    # Fill _pos_ with positions in the order
    # that we want to fill them.
    pos = []
    # g[""a""] = [2, 4] implies that s[2] == s[4] == ""a""
    g = {i: s[i] for i in range(len(s))}
    # k sorts letters from low to high count
    k = sorted(g, key=lambda k: len(g[k]))
    while g:
        for letter in k:
            if letter not in g:
                continue
            pos.append(g[letter].pop())
            if not g[letter]:
                del g[letter]
    # Now fill in _new_ with _letters_ according to each position
    # in _pos_, but skip ahead in _letters_ if we can avoid
    # matching characters that way.
    letters = list(s)
    new = ""?"" * len(s)
    while letters:
        i, p = 0, pos.pop()
        while letters[i] == s[p] and i < len(letters) - 1:
            i += 1
        new[p] = letters.pop(i)
    score = sum(1 for c, d in zip(new, s) if c == d)
    return new, score
 
for word in [""abracadabra"", ""seesaw"", ""elk"", ""grrrrrr"", ""up"", ""a""]:
    print(""%s, %s, (%d)"" % (word, *best_shuffle(word)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",Python,"import string, sys
if sys.version_info[0] < 3:
    input = raw_input
 
def ispangram(sentence, alphabet=string.ascii_lowercase):
    alphaset = set(alphabet)
    return alphaset <= set(sentence.lower())
 
print ( ispangram(input('Sentence: ')) )",Human_written,Python_from_C
http://rosettacode.org/wiki/Soundex,Soundex,"Soundex is an algorithm for creating indices for words based on their pronunciation.



Task

The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling   (from the   soundex   Wikipedia article).

Caution

There is a major issue in many of the implementations concerning the separation of two consonants that have the same soundex code! According to the official Rules [[1]]. So check for instance if Ashcraft is coded to A-261.

 If a vowel (A, E, I, O, U) separates two consonants that have the same soundex code, the consonant to the right of the vowel is coded. Tymczak is coded as T-522 (T, 5 for the M, 2 for the C, Z ignored (see ""Side-by-Side"" rule above), 2 for the K). Since the vowel ""A"" separates the Z and K, the K is coded.
 If ""H"" or ""W"" separate two consonants that have the same soundex code, the consonant to the right of the vowel is not coded. Example: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226.

",Python,"from itertools import groupby
 
def soundex(word):
   codes = (""bfpv"",""cgjkqsxz"", ""dt"", ""l"", ""mn"", ""r"")
   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)
   cmap2 = lambda kar: soundDict.get(kar, '9')
   sdx =  ''.join(cmap2(kar) for kar in word.lower())
   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')
   sdx3 = sdx2[0:4].ljust(4,'0')
   return sdx3",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",Python,"#!/usr/bin/env python
 
import sys
 
def main():
    program = sys.argv[0]
    print(""Program: %s"" % program)
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Search_a_list_of_records,Search a list of records,"Many programming languages provide convenient ways to look for a known value in a simple list of strings or numbers.

But what if the elements of the list are themselves compound records/objects/data-structures, and the search condition is more complex than a simple equality test?

Task[edit]
Write a function/method/etc. that can find the first element in a given list matching a given condition.

It should be as generic and reusable as possible.

(Of course if your programming language already provides such a feature, you can use that instead of recreating it.)

Then to demonstrate its functionality, create the data structure specified under #Data set, and perform on it the searches specified under #Test cases.

Data set
The data structure to be used contains the names and populations (in millions) of the 10 largest metropolitan areas in Africa, and looks as follows when represented in JSON:

[
  { ""name"": ""Lagos"",                ""population"": 21.0  },
  { ""name"": ""Cairo"",                ""population"": 15.2  },
  { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
  { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
  { ""name"": ""Mogadishu"",            ""population"":  5.85 },
  { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
  { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
  { ""name"": ""Alexandria"",           ""population"":  4.58 },
  { ""name"": ""Abidjan"",              ""population"":  4.4  },
  { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
However, you shouldn't parse it from JSON, but rather represent it natively in your programming language.

 The top-level data structure should be an ordered collection (i.e. a list, array, vector, or similar).
 Each element in this list should be an associative collection that maps from keys to values (i.e. a struct, object, hash map, dictionary, or similar).
 Each of them has two entries: One string value with key ""name"", and one numeric value with key ""population"".
 You may rely on the list being sorted by population count, as long as you explain this to readers.


If any of that is impossible or unreasonable in your programming language, then feel free to deviate, as long as you explain your reasons in a comment above your solution.

Test cases


 Search

 Expected result


 Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""

 6


 Find the name of the first city in this list whose population is less than 5 million

 Khartoum-Omdurman


 Find the population of the first city in this list whose name starts with the letter ""A""

 4.58

Guidance
If your programming language supports higher-order programming, then the most elegant way to implement the requested functionality in a generic and reusable way, might be to write a function (maybe called ""find_index"" or similar), that takes two arguments:

 The list to search through.
 A function/lambda/closure (the so-called ""predicate""), which will be applied in turn to each element in the list, and whose boolean return value defines whether that element matches the search requirement.
If this is not the approach which would be most natural or idiomatic in your language, explain why, and show what is.

Related tasks
 Search a list
",Python,"dataset = [
    {""name"": ""Lagos"", ""population"": 21.0},
    {""name"": ""Cairo"", ""population"": 15.2},
    {""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3},
    {""name"": ""Greater Johannesburg"", ""population"": 7.55},
    {""name"": ""Mogadishu"", ""population"": 5.85},
    {""name"": ""Khartoum-Omdurman"", ""population"": 4.98},
    {""name"": """", ""population"": 4.7},
    {""name"": ""Alexandria"", ""population"": 4.58},
    {""name"": ""Abidjan"", ""population"": 4.4},
    {""name"": ""Casablanca"", ""population"": 3.98}
]
 
# Find the (zero-based) index of the first city in the list whose name is """"
index = next(i for i, x in enumerate(dataset) if x[""name""] == """")
print(index)
 
# Find the name of the first city in this list whose population is less than 5 million
name = next(x[""name""] for x in dataset if x[""population""] < 5.0)
print(name)
 
# Find the population of the first city in this list whose name starts with the letter ""A""
aNamePopulation = next(x[""population""] for x in dataset if x[""name""].startswith(""A""))
print(aNamePopulation)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Find_the_last_Sunday_of_each_month,Find the last Sunday of each month,"Write a program or a script that returns the last Sundays of each month of a given year. The year may be given through any simple input method in your language (command line, std in, etc).

Example of an expected output:

./last_sundays 2013
2013-01-27
2013-02-24
2013-03-31
2013-04-28
2013-05-26
2013-06-30
2013-07-28
2013-08-25
2013-09-29
2013-10-27
2013-11-24
2013-12-29


Related tasks
 Day of the week
 Five weekends
 Last Friday of each month

",Python,"import sys
import calendar
 
year = 2013
if len(sys.argv) > 1:
    try:
        year = int(sys.argv[-1])
    except ValueError:
        pass
 
for month in range(1, 13):
    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))
    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Menu,Menu,"Task

Given a prompt and a list containing a number of strings of which one is to be selected, create a function that:

 prints a textual menu formatted as an index value followed by its corresponding string for each item in the list;
 prompts the user to enter a number;
 returns the string corresponding to the selected index number.


The function should reject input that is not an integer or is out of range by redisplaying the whole menu before asking again for a number. The function should return an empty string if called with an empty list.

For test purposes use the following four phrases in a list:

   fee fie
   huff and puff
   mirror mirror
   tick tock

Note

This task is fashioned after the action of the Bash select statement.
",Python,"def _menu(items):
    for indexitem in enumerate(items):
        print (""  %2i) %s"" % indexitem)
 
def _ok(reply, itemcount):
    try:
        n = int(reply)
        return 0 <= n < itemcount
    except:
        return False
 
def selector(items, prompt):
    'Prompt to select an item from the items'
    if not items: return ''
    reply = -1
    itemcount = len(items)
    while not _ok(reply, itemcount):
        _menu(items)
        # Use input instead of raw_input for Python 3.x
        reply = raw_input(prompt).strip()
    return items[int(reply)]
 
if __name__ == '__main__':
    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']
    item = selector(items, 'Which is from the three pigs: ')
    print (""You chose: "" + item)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",Python,"#!/usr/bin/env python
print 2**64*2**64",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",Python,"a, b = input().split()
a = int(a)
b = int(b)
print(""a+b ="", a+b)
print(""a-b ="", a-b)
print(""a*b ="", a*b)
print(""a/b ="", a//b, "", remainder"", a%b)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Python,"list = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
a = sum(map(lambda x: x + 2, list)) / len(list)
h = sum(map(lambda x: x * x, list)) / len(list)
g = sum(map(lambda x: x * x * x, list)) / len(list)
print(""A = %f  G = %f  H = %f"" % (a, g, h))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"#!/usr/bin/env python
a = input('Enter value of a: ')
b = input('Enter value of b: ')
 
if a < b:
    print 'a is less than b'
elif a > b:
    print 'a is greater than b'
elif a == b:
    print 'a is equal to b'",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sparkline_in_unicode,Sparkline in unicode,"A sparkline is a graph of successive values laid out horizontally
where the height of the line is proportional to the values in succession.



Task

Use the following series of Unicode characters to create a program
that takes a series of numbers separated by one or more whitespace or comma characters
and generates a sparkline-type bar graph of the values on a single line of output.

The eight characters: '▁▂▃▄▅▆▇█'

(Unicode values U+2581 through U+2588).

Use your program to show sparklines for the following input,
here on this page:

 1 2 3 4 5 6 7 8 7 6 5 4 3 2 1
 1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 
(note the mix of separators in this second case)!
Notes
 
 A space is not part of the generated sparkline.
 The sparkline may be accompanied by simple statistics of the data such as its range.
 A suggestion emerging in later discussion (see Discussion page) is that the bounds between bins should ideally be set to yield the following results for two particular edge cases:
 ""0, 1, 19, 20"" -> ▁▁██
 (Aiming to use just two spark levels)
 ""0, 999, 4000, 4999, 7000, 7999"" -> ▁▁▅▅██
 (Aiming to use just three spark levels)
 It may be helpful to include these cases in output tests.
 You may find that the unicode sparklines on this page are rendered less noisily by Google Chrome than by Firefox or Safari.

",Python,"import sys
import math
 
def main():
	if len(sys.argv) == 1:
		print(""Usage : %s <data points separated by spaces or commas>"" % sys.argv[0])
	else:
		arr = []
		for i in range(1,len(sys.argv)):
			if sys.argv[i][len(sys.argv[i])-1] == ',':
				arr.append(float(sys.argv[i][:-1]))
			else:
				arr.append(float(sys.argv[i]))
		min = arr[0]
		max = arr[0]
		for i in range(1,len(sys.argv)):
			min = min if min < arr[i-1] else arr[i-1]
			max = max if max > arr[i-1] else arr[i-1]
		print(""\nMax : %lf,Min : %lf,Range : %lf\n"" % (max,min,max-min))
		for i in range(1,len(sys.argv)):
			print(chr(9601 + math.ceil((arr[i-1]-min)/(max-min)*7)))
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Perfect_numbers,Perfect numbers,"Write a function which says whether a number is perfect.


A perfect number is a positive integer that is the sum of its proper positive divisors excluding the number itself.

Equivalently, a perfect number is a number that is half the sum of all of its positive divisors (including itself).



Note:   The faster   Lucas-Lehmer test   is used to find primes of the form    2n-1,   all known perfect numbers can be derived from these primes
using the formula    (2n - 1) × 2n - 1.

It is not known if there are any odd perfect numbers (any that exist are larger than 102000).

The number of   known   perfect numbers is   51   (as of December, 2018),   and the largest known perfect number contains  49,724,095  decimal digits.



See also

   Rational Arithmetic
   Perfect numbers on OEIS
   Odd Perfect showing the current status of bounds on odd perfect numbers.

",Python,"def perf1(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum == n",Human_written,Python_from_C++
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"import random
from PIL import Image

def main():
    bm = Image.new('RGB', (600, 600))
    reference_points = [
        (0, 600),
        (600, 600),
        (300, 81)
    ]
    r = random.Random()
    p = (r.randint(0, 600), r.randint(0, 600))
    for count in range(10000):
        bm.putpixel(p, (255, 0, 255))
        i = r.randint(0, 2)
        p = (
            (p[0] + reference_points[i][0]) // 2,
            (p[1] + reference_points[i][1]) // 2
        )
    bm.save('Chaos Game.png')

if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Voronoi_diagram,Voronoi diagram,"A Voronoi diagram is a diagram consisting of a number of sites.

Each Voronoi site s also has a Voronoi cell consisting of all points closest to s.



Task

Demonstrate how to generate and display a Voroni diagram.



See algo K-means++ clustering.



",Python,"from PIL import Image
import random
import math
 
def generate_voronoi_diagram(width, height, num_cells):
	image = Image.new(""RGB"", (width, height))
	putpixel = image.putpixel
	imgx, imgy = image.size
	nx = []
	ny = []
	nr = []
	ng = []
	nb = []
	for i in range(num_cells):
		nx.append(random.randrange(imgx))
		ny.append(random.randrange(imgy))
		nr.append(random.randrange(256))
		ng.append(random.randrange(256))
		nb.append(random.randrange(256))
	for y in range(imgy):
		for x in range(imgx):
			dmin = math.hypot(imgx-1, imgy-1)
			j = -1
			for i in range(num_cells):
				d = math.hypot(nx[i]-x, ny[i]-y)
				if d < dmin:
					dmin = d
					j = i
			putpixel((x, y), (nr[j], ng[j], nb[j]))
	image.save(""VoronoiDiagram.png"", ""PNG"")
        image.show()
 
generate_voronoi_diagram(500, 500, 25)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Casting_out_nines,Casting out nines,"Task   (in three parts)



Part 1
Write a procedure (say 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

) which implements Casting Out Nines as described by returning the checksum for 



x


{\displaystyle x}

. Demonstrate the procedure using the examples given there, or others you may consider lucky.

Part 2
Notwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:

 Consider the statement ""318682 is 101558 + 217124 and squared is 101558217124"" (see: Kaprekar numbers#Casting Out Nines (fast)).
 note that 



318682


{\displaystyle 318682}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

);
 note that 



101558217124


{\displaystyle 101558217124}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

) because for a Kaprekar they are made up of the same digits (sometimes with extra zeroes);
 note that this implies that for Kaprekar numbers the checksum of 



k


{\displaystyle k}

 equals the checksum of 




k

2




{\displaystyle k^{2}}

.
Demonstrate that your procedure can be used to generate or filter a range of numbers with the property 





c
o
9


(
k
)
=


c
o
9


(

k

2


)


{\displaystyle {\mathit {co9}}(k)={\mathit {co9}}(k^{2})}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.

Part 3
Considering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:

 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

 is the residual of 



x


{\displaystyle x}

 mod 



9


{\displaystyle 9}

;
 the procedure can be extended to bases other than 9.
Demonstrate your algorithm by generating or filtering a range of numbers with the property 



k
%
(


B
a
s
e


−
1
)
==
(

k

2


)
%
(


B
a
s
e


−
1
)


{\displaystyle k\%({\mathit {Base}}-1)==(k^{2})\%({\mathit {Base}}-1)}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.



related tasks
 First perfect square in base N with N unique digits
 Kaprekar numbers

",Python,"# Casting out Nines
#
# Nigel Galloway: June 27th., 2012,
#
def CastOut(Base=10, Start=1, End=999999):
  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]
  x,y = divmod(Start, Base-1)
  while True:
    for n in ran:
      k = (Base-1)*x + n
      if k < Start:
        continue
      if k > End:
        return
      yield k
    x += 1
 
for V in CastOut(Base=16,Start=1,End=255):
  print(V, end=' ')",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Handle_a_signal,Handle a signal,"Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.
Unhandled signals generally terminate a program in a disorderly manner.
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second.
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.



",Python,"import time
 
def counter():
    n = 0
    t1 = time.time()
    while True:
        try:
            time.sleep(0.5)
            n += 1
            print n
        except KeyboardInterrupt, e:
            print 'Program has run for %5.3f seconds.' % (time.time() - t1)
            break
 
counter()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Anagrams,Anagrams,"When two or more words are composed of the same characters, but in a different order, they are called anagrams.

Task[edit]
Using the word list at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

find the sets of words that share the same characters that contain the most words in them.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> import urllib.request
>>> from collections import defaultdict
>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()
>>> anagram = defaultdict(list) # map sorted chars to anagrams
>>> for word in words:
	anagram[tuple(sorted(word))].append( word )
 
 
>>> count = max(len(ana) for ana in anagram.values())
>>> for ana in anagram.values():
	if len(ana) >= count:
		print ([x.decode() for x in ana])",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Truncate_a_file,Truncate a file,"Task

Truncate a file to a specific length.   This should be implemented as a routine that takes two parameters: the filename and the required file length (in bytes).



Truncation can be achieved using system or library calls intended for such a task, if such methods exist, or by creating a temporary file of a reduced size and renaming it, after first deleting the original file, if no other method is available.   The file may contain non human readable binary data in an unspecified format, so the routine should be ""binary safe"", leaving the contents of the untruncated part of the file unchanged.

If the specified filename does not exist, or the provided length is not less than the current file length, then the routine should raise an appropriate error condition.

On some systems, the provided file truncation facilities might not change the file or may extend the file, if the specified length is greater than the current length of the file.

This task permits the use of such facilities.   However, such behaviour should be noted, or optionally a warning message relating to an non change or increase in file size may be implemented.



",Python,"def truncate_file(name, length):
    if not os.path.isfile(name):
        return False
    if length >= os.path.getsize(name):
        return False
    with open(name, 'ab') as f:
        f.truncate(length)
    return True",Human_written,Python_from_Java
http://rosettacode.org/wiki/100_doors,100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",Python,"doors = [False] * 100
for i in range(100):
   for j in range(i, 100, i+1):
       doors[j] = not doors[j]
   print(""Door %d:"" % (i+1), 'open' if doors[i] else 'close')",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Empty_directory,Empty directory,"Starting with a path to some directory, determine whether the directory is empty.

An empty directory contains no files nor subdirectories.
With Unix or Windows systems, every directory contains an entry for “.” and almost every directory contains “..” (except for a root directory); an empty directory contains no other entries.
",Python,"import os;
if os.listdir(raw_input(""directory"")):
    print ""not empty""
else:
    print ""empty""",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/URL_parser,URL parser,"URLs are strings with a simple syntax:

  scheme://[username:password@]domain[:port]/path?query_string#fragment_id



Task

Parse a well-formed URL to retrieve the relevant information:   scheme, domain, path, ...



Note:   this task has nothing to do with URL encoding or URL decoding.



According to the standards, the characters:

     ! * ' ( ) ; : @ & = + $ , / ? % # [ ] 
only need to be percent-encoded   (%)   in case of possible confusion.

Also note that the path, query and fragment are case sensitive, even if the scheme and domain are not.

The way the returned information is provided (set of variables, array, structured, record, object,...)
is language-dependent and left to the programmer, but the code should be clear enough to reuse.

Extra credit is given for clear error diagnostics.

   Here is the official standard:     https://tools.ietf.org/html/rfc3986, 
   and here is a simpler   BNF:     http://www.w3.org/Addressing/URL/5_URI_BNF.html.


Test cases

According to T. Berners-Lee

foo://example.com:8042/over/there?name=ferret#nose     should parse into:

   scheme = foo
   domain = example.com
   port = :8042
   path = over/there
   query = name=ferret
   fragment = nose

urn:example:animal:ferret:nose     should parse into:

   scheme = urn
   path = example:animal:ferret:nose

other URLs that must be parsed include:

   jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true 
   ftp://ftp.is.co.za/rfc/rfc1808.txt 
   http://www.ietf.org/rfc/rfc2396.txt#header1 
   ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two 
   mailto:John.Doe@example.com 
   news:comp.infosystems.www.servers.unix 
   tel:+1-816-555-1212 
   telnet://192.0.2.16:80/ 
   urn:oasis:names:specification:docbook:dtd:xml:4.1.2 

",Python,"import urllib.parse as up # urlparse for Python v2
 
url = up.urlparse('http://user:pass@example.com:8081/path/file.html;params?query1=1#fragment')
 
print('url.scheme = ', url.scheme)
print('url.netloc = ', url.netloc)
print('url.hostname = ', url.hostname)
print('url.port = ', url.port)
print('url.path = ', url.path)
print('url.params = ', url.params)
print('url.query = ', url.query)
print('url.fragment = ', url.fragment)
print('url.username = ', url.username)
print('url.password = ', url.password)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",Python,"T = [[""79"", ""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""],
     ["""",   ""H"", ""O"", ""L"", """",  ""M"", ""E"", ""S"", """",  ""R"", ""T""],
     [""3"",  ""A"", ""B"", ""C"", ""D"", ""F"", ""G"", ""I"", ""J"", ""K"", ""N""],
     [""7"",  ""P"", ""Q"", ""U"", ""V"", ""W"", ""X"", ""Y"", ""Z"", ""."", ""/""]]
 
def straddle(s):
    return """".join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L)
 
def unstraddle(s):
    s = iter(s)
    for c in s:
        if c in [T[2][0], T[3][0]]:
            i = [T[2][0], T[3][0]].index(c)
            n = T[2 + i][T[0].index(s.next())]
            yield s.next() if n == ""/"" else n
        else:
            yield T[1][T[0].index(c)]
 
O = ""One night-it was on the twentieth of March, 1888-I was returning""
print ""Encoded:"", straddle(O)
print ""Decoded:"", """".join(unstraddle(straddle(O)))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sequence:_smallest_number_greater_than_previous_term_with_exactly_n_divisors,Sequence: smallest number greater than previous term with exactly n divisors,"Calculate the sequence where each term an is the smallest natural number greater than the previous term, that has exactly n divisors.



Task
Show here, on this page, at least the first 15 terms of the sequence.



See also
 OEIS:A069654


Related tasks
 Sequence: smallest number with exactly n divisors
 Sequence: nth number with exactly n divisors‎‎

",Python,"# Version 1.3.21
 
MAX = 15
 
def countDivisors(n):
    count = 0
    i = 1
    while i * i <= n:
        if n % i == 0:
            count += 1 if i == n // i else 2
        i += 1
    return count
 
print(""The first"", MAX, ""terms of the sequence are:"")
i = 1
next = 1
while next <= MAX:
    if next == countDivisors(i):
        print(i, end="" "")
        next += 1
    i += 1
print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Reflection/Get_source,Reflection/Get source,"Task

The goal is to get the source code or file path and line number where a programming object (e.g. module, class, function, method) is defined.



",Python,"import math
math.sqrt.__code__.co_filename
# '/usr/local/lib/python3.5/math.py'
 
Class.nesting.__code__.co_filename
# AttributeError: 'builtin_function_or_method' object has no attribute 'co_filename'",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Python,"def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = _matrix[row][int(digit)] 
    return row == 0
 
_matrix = (
    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),
    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),
    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),
    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),
    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),
    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),
    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),
    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),
    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),
    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)
)
 
if __name__ == '__main__':
    for test in [5724, 5727, 112946]:
        print(f'{test}\t Validates as: {damm(test)}')",Human_written,Python_from_C#
http://rosettacode.org/wiki/Bitwise_operations,Bitwise operations,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Write a routine to perform a bitwise AND, OR, and XOR on two integers, a bitwise NOT on the first integer, a left shift, right shift, right arithmetic shift, left rotate, and right rotate.

All shifts and rotates should be done on the first integer with a shift/rotate amount of the second integer.

If any operation is not available in your language, note it.



",Python,"#  for symmetry with Kotlin's other binary bitwise operators
#  we wrap Java's 'rotate' methods as infix functions
def rol(x, distance):
    return (x << distance) | (x >> (32 - distance))
def ror(x, distance):
    return (x >> distance) | (x << (32 - distance))
 
# inferred type of x and y is Int i.e. 32 bit signed integers
x = 10
y = 2
print(""x       ="", x)
print(""y       ="", y)
print(""NOT x   ="", ~x)
print(""x AND y ="", x & y)
print(""x OR  y ="", x | y)
print(""x XOR y ="", x ^ y)
print(""x SHL y ="", x << y)
print(""x ASR y ="", x >> y)   # arithmetic shift right (sign bit filled)
print(""x LSR y ="", x >> y)  # logical shift right    (zero filled)
print(""x ROL y ="", rol(x, y))
print(""x ROR y ="", ror(x, y))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"import bpy
 
# select default cube
bpy.data.objects['Cube'].select_set(True)
 
# delete default cube
bpy.ops.object.delete(True)
 
# add text to Blender scene  
bpy.data.curves.new(type=""FONT"", name=""Font Curve"").body = ""Hello World""
font_obj = bpy.data.objects.new(name=""Font Object"", object_data=bpy.data.curves[""Font Curve""])
bpy.context.scene.collection.objects.link(font_obj)
 
# camera center to text
bpy.context.scene.camera.location = (2.5,0.3,10)
 
# camera orient angle to text
bpy.context.scene.camera.rotation_euler = (0,0,0)
 
# change 3D scene to view from the camera
area = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')
area.spaces[0].region_3d.view_perspective = 'CAMERA'",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Eban_numbers,Eban numbers,"

Definition

An   eban   number is a number that has no letter    e    in it when the number is spelled in English.

Or more literally,   spelled numbers that contain the letter   e   are banned.



The American version of spelling numbers will be used here   (as opposed to the British).

2,000,000,000   is two billion,   not   two milliard.



Only numbers less than   one sextillion   (1021)   will be considered in/for this task.

This will allow optimizations to be used.



Task

   show all eban numbers   ≤   1,000   (in a horizontal format),   and a count
   show all eban numbers between   1,000   and   4,000   (inclusive),   and a count
   show a count of all eban numbers up and including           10,000
   show a count of all eban numbers up and including         100,000
   show a count of all eban numbers up and including      1,000,000
   show a count of all eban numbers up and including    10,000,000
   show all output here.


See also

   The MathWorld entry:   eban numbers.
   The OEIS entry:   A6933, eban numbers.

",Python,"import sys
 
class Interval:
    def __init__(self, start, end, print):
        self.start = start
        self.end = end
        self.print = print
 
def main():
    intervals = [
        Interval(2, 1_000, True),
        Interval(1_000, 4_000, True),
        Interval(2, 10_000, False),
        Interval(2, 100_000, False),
        Interval(2, 1_000_000, False),
        Interval(2, 10_000_000, False),
        Interval(2, 100_000_000, False),
        Interval(2, 1_000_000_000, False),
    ]
    for intv in intervals:
        if intv.start == 2:
            print(""eban numbers up to and including {0}:"".format(intv.end))
        else:
            print(""eban numbers between {0} and {1} (inclusive):"".format(intv.start, intv.end))
 
        count = 0
        for i in range(intv.start, intv.end + 1, 2):
            b = i // 1_000_000_000
            r = i % 1_000_000_000
            m = r // 1_000_000
            r = i % 1_000_000
            t = r // 1_000
            r %= 1_000
            if m >= 30 and m <= 66: m %= 10
            if t >= 30 and t <= 66: t %= 10
            if r >= 30 and r <= 66: r %= 10
            if b == 0 or b == 2 or b == 4 or b == 6:
                if m == 0 or m == 2 or m == 4 or m == 6:
                    if t == 0 or t == 2 or t == 4 or t == 6:
                        if r == 0 or r == 2 or r == 4 or r == 6:
                            if intv.print: print(""{0} "".format(i), end="""")
                            count += 1
        if intv.print:
            print()
        print(""count = {0}\n"".format(count))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Integer_overflow,Integer overflow,"Some languages support one or more integer types of the underlying processor.

This integer types have fixed size;   usually   8-bit,   16-bit,   32-bit,   or   64-bit.

The integers supported by such a type can be   signed   or   unsigned.

Arithmetic for machine level integers can often be done by single CPU instructions.

This allows high performance and is the main reason to support machine level integers.



Definition

An integer overflow happens when the result of a computation does not fit into the fixed size integer.
The result can be too small or too big to be representable in the fixed size integer.



Task

When a language has fixed size integer types, create a program that
does arithmetic computations for the fixed size integers of the language.

These computations must be done such that the result would overflow.

The program should demonstrate what the following expressions do.



For 32-bit signed integers:



Expression

Result that does not fit into a 32-bit signed integer


 -(-2147483647-1)

 2147483648


 2000000000 + 2000000000

 4000000000


 -2147483647 - 2147483647

 -4294967294


 46341 * 46341

 2147488281


 (-2147483647-1) / -1

 2147483648

For 64-bit signed integers:



Expression

Result that does not fit into a 64-bit signed integer


 -(-9223372036854775807-1)

 9223372036854775808


 5000000000000000000+5000000000000000000

 10000000000000000000


 -9223372036854775807 - 9223372036854775807

 -18446744073709551614


 3037000500 * 3037000500

 9223372037000250000


 (-9223372036854775807-1) / -1

 9223372036854775808

For 32-bit unsigned integers:



Expression

Result that does not fit into a 32-bit unsigned integer


 -4294967295

 -4294967295


 3000000000 + 3000000000

 6000000000


 2147483647 - 4294967295

 -2147483648


 65537 * 65537

 4295098369

For 64-bit unsigned integers:



Expression

Result that does not fit into a 64-bit unsigned integer


 -18446744073709551615

 -18446744073709551615


 10000000000000000000 + 10000000000000000000

 20000000000000000000


 9223372036854775807 - 18446744073709551615

 -9223372036854775808


 4294967296 * 4294967296

 18446744073709551616



Notes

   When the integer overflow does trigger an exception show how the exception is caught.
   When the integer overflow produces some value,   print it.
   It should be explicitly noted when an integer overflow is not recognized,   the program continues with wrong results.
   This should be done for signed and unsigned integers of various sizes supported by the computer programming language.
   When a language has no fixed size integer type,   or when no integer overflow can occur for other reasons,   this should be noted.
   It is okay to mention,   when a language supports unlimited precision integers,   but this task is NOT the place to demonstrate the 
  capabilities of unlimited precision integers.

",Python,"import sys
import math

class IntegerOverflow:
    @staticmethod
    def main():
        print(""For 32-bit signed integers:"")
        print(-(-2147483647 - 1))
        print(2000000000 + 2000000000)
        print(-2147483647 - 2147483647)
        print(46341 * 46341)
        print((-2147483647 - 1) / -1)
        print()
        print(""For 64-bit signed integers:"")
        print(-(-9223372036854775807 - 1))
        print(5000000000000000000 + 5000000000000000000)
        print(-9223372036854775807 - 9223372036854775807)
        print(3037000500 * 3037000500)
        print((-9223372036854775807 - 1) / -1)
        print()
        print(""For 32-bit unsigned integers:"")
        #Negating a 32-bit unsigned integer will convert it to a signed 64-bit integer.
        print(-4294967295)
        print(3000000000 + 3000000000)
        print(2147483647 - 4294967295)
        print(65537 * 65537)
        print()
        print(""For 64-bit unsigned integers:"")
        # The - operator cannot be applied to 64-bit unsigned integers; it will always give a compile-time error.
        #Console.WriteLine(-18446744073709551615UL);
        print(10000000000000000000 + 10000000000000000000)
        print(9223372036854775807 - 18446744073709551615)
        print(4294967296 * 4294967296)
        print()
        i = 2147483647
        print(i + 1)
        try:
            print(i + 1)
        except OverflowError:
            print(""Overflow!"")

if __name__ == '__main__':
    IntegerOverflow.main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",Python,"import time
 
epoch = time.gmtime(0)
print(time.asctime(epoch))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Quickselect_algorithm,Quickselect algorithm,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Use the quickselect algorithm on the vector

 [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
To show the first, second, third, ... up to the tenth largest member of the vector, in order, here on this page.

 Note: Quicksort has a separate task. 

",Python,"import random
 
def partition(vector, left, right, pivotIndex):
    pivotValue = vector[pivotIndex]
    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  # Move pivot to end
    storeIndex = left
    for i in range(left, right):
        if vector[i] < pivotValue:
            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]
            storeIndex += 1
    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  # Move pivot to its final place
    return storeIndex
 
def _select(vector, left, right, k):
    ""Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.""
    while True:
        pivotIndex = random.randint(left, right)     # select pivotIndex between left and right
        pivotNewIndex = partition(vector, left, right, pivotIndex)
        pivotDist = pivotNewIndex - left
        if pivotDist == k:
            return vector[pivotNewIndex]
        elif k < pivotDist:
            right = pivotNewIndex - 1
        else:
            k -= pivotDist + 1
            left = pivotNewIndex + 1
 
def select(vector, k, left=None, right=None):
    """"""\
    Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1].
    left, right default to (0, len(vector) - 1) if omitted
    """"""
    if left is None:
        left = 0
    lv1 = len(vector) - 1
    if right is None:
        right = lv1
    assert vector and k >= 0, ""Either null vector or k < 0 ""
    assert 0 <= left <= lv1, ""left is out of range""
    assert left <= right <= lv1, ""right is out of range""
    return _select(vector, left, right, k)
 
if __name__ == '__main__':
    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
    print([select(v, i) for i in range(10)])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Mad_Libs,Mad Libs,"

 This page uses content from Wikipedia. The original article was at Mad Libs. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Mad Libs is a phrasal template word game where one player prompts another for a list of words to substitute for blanks in a story, usually with funny results.



Task;
Write a program to create a Mad Libs like story.

The program should read an arbitrary multiline story from input.

The story will be terminated with a blank line.

Then, find each replacement to be made within the story, ask the user for a word to replace it with, and make all the replacements.

Stop when there are none left and print the final story.



The input should be an arbitrary story in the form:

<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.

Given this example, it should then ask for a name, a he or she and a noun (<name> gets replaced both times with the same value).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
# Optional Python 2.x compatibility
#try: input = raw_input
#except: pass
 
template = '''<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.'''
 
def madlibs(template):
    print('The story template is:\n' + template)
    fields = sorted(set( re.findall('<[^>]+>', template) ))
    values = input('\nInput a comma-separated list of words to replace the following items'
                   '\n  %s: ' % ','.join(fields)).split(',')
    story = template
    for f,v in zip(fields, values):
        story = story.replace(f, v)
    print('\nThe story becomes:\n\n' + story)
 
madlibs(template)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Substring,Substring,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Display a substring:

   starting from   n   characters in and of   m   length;
   starting from   n   characters in,   up to the end of the string;
   whole string minus the last character;
   starting from a known   character   within the string and of   m   length;
   starting from a known   substring   within the string and of   m   length.


If the program uses UTF-8 or UTF-16,   it must work on any valid Unicode code point,
whether in the   Basic Multilingual Plane   or above it.

The program must reference logical characters (code points),   not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.0.6

s = ""0123456789""
n = 3
m = 4
c = '5'
z = ""12""
i = 0
print(s[n:n + m])
print(s[n:])
print(s[:-1])
i = s.index(c)
print(s[i:i + m])
i = s.index(z)
print(s[i:i + m])",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Break_OO_privacy,Break OO privacy,"Show how to access private or protected members of a class in an object-oriented language from outside an instance of the class, without calling non-private or non-protected members of the class as a proxy.
The intent is to show how a debugger, serializer, or other meta-programming tool might access information that is barred by normal access methods to the object but can nevertheless be accessed from within the language by some provided escape hatch or reflection mechanism.
The intent is specifically not to demonstrate heroic measures such as peeking and poking raw memory.

Note that cheating on your type system is almost universally regarded
as unidiomatic at best, and poor programming practice at worst.
Nonetheless, if your language intentionally maintains a double-standard for OO privacy, here's where you can show it off.
",Python,"import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.jvm.isAccessible
 
class ToBeBroken:
    def __init__(self):
        self.secret = 42
 
def main(args):
    tbb = ToBeBroken()
    props = ToBeBroken.__class__.declaredMemberProperties
    for prop in props:
        prop.isAccessible = True  # make private properties accessible
        print(f""{prop.name} -> {prop.get(tbb)}"")
 
if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort,Sorting algorithms/Counting sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Counting sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Counting sort.   This is a way of sorting integers when the minimum and maximum value are known.



Pseudocode

function countingSort(array, min, max):
    count: array of (max - min + 1) elements
    initialize count with 0
    for each number in array do
        count[number - min] := count[number - min] + 1
    done
    z := 0
    for i from min to max do
        while ( count[i - min] > 0 ) do
            array[z] := i
            z := z+1
            count[i - min] := count[i - min] - 1
        done
    done

The min and max can be computed apart, or be known a priori.


Note:   we know that, given an array of integers,   its maximum and minimum values can be always found;   but if we imagine the worst case for an array that can hold up to 32 bit integers,   we see that in order to hold the counts,   an array of up to 232 elements may be needed.   I.E.:   we need to hold a count value up to 232-1,   which is a little over 4.2 Gbytes.   So the counting sort is more practical when the range is (very) limited,   and minimum and maximum values are known   a priori.     (However, as a counterexample,   the use of   sparse arrays   minimizes the impact of the memory usage,   as well as removing the need of having to know the minimum and maximum values   a priori.)



",Python,"# version 1.1.0
 
def countingSort(array):
    if not array: return 
    min = min(array)
    max = max(array)
    count = [0] * (max - min + 1)  # all elements zero by default
    for number in array: count[number - min] += 1
    z = 0
    for i in range(min, max + 1): 
        while count[i - min] > 0:
            array[z] = i
            z += 1
            count[i - min] -= 1
 
if __name__ == '__main__':
    array = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1]
    print(""Original : {}"".format(array))
    countingSort(array)
    print(""Sorted   : {}"".format(array))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Last_Friday_of_each_month,Last Friday of each month,"Task

Write a program or a script that returns the date of the last Fridays of each month of a given year.

The year may be given through any simple input method in your language (command line, std in, etc).



Example of an expected output:

./last_fridays 2012
2012-01-27
2012-02-24
2012-03-30
2012-04-27
2012-05-25
2012-06-29
2012-07-27
2012-08-31
2012-09-28
2012-10-26
2012-11-30
2012-12-28



Related tasks
 Five weekends
 Day of the week
 Find the last Sunday of each month

",Python,"import datetime
import sys
 
def last_fridays_of_year(year):
    for month in range(1, 13):
        date = datetime.date(year, month, 1) + datetime.timedelta(days=31)
        while date.weekday()!= 4:
            date -= datetime.timedelta(days=1)
        yield date
 
if __name__ == '__main__':
    year = int(sys.argv[1]) if len(sys.argv) > 1 else datetime.date.today().year
    for date in last_fridays_of_year(year):
        print(date)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/File_input/output,File input/output,"File input/output is part of Short Circuit's Console Program Basics selection.
Task

Create a file called   ""output.txt"",   and place in it the contents of the file   ""input.txt"",   via an intermediate variable.

In other words, your program will demonstrate:

   how to read from a file into a variable
   how to write a variable's contents into a file


Oneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.



",Python,"import shutil
shutil.copyfile('input.txt', 'output.txt')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Main_step_of_GOST_28147-89,Main step of GOST 28147-89,"GOST 28147-89 is a standard symmetric encryption based on a Feistel network.



The structure of the algorithm consists of three levels:

   encryption modes - simple replacement, application range, imposing a range of feedback and authentication code generation;
   cycles - 32-З, 32-Р and 16-З, is a repetition of the main step;
   main step, a function that takes a 64-bit block of text and one of the eight 32-bit encryption key elements, and uses the replacement table (8x16 matrix of 4-bit values), and returns encrypted block.


Task

Implement the main step of this encryption algorithm.



",Python,"k8 = [	14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] 
k7 = [	15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]
k6 = [	10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]
k5 = [	 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]
k4 = [	 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]
k3 = [	12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]
k2 = [	 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]
k1 = [	13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]
 
k87 = [0] * 256
k65 = [0] * 256
k43 = [0] * 256
k21 = [0] * 256
 
def kboxinit():
	for i in range(256):
		k87[i] = k8[i >> 4] << 4 | k7[i & 15]
		k65[i] = k6[i >> 4] << 4 | k5[i & 15]
		k43[i] = k4[i >> 4] << 4 | k3[i & 15]
		k21[i] = k2[i >> 4] << 4 | k1[i & 15]
 
def f(x):
	x = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |
	      k43[x>> 8 & 255] <<  8 | k21[x & 255] )
	return x<<11 | x>>(32-11)",Human_written,Python_from_C
http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",Python,"alphabet = [""ESTONIA  R"", ""BCDFGHJKLM"", ""PQUVWXYZ./""]
prefixes = [0, alphabet[0].index("" ""), alphabet[0].rindex("" "")]
 
def straddle(message):
    out = """"
    message = message.upper()
    message = message.replace(r""([0-9])"", r""/\1"")
    for i in range(len(message)):
        chr = message[i]
        if chr == "" "":
            continue
        for j in range(3):
            k = alphabet[j].index(chr)
            if k < 0:
                continue
            out += str(prefixes[j]) + str(k)
        if chr == ""/"":
            out += message[i + 1]
    return out
 
def unstraddle(message):
    out = """"
    n = 0
    o = 0
    for i in range(len(message)):
        n = message[i] * 1
        if n == prefixes[1]:
            o = alphabet[1][message[i + 1]]
        elif n == prefixes[2]:
            o = alphabet[2][message[i + 1]]
        else:
            o = alphabet[0][n]
        if o == ""/"":
            out += message[i + 1]
        else:
            out += o
    return out
 
str = ""One night-it was on the twentieth of March, 1888-I was returning.""
print(str)
print(straddle(str))
print(unstraddle(straddle(str)))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Solve_a_Hidato_puzzle,Solve a Hidato puzzle,"The task is to write a program which solves Hidato (aka Hidoku) puzzles.

The rules are:

 You are given a grid with some numbers placed in it. The other squares in the grid will be blank.
 The grid is not necessarily rectangular.
 The grid may have holes in it.
 The grid is always connected.
 The number “1” is always present, as is another number that is equal to the number of squares in the grid. Other numbers are present so as to force the solution to be unique.
 It may be assumed that the difference between numbers present on the grid is not greater than lucky 13.
 The aim is to place a natural number in each blank square so that in the sequence of numbered squares from “1” upwards, each square is in the wp:Moore neighborhood of the squares immediately before and after it in the sequence (except for the first and last squares, of course, which only have one-sided constraints).
 Thus, if the grid was overlaid on a chessboard, a king would be able to make legal moves along the path from first to last square in numerical order.
 A square may only contain one number.
 In a proper Hidato puzzle, the solution is unique.

For example the following problem


has the following solution, with path marked on it:




Related tasks

 A* search algorithm
 N-queens problem
 Solve a Holy Knight's tour
 Solve a Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle;

",Python,"import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
 
public class Hidato {
 
    private static int[][] board;
    private static int[] given, start;
 
    public static void main(String[] args) {
        String[] input = {""_ 33 35 _ _..."",
            ""_ _ 24 22 _..."",
            ""_ _ _ 21 _ _.."",
            ""_ 26 _ 13 40 11.."",
            ""27 _ _ _ 9 _ 1."",
            "".. _ _ 18 _ _."",
            "".... _ 7 _ _"",
            ""...... 5 _""};
 
        setup(input);
        printBoard();
        System.out.println(""\nFound:"");
        solve(start[0], start[1], 1, 0);
        printBoard();
    }
 
    private static void setup(String[] input) {
        /* This task is not about input validation, so
           we're going to trust the input to be valid */
 
        String[][] puzzle = new String[input.length][];
        for (int i = 0; i < input.length; i++)
            puzzle[i] = input[i].split("" "");
 
        int nCols = puzzle[0].length;
        int nRows = puzzle.length;
 
        List<Integer> list = new ArrayList<>(nRows * nCols);
 
        board = new int[nRows + 2][nCols + 2];
        for (int[] row : board)
            for (int c = 0; c < nCols + 2; c++)
                row[c] = -1;
 
        for (int r = 0; r < nRows; r++) {
            String[] row = puzzle[r];
            for (int c = 0; c < nCols; c++) {
                String cell = row[c];
                switch (cell) {
                    case ""_"":
                        board[r + 1][c + 1] = 0;
                        break;
                    case ""."":
                        break;
                    default:
                        int val = Integer.parseInt(cell);
                        board[r + 1][c + 1] = val;
                        list.add(val);
                        if (val == 1)
                            start = new int[]{r + 1, c + 1};
                }
            }
        }
        Collections.sort(list);
        given = new int[list.size()];
        for (int i = 0; i < given.length; i++)
            given[i] = list.get(i);
    }
 
    private static boolean solve(int r, int c, int n, int next) {
        if (n > given[given.length - 1])
            return true;
 
        if (board[r][c]!= 0 && board[r][c]!= n)
            return false;
 
        if (board[r][c] == 0 && given[next] == n)
            return false;
 
        int back = board[r][c];
        if (back == n)
            next++;
 
        board[r][c] = n;
        for (int i = -1; i < 2; i++)
            for (int j = -1; j < 2; j++)
                if (solve(r + i, c + j, n + 1, next))
                    return true;
 
        board[r][c] = back;
        return false;
    }
 
    private static void printBoard() {
        for (int[] row : board) {
            for (int c : row) {
                if (c == -1)
                    System.out.print("". "");
                else
                    System.out.printf(c > 0? ""%2d "" : ""__ "", c);
            }
            System.out.println();
        }
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Almost_prime,Almost prime,"A   k-Almost-prime   is a natural number   



n


{\displaystyle n}

   that is the product of   



k


{\displaystyle k}

   (possibly identical) primes.



Example

1-almost-primes,   where   



k
=
1


{\displaystyle k=1}

,   are the prime numbers themselves.

2-almost-primes,   where   



k
=
2


{\displaystyle k=2}

,   are the   semiprimes.



Task

Write a function/method/subroutine/... that generates k-almost primes and use it to create a table here of the first ten members of k-Almost primes for   



1
<=
K
<=
5


{\displaystyle 1<=K<=5}

.



Related tasks

   Semiprime
   Category:Prime Numbers

",Python,"from prime_decomposition import decompose
from itertools import islice, count
try: 
    from functools import reduce
except: 
    pass
 
 
def almostprime(n, k=2):
    d = decompose(n)
    try:
        terms = [next(d) for i in range(k)]
        return reduce(int.__mul__, terms, 1) == n
    except:
        return False
 
if __name__ == '__main__':
    for k in range(1,6):
        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII,Write language name in 3D ASCII,"Task

Write/display a language's name in 3D ASCII.



(We can leave the definition of ""3D ASCII"" fuzzy,
so long as the result is interesting or amusing,
not a cheap hack to satisfy the task.)



Related tasks

 draw a sphere
 draw a cuboid
 draw a rotating cube
 draw a Deathstar

",Python,"text = """"""
####        #
#   #       #
#   #       #
####  #  #  ###  #   #
# #   #  #  #  #  # #
#  #  #  #  #  #   #
#   #  ###  ###   #
                 #
                #
""""""
 
def banner3D_1(text, shift=-1):
    txt = [line.replace('#','__/').replace(' ','   ') for line in text.splitlines()]
    offset = [''* abs(shift) * i for i in range(len(txt))]
    if shift < 0:
        offset.reverse()
    for i in range(len(txt)):
        print(offset[i] + txt[i])
 
banner3D_1(text)
 
print()
# Other display:
def banner3D_2(text, shift=-2):
    txt = [line.rstrip() +'' for line in text.splitlines()]
    offset = [''* abs(shift) * i for i in range(len(txt))]
    if shift < 0:
        offset.reverse()
    for i in range(len(txt)):
        line2 = offset[i] + txt[i].replace(' ','   ').replace('#','///').replace('/ ','/\\')
        print(line2)
        print(line2.replace('/','\\').replace('\\','/'))
 
banner3D_2(text)
 
print()
# Another display:
def banner3D_3(text):
    txt = [line.rstrip() for line in text.splitlines()]
    offset = list(range(len(txt)))[::-1]
    area = {}
    box = [['/','/','/','\\'],['\\','\\','\\','/']]
    for i in range(len(txt)):
        line = txt[i]
        for j in range(len(line)):
            c = line[j]
            if c =='':
                continue
            x = offset[i] + 2*j
            for k in range(4):
                area[(x+k,i)] = box[0][k]
            for k in range(4):
                area[(x+k,i+1)] = box[1][k]
    xmin, xmax = min(area.keys(), key=lambda x: x[0])[0], max(area.keys(), key=lambda x: x[0])[0]
    ymin, ymax = min(area.keys(), key=lambda x: x[1])[1], max(area.keys(), key=lambda x: x[1])[1]
    for y in range(ymin, ymax+1):
        for x in range(xmin, xmax+1):
            print(area.get((x,y),''), end='')
        print()
 
banner3D_3(""""""
####         #
#   #        #
#   #        #
#   #        #
####   #  #  ####  #     #
# #    #  #  #   #  #   #
#  #   #  #  #   #   # #
#   #  #  #  #   #    #
#    #  ###  ####    #
                    #
                   #
"""""")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Guess_the_number,Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",Python,"import random
import sys
 
def main():
    n = 0
    g = 0
    c = 0
 
    random.seed()
    n = 1 + (random.randint(0, 10))
 
    print(""I'm thinking of a number between 1 and 10."")
    print(""Try to guess it:"")
 
    while True:
        g = int(input())
 
        if g == n:
            print(""Correct!"")
            return 0
        print(""That's not my number. Try another guess:"")
 
if __name__ == ""__main__"":
    sys.exit(main())",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area,Shoelace formula for polygonal area,"Given the n + 1 vertices x[0], y[0] .. x[N], y[N] of a simple polygon described in a clockwise direction, then the polygon's area can be calculated by:

abs( (sum(x[0]*y[1] + ... x[n-1]*y[n]) + x[N]*y[0]) -
     (sum(x[1]*y[0] + ... x[n]*y[n-1]) + x[0]*y[N])
   ) / 2
(Where abs returns the absolute value)

Task

Write a function/method/routine to use the the Shoelace formula to calculate the area of the polygon described by the ordered points:

     (3,4), (5,11), (12,8), (9,5), and (5,6) 



Show the answer here, on this page.



",Python,">>> def area_by_shoelace(x, y):
    ""Assumes x,y points go around the polygon in one direction""
    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))
               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2
 
>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]
>>> x, y = zip(*points)
>>> area_by_shoelace(x, y)
30.0
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Random_number_generator_(device),Random number generator (device),"Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:

show how to obtain a random 32-bit number from that mechanism.

Related task
 Random_number_generator_(included)

",Python,"# version 1.1.2
import random
 
rng = random.SystemRandom()
rn1 = rng.randint(0, 2**31-1)
rn2 = rng.randint(0, 2**31-1)
newSeed = rn1 * rn2
rng.seed(newSeed)
print(rng.randint(0, 2**31-1))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Empty_program,Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",Python,"1
QUIT",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",Python,">>> import time
>>> time.asctime(time.gmtime(0))
'Thu Jan  1 00:00:00 1970'
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Sudoku,Sudoku,"Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format.

references

 Algorithmics of Sudoku   may help implement this.
 Python Sudoku Solver Computerphile video.

",Python,"def initiate():
    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])
    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])
    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])
    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])
    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])
    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])
    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])
    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])
    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])
    for i in range(0, 81, 9):
        row.append(range(i, i+9))
    for i in range(9):
        column.append(range(i, 80+i, 9))
 
def valid(n, pos):
    current_row = pos/9
    current_col = pos%9
    current_box = (current_row/3)*3 + (current_col/3)
    for i in row[current_row]:
        if (grid[i] == n):
            return False
    for i in column[current_col]:
        if (grid[i] == n):
            return False
    for i in box[current_box]:
        if (grid[i] == n):
            return False
    return True
 
def solve():
    i = 0
    proceed = 1
    while(i < 81):
        if given[i]:
            if proceed:
                    i += 1
            else:
                i -= 1
        else:
            n = grid[i]
            prev = grid[i]
            while(n < 9):
              if (n < 9):
                  n += 1
              if valid(n, i):
                  grid[i] = n
                  proceed = 1
                  break
            if (grid[i] == prev):
               grid[i] = 0
               proceed = 0
            if proceed:
               i += 1
            else:
               i -=1
 
def inputs():
    nextt = 'T'
    number = 0
    pos = 0
    while(not(nextt == 'N' or nextt == 'n')):
        print ""Enter the position:"",
        pos = int(raw_input())
        given[pos - 1] = True
        print ""Enter the numerical:"",
        number = int(raw_input())
        grid[pos - 1] = number
        print ""Do you want to enter another given?(Y, for yes: N, for no)""
        nextt = raw_input()
 
 
grid = [0]*81
given = [False]*81
box = []
row = []
column = []
initiate()
inputs()
solve()
for i in range(9):
    print grid[i*9:i*9+9]
raw_input()",Human_written,Python_from_C
http://rosettacode.org/wiki/Terminal_control/Clear_the_screen,Terminal control/Clear the screen,"Task

Clear the terminal window.



",Python,"import os
os.system('cls' if os.name == 'nt' else 'clear')",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Price_fraction,Price fraction,"A friend of mine runs a pharmacy.   He has a specialized function in his Dispensary application which receives a decimal value of currency and replaces it to a standard value.   This value is regulated by a government department.



Task

Given a floating point value between   0.00   and   1.00,   rescale according to the following table:

>=  0.00  <  0.06  :=  0.10
>=  0.06  <  0.11  :=  0.18
>=  0.11  <  0.16  :=  0.26
>=  0.16  <  0.21  :=  0.32
>=  0.21  <  0.26  :=  0.38
>=  0.26  <  0.31  :=  0.44
>=  0.31  <  0.36  :=  0.50
>=  0.36  <  0.41  :=  0.54
>=  0.41  <  0.46  :=  0.58
>=  0.46  <  0.51  :=  0.62
>=  0.51  <  0.56  :=  0.66
>=  0.56  <  0.61  :=  0.70
>=  0.61  <  0.66  :=  0.74
>=  0.66  <  0.71  :=  0.78
>=  0.71  <  0.76  :=  0.82
>=  0.76  <  0.81  :=  0.86
>=  0.81  <  0.86  :=  0.90
>=  0.86  <  0.91  :=  0.94
>=  0.91  <  0.96  :=  0.98
>=  0.96  <  1.01  :=  1.00


",Python,"import math

def main():
    for x in range(0, 10):
        print(""In: {0:0.00}, Out: {1:0.00}"".format(((float)(x)) / 10, SpecialRound(((float)(x)) / 10)))

    print()

    for x in range(0, 10):
        print(""In: {0:0.00}, Out: {1:0.00}"".format(((float)(x)) / 10 + 0.05, SpecialRound(((float)(x)) / 10 + 0.05)))

    print()
    print(""In: {0:0.00}, Out: {1:0.00}"".format(1.01, SpecialRound(1.01)))

def SpecialRound(inValue):
    if inValue > 1:
        return 1

    Splitters = [0.00, 0.06, 0.11, 0.16, 0.21, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.56, 0.61, 0.66, 0.71, 0.76, 0.81, 0.86, 0.91, 0.96]
    replacements = [0.10, 0.18, 0.26, 0.32, 0.38, 0.44, 0.50, 0.54, 0.58, 0.62, 0.66, 0.70, 0.74, 0.78, 0.82, 0.86, 0.90, 0.94, 0.98, 1.00]

    for x in range(0, len(Splitters) - 1):
        if inValue >= Splitters[x] and inValue < Splitters[x + 1]:
            return replacements[x]

    return inValue

if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Idiomatically_determine_all_the_lowercase_and_uppercase_letters,Idiomatically determine all the lowercase and uppercase letters,"
Idiomatically determine all the lowercase and uppercase letters   (of the Latin [English] alphabet)   being used currently by a computer programming language.
The method should find the letters regardless of the hardware architecture that is being used (ASCII, EBCDIC, or other).



Task requirements
Display the set of all:

   lowercase letters 
   uppercase letters

that can be used (allowed) by the computer program,


where   letter   is a member of the Latin (English) alphabet:     a ──► z     and     A ──► Z.



You may want to mention what hardware architecture is being used, and if applicable, the operating system.



See also
 Idiomatically determine all the characters that can be used for symbols.

",Python,"def main():
    print(
        ""Lowercase letters: {}"".format(
            """".join(chr(c) for c in range(ord(""a""), ord(""z"") + 1))
        )
    )
    print(
        ""Uppercase letters: {}"".format(
            """".join(chr(c) for c in range(ord(""A""), ord(""Z"") + 1))
        )
    )",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sequence:_smallest_number_greater_than_previous_term_with_exactly_n_divisors,Sequence: smallest number greater than previous term with exactly n divisors,"Calculate the sequence where each term an is the smallest natural number greater than the previous term, that has exactly n divisors.



Task
Show here, on this page, at least the first 15 terms of the sequence.



See also
 OEIS:A069654


Related tasks
 Sequence: smallest number with exactly n divisors
 Sequence: nth number with exactly n divisors‎‎

",Python,"import math
 
MAX = 15
 
def count_divisors(n):
    count = 0
    for i in range(1, int(math.sqrt(n)) + 1):
        if n % i == 0:
            if i == n / i:
                count += 1
            else:
                count += 2
    return count
 
print(""The first"", MAX, ""terms of the sequence are:"")
for i in range(1, MAX + 1):
    if i == count_divisors(i):
        print(i, end="" "")
print()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Unprimeable_numbers,Unprimeable numbers,"Definitions

As used here, all unprimeable numbers   (positive integers)   are always expressed in base ten.



───── Definition from OEIS ─────:

Unprimeable numbers are composite numbers that always remain composite when a single decimal digit of the number is changed.



───── Definition from Wiktionary   (referenced from Adam Spencer's book) ─────:

(arithmetic)   that cannot be turned into a prime number by changing just one of its digits to any other
digit.   (sic)



Unprimeable numbers are also spelled:   unprimable.

All one─ and two─digit numbers can be turned into primes by changing a single decimal digit.



Examples

190   isn't unprimeable,   because by changing the zero digit into a three yields   193,   which is a prime.



The number   200   is unprimeable,   since none of the numbers   201, 202, 203, ··· 209   are
prime, and all the other numbers obtained by changing a single digit to
produce   100, 300, 400, ··· 900,   or   210, 220, 230, ··· 290   which are all even.



It is valid to change   189   into   089   by changing the   1   (one)   into
a   0   (zero),   which then the leading zero can be removed,   and then treated as if
the   ""new""   number is   89.



Task

   show the first   35   unprimeable numbers   (horizontally, on one line, preferably with a title)
   show the   600th   unprimeable number
   (optional) show the lowest unprimeable number ending in a specific decimal digit   (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
   (optional) use commas in the numbers where appropriate


Show all output here, on this page.



Also see

   the     OEIS     entry:   A118118 (unprimeable)
   with some useful counts to compare unprimeable number
   the Wiktionary entry (reference from below):   (arithmetic definition) unprimeable
   from the Adam Spencer book   (page 200):   Adam Spencer's World of Numbers       (Xoum Publishing)

",Python,"from itertools import count, islice
 
def primes(_cache=[2, 3]):
    yield from _cache
    for n in count(_cache[-1]+2, 2):
        if isprime(n):
            _cache.append(n)
            yield n
 
def isprime(n, _seen={0: False, 1: False}):
    def _isprime(n):
        for p in primes():
            if p*p > n:
                return True
            if n%p == 0:
                return False
 
    if n not in _seen:
        _seen[n] = _isprime(n)
    return _seen[n]
 
def unprime():
    for a in count(1):
        d = 1
        while d <= a:
            base = (a//(d*10))*(d*10) + (a%d) # remove current digit
            if any(isprime(y) for y in range(base, base + d*10, d)):
                break
            d *= 10
        else:
            yield a
 
 
print('First 35:')
print(' '.join(str(i) for i in islice(unprime(), 35)))
 
print('\nThe 600-th:')
print(list(islice(unprime(), 599, 600))[0])
print()
 
first, need = [False]*10, 10
for p in unprime():
    i = p%10
    if first[i]: continue
 
    first[i] = p
    need -= 1
    if not need:
        break
 
for i,v in enumerate(first):
    print(f'{i} ending: {v}')",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Non-decimal_radices/Output,Non-decimal radices/Output,"Programming languages often have built-in routines to convert a non-negative integer for printing in different number bases. Such common number bases might include binary, Octal and Hexadecimal.



Task

Print a small range of integers in some different bases, as supported by standard routines of your programming language.



Note

This is distinct from Number base conversion as a user-defined conversion function is not asked for.)

The reverse operation is Common number base parsing.



",Python,"for n in range(34):
  print "" %3o %2d %2X"" % (n, n, n)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Fibonacci_word,Fibonacci word,"The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:

    Define   F_Word1   as   1
    Define   F_Word2   as   0
    Form     F_Word3   as   F_Word2     concatenated with   F_Word1    i.e.:   01
    Form     F_Wordn   as   F_Wordn-1   concatenated with   F_wordn-2



Task

Perform the above steps for     n = 37.

You may display the first few but not the larger values of   n.

{Doing so will get the task's author into trouble with them what be (again!).} 

Instead, create a table for   F_Words   1   to   37   which shows:

   The number of characters in the word
   The word's Entropy


Related tasks
 
   Fibonacci word/fractal
   Entropy
   Entropy/Narcissist

",Python,">>> import math
>>> from collections import Counter
>>> 
>>> def entropy(s):
...     p, lns = Counter(s), float(len(s))
...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
... 
>>> 
>>> def fibword(nmax=37):
...     fwords = ['1', '0']
...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))
...     def pr(n, fwords):
...         while len(fwords) < n:
...             fwords += [''.join(fwords[-2:][::-1])]
...         v = fwords[n-1]
...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))
...     for n in range(1, nmax+1): pr(n, fwords)
... 
>>> fibword()
N       Length Entropy    Fibword
  1          1         -0 1
  2          1         -0 0
  3          2          1 01
  4          3  0.9182958 010
  5          5  0.9709506 01001
  6          8   0.954434 01001010
  7         13  0.9612366 0100101001001
  8         21  0.9587119 <too long>
  9         34  0.9596869 <too long>
 10         55   0.959316 <too long>
 11         89  0.9594579 <too long>
 12        144  0.9594038 <too long>
 13        233  0.9594244 <too long>
 14        377  0.9594165 <too long>
 15        610  0.9594196 <too long>
 16        987  0.9594184 <too long>
 17       1597  0.9594188 <too long>
 18       2584  0.9594187 <too long>
 19       4181  0.9594187 <too long>
 20       6765  0.9594187 <too long>
 21      10946  0.9594187 <too long>
 22      17711  0.9594187 <too long>
 23      28657  0.9594187 <too long>
 24      46368  0.9594187 <too long>
 25      75025  0.9594187 <too long>
 26     121393  0.9594187 <too long>
 27     196418  0.9594187 <too long>
 28     317811  0.9594187 <too long>
 29     514229  0.9594187 <too long>
 30     832040  0.9594187 <too long>
 31    1346269  0.9594187 <too long>
 32    2178309  0.9594187 <too long>
 33    3524578  0.9594187 <too long>
 34    5702887  0.9594187 <too long>
 35    9227465  0.9594187 <too long>
 36   14930352  0.9594187 <too long>
 37   24157817  0.9594187 <too long>
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Hello_world/Newline_omission,Hello world/Newline omission,"Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output.



Task

Display the string   Goodbye, World!   without a trailing newline.



Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Standard error
   Hello world/Text

",Python,"print(""Goodbye, World!"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/URL_encoding,URL encoding,"Task

Provide a function or mechanism to convert a provided string into URL encoding representation.

In URL encoding, special characters, control characters and extended characters
are converted into a percent symbol followed by a two digit hexadecimal code,
So a space character encodes into %20 within the string.

For the purposes of this task, every character except 0-9, A-Z and a-z requires conversion, so the following characters all require conversion by default:

 ASCII control codes (Character ranges 00-1F hex (0-31 decimal) and 7F (127 decimal).
 ASCII symbols (Character ranges 32-47 decimal (20-2F hex))
 ASCII symbols (Character ranges 58-64 decimal (3A-40 hex))
 ASCII symbols (Character ranges 91-96 decimal (5B-60 hex))
 ASCII symbols (Character ranges 123-126 decimal (7B-7E hex))
 Extended characters with character codes of 128 decimal (80 hex) and above.


Example

The string ""http://foo bar/"" would be encoded as ""http%3A%2F%2Ffoo%20bar%2F"".



Variations

 Lowercase escapes are legal, as in ""http%3a%2f%2ffoo%20bar%2f"".
 Some standards give different rules: RFC 3986, Uniform Resource Identifier (URI): Generic Syntax, section 2.3, says that ""-._~"" should not be encoded. HTML 5, section 4.10.22.5 URL-encoded form data, says to preserve ""-._*"", and to encode space "" "" to ""+"". The options below provide for utilization of an exception string, enabling preservation (non encoding) of particular characters to meet specific standards.


Options

It is permissible to use an exception string (containing a set of symbols
that do not need to be converted).
However, this is an optional feature and is not a requirement of this task.



Related tasks
 
   URL decoding
   URL parser

",Python,"import urllib
s = 'http://foo/bar/'
s = urllib.quote(s)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/EKG_sequence_convergence,EKG sequence convergence,"The sequence is from the natural numbers and is defined by:

 a(1) = 1; 
 a(2) = Start = 2;
 for n > 2, a(n) shares at least one prime factor with a(n-1) and is the smallest such natural number not already used.

The sequence is called the EKG sequence (after its visual similarity to an electrocardiogram when graphed).

Variants of the sequence can be generated starting 1, N where N is any natural number larger than one. For the purposes of this task let us call:

 The sequence described above , starting 1, 2, ... the EKG(2) sequence;
 the sequence starting 1, 3, ... the EKG(3) sequence; 
 ... the sequence starting 1, N, ... the EKG(N) sequence.


Convergence
If an algorithm that keeps track of the minimum amount of numbers and their corresponding prime factors used to generate the next term is used, then this may be known as the generators essential state. Two EKG generators with differing starts can converge to produce the same sequence after initial differences.

EKG(N1) and EKG(N2) are said to to have converged at and after generation a(c) if state_of(EKG(N1).a(c)) == state_of(EKG(N2).a(c)).



Task

 Calculate and show here the first 10 members of EKG(2).
 Calculate and show here the first 10 members of EKG(5).
 Calculate and show here the first 10 members of EKG(7).
 Calculate and show here the first 10 members of EKG(9).
 Calculate and show here the first 10 members of EKG(10).
 Calculate and show here at which term EKG(5) and EKG(7) converge   (stretch goal).
Related Tasks

 Greatest common divisor
 Sieve of Eratosthenes


Reference

 The EKG Sequence and the Tree of Numbers. (Video).

",Python,"from functools import reduce
from operator import mul
from math import gcd
from itertools import count
 
def ekg(start):
    ekg = [1, start]
    for n in count(2):
        for i in count(2):
            if i not in ekg and gcd(ekg[-1], i) > 1:
                ekg.append(i)
                break
        yield ekg
 
def main():
    for start in (2, 5, 7, 9, 10):
        print(f'EKG({start}): {list(next(ekg(start)))[:30]}')
 
    ekg5 = ekg(5)
    ekg7 = ekg(7)
    for i in count(2):
        if next(ekg5)[i] == next(ekg7)[i] and all(next(ekg5)[:i] == next(ekg7)[:i]):
            print(f'\nEKG(5) and EKG(7) converge at term {i+1}')
            return
    print(f'\nEKG5(5) and EKG(7) do not converge within {limit} terms')
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Conditional_structures,Conditional structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Task

List the conditional structures offered by a programming language. See Wikipedia: conditionals for descriptions.

Common conditional structures include if-then-else and switch.

Less common are arithmetic if, ternary operator and Hash-based conditionals.

Arithmetic if allows tight control over computed gotos, which optimizers have a hard time to figure out.


",Python,"if x == 0:
    foo()
elif x == 1:
    bar()
elif x == 2:
    baz()
else:
    boz()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters,Determine if a string has all the same characters,"Task

Given a character string   (which may be empty, or have a length of zero characters):

   create a function/procedure/routine to:
   determine if all the characters in the string are the same
   indicate if or which character is different from the previous character
   display each string and its length   (as the strings are being examined)
   a zero─length (empty) string shall be considered as all the same character(s)
   process the strings from left─to─right
   if       all the same character,   display a message saying such
   if not all the same character,   then:
   display a message saying such
   display what character is different
   only the 1st different character need be displayed
   display where the different character is in the string
   the above messages can be part of a single message
   display the hexadecimal value of the different character


Use (at least) these seven test values   (strings):

   a string of length   0   (an empty string)
   a string of length   3   which contains three blanks
   a string of length   1   which contains:   2
   a string of length   3   which contains:   333
   a string of length   3   which contains:   .55
   a string of length   6   which contains:   tttTTT
   a string of length   9   with a blank in the middle:   4444   444k


Show all output here on this page.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"'''Determine if a string has all the same characters'''
 
from itertools import groupby
 
 
# firstDifferingCharLR :: String -> Either String Dict
def firstDifferingCharLR(s):
    '''Either a message reporting that no character changes were
       seen, or a dictionary with details of the  first character
       (if any) that differs from that at the head of the string.
    '''
    def details(xs):
        c = xs[1][0]
        return {
            'char': repr(c),
            'hex': hex(ord(c)),
            'index': s.index(c),
            'total': len(s)
        }
    xs = list(groupby(s))
    return Right(details(xs)) if 1 < len(xs) else (
        Left('Total length ' + str(len(s)) + ' - No character changes.')
    )
 
 
# TEST ----------------------------------------------------
# main :: IO ()
def main():
    '''Test of 7 strings'''
 
    print(fTable('First, if any, points of difference:\n')(repr)(
        either(identity)(
            lambda dct: dct['char'] + ' (' + dct['hex'] +
            ') at character ' + str(1 + dct['index']) +
            ' of ' + str(dct['total']) + '.'
        )
    )(firstDifferingCharLR)([
        '',
        '   ',
        '2',
        '333',
        '.55',
        'tttTTT',
        '4444 444'
    ]))
 
 
# GENERIC -------------------------------------------------
 
# either :: (a -> c) -> (b -> c) -> Either a b -> c
def either(fl):
    '''The application of fl to e if e is a Left value,
       or the application of fr to e if e is a Right value.
    '''
    return lambda fr: lambda e: fl(e['Left']) if (
        None is e['Right']
    ) else fr(e['Right'])
 
 
# identity :: a -> a
def identity(x):
    '''The identity function.'''
    return x
 
 
# fTable :: String -> (a -> String) ->
# (b -> String) -> (a -> b) -> [a] -> String
def fTable(s):
    '''Heading -> x display function -> fx display function ->
       f -> xs -> tabular string.
    '''
    def go(xShow, fxShow, f, xs):
        ys = [xShow(x) for x in xs]
        w = max(map(len, ys))
        return s + '\n' + '\n'.join(map(
            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),
            xs, ys
        ))
    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(
        xShow, fxShow, f, xs
    )
 
 
# Left :: a -> Either a b
def Left(x):
    '''Constructor for an empty Either (option type) value
       with an associated string.
    '''
    return {'type': 'Either', 'Right': None, 'Left': x}
 
 
# Right :: b -> Either a b
def Right(x):
    '''Constructor for a populated Either (option type) value'''
    return {'type': 'Either', 'Left': None, 'Right': x}
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_C
http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",Python,"class Arc:
def __init__(self,posX,posY,radius,startAngle,endAngle,color):
self.posX=posX
self.posY=posY
self.radius=radius
self.startAngle=startAngle
self.endAngle=endAngle
self.color=color
#0,0 is the top left of the screen
YingYang=[
Arc(0.5,0.5,1,0.5*math.pi,1.5*math.pi,""white""),#Half white semi-circle
Arc(0.5,0.5,1,1.5*math.pi,0.5*math.pi,""black""),#Half black semi-circle
Arc(0.5,0.25,.5,0,2*math.pi,""black""),#black circle
Arc(0.5,0.75,.5,0,2*math.pi,""white""),#white circle
Arc(0.5,0.25,1/6,0,2*math.pi,""white""),#small white circle
Arc(0.5,0.75,1/6,0,2*math.pi,""black"")#small black circle
]
#Ying Yang is DONE!
#Now we'll have to draw it.
#We'll draw it in a matrix that way we can get results graphically or by text!
class Array2D:
def __init__(self,width,height):
self.height=height
self.width=width
self.array2d=[]
for i in range(self.height):
self.array2d.append([None]*self.width)
def resize(self,width,height):#This is expensive
#nheight and nwidth is the difference of the new and old height
nheight=height-self.height
nwidth=width-self.width
if nwidth>0:
for i in range(self.height):
if i<height:
self.array2d[i].extend([None]*nwidth)
elif nwidth<0:
for i in range(self.height):
if i<height:
del self.array2d[i][width:nwidth]
if nheight>0:
self.array2d.extend([[None]*self.width]*nheight)
elif nheight<0:
del self.array2d[height:nheight]
def loop(self,callback):
for i in range(self.height):
for i2 in range(self.width):
callback(self.array2d[i][i2],i,i2)
mat=Array2D(100,100)#this sounds fine;
YingYang[0];
#In construction.",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",Python,">>> from operator import mul
>>> def matrixMul(m1, m2):
  return map(
    lambda row:
      map(
        lambda *column:
          sum(map(mul, row, column)),
        *m2),
    m1)
 
>>> def identity(size):
	size = range(size)
	return [[(i==j)*1 for i in size] for j in size]
 
>>> def matrixExp(m, pow):
	assert pow>=0 and int(pow)==pow, ""Only non-negative, integer powers allowed""
	accumulator = identity(len(m))
	for i in range(pow):
		accumulator = matrixMul(accumulator, m)
	return accumulator
 
>>> def printtable(data):
	for row in data:
		print ' '.join('%-5s' % ('%s' % cell) for cell in row)
 
 
>>> m = [[3,2], [2,1]]
>>> for i in range(5):
	print '\n%i:' % i
	printtable( matrixExp(m, i) )
 
 
 
0:
1     0    
0     1    
 
1:
3     2    
2     1    
 
2:
13    8    
8     5    
 
3:
55    34   
34    21   
 
4:
233   144  
144   89   
>>> printtable( matrixExp(m, 10) )
1346269 832040
832040 514229
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Barnsley_fern,Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",Python,"import numpy as np
import matplotlib.pyplot as plt

def create_fern(w, h):
    x = 0
    y = 0
    for i in range(200000):
        r = np.random.random()
        if r <= 0.01:
            tmpx = 0
            tmpy = 0.16 * y
        elif r <= 0.08:
            tmpx = 0.2 * x - 0.26 * y
            tmpy = 0.23 * x + 0.22 * y + 1.6
        elif r <= 0.15:
            tmpx = -0.15 * x + 0.28 * y
            tmpy = 0.26 * x + 0.24 * y + 0.44
        else:
            tmpx = 0.85 * x + 0.04 * y
            tmpy = -0.04 * x + 0.85 * y + 1.6
        x = tmpx
        y = tmpy
        plt.plot(w / 2 + x * w / 11, h - y * h / 11, 'go', markersize=0.1)

plt.figure(figsize=(10, 10))
create_fern(640, 640)
plt.show()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Fork,Fork,"Task

Spawn a new process which can run simultaneously with, and independently of, the original parent process.



",Python,"import os
 
pid = os.fork()
if pid > 0:
 # parent code
else:
 # child code",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Empty_program,Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",Python,"1
QUIT",Human_written,Python_from_Go
http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",Python,"def longmult(x,y):
    result = [0]
    j = 0
    for m in reversed(y):
        c = 0
        i = j
        for d in reversed(x):
            v = result[i]
            if v == 0:
                result.append(0)
            c, v = divmod(v + c + d*m, 10)
            result[i] = v
            i += 1
        result[i] += c
        j += 1
    # calculate the answer from the result array of digits
    return sum(10**i * n for i, n in enumerate(reversed(result)))
 
n=2**64
print(""         %d * %d = %d"" % (n, n, n*n))
print(""longmult(%d, %d) = %d"" % (n, n, longmult(n,n)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Empty_program,Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",Python,"1
QUIT",Human_written,Python_from_C
http://rosettacode.org/wiki/Walk_a_directory/Recursively,Walk a directory/Recursively,"Task

Walk a given directory tree and print files matching a given pattern.


Note: This task is for recursive methods.   These tasks should read an entire directory tree, not a single directory.


Note: Please be careful when running any code examples found here.



Related task

   Walk a directory/Non-recursively   (read a single directory). 

",Python,"from pathlib import Path
 
for path in Path('.').rglob('*.*'):
    print(path)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Find_the_intersection_of_two_lines,Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",Python,"def line_intersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):
    """""" returns a (x, y) tuple or None if there is no intersection """"""
    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)
    if d:
        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d
        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d
    else:
        return
    if not(0 <= uA <= 1 and 0 <= uB <= 1):
        return
    x = Ax1 + uA * (Ax2 - Ax1)
    y = Ay1 + uA * (Ay2 - Ay1)
 
    return x, y
 
if __name__ == '__main__':
    (a, b), (c, d) = (4, 0), (6, 10)  # try (4, 0), (6, 4)
    (e, f), (g, h) = (0, 3), (10, 7)  # for non intersecting test
    pt = line_intersect(a, b, c, d, e, f, g, h)
    print(pt)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Palindrome_dates,Palindrome dates,"Today   (2020-02-02,   at the time of this writing)   happens to be a palindrome,   without the hyphens,   not only for those countries which express their dates in the   yyyy-mm-dd   format but,   unusually,   also for countries which use the   dd-mm-yyyy   format.



Task
Write a program which calculates and shows the next 15 palindromic dates for those countries which express their dates in the   yyyy-mm-dd   format.



",Python,"import datetime
import calendar
 
def is_palindrome(date):
    date_str = date.strftime(""%Y%m%d"")
    return date_str == date_str[::-1]
 
def main():
    date = datetime.date(2020, 2, 3)
    print(""First 15 palindrome dates after 2020-02-02 are:"")
    count = 0
    while count < 15:
        if is_palindrome(date):
            count += 1
            print(date.strftime(""%Y-%m-%d""))
        date += datetime.timedelta(days=1)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Ethiopian_multiplication,Ethiopian multiplication,"Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.


Method:

 Take two numbers to be multiplied and write them down at the top of two columns.
 In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
 In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
 Examine the table produced and discard any row where the value in the left column is even.
 Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.



Task

The task is to define three named functions/methods/procedures/subroutines:

 one to halve an integer,
 one to double an integer, and
 one to state if an integer is even.


Use these functions to create a function that does Ethiopian multiplication.



References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication

",Python,"# version 1.1.2
 
def halve(n):
    return n // 2
 
def double(n):
    return n * 2
 
def isEven(n):
    return n % 2 == 0
 
def ethiopianMultiply(x, y):
    xx = x
    yy = y
    sum = 0
    while xx >= 1:
        if not isEven(xx):
            sum += yy
        xx = halve(xx)
        yy = double(yy)
    return sum
 
if __name__ == ""__main__"":
    print(""17 x 34 = {}"".format(ethiopianMultiply(17, 34)))
    print(""99 x 99 = {}"".format(ethiopianMultiply(99, 99)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Polyspiral,Polyspiral,"A Polyspiral is a spiral made of multiple line segments, whereby each segment is larger (or smaller) than the previous one by a given amount. Each segment also changes direction at a given angle.



Task
Animate a series of polyspirals, by drawing a complete spiral then incrementing the angle, and (after clearing the background) drawing the next, and so on. Every spiral will be a frame of the animation. The animation may stop as it goes full circle or continue indefinitely. The given input values may be varied.

If animation is not practical in your programming environment, you may show a single frame instead.



Pseudo code
    set incr to 0.0

    // animation loop
    WHILE true 

        incr = (incr + 0.05) MOD 360
        x = width / 2
        y = height / 2
        length = 5
        angle = incr

        // spiral loop
        FOR 1 TO 150
            drawline
            change direction by angle
            length = length + 3
            angle = (angle + incr) MOD 360
        ENDFOR
    


",Python,"import math
import tkinter
 
class Form1(tkinter.Tk):
    def __init__(self):
        super().__init__()
        self.width = self.height = 640
        self.title(""Polyspiral"")
        self.geometry(f""{self.width}x{self.height}"")
        self.resizable(False, False)
        self.inc = 0
        self.after(40, self.update)
 
    def update(self):
        self.inc = (self.inc + 0.05) % 360
        self.draw_spiral(5, self.to_radians(self.inc))
        self.after(40, self.update)
 
    def draw_spiral(self, len, angle_increment):
        x1 = self.width / 2
        y1 = self.height / 2
        angle = angle_increment
 
        for i in range(150):
            x2 = x1 + math.cos(angle) * len
            y2 = y1 - math.sin(angle) * len
            self.create_line(x1, y1, x2, y2, fill=""blue"")
            x1 = x2
            y1 = y2
 
            len += 3
 
            angle = (angle + angle_increment) % (math.pi * 2)
 
    def to_radians(self, angle):
        return math.pi * angle / 180
 
if __name__ == ""__main__"":
    Form1().mainloop()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers,Sort a list of object identifiers,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Object identifiers (OID)


Task

Show how to sort a list of OIDs, in their natural sort order.

Details
 An OID consists of one or more non-negative integers in base 10, separated by dots. It starts and ends with a number.
 Their natural sort order is lexicographical with regard to the dot-separated fields, using numeric comparison between fields.
Test case


 Input (list of strings)

 Output (list of strings)



1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11150.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11150.3.4.0



1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11150.3.4.0
1.3.6.1.4.1.11150.3.4.0.1


Related tasks
 Natural sorting
 Sort using a custom comparator
",Python,"import re
from itertools import zip_longest
from functools import cmp_to_key
 
def splitOnChar(s, c):
    return re.split(c, s)
 
def myCompare(s1, s2):
    firstcopy = s1
    secondcopy = s2
    firstparts = splitOnChar(firstcopy, '.')
    secondparts = splitOnChar(secondcopy, '.')
    numbers1 = [int(x) for x in firstparts]
    numbers2 = [int(x) for x in secondparts]
    it1 = iter(numbers1)
    it2 = iter(numbers2)
    while next(it1, None) == next(it2, None):
        pass
    if next(it1, None) is None or next(it2, None) is None:
        return (s1 > s2) - (s1 < s2)
    return next(it1, None) - next(it2, None)
 
arrayOID = [""1.3.6.1.4.1.11.2.17.19.3.4.0.10"",
            ""1.3.6.1.4.1.11.2.17.5.2.0.79"",
            ""1.3.6.1.4.1.11.2.17.19.3.4.0.4"",
            ""1.3.6.1.4.1.11150.3.4.0.1"",
            ""1.3.6.1.4.1.11.2.17.19.3.4.0.1"",
            ""1.3.6.1.4.1.11150.3.4.0""]
 
arrayOID.sort(key=cmp_to_key(myCompare))
 
for s in arrayOID:
    print(s)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/N-smooth_numbers,N-smooth numbers,"n-smooth   numbers are positive integers which have no prime factors  >  n.

The   n   (when using it in the expression)   n-smooth   is always prime,

there are   no   9-smooth numbers.

1   (unity)   is always included in n-smooth numbers.




2-smooth   numbers are non-negative powers of two.

5-smooth   numbers are also called   Hamming numbers.

7-smooth   numbers are also called    humble   numbers.



A way to express   11-smooth   numbers is:

  11-smooth  =  2i × 3j × 5k × 7m × 11p

           where     i, j, k, m, p ≥ 0  



Task

   calculate and show the first   25   n-smooth numbers   for   n=2   ───►   n=29
   calculate and show   three numbers starting with   3,000   n-smooth numbers   for   n=3   ───►   n=29
   calculate and show twenty numbers starting with  30,000   n-smooth numbers   for   n=503   ───►   n=521   (optional)


All ranges   (for   n)   are to be inclusive, and only prime numbers are to be used.

The (optional) n-smooth numbers for the third range are:   503,   509,   and   521.

Show all n-smooth numbers for any particular   n   in a horizontal list.

Show all output here on this page.



Related tasks

   Hamming numbers
   humble numbers


References

   Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
   Wikipedia entry:   Smooth number
   OEIS entry:   A000079    2-smooth numbers or non-negative powers of two
   OEIS entry:   A003586    3-smooth numbers
   OEIS entry:   A051037    5-smooth numbers or Hamming numbers
   OEIS entry:   A002473    7-smooth numbers or humble numbers
   OEIS entry:   A051038   11-smooth numbers
   OEIS entry:   A080197   13-smooth numbers
   OEIS entry:   A080681   17-smooth numbers
   OEIS entry:   A080682   19-smooth numbers
   OEIS entry:   A080683   23-smooth numbers

",Python,"def prime(n):
    if n < 5:
        return n | 1 == 3
    if n % 2 == 0 or n % 3 == 0:
        return False
    for i in range(5, int(n**0.5) + 1, 6):
        if n % i == 0 or n % (i + 2) == 0:
            return False
    return True
 
def gen_primes(a, b):
    return [i for i in range(a, b + 1) if prime(i)]
 
def nsmooth(n, limit):
    if n < 2 or n > 521 or limit < 1:
        raise Exception(""n or limit"")
    if not prime(n):
        raise Exception(""must be a prime number: n"")
 
    primes = gen_primes(2, n)
    ns = [0] * limit
    ns[0] = 1
    nextp = primes[:primes.index(n) + 1]
 
    indices = [0] * len(nextp)
    for m in range(1, limit):
        ns[m] = min(nextp)
        for i in range(len(indices)):
            if ns[m] == nextp[i]:
                indices[i] += 1
                nextp[i] = primes[i] * ns[indices[i]]
    return ns
 
for prime in gen_primes(2, 29):
    print(""The first 25 {}-smooth numbers are: "".format(prime))
    print(nsmooth(prime, 25))
print()
for prime in gen_primes(3, 29):
    print(""The 3000 to 3202 {}-smooth numbers are: "".format(prime))
    print(nsmooth(prime, 3002)[2999:])
    print()
for prime in gen_primes(503, 521):
    print(""The 30,000 to 30,019 {}-smooth numbers are: "".format(prime))
    print(nsmooth(prime, 30019)[29999:])
    print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Loops/Do-while,Loops/Do-while,"Start with a value at 0. Loop while value mod 6 is not equal to 0.
Each time through the loop, add 1 to the value then print it.
The loop must execute at least once.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges


Reference

 Do while loop Wikipedia.

",Python,"val = 0
while val % 6!= 0:
    val += 1
    print(val)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"# version 1.1.2
def isPrime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    limit = int(math.sqrt(n))
    return not any(n % it == 0 for it in range(3, limit + 1, 2))
 
# test by printing all primes below 100 say
print(*filter(isPrime, range(2, 100)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Morse_code,Morse code,"Morse code
It has been in use for more than 175 years — longer than any other electronic encoding system.



Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).



As the standard Morse code does not contain all possible characters,
you may either ignore unknown characters in the file,
or indicate them somehow   (e.g. with a different pitch).



",Python,"import time, winsound #, sys
 
char2morse = {          
          ""!"": ""---."",      ""\"""": "".-..-."",     ""$"": ""...-..-"",    ""'"": "".----."",  
          ""("": ""-.--."",      "")"": ""-.--.-"",     ""+"": "".-.-."",      "","": ""--..--"", 
          ""-"": ""-....-"",     ""."": "".-.-.-"",     ""/"": ""-..-."", 
          ""0"": ""-----"",      ""1"": "".----"",      ""2"": ""..---"",      ""3"": ""...--"", 
          ""4"": ""....-"",      ""5"": ""....."",      ""6"": ""-...."",      ""7"": ""--..."", 
          ""8"": ""---.."",      ""9"": ""----."", 
          "":"": ""---..."",     "";"": ""-.-.-."",     ""="": ""-...-"",      ""?"": ""..--.."", 
          ""@"": "".--.-."", 
          ""A"": "".-"",         ""B"": ""-..."",       ""C"": ""-.-."",       ""D"": ""-.."", 
          ""E"": ""."",          ""F"": ""..-."",       ""G"": ""--."",        ""H"": ""...."", 
          ""I"": "".."",         ""J"": "".---"",       ""K"": ""-.-"",        ""L"": "".-.."", 
          ""M"": ""--"",         ""N"": ""-."",         ""O"": ""---"",        ""P"": "".--."", 
          ""Q"": ""--.-"",       ""R"": "".-."",        ""S"": ""..."",        ""T"": ""-"", 
          ""U"": ""..-"",        ""V"": ""...-"",       ""W"": "".--"",        ""X"": ""-..-"", 
          ""Y"": ""-.--"",       ""Z"": ""--.."", 
          ""["": ""-.--."",      ""]"": ""-.--.-"",     ""_"": ""..--.-"",
 }
 
e = 50      # Element time in ms. one dit is on for e then off for e
f = 1280    # Tone freq. in hertz
chargap = 1 # Time between characters of a word, in units of e
wordgap = 7 # Time between words, in units of e
 
def gap(n=1):
    time.sleep(n * e / 1000)
off = gap
 
def on(n=1):
    winsound.Beep(f, n * e)
 
def dit():
    on(); off()
 
def dah():
    on(3); off()
 
def bloop(n=3):
    winsound.Beep(f//2, n * e)
 
def windowsmorse(text):
    for word in text.strip().upper().split():
        for char in word:
            for element in char2morse.get(char, '?'):
                if element == '-':
                    dah()
                elif element == '.':
                    dit()
                else:
                    bloop()
            gap(chargap)
        gap(wordgap)
 
# Outputs its own source file as Morse. An audible quine!
#with open(sys.argv[0], 'r') as thisfile:
#    windowsmorse(thisfile.read())
 
while True:
    windowsmorse(input('A string to change into morse: '))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Python,"def damm(num: int) -> bool:
    row = 0
    for digit in str(num):
        row = _matrix[row][int(digit)] 
    return row == 0
 
_matrix = (
    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),
    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),
    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),
    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),
    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),
    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),
    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),
    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),
    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),
    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)
)
 
if __name__ == '__main__':
    for test in [5724, 5727, 112946]:
        print(f'{test}\t Validates as: {damm(test)}')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Repunit_primes,Repunit primes,"Repunit is a portmanteau of the words ""repetition"" and ""unit"", with unit being ""unit value""... or in laymans terms, 1. So 1, 11, 111, 1111 & 11111 are all repunits.

Every standard integer base has repunits since every base has the digit 1. This task involves finding the repunits in different bases that are prime.

In base two, the repunits 11, 111, 11111, 1111111, etc. are prime. (These correspond to the Mersenne primes.)

In base three: 111, 1111111, 1111111111111, etc.

Repunit primes, by definition, are also circular primes.

Any repunit in any base having a composite number of digits is necessarily composite. Only repunits (in any base) having a prime number of digits might be prime.



Rather than expanding the repunit out as a giant list of 1s or converting to base 10, it is common to just list the number of 1s in the repunit; effectively the digit count. The base two repunit primes listed above would be represented as: 2, 3, 5, 7, etc.

Many of these sequences exist on OEIS, though they aren't specifically listed as ""repunit prime digits"" sequences.

Some bases have very few repunit primes. Bases 4, 8, and likely 16 have only one. Base 9 has none at all. Bases above 16 may have repunit primes as well... but this task is getting large enough already.



Task
 For bases 2 through 16, Find and show, here on this page, the repunit primes as digit counts, up to a limit of 1000.


Stretch
 Increase the limit to 2700 (or as high as you have patience for.)


See also
 Wikipedia: Repunit primes
 OEIS:A000043 - Mersenne exponents: primes p such that 2^p - 1 is prime. Then 2^p - 1 is called a Mersenne prime (base 2)
 OEIS:A028491 - Numbers k such that (3^k - 1)/2 is prime (base 3)
 OEIS:A004061 - Numbers n such that (5^n - 1)/4 is prime (base 5)
 OEIS:A004062 - Numbers n such that (6^n - 1)/5 is prime (base 6)
 OEIS:A004063 - Numbers k such that (7^k - 1)/6 is prime (base 7)
 OEIS:A004023 - Indices of prime repunits: numbers n such that 11...111 (with n 1's) = (10^n - 1)/9 is prime (base 10)
 OEIS:A005808 - Numbers k such that (11^k - 1)/10 is prime (base 11)
 OEIS:A004064 - Numbers n such that (12^n - 1)/11 is prime (base 12)
 OEIS:A016054 - Numbers n such that (13^n - 1)/12 is prime (base 13)
 OEIS:A006032 - Numbers k such that (14^k - 1)/13 is prime (base 14)
 OEIS:A006033 - Numbers n such that (15^n - 1)/14 is prime (base 15)
 Related task: Circular primes

",Python,"import math
import gmpy2
import itertools
 
def primes(limit):
    """"""
    Sieve of Eratosthenes
    Code by, UC Irvine, 28 Feb 2002
    http://code.activestate.com/recipes/117119/
    """"""
    # Code by, UC Irvine, 28 Feb 2002
    # http://code.activestate.com/recipes/117119/
    #...with some changes to allow for arbitrary start values
    #...and to make it a generator
    D = {}
    q = 2
    while q <= limit:
        if q not in D:
            yield q
            D[q * q] = [q]
        else:
            for p in D[q]:
                D.setdefault(p + q, []).append(p)
            del D[q]
        q += 1
 
def main():
    limit = 2700
    primes = list(primes(limit))
    for b in range(2, 37):
        rPrimes = []
        for p in primes:
            s = int(str(1) * p, b)
            if gmpy2.is_prime(s):
                rPrimes.append(p)
        print(""Base {0}: {1}"".format(b, rPrimes))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Elementary_cellular_automaton/Random_Number_Generator,Elementary cellular automaton/Random Number Generator,"Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.

Steven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.

The purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.

You can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.

For extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.

Reference

 Cellular automata: Is Rule 30 random? (PDF).

",Python,"from elementary_cellular_automaton import eca, eca_wrap
 
def rule30bytes(lencells=100):
    cells = '1' + '0' * (lencells - 1)
    gen = eca(cells, 30)
    while True:
        yield int(''.join(next(gen)[0] for i in range(8)), 2)
 
if __name__ == '__main__':
    print([b for i,b in zip(range(10), rule30bytes())])",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pinstripe/Display,Pinstripe/Display," Sample image
The task is to demonstrate the creation of a series of vertical pinstripes across the entire width of the display.

 in the first quarter the pinstripes should alternate one pixel white, one pixel black = 1 pixel wide vertical pinestripes
 Quarter of the way down the display, we can switch to a wider 2 pixel wide vertical pinstripe pattern, alternating two pixels white, two pixels black. 
 Half way down the display, we switch to 3 pixels wide, 
 for the lower quarter of the display we use 4 pixels.


c.f. Colour_pinstripe/Display
",Python,"#Python task for Pinstripe/Display 
#Tested for Python2.7 by Benjamin Curutchet
 
#Import PIL libraries
from PIL import Image
from PIL import ImageColor
from PIL import ImageDraw
 
#Create the picture (size parameter 1660x1005 like the example)
x_size = 1650
y_size = 1000
im = Image.new('RGB',(x_size, y_size))
 
#Create a full black picture
draw = ImageDraw.Draw(im)
 
#RGB code for the White Color
White  = (255,255,255) 
 
#First loop in order to create four distinct lines
y_delimiter_list = []
for y_delimiter in range(1,y_size,y_size/4):
	y_delimiter_list.append(y_delimiter)
 
 
#Four different loops in order to draw columns in white depending on the
#number of the line
 
for x in range(1,x_size,2):
	for y in range(1,y_delimiter_list[1],1):
		draw.point((x,y),White)
 
for x in range(1,x_size-1,4):
	for y in range(y_delimiter_list[1],y_delimiter_list[2],1):
		draw.point((x,y),White)
		draw.point((x+1,y),White)
 
for x in range(1,x_size-2,6):
	for y in range(y_delimiter_list[2],y_delimiter_list[3],1):
		draw.point((x,y),White)
		draw.point((x+1,y),White)
		draw.point((x+2,y),White)
 
for x in range(1,x_size-3,8):
	for y in range(y_delimiter_list[3],y_size,1):
		draw.point((x,y),White)
		draw.point((x+1,y),White)
		draw.point((x+2,y),White)
		draw.point((x+3,y),White)
 
 
 
#Save the picture under a name as a jpg file.
print ""Your picture is saved""		
im.save('PictureResult.jpg')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",Python,"def reverse(s):
    return """".join(reversed(s))

s = ""stressed""
print(f""{s} -> {reverse(s)}"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Monads/Writer_monad,Monads/Writer monad,"The Writer monad is a programming design pattern which makes it possible to compose functions which return their result values paired with a log string. The final result of a composed function yields both a value, and a concatenation of the logs from each component function application.

Demonstrate in your programming language the following:

 Construct a Writer monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that monad (or just use what the language already provides)
 Write three simple functions: root, addOne, and half
 Derive Writer monad versions of each of these functions
 Apply a composition of the Writer versions of root, addOne, and half to the integer 5, deriving both a value for the Golden Ratio φ, and a concatenated log of the function applications (starting with the initial value, and followed by the application of root, etc.)",Python,"""""""A Writer Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
 
import functools
import math
import os
 
from typing import Any
from typing import Callable
from typing import Generic
from typing import List
from typing import TypeVar
from typing import Union
 
 
T = TypeVar(""T"")
 
 
class Writer(Generic[T]):
    def __init__(self, value: Union[T, Writer[T]], *msgs: str):
        if isinstance(value, Writer):
            self.value: T = value.value
            self.msgs: List[str] = value.msgs + list(msgs)
        else:
            self.value = value
            self.msgs = list(f""{msg}: {self.value}"" for msg in msgs)
 
    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        writer = func(self.value)
        return Writer(writer, *self.msgs)
 
    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        return self.bind(func)
 
    def __str__(self):
        return f""{self.value}\n{os.linesep.join(reversed(self.msgs))}""
 
    def __repr__(self):
        return f""Writer({self.value}, \""{', '.join(reversed(self.msgs))}\"")""
 
 
def lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:
    """"""Return a writer monad version of the simple function `func`.""""""
 
    @functools.wraps(func)
    def wrapped(value):
        return Writer(func(value), msg)
 
    return wrapped
 
 
if __name__ == ""__main__"":
    square_root = lift(math.sqrt, ""square root"")
    add_one = lift(lambda x: x + 1, ""add one"")
    half = lift(lambda x: x / 2, ""div two"")
 
    print(Writer(5, ""initial"") >> square_root >> add_one >> half)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Elliptic_curve_arithmetic,Elliptic curve arithmetic,"Elliptic curves   are sometimes used in   cryptography   as a way to perform   digital signatures.

The purpose of this task is to implement a simplified (without modular arithmetic) version of the elliptic curve arithmetic which is required by the   elliptic curve DSA   protocol.

In a nutshell, an elliptic curve is a bi-dimensional curve defined by the following relation between the x and y coordinates of any point on the curve:

   




y

2


=

x

3


+
a
x
+
b


{\displaystyle y^{2}=x^{3}+ax+b}


a and b are arbitrary parameters that define the specific curve which is used.

For this particular task, we'll use the following parameters:

    a=0,   b=7 
The most interesting thing about elliptic curves is the fact that it is possible to define a   group   structure on it.

To do so we define an   internal composition   rule with an additive notation +,   such that for any three distinct points P, Q and R on the curve, whenever these points are aligned, we have:

    P + Q + R = 0  
Here   0   (zero)   is the infinity point,   for which the x and y values are not defined.   It's basically the same kind of point which defines the horizon in   projective geometry.

We'll also assume here that this infinity point is unique and defines the   neutral element   of the addition.

This was not the definition of the addition, but only its desired property.   For a more accurate definition, we proceed as such:

Given any three aligned points P, Q and R,   we define the sum   S = P + Q   as the point (possibly the infinity point) such that   S, R   and the infinity point are aligned.

Considering the symmetry of the curve around the x-axis, it's easy to convince oneself that two points S and R can be aligned with the infinity point if and only if S and R are symmetric of one another towards the x-axis   (because in that case there is no other candidate than the infinity point to complete the alignment triplet).

S is thus defined as the symmetric of R towards the x axis.

The task consists in defining the addition which, for any two points of the curve, returns the sum of these two points.   You will pick two random points on the curve, compute their sum and show that the symmetric of the sum is aligned with the two initial points.

You will use the a and b parameters of secp256k1, i.e. respectively zero and seven.

Hint:   You might need to define a ""doubling"" function, that returns P+P for any given point P.

Extra credit:   define the full elliptic curve arithmetic (still not modular, though) by defining a ""multiply"" function that returns,

for any point P and integer n,   the point P + P + ... + P     (n times).



",Python,"#!/usr/bin/env python3
 
class Point:
    b = 7
    def __init__(self, x=float('inf'), y=float('inf')):
        self.x = x
        self.y = y
 
    def copy(self):
        return Point(self.x, self.y)
 
    def is_zero(self):
        return self.x > 1e20 or self.x < -1e20
 
    def neg(self):
        return Point(self.x, -self.y)
 
    def dbl(self):
        if self.is_zero():
            return self.copy()
        try:
            L = (3 * self.x * self.x) / (2 * self.y)
        except ZeroDivisionError:
            return Point()
        x = L * L - 2 * self.x
        return Point(x, L * (self.x - x) - self.y)
 
    def add(self, q):
        if self.x == q.x and self.y == q.y:
            return self.dbl()
        if self.is_zero():
            return q.copy()
        if q.is_zero():
            return self.copy()
        try:
            L = (q.y - self.y) / (q.x - self.x)
        except ZeroDivisionError:
            return Point()
        x = L * L - self.x - q.x
        return Point(x, L * (self.x - x) - self.y)
 
    def mul(self, n):
        p = self.copy()
        r = Point()
        i = 1
        while i <= n:
            if i&n:
                r = r.add(p)
            p = p.dbl()
            i <<= 1
        return r
 
    def __str__(self):
        return ""({:.3f}, {:.3f})"".format(self.x, self.y)
 
def show(s, p):
    print(s, ""Zero"" if p.is_zero() else p)
 
def from_y(y):
    n = y * y - Point.b
    x = n**(1./3) if n>=0 else -((-n)**(1./3))
    return Point(x, y)
 
# demonstrate
a = from_y(1)
b = from_y(2)
show(""a ="", a)
show(""b ="", b)
c = a.add(b)
show(""c = a + b ="", c)
d = c.neg()
show(""d = -c ="", d)
show(""c + d ="", c.add(d))
show(""a + b + d ="", a.add(b.add(d)))
show(""a * 12345 ="", a.mul(12345))",Human_written,Python_from_C
http://rosettacode.org/wiki/System_time,System time,"Task

Output the system time   (any units will do as long as they are noted) either by a system command or one built into the language.

The system time can be used for debugging, network information, random number seeds, or something as simple as program performance.



Related task

   Date format


See also

   Retrieving system time (wiki)

",Python,"from boost.date_time import posix_time
from boost.date_time import time_format
 
t = posix_time.second_clock.local_time()
print time_format.to_simple_string(t)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Substring/Top_and_tail,Substring/Top and tail,"The task is to demonstrate how to remove the first and last characters from a string.

The solution should demonstrate how to obtain the following results:

 String with first character removed
 String with last character removed
 String with both the first and last characters removed


If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it.

The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.

Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"print(""Hello world"".rfind(""Hello""))
print(""Hello world"".rfind(""hello""))
print(""Hello world"".rfind(""world""))
print(""Hello world"".rfind(""World""))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Identity_matrix,Identity matrix,"Task

Build an   identity matrix   of a size known at run-time.



An identity matrix is a square matrix of size n × n,

where the diagonal elements are all 1s (ones),

and all the other elements are all 0s (zeroes).







I

n


=


[



1


0


0


⋯


0




0


1


0


⋯


0




0


0


1


⋯


0




⋮


⋮


⋮


⋱


⋮




0


0


0


⋯


1



]




{\displaystyle I_{n}={\begin{bmatrix}1&0&0&\cdots &0\\0&1&0&\cdots &0\\0&0&1&\cdots &0\\\vdots &\vdots &\vdots &\ddots &\vdots \\0&0&0&\cdots &1\\\end{bmatrix}}}





Related tasks

   Spiral matrix
   Zig-zag matrix 
   Ulam_spiral_(for_primes)

",Python,"import numpy as np
 
a = np.array([[1, 2], [3, 4]])
b = a.T
print(b)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/String_concatenation,String concatenation,"String concatenation

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a string variable equal to any text value.

Create another string variable whose value is the original variable concatenated with another string literal.

To illustrate the operation, show the content of the variables.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def main(args):
    s1 = ""James""
    s2 = ""Bond""
    print(s1)
    print(s2)
    s3 = s1 + "" "" + s2
    print(s3)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Negative_base_numbers,Negative base numbers,"Negative base numbers are an alternate way to encode numbers without the need for a minus sign. Various negative bases may be used including negadecimal (base -10), negabinary (-2) and negaternary (-3).[1][2]



Task

Encode the decimal number 10 as negabinary (expect 11110)
Encode the decimal number 146 as negaternary (expect 21102)
Encode the decimal number 15 as negadecimal (expect 195)
In each of the above cases, convert the encoded number back to decimal.


extra credit

 supply an integer, that when encoded to base   -62   (or something ""higher""),   expresses the 
name of the language being used   (with correct capitalization).   If the computer language has 
non-alphanumeric characters,   try to encode them into the negatory numerals,   or use other 
characters instead.

",Python,"#!/bin/python
from __future__ import print_function
 
def EncodeNegBase(n, b): #Converts from decimal
	if n == 0:
		return ""0""
	out = []
	while n != 0:
		n, rem = divmod(n, b)
		if rem < 0:
			n += 1
			rem -= b
		out.append(rem)
	return """".join(map(str, out[::-1]))
 
def DecodeNegBase(nstr, b): #Converts to decimal
	if nstr == ""0"":
		return 0
 
	total = 0
	for i, ch in enumerate(nstr[::-1]):
		total += int(ch) * b**i
	return total
 
if __name__==""__main__"":
 
	print (""Encode 10 as negabinary (expect 11110)"")
	result = EncodeNegBase(10, -2)
	print (result)
	if DecodeNegBase(result, -2) == 10: print (""Converted back to decimal"")
	else: print (""Error converting back to decimal"")
 
	print (""Encode 146 as negaternary (expect 21102)"")
	result = EncodeNegBase(146, -3)
	print (result)
	if DecodeNegBase(result, -3) == 146: print (""Converted back to decimal"")
	else: print (""Error converting back to decimal"")
 
	print (""Encode 15 as negadecimal (expect 195)"")
	result = EncodeNegBase(15, -10)
	print (result)
	if DecodeNegBase(result, -10) == 15: print (""Converted back to decimal"")
	else: print (""Error converting back to decimal"")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Tonelli-Shanks_algorithm,Tonelli-Shanks algorithm,"

 This page uses content from Wikipedia. The original article was at Tonelli-Shanks algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In computational number theory, the Tonelli–Shanks algorithm is a technique for solving for x in a congruence of the form:


 x2 ≡ n (mod p)

where n is an integer which is a quadratic residue (mod p), p is an odd prime, and x,n ∈ Fp where Fp = {0, 1, ..., p - 1}.

It is used in cryptography techniques.



To apply the algorithm, we need the Legendre symbol:

The Legendre symbol (a | p) denotes the value of a(p-1)/2 (mod p).

 (a | p) ≡ 1    if a is a square (mod p)
 (a | p) ≡ -1    if a is not a square (mod p)
 (a | p) ≡ 0    if a ≡ 0 (mod p) 


Algorithm pseudo-code


All ≡ are taken to mean (mod p) unless stated otherwise.

 Input: p an odd prime, and an integer n .
 Step 0: Check that n is indeed a square: (n | p) must be ≡ 1 .
 Step 1: By factoring out powers of 2 from p - 1, find q and s such that p - 1 = q2s with q odd .
 If p ≡ 3 (mod 4) (i.e. s = 1), output the two solutions r ≡ ± n(p+1)/4 .
 Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq .
 Step 3: Set r ≡ n(q+1)/2, t ≡ nq, m = s .
 Step 4: Loop the following:
 If t ≡ 1, output r and p - r .
 Otherwise find, by repeated squaring, the lowest i, 0 < i < m , such that t2i ≡ 1 .
 Let b ≡ c2(m - i - 1), and set r ≡ rb, t ≡ tb2, c ≡ b2 and m = i .




Task

Implement the above algorithm.

Find solutions (if any) for

 n = 10 p = 13
 n = 56 p = 101
 n = 1030 p = 10009
 n = 1032 p = 10009
 n = 44402 p = 100049 
Extra credit

 n = 665820697 p = 1000000009 
 n = 881398088036 p = 1000000000039 
 n = 41660815127637347468140745042827704103445750172002 p = 10^50 + 577 


See also

 Modular exponentiation
 Cipolla's algorithm

",Python,"def ts(n, p):
    # a^e mod p
    def powModP(a, e):
        s = 1
        while e > 0:
            s = s * a % p
            e -= 1
        return s
    # Legendre symbol, returns 1, 0, or -1 mod p -- that's 1, 0, or p-1.
    def ls(a):
        return powModP(a, (p-1)/2)
    # argument validation
    if ls(n)!= 1:
        return 0, 0, False
    # WP step 1, factor out powers two.
    # variables Q, S named as at WP.
    Q = p - 1
    S = 0
    while Q&1 == 0:
        S += 1
        Q >>= 1
    # WP step 1, direct solution
    if S == 1:
        R1 = powModP(n, (p+1)/4)
        return R1, p - R1, True
    # WP step 2, select z, assign c
    z = 2
    while ls(z)!= p-1:
        z += 1
    c = powModP(z, Q)
    # WP step 3, assign R, t, M
    R = powModP(n, (Q+1)/2)
    t = powModP(n, Q)
    M = S
    # WP step 4, loop
    while True:
        # WP step 4.1, termination condition
        if t == 1:
            return R, p - R, True
        # WP step 4.2, find lowest i...
        i = 0
        while t!= 1 and i < M-1:
            t = t * t % p
            i += 1
        # WP step 4.3, using a variable b, assign new values of R, t, c, M
        b = c
        for e in range(M - i - 1):
            b = b * b % p
        R = R * b % p
        c = b * b % p # more convenient to compute c before t
        t = t * c % p
        M = i
 
print(ts(10, 13))
print(ts(56, 101))
print(ts(1030, 10009))
print(ts(1032, 10009))
print(ts(44402, 100049))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Python,"import sys
 
class pair:
    def __init__(self, s, z):
        self.p = (s, z)
    def __lt__(self, o):
        return self.i() < o.i()
    def i(self):
        return self.p[0]
    def s(self):
        return self.p[1]
 
def gFizzBuzz(c, v):
    output = False
    for x in range(1, c + 1):
        output = False
        for i in v:
            if not x % i.i():
                sys.stdout.write(i.s())
                output = True
        if not output:
            sys.stdout.write(str(x))
        sys.stdout.write(""\n"")
 
v = []
v.append(pair(7, ""Baxx""))
v.append(pair(3, ""Fizz""))
v.append(pair(5, ""Buzz""))
v.sort()
gFizzBuzz(20, v)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Draw_a_sphere,Draw a sphere,"Task

Draw a sphere.

The sphere can be represented graphically, or in ASCII art, depending on the language capabilities.

Either static or rotational projection is acceptable for this task.



Related tasks

 draw a cuboid
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Python,"import math
 
shades = ('.',':','!','*','o','e','&','#','%','@')
 
def normalize(v):
	len = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)
	return (v[0]/len, v[1]/len, v[2]/len)
 
def dot(x,y):
	d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]
	return -d if d < 0 else 0
 
def draw_sphere(r, k, ambient, light):
	for i in range(int(math.floor(-r)),int(math.ceil(r)+1)):
		x = i + 0.5
		line = ''
 
		for j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):
			y = j/2 + 0.5
			if x*x + y*y <= r*r:
				vec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))
				b = dot(light,vec)**k + ambient
				intensity = int((1-b)*(len(shades)-1))
				line += shades[intensity] if 0 <= intensity < len(shades) else shades[0]
			else:
				line += ' '
 
		print(line)
 
light = normalize((30,30,-50))
draw_sphere(20,4,0.1, light)
draw_sphere(10,2,0.4, light)",Human_written,Python_from_C
http://rosettacode.org/wiki/Resistor_mesh,Resistor mesh,"
Task

Given    10×10    grid nodes   (as shown in the image)   interconnected by    1Ω    resistors as shown,

find the resistance between points   A   and   B.



See also

   (humor, nerd sniping)   xkcd.com cartoon

",Python,"DIFF_THRESHOLD = 1e-40
 
class Fixed:
    FREE = 0
    A = 1
    B = 2
 
class Node:
    __slots__ = [""voltage"", ""fixed""]
    def __init__(self, v=0.0, f=Fixed.FREE):
        self.voltage = v
        self.fixed = f
 
def set_boundary(m):
    m[1][1] = Node( 1.0, Fixed.A)
    m[6][7] = Node(-1.0, Fixed.B)
 
def calc_difference(m, d):
    h = len(m)
    w = len(m[0])
    total = 0.0
 
    for i in xrange(h):
        for j in xrange(w):
            v = 0.0
            n = 0
            if i != 0:  v += m[i-1][j].voltage; n += 1
            if j != 0:  v += m[i][j-1].voltage; n += 1
            if i < h-1: v += m[i+1][j].voltage; n += 1
            if j < w-1: v += m[i][j+1].voltage; n += 1
            v = m[i][j].voltage - v / n
 
            d[i][j].voltage = v
            if m[i][j].fixed == Fixed.FREE:
                total += v ** 2
    return total
 
def iter(m):
    h = len(m)
    w = len(m[0])
    difference = [[Node() for j in xrange(w)] for i in xrange(h)]
 
    while True:
        set_boundary(m) # Enforce boundary conditions.
        if calc_difference(m, difference) < DIFF_THRESHOLD:
            break
        for i, di in enumerate(difference):
            for j, dij in enumerate(di):
                m[i][j].voltage -= dij.voltage
 
    cur = [0.0] * 3
    for i, di in enumerate(difference):
        for j, dij in enumerate(di):
            cur[m[i][j].fixed] += (dij.voltage *
                (bool(i) + bool(j) + (i < h-1) + (j < w-1)))
 
    return (cur[Fixed.A] - cur[Fixed.B]) / 2.0
 
def main():
    w = h = 10
    mesh = [[Node() for j in xrange(w)] for i in xrange(h)]
    print ""R = %.16f"" % (2 / iter(mesh))
 
main()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call,Exceptions/Catch an exception thrown in a nested call,"Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.

   Create two user-defined exceptions,   U0   and   U1. 
   Have function   foo   call function   bar   twice.
   Have function   bar   call function   baz. 
   Arrange for function   baz   to raise, or throw exception   U0   on its first call, then exception   U1   on its second.
   Function   foo   should catch only exception   U0,   not   U1.


Show/describe what happens when the program is run.



",Python,"class U0(Exception): pass
class U1(Exception): pass
 
def foo():
    for i in range(2):
        try:
            bar(i)
        except U0:
            print(""Function foo caught exception U0"")
 
def bar(i):
    baz(i) # Nest those calls
 
def baz(i):
    raise U1 if i else U0
 
foo()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Anagrams/Deranged_anagrams,Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import collections
import itertools
import sys
 
def is_deranged(word1, word2):
    for i in range(len(word1)):
        if word1[i] == word2[i]:
            return False
    return True
 
def print_longest_deranged_anagram(words):
    words.sort(key=lambda word: (-len(word), word))
 
    anagrams = collections.defaultdict(list)
    for word in words:
        key = ''.join(sorted(word))
        for anagram in anagrams[key]:
            if is_deranged(word, anagram):
                print(anagram, word)
                return
        anagrams[key].append(word)
    print('no result')
 
def main():
    with open('unixdict.txt') as f:
        words = f.read().splitlines()
    print_longest_deranged_anagram(words)
 
if __name__ == '__main__':
    sys.exit(main())",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Write_to_Windows_event_log,Write to Windows event log,"Task

Write script status to the Windows Event Log



",Python,"import clr
clr.AddReference(""System.Diagnostics"")
from System.Diagnostics import *
 
sSource = ""Sample App""
sLog = ""Application""
sEvent = ""Hello from RC!""
 
if not EventLog.SourceExists(sSource):
    EventLog.CreateEventSource(sSource, sLog)
 
EventLog.WriteEntry(sSource, sEvent)
EventLog.WriteEntry(sSource, sEvent, EventLogEntryType.Information)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Identity_matrix,Identity matrix,"Task

Build an   identity matrix   of a size known at run-time.



An identity matrix is a square matrix of size n × n,

where the diagonal elements are all 1s (ones),

and all the other elements are all 0s (zeroes).







I

n


=


[



1


0


0


⋯


0




0


1


0


⋯


0




0


0


1


⋯


0




⋮


⋮


⋮


⋱


⋮




0


0


0


⋯


1



]




{\displaystyle I_{n}={\begin{bmatrix}1&0&0&\cdots &0\\0&1&0&\cdots &0\\0&0&1&\cdots &0\\\vdots &\vdots &\vdots &\ddots &\vdots \\0&0&0&\cdots &1\\\end{bmatrix}}}





Related tasks

   Spiral matrix
   Zig-zag matrix 
   Ulam_spiral_(for_primes)

",Python,"import sys
import os
import math

def main():
    if len(sys.argv) < 2:
        print(""usage: identitymatrix <number of rows>"")
        sys.exit(1)
    rowsize = int(sys.argv[1])
    if rowsize < 0:
        print(""Dimensions of matrix cannot be negative"")
        sys.exit(1)
    numElements = rowsize * rowsize
    if numElements < rowsize:
        print(""Squaring %d caused result to overflow to %d."" % (rowsize, numElements))
        sys.exit(1)
    matrix = [None] * numElements
    for row in range(0, rowsize):
        matrix[row] = [None] * numElements
        matrix[row][row] = 1
    print(""Matrix is: "")
    for row in range(0, rowsize):
        for column in range(0, rowsize):
            print(""%d "" % matrix[row][column], end="""")
        print()

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Fractal_tree,Fractal tree,"Generate and draw a fractal tree.

 Draw the trunk
 At the end of the trunk, split by some angle and draw two branches
 Repeat at the end of each branch until a sufficient level of branching is reached


Related tasks
 Pythagoras Tree

",Python,"from shoes import *

Shoes.app(title=""Fractal Tree"", width=600, height=600)

background(""#fff"")
stroke(""#000"")

deg_to_rad = Math::PI / 180.0

def drawTree(x1, y1, angle, depth):
    if depth!= 0:
        x2 = x1 + (Math.cos(angle * deg_to_rad) * depth * 10.0).to_i
        y2 = y1 + (Math.sin(angle * deg_to_rad) * depth * 10.0).to_i

        line(x1, y1, x2, y2)

        drawTree(x2, y2, angle - 20, depth - 1)
        drawTree(x2, y2, angle + 20, depth - 1)

drawTree(300,550,-90,9)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Earliest_difference_between_prime_gaps,Earliest difference between prime gaps,"When calculating prime numbers > 2, the difference between adjacent primes is always an even number. This difference, also referred to as the gap, varies in an random pattern; at least, no pattern has ever been discovered, and it is strongly conjectured that no pattern exists. However, it is also conjectured that between some two adjacent primes will be a gap corresponding to every positive even integer.






gap
minimal
starting
prime
ending
prime


2
3
5


4
7
11


6
23
29


8
89
97


10
139
149


12
199
211


14
113
127


16
1831
1847


18
523
541


20
887
907


22
1129
1151


24
1669
1693


26
2477
2503


28
2971
2999


30
4297
4327


This task involves locating the minimal primes corresponding to those gaps.

Though every gap value exists, they don't seem to come in any particular order. For example, this table shows the gaps and minimum starting value primes for 2 through 30:



For the purposes of this task, considering only primes greater than 2, consider prime gaps that differ by exactly two to be adjacent.



Task
For each order of magnitude m from 10¹ through 10⁶:

 Find the first two sets of adjacent minimum prime gaps where the absolute value of the difference between the prime gap start values is greater than m.


E.G.
For an m of 10¹;

The start value of gap 2 is 3, the start value of gap 4 is 7, the difference is 7 - 3 or 4. 4 < 10¹ so keep going.

The start value of gap 4 is 7, the start value of gap 6 is 23, the difference is 23 - 7, or 16. 16 > 10¹ so this the earliest adjacent gap difference > 10¹.



Stretch goal
 Do the same for 10⁷ and 10⁸ (and higher?) orders of magnitude
Note: the earliest value found for each order of magnitude may not be unique, in fact, is not unique; also, with the gaps in ascending order, the minimal starting values are not strictly ascending.
",Python,""""""" https://rosettacode.org/wiki/Earliest_difference_between_prime_gaps """"""
 
from primesieve import primes
 
LIMIT = 10**9
pri = primes(LIMIT * 5)
gapstarts = {}
for i in range(1, len(pri)):
    if pri[i] - pri[i - 1] not in gapstarts:
        gapstarts[pri[i] - pri[i - 1]] = pri[i - 1]
 
PM, GAP1, = 10, 2
while True:
    while GAP1 not in gapstarts:
        GAP1 += 2
    start1 = gapstarts[GAP1]
    GAP2 = GAP1 + 2
    if GAP2 not in gapstarts:
        GAP1 = GAP2 + 2
        continue
    start2 = gapstarts[GAP2]
    diff = abs(start2 - start1)
    if diff > PM:
        print(f""Earliest difference >{PM: ,} between adjacent prime gap starting primes:"")
        print(f""Gap {GAP1} starts at{start1: ,}, gap {GAP2} starts at{start2: ,}, difference is{diff: ,}.\n"")
        if PM == LIMIT:
            break
        PM *= 10
    else:
        GAP1 = GAP2",Human_written,Python_from_Java
http://rosettacode.org/wiki/Extend_your_language,Extend your language,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Some programming languages allow you to extend the language. While this can be done to a certain degree in most languages (e.g. by using macros), other languages go much further. Most notably in the Forth and Lisp families, programming per se is done by extending the language without any formal distinction between built-in and user-defined elements.

If your language supports it, show how to introduce a new flow control mechanism. A practical and useful example is a four-way branch:

Occasionally, code must be written that depends on two conditions, resulting in up to four branches (depending on whether both, only the first, only the second, or none of the conditions are ""true""). In a C-like language this could look like the following:

  if (condition1isTrue) {
     if (condition2isTrue)
        bothConditionsAreTrue();
     else
        firstConditionIsTrue();
  }
  else if (condition2isTrue)
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Besides being rather cluttered, the statement(s) for 'condition2isTrue' must be written down twice. If 'condition2isTrue' were a lengthy and involved expression, it would be quite unreadable, and the code generated by the compiler might be unnecessarily large.

This can be improved by introducing a new keyword if2. It is similar to if, but takes two conditional statements instead of one, and up to three 'else' statements. One proposal (in pseudo-C syntax) might be:

  if2 (condition1isTrue) (condition2isTrue)
     bothConditionsAreTrue();
  else1
     firstConditionIsTrue();
  else2
     secondConditionIsTrue();
  else
     noConditionIsTrue();

Pick the syntax which suits your language. The keywords 'else1' and 'else2' are just examples. The new conditional expression should look, nest and behave analogously to the language's built-in 'if' statement.
",Python,"a, b = 1, 0
 
if (c1 := a == 1) and (c2 := b == 3):
  print('a = 1 and b = 3')
elif c1:
  print('a = 1 and b <> 3')
elif c2:
  print('a <> 1 and b = 3')
else:
  print('a <> 1 and b <> 3')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Iterated_digits_squaring,Iterated digits squaring,"If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:

15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89
7 -> 49 -> 97 -> 130 -> 10 -> 1
An example in Python:

>>> step = lambda x: sum(int(d) ** 2 for d in str(x))
>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))
>>> [iterate(x) for x in xrange(1, 20)]
[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]


Task

 Count how many number chains for integers 1 <= n < 100_000_000 end with a value 89.
Or, for much less credit - (showing that your algorithm and/or language is slow):

 Count how many number chains for integers 1 <= n < 1_000_000 end with a value 89.
This problem derives from the Project Euler problem 92.

For a quick algorithm for this task see the talk page



Related tasks

 Combinations with repetitions
 Digital root
 Digital root/Multiplicative digital root

",Python,"from math import ceil, log10, factorial
 
def next_step(x):
    result = 0
    while x > 0:
        result += (x % 10) ** 2
        x /= 10
    return result
 
def check(number):
    candidate = 0
    for n in number:
        candidate = candidate * 10 + n
 
    while candidate != 89 and candidate != 1:
        candidate = next_step(candidate)
 
    if candidate == 89:
        digits_count = [0] * 10
        for d in number:
            digits_count[d] += 1
 
        result = factorial(len(number))
        for c in digits_count:
            result /= factorial(c)
        return result
 
    return 0
 
def main():
    limit = 100000000
    cache_size = int(ceil(log10(limit)))
    assert 10 ** cache_size == limit
 
    number = [0] * cache_size
    result = 0
    i = cache_size - 1
 
    while True:
        if i == 0 and number[i] == 9:
            break
        if i == cache_size - 1 and number[i] < 9:
            number[i] += 1
            result += check(number)
        elif number[i] == 9:
            i -= 1
        else:
            number[i] += 1
            for j in xrange(i + 1, cache_size):
                number[j] = number[i]
            i = cache_size - 1
            result += check(number)
 
    print result
 
main()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character,Split a character string based on change of character,"

Task

Split a (character) string into comma (plus a blank) delimited
strings based on a change of character   (left to right).

Show the output here   (use the 1st example below).



Blanks should be treated as any other character   (except
they are problematic to display clearly).   The same applies
to commas.



For instance, the string:

 gHHH5YY++///\ 

should be split and show:

 g, HHH, 5, YY, ++, ///, \ 




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import groupby
 
def splitter(text):
    return ', '.join(''.join(group) for key, group in groupby(text))
 
if __name__ == '__main__':
    txt = 'gHHH5YY++///\\'      # Note backslash is the Python escape char.
    print(f'Input: {txt}\nSplit: {splitter(txt)}')",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Subleq,Subleq,"Subleq is an example of a One-Instruction Set Computer (OISC).

It is named after its only instruction, which is SUbtract and Branch if Less than or EQual to zero.

Task
Your task is to create an interpreter which emulates a SUBLEQ machine.

The machine's memory consists of an array of signed integers.   These integers may be interpreted in three ways:

   simple numeric values 
   memory addresses 
   characters for input or output
Any reasonable word size that accommodates all three of the above uses is fine.

The program should load the initial contents of the emulated machine's memory, set the instruction pointer to the first address (which is defined to be address 0), and begin emulating the machine, which works as follows:

   Let A be the value in the memory location identified by the instruction pointer;   let B and C be the values stored in the next two consecutive addresses in memory.
   Advance the instruction pointer three words, to point at the address after the address containing C.
   If A is   -1   (negative unity),   then a character is read from the machine's input and its numeric value stored in the address given by B.   C is unused.
   If B is   -1   (negative unity),   then the number contained in the address given by A is interpreted as a character and written to the machine's output.   C is unused.
   Otherwise, both A and B are treated as addresses.   The number contained in address A is subtracted from the number in address B (and the difference left in address B).   If the result is positive, execution continues uninterrupted; if the result is zero or negative, the number in C becomes the new instruction pointer.
   If the instruction pointer becomes negative, execution halts.
Your solution may initialize the emulated machine's memory in any convenient manner, but if you accept it as input, it should be a separate input stream from the one fed to the emulated machine once it is running. And if fed as text input, it should be in the form of raw subleq ""machine code"" - whitespace-separated decimal numbers, with no symbolic names or other assembly-level extensions, to be loaded into memory starting at address   0   (zero).

For purposes of this task, show the output of your solution when fed the below   ""Hello, world!""   program.

As written, this example assumes ASCII or a superset of it, such as any of the Latin-N character sets or Unicode;   you may translate the numbers representing characters (starting with 72=ASCII 'H') into another character set if your implementation runs in a non-ASCII-compatible environment. If 0 is not an appropriate terminator in your character set, the program logic will need some adjustment as well.

15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0
The above ""machine code"" corresponds to something like this in a hypothetical assembler language for a signed 8-bit version of the machine:

start:
    0f 11 ff subleq (zero), (message), -1
    11 ff ff subleq (message), -1, -1    ; output character at message
    10 01 ff subleq (neg1), (start+1), -1
    10 03 ff subleq (neg1), (start+3), -1
    0f 0f 00 subleq (zero), (zero), start
; useful constants
zero: 
    00      .data 0  
neg1: 
    ff      .data -1
; the message to print
message: .data ""Hello, world!\n\0""
    48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 0a 00

",Python,"import sys
 
def subleq(a):
    i = 0
    try:
        while i >= 0:
            if a[i] == -1:
                a[a[i + 1]] = ord(sys.stdin.read(1))
            elif a[i + 1] == -1:
                print(chr(a[a[i]]), end="""")
            else:
                a[a[i + 1]] -= a[a[i]]
                if a[a[i + 1]] <= 0:
                    i = a[i + 2]
                    continue
            i += 3
    except (ValueError, IndexError, KeyboardInterrupt):
        print(""abort"")
        print(a)
 
subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,
        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,
        114, 108, 100, 33, 10, 0])",Human_written,Python_from_C#
http://rosettacode.org/wiki/Faulhaber%27s_formula,Faulhaber's formula,"In mathematics,   Faulhaber's formula,   named after Johann Faulhaber,   expresses the sum of the p-th powers of the first n positive integers as a (p + 1)th-degree polynomial function of n,   the coefficients involving Bernoulli numbers.



Task

Generate the first 10 closed-form expressions, starting with p = 0.



Related tasks

   Bernoulli numbers.
   evaluate binomial coefficients.


See also

   The Wikipedia entry:   Faulhaber's formula.
   The Wikipedia entry:   Bernoulli numbers.
   The Wikipedia entry:   binomial coefficients.

",Python,"def binomial(n,k):
    if n < 0 or k < 0 or n < k:
        return -1
    if n == 0 or k == 0:
        return 1
 
    num = 1
    for i in range(k+1, n+1):
        num = num * i
    denom = 1
    for i in range(2, n-k+1):
        denom = denom * i
    return num / denom
 
def bernoulli(n):
    if n < 0:
        raise ""n cannot be less than zero""
    a = [0] * 16
    for m in range(0, n+1):
        a[m] = 1 / (m + 1)
        for j in range(m, 0, -1):
            a[j-1] = (a[j-1] - a[j]) * j
    if n!= 1:
        return a[0]
    return -a[0]
 
def faulhaber(p):
    print(""%d : "" % [p])
    q = 1 / (p + 1)
    sign = -1
    for j in range(0, p+1):
        sign = -1 * sign
        coeff = q * sign * binomial(p+1, j) * bernoulli(j)
        if coeff == 0:
            continue
        if j == 0:
            if coeff!= 1:
                if coeff == -1:
                    print ""-"",
                else:
                    print coeff,
        else:
            if coeff == 1:
                print "" + "",
            elif coeff == -1:
                print "" - "",
            elif 0 < coeff:
                print "" + "",
                print coeff,
            else:
                print "" - "",
                print -coeff,
        pwr = p + 1 - j
        if pwr > 1:
            print ""n^%d"" % [pwr],
        else:
            print ""n"",
    print ""\n""
 
def main():
    for i in range(0, 10):
        faulhaber(i)
 
main()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort,Sorting algorithms/Insertion sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Insertion sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



An O(n2) sorting algorithm which moves elements one at a time into the correct position.
The algorithm consists of inserting one element at a time into the previously sorted part of the array, moving higher ranked elements up as necessary.
To start off, the first (or smallest, or any arbitrary) element of the unsorted array is considered to be the sorted part.

Although insertion sort is an O(n2) algorithm, its simplicity, low overhead, good locality of reference and efficiency make it a good choice in two cases: 


   small   n, 

   as the final finishing-off algorithm for O(n logn) algorithms such as mergesort and quicksort.


The algorithm is as follows (from wikipedia):

function insertionSort(array A)
    for i from 1 to length[A]-1 do
        value := A[i] 
        j := i-1
        while j >= 0 and A[j] > value do
            A[j+1] := A[j]
            j := j-1
        done
        A[j+1] = value
    done

Writing the algorithm for integers will suffice.



",Python,"def insertion_sort(array):
    for index in range(1, len(array)):
        value = array[index]
        sub_index = index - 1
        while sub_index >= 0 and array[sub_index] > value:
            array[sub_index + 1] = array[sub_index]
            sub_index -= 1
        array[sub_index + 1] = value
 
def main():
    numbers = [5, 2, 3, 17, 12, 1, 8, 3, 4, 9, 7]
 
    def print_array(message, array):
        print(f""{message} {array}"")
 
    print_array(""Unsorted:"", numbers)
    insertion_sort(numbers)
    print_array(""Sorted:"", numbers)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",Python,"FLOAT
    :   '.' DIGITS (Exponent)?
    |   DIGITS '.' Exponent
    |   DIGITS ('.' (DIGITS (Exponent)?)? | Exponent)
    ;
 
DIGITS : ( '0' .. '9' )+ ;
 
Exponent
    :    ('e' | 'E') ( '+' | '-' )? DIGITS
    ;",Human_written,Python_from_Java
http://rosettacode.org/wiki/Loops/Wrong_ranges,Loops/Wrong ranges,"Loops/Wrong ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages have syntax or function(s) to generate a range of numeric values from a start value, a stop value, and an increment.

The purpose of this task is to select the range syntax/function that would generate at least two increasing numbers when given a stop value more than the start value and a positive increment of less than half the difference.   You are then to use that same syntax/function but with different parameters; and show, here, what would happen.

Use these values if possible:



start 
stop 
increment 
Comment


 -2
2
1
Normal


 -2
2
0
Zero increment


 -2
2
-1
Increments away from stop value


 -2
2
10
First increment is beyond stop value


2
-2
1
Start more than stop: positive increment


2
2
1
Start equal stop: positive increment


2
2
-1
Start equal stop: negative increment


2
2
0
Start equal stop: zero increment


0
0
0
Start equal stop equal zero: zero increment

Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"#include <stdio.h>
 
#define TRUE 1
#define FALSE 0
 
typedef int bool;
 
typedef struct {
    int start, stop, incr;
    const char *comment;
} S;
 
S examples[9] = {
    {-2, 2, 1, ""Normal""},
    {-2, 2, 0, ""Zero increment""},
    {-2, 2, -1, ""Increments away from stop value""},
    {-2, 2, 10, ""First increment is beyond stop value""},
    {2, -2, 1, ""Start more than stop: positive increment""},
    {2, 2, 1, ""Start equal stop: positive increment""},
    {2, 2, -1, ""Start equal stop: negative increment""},
    {2, 2, 0, ""Start equal stop: zero increment""},
    {0, 0, 0, ""Start equal stop equal zero: zero increment""}
};
 
int main() {
    int i, j, c;
    bool empty;
    S s;
    const int limit = 10;
    for (i = 0; i < 9; ++i) {
        s = examples[i];
        printf(""%s\n"", s.comment);
        printf(""Range(%d, %d, %d) -> ["", s.start, s.stop, s.incr);
        empty = TRUE;
        for (j = s.start, c = 0; j <= s.stop && c < limit; j += s.incr, ++c) {
            printf(""%d "", j);
            empty = FALSE;
        }
        if (!empty) printf(""\b"");
        printf(""]\n\n"");
    }
    return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Number_reversal_game,Number reversal game,"Task

Given a jumbled list of the numbers   1   to   9   that are definitely   not   in
ascending order.

Show the list,   and then ask the player how many digits from the
left to reverse.

Reverse those digits,   then ask again,   until all the digits end up in ascending order.



The score is the count of the reversals needed to attain the ascending order.



Note: Assume the player's input does not need extra validation.



Related tasks

   Sorting algorithms/Pancake sort
   Pancake sorting.
   Topswops

",Python,"# version 1.1.2
 
def isAscending(a):
    for i in range(0, 8):
        if a[i]!= i + 1:
            return False
    return True
 
import random
count = 0
numbers = [0] * 9
numbers[0] = 2 + random.randint(0, 8) # this will ensure list isn't ascending
for i in range(1, 9):
    rn = 1 + random.randint(0, 8)
    while rn in numbers:
        rn = 1 + random.randint(0, 8)
    numbers[i] = rn
print(""Here's your first list : "", numbers)
while True:
    rev = int(input(""How many numbers from the left are to be reversed : ""))
    count += 1
    i = 0
    j = rev - 1
    while i < j:
        temp = numbers[i]
        numbers[i] = numbers[j]
        numbers[j] = temp
        i += 1
        j -= 1
    if isAscending(numbers):
        print(""Here's your final list : "", numbers)
        break
    print(""Here's your list now   : "", numbers)
print(""So you've completed the game with a score of "", count)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Fibonacci_word,Fibonacci word,"The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:

    Define   F_Word1   as   1
    Define   F_Word2   as   0
    Form     F_Word3   as   F_Word2     concatenated with   F_Word1    i.e.:   01
    Form     F_Wordn   as   F_Wordn-1   concatenated with   F_wordn-2



Task

Perform the above steps for     n = 37.

You may display the first few but not the larger values of   n.

{Doing so will get the task's author into trouble with them what be (again!).} 

Instead, create a table for   F_Words   1   to   37   which shows:

   The number of characters in the word
   The word's Entropy


Related tasks
 
   Fibonacci word/fractal
   Entropy
   Entropy/Narcissist

",Python,">>> import math
>>> from collections import Counter
>>> 
>>> def entropy(s):
...     p, lns = Counter(s), float(len(s))
...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
... 
>>> 
>>> def fibword(nmax=37):
...     fwords = ['1', '0']
...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))
...     def pr(n, fwords):
...         while len(fwords) < n:
...             fwords += [''.join(fwords[-2:][::-1])]
...         v = fwords[n-1]
...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))
...     for n in range(1, nmax+1): pr(n, fwords)
... 
>>> fibword()
N       Length Entropy    Fibword
  1          1         -0 1
  2          1         -0 0
  3          2          1 01
  4          3  0.9182958 010
  5          5  0.9709506 01001
  6          8   0.954434 01001010
  7         13  0.9612366 0100101001001
  8         21  0.9587119 <too long>
  9         34  0.9596869 <too long>
 10         55   0.959316 <too long>
 11         89  0.9594579 <too long>
 12        144  0.9594038 <too long>
 13        233  0.9594244 <too long>
 14        377  0.9594165 <too long>
 15        610  0.9594196 <too long>
 16        987  0.9594184 <too long>
 17       1597  0.9594188 <too long>
 18       2584  0.9594187 <too long>
 19       4181  0.9594187 <too long>
 20       6765  0.9594187 <too long>
 21      10946  0.9594187 <too long>
 22      17711  0.9594187 <too long>
 23      28657  0.9594187 <too long>
 24      46368  0.9594187 <too long>
 25      75025  0.9594187 <too long>
 26     121393  0.9594187 <too long>
 27     196418  0.9594187 <too long>
 28     317811  0.9594187 <too long>
 29     514229  0.9594187 <too long>
 30     832040  0.9594187 <too long>
 31    1346269  0.9594187 <too long>
 32    2178309  0.9594187 <too long>
 33    3524578  0.9594187 <too long>
 34    5702887  0.9594187 <too long>
 35    9227465  0.9594187 <too long>
 36   14930352  0.9594187 <too long>
 37   24157817  0.9594187 <too long>
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Population_count,Population count,"Population count

You are encouraged to solve this task according to the task description, using any language you may know.
The   population count   is the number of   1s   (ones)   in the binary representation of a non-negative integer.

Population count   is also known as:

   pop count
   popcount 
   sideways sum
   bit summation 
   Hamming weight 


For example,   5   (which is   101   in binary)   has a population count of   2.


Evil numbers   are non-negative integers that have an   even   population count.

Odious numbers     are  positive integers that have an    odd   population count.



Task

 write a function (or routine) to return the population count of a non-negative integer.
 all computation of the lists below should start with   0   (zero indexed).
 display the   pop count   of the   1st   thirty powers of   3       (30,   31,   32,   33,   34,   ∙∙∙   329).
 display the   1st   thirty     evil     numbers.
 display the   1st   thirty   odious   numbers.
 display each list of integers on one line   (which may or may not include a title),   each set of integers being shown should be properly identified.


See also
 The On-Line Encyclopedia of Integer Sequences:   A000120 population count.
 The On-Line Encyclopedia of Integer Sequences:   A000069 odious numbers.
 The On-Line Encyclopedia of Integer Sequences:   A001969 evil numbers.

",Python,">>> def popcount(n): return bin(n).count(""1"")
... 
>>> [popcount(3**i) for i in range(30)]
[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]
>>> evil, odious, i = [], [], 0
>>> while len(evil) < 30 or len(odious) < 30:
...     p = popcount(i)
...     if p % 2: odious.append(i)
...     else: evil.append(i)
...     i += 1
... 
>>> evil[:30]
[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]
>>> odious[:30]
[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Benford%27s_law,Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",Python,"import math
import numpy as np

def Fib1000():
    a, b, r = 0., 1., [1000]
    for i in range(len(r)):
        r[i], a, b = b, b, b+a
    return r

def show(c, title):
    f = [0] * 9
    for v in c:
        f[int(str(v)[0]) - 1] += 1
    print(title)
    print(""Digit  Observed  Predicted"")
    for i, n in enumerate(f):
        print(""  %d  %9.3f  %8.3f\n"" % (i+1, float(n)/float(len(c)),
            math.log10(1+1/float(i+1))))

show(Fib1000(), ""First 1000 Fibonacci numbers"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Parameterized_SQL_statement,Parameterized SQL statement,"SQL injection
Using a SQL update statement like this one (spacing is optional):

UPDATE players
   SET name = 'Smith, Steve', score = 42, active = TRUE
   WHERE jerseyNum = 99
Non-parameterized SQL is the GoTo statement of database programming. Don't do it, and make sure your coworkers don't either.",Python,"import sqlite3
 
db = sqlite3.connect(':memory:')
 
# setup
db.execute('create temp table players (name, score, active, jerseyNum)')
db.execute('insert into players values (""name"",0,""false"",99)')
db.execute('insert into players values (""name"",0,""false"",100)')
 
# demonstrate parameterized SQL
 
# example 1 -- simple placeholders
db.execute('update players set name=?, score=?, active=? where jerseyNum=?', ('Smith, Steve', 42, True, 99))
 
# example 2 -- named placeholders
db.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',
    {'num': 100,
     'name': 'John Doe',
     'active': False,
     'score': -1}
)
 
# and show the results
for row in db.execute('select * from players'):
   print(row)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Runtime_evaluation/In_an_environment,Runtime evaluation/In an environment,"x
x
x


Do so in a way which:

 does not involve string manipulation of the input source code
 is plausibly extensible to a runtime-chosen set of bindings rather than just x
 does not make x a global variable


or note that these are impossible.



See also

 For more general examples and language-specific details, see Eval.
 Dynamic variable names is a similar task.

",Python,"def evalWithX(expr, a, b):
    x = a
    atA = eval(expr)
    x = b
    atB = eval(expr)
    return atB - atA",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Recaman%27s_sequence,Recaman's sequence,"The Recamán's sequence generates Natural numbers.

Starting from a(0)=0, the n'th term a(n), where n>0, is the previous term minus n i.e a(n) = a(n-1) - n but only if this is both positive and has not been previousely generated.


If the conditions don't hold then a(n) = a(n-1) + n.



Task

 Generate and show here the first 15 members of the sequence.
 Find and show here, the first duplicated number in the sequence.
 Optionally: Find and show here, how many terms of the sequence are needed until all the integers 0..1000, inclusive, are generated.


References

 A005132, The On-Line Encyclopedia of Integer Sequences.
 The Slightly Spooky Recamán Sequence, Numberphile video.
 Recamán's sequence, on Wikipedia.

",Python,"from itertools import islice
 
class Recamans():
    ""Recamán's sequence generator callable class""
    def __init__(self):
        self.a = None   # Set of results so far
        self.n = None   # n'th term (counting from zero)
 
    def __call__(self):
        ""Recamán's sequence  generator""
        nxt = 0
        a, n = {nxt}, 0
        self.a = a
        self.n = n
        yield nxt
        while True:
            an1, n = nxt, n + 1
            nxt = an1 - n
            if nxt < 0 or nxt in a:
                nxt = an1 + n
            a.add(nxt)
            self.n = n
            yield nxt
 
if __name__ == '__main__':
    recamans = Recamans()
    print(""First fifteen members of Recamans sequence:"", 
          list(islice(recamans(), 15)))
 
    so_far = set()
    for term in recamans():
        if term in so_far:
            print(f""First duplicate number in series is: a({recamans.n}) = {term}"")
            break
        so_far.add(term)
 
    n = 1_000
    setn = set(range(n + 1))    # The target set of numbers to be covered
    for _ in recamans():
        if setn.issubset(recamans.a):
            print(f""Range 0 ..{n} is covered by terms up to a({recamans.n})"")
            break",Human_written,Python_from_Java
http://rosettacode.org/wiki/Numerical_integration,Numerical integration,"Write functions to calculate the definite integral of a function  ƒ(x)  using all five of the following methods:

 rectangular
 left
 right
 midpoint
 trapezium
 Simpson's
 composite
Your functions should take in the upper and lower bounds (a and b), and the number of approximations to make in that range (n).

Assume that your example already has a function that gives values for  ƒ(x) .

Simpson's method is defined by the following pseudo-code:


 Pseudocode: Simpson's method, composite



procedure quad_simpson_composite(f, a, b, n)
    h := (b - a) / n
    sum1 := f(a + h/2)
    sum2 := 0

    loop on i from 1 to (n - 1)
        sum1 := sum1 + f(a + h * i + h/2)
        sum2 := sum2 + f(a + h * i)
                                            
    answer := (h / 6) * (f(a) + f(b) + 4*sum1 + 2*sum2)




Demonstrate your function by showing the results for:

   ƒ(x) = x3,       where   x   is     [0,1],       with           100 approximations.   The exact result is     0.25               (or 1/4)
   ƒ(x) = 1/x,     where   x   is   [1,100],     with        1,000 approximations.   The exact result is     4.605170+     (natural log of 100)
   ƒ(x) = x,         where   x   is   [0,5000],   with 5,000,000 approximations.   The exact result is   12,500,000
   ƒ(x) = x,         where   x   is   [0,6000],   with 6,000,000 approximations.   The exact result is   18,000,000


See also

   Active object for integrating a function of real time.
   Special:PrefixIndex/Numerical integration for other integration methods.

",Python,"from fractions import Fraction
 
def left_rect(f,x,h):
  return f(x)
 
def mid_rect(f,x,h):
  return f(x + h/2)
 
def right_rect(f,x,h):
  return f(x+h)
 
def trapezium(f,x,h):
  return (f(x) + f(x+h))/2.0
 
def simpson(f,x,h):
  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0
 
def cube(x):
  return x*x*x
 
def reciprocal(x):
  return 1/x
 
def identity(x):
  return x
 
def integrate( f, a, b, steps, meth):
   h = (b-a)/steps
   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))
   return ival  
 
# Tests
for a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               integrate( func, a, b, steps, rule)))
    a, b = Fraction.from_float(a), Fraction.from_float(b)
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps and fractions) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               float(integrate( func, a, b, steps, rule))))
 
# Extra tests (compute intensive)
for a, b, steps, func in ((0., 5000., 5000000, identity),
                          (0., 6000., 6000000, identity)):
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               integrate( func, a, b, steps, rule)))
    a, b = Fraction.from_float(a), Fraction.from_float(b)
    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):
        print('%s integrated using %s\n  from %r to %r (%i steps and fractions) = %r' %
              (func.__name__, rule.__name__, a, b, steps,
               float(integrate( func, a, b, steps, rule))))",Human_written,Python_from_C
http://rosettacode.org/wiki/Count_in_factors,Count in factors,"Task

Write a program which counts up from   1,   displaying each number as the multiplication of its prime factors.

For the purpose of this task,   1   (unity)   may be shown as itself.



Example

      2   is prime,   so it would be shown as itself.

      6   is not prime;   it would be shown as   



2
×
3


{\displaystyle 2\times 3}

.
2144   is not prime;   it would be shown as   



2
×
2
×
2
×
2
×
2
×
67


{\displaystyle 2\times 2\times 2\times 2\times 2\times 67}

.



Related tasks

   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Python,"from functools import lru_cache
 
primes = [2, 3, 5, 7, 11, 13, 17]    # Will be extended
 
@lru_cache(maxsize=2000)
def pfactor(n):
    if n == 1:
        return [1]
    n2 = n // 2 + 1
    for p in primes:
        if p <= n2:
            d, m = divmod(n, p)
            if m == 0:
                if d > 1:
                    return [p] + pfactor(d)
                else:
                    return [p]
        else:
            if n > primes[-1]:
                primes.append(n)
            return [n]
 
if __name__ == '__main__':
    mx = 5000
    for n in range(1, mx + 1):
        factors = pfactor(n)
        if n <= 10 or n >= mx - 20:
            print( '%4i %5s %s' % (n,
                                   '' if factors != [n] or n == 1 else 'prime',
                                   'x'.join(str(i) for i in factors)) )
        if n == 11:
            print('...')
 
    print('\nNumber of primes gathered up to', n, 'is', len(primes))
    print(pfactor.cache_info())",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call,Exceptions/Catch an exception thrown in a nested call,"Show how to create a user-defined exception   and   show how to catch an exception raised from several nested calls away.

   Create two user-defined exceptions,   U0   and   U1. 
   Have function   foo   call function   bar   twice.
   Have function   bar   call function   baz. 
   Arrange for function   baz   to raise, or throw exception   U0   on its first call, then exception   U1   on its second.
   Function   foo   should catch only exception   U0,   not   U1.


Show/describe what happens when the program is run.



",Python,"import sys
def Main():
    i = 0
    print(i)
if __name__ == '__main__':
    Main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Mertens_function,Mertens function,"The Mertens function M(x) is the count of square-free integers up to x that have an even number of prime factors, minus the count of those that have an odd number.

It is an extension of the Möbius function. Given the Möbius function μ(n), the Mertens function M(x) is the sum of the Möbius numbers from n == 1 through n == x.



Task

 Write a routine (function, procedure, whatever) to find the Mertens number for any positive integer x.
 Use that routine to find and display here, on this page, at least the first 99 terms in a grid layout. (Not just one long line or column of numbers.)
 Use that routine to find and display here, on this page, the number of times the Mertens function sequence is equal to zero in the range M(1) through M(1000).
 Use that routine to find and display here, on this page, the number of times the Mertens function sequence crosses zero in the range M(1) through M(1000). (Crossing defined as this term equal to zero but preceding term not.)


See also

 Wikipedia: Mertens function
 Wikipedia: Möbius function
 OEIS: A002321 - Mertens's function
 OEIS: A028442 - Numbers n such that Mertens's function M(n) is zero
 Numberphile - Mertens Conjecture
 Stackexchange: compute the mertens function

This is not code golf.   The stackexchange link is provided as an algorithm reference, not as a guide.



Related tasks

 Möbius function

",Python,"def mertens(count):
    """"""Generate Mertens numbers""""""
    m = [None, 1]
    for n in range(2, count+1):
        m.append(1)
        for k in range(2, n+1):
            m[n] -= m[n//k]
    return m
 
 
ms = mertens(1000)
 
print(""The first 99 Mertens numbers are:"")
print(""  "", end=' ')
col = 1
for n in ms[1:100]:
    print(""{:2d}"".format(n), end=' ')
    col += 1
    if col == 10:
        print()
        col = 0
 
zeroes = sum(x==0 for x in ms)
crosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))
print(""M(N) equals zero {} times."".format(zeroes))
print(""M(N) crosses zero {} times."".format(crosses))",Human_written,Python_from_C
http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",Python,"class RelationalOperators:
    def main(self, args):
        print(1 < 2 and 1 > 2)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",Python,"import os
 
size = os.path.getsize('input.txt')
size = os.path.getsize('/input.txt')",Human_written,Python_from_Java
http://rosettacode.org/wiki/Object_serialization,Object serialization,"Create a set of data types based upon inheritance. Each data type or class should have a print command that displays the contents of an instance of that class to standard output. Create instances of each class in your inheritance hierarchy and display them to standard output. Write each of the objects to a file named objects.dat in binary form using serialization or marshalling. Read the file objects.dat and print the contents of each serialized object.
",Python,"# version 1.2.0
 
import java.io.*
 
open class Entity(val name: String = ""Entity""): Serializable {
    override fun toString() = name
 
    companion object {
        val serialVersionUID = 3504465751164822571L
    }
}
 
class Person(name: String = ""Brian""): Entity(name), Serializable {
    companion object {
        val serialVersionUID = -9170445713373959735L
    }
}
 
fun main(args: Array<String>) {
    val instance1 = Person()
    println(instance1)
 
    val instance2 = Entity()
    println(instance2)
 
    # serialize
    try {
        val out = ObjectOutputStream(FileOutputStream(""objects.dat""))
        out.writeObject(instance1)
        out.writeObject(instance2)
        out.close()
        println(""Serialized..."")
    }
    catch (e: IOException) {
        println(""Error occurred whilst serializing"")
        System.exit(1)
    }
 
    # deserialize 
    try {
        val inp = ObjectInputStream(FileInputStream(""objects.dat""))
        val readObject1 = inp.readObject()
        val readObject2 = inp.readObject()
        inp.close()
        println(""Deserialized..."")
        println(readObject1)
        println(readObject2)        
    }
    catch (e: IOException) {
        println(""Error occurred whilst deserializing"")
        System.exit(1)
    }
    catch (e: ClassNotFoundException) {
        println(""Unknown class for deserialized object"")
        System.exit(1)
    }
}",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Canonicalize_CIDR,Canonicalize CIDR,"Task

Implement a function or program that, given a range of IPv4 addresses in CIDR notation (dotted-decimal/network-bits), will return/output the same range in canonical form.

That is, the IP address portion of the output CIDR block must not contain any set (1) bits in the host part of the address.



Example

Given   87.70.141.1/22,   your code should output   87.70.140.0/22



Explanation

An Internet Protocol version 4 address is a 32-bit value, conventionally represented as a number in base 256 using dotted-decimal notation, where each base-256 ""digit"" is represented by the digit value in decimal and the digits are separated by periods. Logically, this 32-bit value represents two components: the leftmost (most-significant) bits determine the ""network"" portion of the address, while the rightmost (least-significant) bits determine the ""host"" portion. Classless Internet Domain Routing block notation indicates where the boundary between these two components is for a given address by adding a slash followed by the number of bits in the network portion.

In general, CIDR blocks stand in for the entire set of IP addresses sharing the same ""network"" component; it's common to see access control lists specify a single IP address using CIDR with /32 to indicate that only the one address is included. Often, the tools using this notation expect the address to be entered in canonical form, in which the ""host"" bits are all zeroes in the binary representation. But careless network admins may provide CIDR blocks without canonicalizing them first. This task handles the canonicalization.

The example address, 87.70.141.1, translates into 01010111010001101000110100000001 in binary notation zero-padded to 32 bits. The /22 means that the first 22 of those bits determine the match; the final 10 bits should be 0. But they instead include two 1 bits: 0100000001. So to canonicalize the address, change those 1's to 0's to yield 01010111010001101000110000000000, which in dotted-decimal is 87.70.140.0.



More examples for testing
        36.18.154.103/12    →  36.16.0.0/12
        62.62.197.11/29     →  62.62.197.8/29
        67.137.119.181/4    →  64.0.0.0/4
        161.214.74.21/24    →  161.214.74.0/24
        184.232.176.184/18  →  184.232.128.0/18


",Python,"import ipaddress
import sys
 
def canonicalize(cidr):
    ip = ipaddress.ip_network(cidr)
    return str(ip.network_address) + ""/"" + str(ip.prefixlen)
 
if __name__ == ""__main__"":
    tests = [
        ""87.70.141.1/22"",
        ""36.18.154.103/12"",
        ""62.62.197.11/29"",
        ""67.137.119.181/4"",
        ""161.214.74.21/24"",
        ""184.232.176.184/18"",
    ]
 
    for test in tests:
        print(f""{test:18} -> {canonicalize(test)}"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Walk_a_directory/Recursively,Walk a directory/Recursively,"Task

Walk a given directory tree and print files matching a given pattern.


Note: This task is for recursive methods.   These tasks should read an entire directory tree, not a single directory.


Note: Please be careful when running any code examples found here.



Related task

   Walk a directory/Non-recursively   (read a single directory). 

",Python,"import shapely.geometry
 
poly = shapely.geometry.Polygon([(0, 0), (10, 0), (10, 10), (0, 10)])
print poly.area",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Diversity_prediction_theorem,Diversity prediction theorem,"The   wisdom of the crowd   is the collective opinion of a group of individuals rather than that of a single expert.

Wisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise,   an explanation that assumes independence of the individual judgments from each other.

Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.



Scott E. Page introduced the diversity prediction theorem:

 The squared error of the collective prediction equals the average squared error minus the predictive diversity. 


Therefore,   when the diversity in a group is large,   the error of the crowd is small.



Definitions

   Average Individual Error:   Average of the individual squared errors
   Collective Error:   Squared error of the collective prediction
   Prediction Diversity:   Average squared distance from the individual predictions to the collective prediction
   Diversity Prediction Theorem:   Given a crowd of predictive models,     then
   Collective Error   =   Average Individual Error   ─   Prediction Diversity
Task

For a given   true   value and a number of number of estimates (from a crowd),   show   (here on this page):

   the true value   and   the crowd estimates
   the average error
   the crowd error
   the prediction diversity


Use   (at least)   these two examples:

   a true value of   49   with crowd estimates of:    48   47   51
   a true value of   49   with crowd estimates of:    48   47   51   42


Also see

   Wikipedia entry:   Wisdom of the crowd
   University of Michigan: PDF paper         (exists on a web archive,   the Wayback Machine).

",Python,"'''Diversity prediction theorem'''
 
from itertools import chain
from functools import reduce
 
 
#  diversityValues :: Num a => a -> [a] ->
#  { mean-Error :: a, crowd-error :: a, diversity :: a }
def diversityValues(x):
    '''The mean error, crowd error and
       diversity, for a given observation x
       and a non-empty list of predictions ps.
    '''
    def go(ps):
        mp = mean(ps)
        return {
            'mean-error': meanErrorSquared(x)(ps),
            'crowd-error': pow(x - mp, 2),
            'diversity': meanErrorSquared(mp)(ps)
        }
    return go
 
 
# meanErrorSquared :: Num -> [Num] -> Num
def meanErrorSquared(x):
    '''The mean of the squared differences
       between the observed value x and
       a non-empty list of predictions ps.
    '''
    def go(ps):
        return mean([
            pow(p - x, 2) for p in ps
        ])
    return go
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    '''Observed value: 49,
       prediction lists: various.
    '''
 
    print(unlines(map(
        showDiversityValues(49),
        [
            [48, 47, 51],
            [48, 47, 51, 42],
            [50, '?', 50, {}, 50],  # Non-numeric values.
            []                      # Missing predictions.
        ]
    )))
    print(unlines(map(
        showDiversityValues('49'),  # String in place of number.
        [
            [50, 50, 50],
            [40, 35, 40],
        ]
    )))
 
 
# ---------------------- FORMATTING ----------------------
 
# showDiversityValues :: Num -> [Num] -> Either String String
def showDiversityValues(x):
    '''Formatted string representation
       of diversity values for a given
       observation x and a non-empty
       list of predictions p.
    '''
    def go(ps):
        def showDict(dct):
            w = 4 + max(map(len, dct.keys()))
 
            def showKV(a, kv):
                k, v = kv
                return a + k.rjust(w, ' ') + (
                    ' : ' + showPrecision(3)(v) + '\n'
                )
            return 'Predictions: ' + showList(ps) + ' ->\n' + (
                reduce(showKV, dct.items(), '')
            )
 
        def showProblem(e):
            return (
                unlines(map(indented(1), e)) if (
                    isinstance(e, list)
                ) else indented(1)(repr(e))
            ) + '\n'
 
        return 'Observation:  ' + repr(x) + '\n' + (
            either(showProblem)(showDict)(
                bindLR(numLR(x))(
                    lambda n: bindLR(numsLR(ps))(
                        compose(Right, diversityValues(n))
                    )
                )
            )
        )
    return go
 
 
# ------------------ GENERIC FUNCTIONS -------------------
 
# Left :: a -> Either a b
def Left(x):
    '''Constructor for an empty Either (option type) value
       with an associated string.
    '''
    return {'type': 'Either', 'Right': None, 'Left': x}
 
 
# Right :: b -> Either a b
def Right(x):
    '''Constructor for a populated Either (option type) value'''
    return {'type': 'Either', 'Left': None, 'Right': x}
 
 
# bindLR (>>=) :: Either a -> (a -> Either b) -> Either b
def bindLR(m):
    '''Either monad injection operator.
       Two computations sequentially composed,
       with any value produced by the first
       passed as an argument to the second.
    '''
    def go(mf):
        return (
            mf(m.get('Right')) if None is m.get('Left') else m
        )
    return go
 
 
# compose :: ((a -> a), ...) -> (a -> a)
def compose(*fs):
    '''Composition, from right to left,
       of a series of functions.
    '''
    def go(f, g):
        def fg(x):
            return f(g(x))
        return fg
    return reduce(go, fs, identity)
 
 
# concatMap :: (a -> [b]) -> [a] -> [b]
def concatMap(f):
    '''A concatenated list over which a function has been mapped.
       The list monad can be derived by using a function f which
       wraps its output in a list,
       (using an empty list to represent computational failure).
    '''
    def go(xs):
        return chain.from_iterable(map(f, xs))
    return go
 
 
# either :: (a -> c) -> (b -> c) -> Either a b -> c
def either(fl):
    '''The application of fl to e if e is a Left value,
       or the application of fr to e if e is a Right value.
    '''
    return lambda fr: lambda e: fl(e['Left']) if (
        None is e['Right']
    ) else fr(e['Right'])
 
 
# identity :: a -> a
def identity(x):
    '''The identity function.'''
    return x
 
 
# indented :: Int -> String -> String
def indented(n):
    '''String indented by n multiples
       of four spaces.
    '''
    return lambda s: (4 * ' ' * n) + s
 
# mean :: [Num] -> Float
def mean(xs):
    '''Arithmetic mean of a list
       of numeric values.
    '''
    return sum(xs) / float(len(xs))
 
 
# numLR :: a -> Either String Num
def numLR(x):
    '''Either Right x if x is a float or int,
       or a Left explanatory message.'''
    return Right(x) if (
        isinstance(x, (float, int))
    ) else Left(
        'Expected number, saw: ' + (
            str(type(x)) + ' ' + repr(x)
        )
    )
 
 
# numsLR :: [a] -> Either String [Num]
def numsLR(xs):
    '''Either Right xs if all xs are float or int,
       or a Left explanatory message.'''
    def go(ns):
        ls, rs = partitionEithers(map(numLR, ns))
        return Left(ls) if ls else Right(rs)
    return bindLR(
        Right(xs) if (
            bool(xs) and isinstance(xs, list)
        ) else Left(
            'Expected a non-empty list, saw: ' + (
                str(type(xs)) + ' ' + repr(xs)
            )
        )
    )(go)
 
 
# partitionEithers :: [Either a b] -> ([a],[b])
def partitionEithers(lrs):
    '''A list of Either values partitioned into a tuple
       of two lists, with all Left elements extracted
       into the first list, and Right elements
       extracted into the second list.
    '''
    def go(a, x):
        ls, rs = a
        r = x.get('Right')
        return (ls + [x.get('Left')], rs) if None is r else (
            ls, rs + [r]
        )
    return reduce(go, lrs, ([], []))
 
 
# showList :: [a] -> String
def showList(xs):
    '''Compact string representation of a list'''
    return '[' + ','.join(str(x) for x in xs) + ']'
 
 
# showPrecision :: Int -> Float -> String
def showPrecision(n):
    '''A string showing a floating point number
       at a given degree of precision.'''
    def go(x):
        return str(round(x, n))
    return go
 
 
# unlines :: [String] -> String
def unlines(xs):
    '''A single string derived by the intercalation
       of a list of strings with the newline character.'''
    return '\n'.join(xs)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Roman_numerals/Encode,Roman numerals/Encode,"Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero.



In Roman numerals:

 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
 2008 is written as 2000=MM, 8=VIII; or MMVIII
 1666 uses each Roman symbol in descending order: MDCLXVI

",Python,"import roman
print(roman.toRoman(2022))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Named_parameters,Named parameters,"Create a function which takes in a number of arguments which are specified by name rather than (necessarily) position, and show how to call the function. If the language supports reordering the arguments or optionally omitting some of them, note this.

Note:

 Named parameters relies on being able to use the names given to function parameters when the function is defined, when assigning arguments when the function is called.
 For example, if a function were to be defined as define func1( paramname1, paramname2); then it could be called normally as func1(argument1, argument2) and in the called function paramname1 would be associated with argument1 and paramname2 with argument2.
 func1 must also be able to be called in a way that visually binds each parameter to its respective argument, irrespective of argument order, for example: func1(paramname2=argument2, paramname1=argument1) which explicitly makes the same parameter/argument bindings as before.
 Named parameters are often a feature of languages used in safety critical areas such as Verilog and VHDL.
See also:

 Varargs
 Optional parameters
 Wikipedia: Named parameter

",Python,"processNutritionFacts(NutritionFacts.Builder(240, 8).calories(100).sodium(35).carbohydrate(27).build())",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Truncatable_primes,Truncatable primes,"A truncatable prime is a prime number that when you successively remove digits from one end of the prime, you are left with a new prime number.



Examples

The number 997 is called a left-truncatable prime as the numbers 997, 97, and 7 are all prime.

The number 7393 is a right-truncatable prime as the numbers 7393, 739, 73, and 7 formed by removing digits from its right are also prime.

No zeroes are allowed in truncatable primes.



Task

The task is to find the largest left-truncatable and right-truncatable primes less than one million (base 10 is implied).



Related tasks
 
 Find largest left truncatable prime in a given base
 Sieve of Eratosthenes


See also

 Truncatable Prime from MathWorld.]

",Python,"def is_prime(n):
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    if n % 3 == 0:
        return n == 3
    p = 5
    while p * p <= n:
        if n % p == 0:
            return False
        p += 2
        if n % p == 0:
            return False
        p += 4
    return True
 
def is_left_truncatable(p):
    n = 10
    q = p
    while p > n:
        if not is_prime(p % n) or q == p % n:
            return False
        q = p % n
        n *= 10
    return True
 
def is_right_truncatable(p):
    q = p / 10
    while q > 0:
        if not is_prime(q):
            return False
        q /= 10
    return True
 
limit = 1000000
largest_left = 0
largest_right = 0
p = limit
while p >= 2:
    if is_prime(p) and is_left_truncatable(p):
        largest_left = p
        break
    p -= 1
print(""Largest left truncatable prime is {}"".format(largest_left))
p = limit
while p >= 2:
    if is_prime(p) and is_right_truncatable(p):
        largest_right = p
        break
    p -= 1
print(""Largest right truncatable prime is {}"".format(largest_right))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Draw_a_rotating_cube,Draw a rotating cube,"Task
Draw a rotating cube.

It should be oriented with one vertex pointing straight up, and its opposite vertex on the main diagonal (the one farthest away) straight down. It can be solid or wire-frame, and you can use ASCII art if your language doesn't have graphical capabilities. Perspective is optional.




Related tasks
 Draw a cuboid
 write language name in 3D ASCII

",Python,"# version 1.1
 
import math
import tkinter as tk
 
class RotatingCube(tk.Canvas):
    def __init__(self, master):
        super().__init__(master, width=640, height=640, bg='white')
        self.nodes = [
            [-1.0, -1.0, -1.0],
            [-1.0, -1.0,  1.0],
            [-1.0,  1.0, -1.0],
            [-1.0,  1.0,  1.0],
            [ 1.0, -1.0, -1.0],
            [ 1.0, -1.0,  1.0],
            [ 1.0,  1.0, -1.0],
            [ 1.0,  1.0,  1.0]
        ]
        self.edges = [
            [0, 1],
            [1, 3],
            [3, 2],
            [2, 0],
            [4, 5],
            [5, 7],
            [7, 6],
            [6, 4],
            [0, 4],
            [1, 5],
            [2, 6],
            [3, 7]
        ]
        self.scale(100.0)
        self.rotate_cube(math.pi / 4.0, math.atan(math.sqrt(2.0)))
        self.after(17, self.rotate_cube_and_repaint)
 
    def scale(self, s):
        for node in self.nodes:
            node[0] *= s
            node[1] *= s
            node[2] *= s
 
    def rotate_cube(self, angle_x, angle_y):
        sin_x = math.sin(angle_x)
        cos_x = math.cos(angle_x)
        sin_y = math.sin(angle_y)
        cos_y = math.cos(angle_y)
        for node in self.nodes:
            x = node[0]
            y = node[1]
            z = node[2]
            node[0] = x * cos_x - z * sin_x
            node[2] = z * cos_x + x * sin_x
            z = node[2]
            node[1] = y * cos_y - z * sin_y
            node[2] = z * cos_y + y * sin_y
 
    def rotate_cube_and_repaint(self):
        self.rotate_cube(math.pi / 180.0, 0.0)
        self.draw_cube()
        self.after(17, self.rotate_cube_and_repaint)
 
    def draw_cube(self):
        self.delete('all')
        for edge in self.edges:
            xy1 = self.nodes[edge[0]]
            xy2 = self.nodes[edge[1]]
            self.create_line(round(xy1[0]) + 320, round(xy1[1]) + 320,
                             round(xy2[0]) + 320, round(xy2[1]) + 320,
                             fill='blue')
        for node in self.nodes:
            self.create_oval(round(node[0]) + 316, round(node[1]) + 316,
                             round(node[0]) + 324, round(node[1]) + 324,
                             fill='blue')
 
if __name__ == '__main__':
    root = tk.Tk()
    root.title('Rotating cube')
    root.resizable(False, False)
    RotatingCube(root).pack()
    root.mainloop()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm,Trabb Pardo–Knuth algorithm,"The TPK algorithm is an early example of a programming chrestomathy.
It was used in Donald Knuth and Luis Trabb Pardo's Stanford tech report The Early Development of Programming Languages.
The report traces the early history of work in developing computer languages in the 1940s and 1950s, giving several translations of the algorithm.

From the wikipedia entry:

ask for 11 numbers to be read into a sequence S
reverse sequence S
for each item in sequence S
    result := call a function to do an operation
    if result overflows
        alert user
    else
        print result

The task is to implement the algorithm:

 Use the function:     



f
(
x
)
=

|

x


|


0.5


+
5

x

3




{\displaystyle f(x)=|x|^{0.5}+5x^{3}}


 The overflow condition is an answer of greater than 400.
 The 'user alert' should not stop processing of other items of the sequence.
 Print a prompt before accepting eleven, textual, numeric inputs.
 You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
 The sequence    S    may be 'implied' and so not shown explicitly.
 Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).

",Python,"import sys
 
def op(x):
    y = abs(x) ** 0.5 + 5 * x * x * x
    if y < 400:
        return y
    else:
        return None
 
xs = [float(x) for x in sys.stdin.readlines()]
 
for x in reversed(xs):
    y = op(x)
    if y is not None:
        print(y)
    else:
        print(""overflow"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",Python,"'''Hilbert curve'''
 
from itertools import (chain, islice)
 
 
# hilbertCurve :: Int -> SVG String
def hilbertCurve(n):
    '''An SVG string representing a
       Hilbert curve of degree n.
    '''
    w = 1024
    return svgFromPoints(w)(
        hilbertPoints(w)(
            hilbertTree(n)
        )
    )
 
 
# hilbertTree :: Int -> Tree Char
def hilbertTree(n):
    '''Nth application of a rule to a seedling tree.'''
 
    # rule :: Dict Char [Char]
    rule = {
        'a': ['d', 'a', 'a', 'b'],
        'b': ['c', 'b', 'b', 'a'],
        'c': ['b', 'c', 'c', 'd'],
        'd': ['a', 'd', 'd', 'c']
    }
 
    # go :: Tree Char -> Tree Char
    def go(tree):
        c = tree['root']
        xs = tree['nest']
        return Node(c)(
            map(go, xs) if xs else map(
                flip(Node)([]),
                rule[c]
            )
        )
    seed = Node('a')([])
    return list(islice(
        iterate(go)(seed), n
    ))[-1] if 0 < n else seed
 
 
# hilbertPoints :: Int -> Tree Char -> [(Int, Int)]
def hilbertPoints(w):
    '''Serialization of a tree to a list of points
       bounded by a square of side w.
    '''
 
    # vectors :: Dict Char [(Int, Int)]
    vectors = {
        'a': [(-1, 1), (-1, -1), (1, -1), (1, 1)],
        'b': [(1, -1), (-1, -1), (-1, 1), (1, 1)],
        'c': [(1, -1), (1, 1), (-1, 1), (-1, -1)],
        'd': [(-1, 1), (1, 1), (1, -1), (-1, -1)]
    }
 
    # points :: Int -> ((Int, Int), Tree Char) -> [(Int, Int)]
    def points(d):
        '''Size -> Centre of a Hilbert subtree -> All subtree points
        '''
        def go(xy, tree):
            r = d // 2
 
            def deltas(v):
                return (
                    xy[0] + (r * v[0]),
                    xy[1] + (r * v[1])
                )
            centres = map(deltas, vectors[tree['root']])
            return chain.from_iterable(
                map(points(r), centres, tree['nest'])
            ) if tree['nest'] else centres
        return go
 
    d = w // 2
    return lambda tree: list(points(d)((d, d), tree))
 
 
# svgFromPoints :: Int -> [(Int, Int)] -> SVG String
def svgFromPoints(w):
    '''Width of square canvas -> Point list -> SVG string'''
 
    def go(xys):
        def points(xy):
            return str(xy[0]) + ' ' + str(xy[1])
        xs = ' '.join(map(points, xys))
        return '\n'.join(
            ['<svg xmlns=""http://www.w3.org/2000/svg""',
             f'width=""512"" height=""512"" viewBox=""5 5 {w} {w}"">',
             f'<path d=""M{xs}"" ',
             'stroke-width=""2"" stroke=""red"" fill=""transparent""/>',
             '</svg>'
             ]
        )
    return go
 
 
# ------------------------- TEST --------------------------
def main():
    '''Testing generation of the SVG for a Hilbert curve'''
    print(
        hilbertCurve(6)
    )
 
 
# ------------------- GENERIC FUNCTIONS -------------------
 
# Node :: a -> [Tree a] -> Tree a
def Node(v):
    '''Contructor for a Tree node which connects a
       value of some kind to a list of zero or
       more child trees.'''
    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}
 
 
# flip :: (a -> b -> c) -> b -> a -> c
def flip(f):
    '''The (curried or uncurried) function f with its
       arguments reversed.
    '''
    return lambda a: lambda b: f(b)(a)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
#  TEST ---------------------------------------------------
if __name__ == '__main__':
    main()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"import random

def bogo(arr):
    while not is_sorted(arr):
        random.shuffle(arr)

def is_sorted(arr):
    for i in range(len(arr) - 1):
        if arr[i] > arr[i + 1]:
            return False
    return True

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
bogo(arr)
print(arr)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sort_three_variables,Sort three variables,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort   (the values of)   three variables   (X,   Y,   and   Z)   that contain any value   (numbers and/or literals).

If that isn't possible in your language, then just sort numbers   (and note if they can be floating point, integer, or other).

I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  'lions, tigers, and'
                        y =  'bears, oh my!'
                        z =  '(from the ""Wizard of OZ"")'

After sorting, the three variables would hold:

                        x =  '(from the ""Wizard of OZ"")'
                        y =  'bears, oh my!'
                        z =  'lions, tigers, and'

For numeric value sorting, use:
I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  77444
                        y =    -12
                        z =      0

After sorting, the three variables would hold:

                        x =    -12
                        y =      0
                        z =  77444

The variables should contain some form of a number, but specify if the algorithm
used can be for floating point or integers.   Note any limitations.

The values may or may not be unique.

The method used for sorting can be any algorithm;   the goal is to use the most idiomatic in the computer programming language used.

More than one algorithm could be shown if one isn't clearly the better choice.



One algorithm could be:

                        •  store the three variables   x, y, and z
                                 into an array (or a list)   A
                         
                        •  sort  (the three elements of)  the array   A
                         
                        •  extract the three elements from the array and place them in the
                                 variables x, y, and z   in order of extraction



Another algorithm   (only for numeric values):

       x= 77444 
       y=   -12 
       z=     0      
    low= x                                          
    mid= y                                          
   high= z 
      x= min(low,  mid,  high)            /*determine the lowest value of X,Y,Z. */    
      z= max(low,  mid,  high)            /*    ""      ""  highest  ""    "" "" "" ""  */    
      y=     low + mid + high - x - z     /*    ""      ""  middle   ""    "" "" "" ""  */      



Show the results of the sort here on this page using at least the values of those shown above.



",Python,"# version 1.1.2
 
def sortThree(x, y, z):
    a = [x, y, z]
    a.sort()
    return (a[0], a[1], a[2])
 
def printThree(x, y, z):
    print(""x = {}\ny = {}\nz = {}\n"".format(x, y, z))
 
if __name__ == ""__main__"":
    x = ""lions, tigers, and""
    y = ""bears, oh my!""
    z = """"""(from the ""Wizard of OZ"")""""""
    t = sortThree(x, y, z)
    x = t[0]
    y = t[1]
    z = t[2]
    printThree(x, y, z)
 
    x2 = 77444
    y2 = -12
    z2 = 0 
    t2 = sortThree(x2, y2, z2)
    x2 = t2[0]
    y2 = t2[1]
    z2 = t2[2]
    printThree(x2, y2, z2)
 
    x3 = 174.5
    y3 = -62.5
    z3 = 41.7
    t3 = sortThree(x3, y3, z3)
    x3 = t3[0]
    y3 = t3[1]
    z3 = t3[2]
    printThree(x3, y3, z3)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/ISBN13_check_digit,ISBN13 check digit,"Task

Validate the check digit of an ISBN-13 code:

   Multiply every other digit by  3.
   Add these numbers and the other digits.
   Take the remainder of this number after division by  10.
   If it is  0,   the ISBN-13 check digit is correct.


Use the following codes for testing:

   978-1734314502       (good)
   978-1734314509         (bad)
   978-1788399081       (good)
   978-1788399083         (bad)


Show output here, on this page



See also

   for details:   13-digit ISBN method of validation.       (installs cookies.)

",Python,"def check_isbn13(isbn):
    ch = isbn[0]
    count = 0
    sum = 0
    # check isbn contains 13 digits and calculate weighted sum
    for ch in isbn:
        # skip hyphens or spaces
        if ch =='' or ch == '-':
            count -= 1
            continue
        if ch < '0' or ch > '9':
            return 0
        if count & 1:
            sum += 3 * (ch - '0')
        else:
            sum += ch - '0'
        count += 1
    if count!= 13:
        return 0
    return not (sum%10)
 
isbns = [""978-1734314502"", ""978-1734314509"", ""978-1788399081"", ""978-1788399083""]
for isbn in isbns:
    print(isbn, "":"", ""good"" if check_isbn13(isbn) else ""bad"")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import deque

queue = deque()
print(len(queue) == 0)  # empty test - True
# queue.remove()       # would throw NoSuchElementException
queue.append(1)
queue.append(2)
queue.append(3)
print(queue)            # deque([1, 2, 3])
print(queue.popleft())  # 1
print(queue)            # deque([2, 3])
print(len(queue) == 0)  # False",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/JortSort,JortSort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 Note:   jortSort is considered a work of satire.   It achieves its result in an intentionally roundabout way.   You are encouraged to write your solutions in the spirit of the original jortsort rather than trying to give the most concise or idiomatic solution.



JortSort is a sorting tool set that makes the user do the work and guarantees efficiency because you don't have to sort ever again.

It was originally presented by Jenn ""Moneydollars"" Schiffer at the
prestigious   JSConf.



JortSort is a function that takes a single array of comparable objects as its argument.

It then sorts the array in ascending order and compares the sorted array to the originally provided array.

If the arrays match   (i.e. the original array was already sorted),   the function returns   true.

If the arrays do not match (i.e. the original array was not sorted), the function returns   false.



",Python,"def jort_sort(a):
    c = a[:]
    c.sort()
    for k, v in enumerate(a):
        if v == c[k]:
            continue
        else:
            return False
    return True

print(jort_sort([1, 2, 1, 11, 213, 2, 4])) #false
print(jort_sort([0, 1, 0, 0, 0, 0]))       #false 
print(jort_sort([1, 2, 4, 11, 22, 22]))    #true
print(jort_sort([0, 0, 0, 1, 2, 2]))       #true",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Base64_decode_data,Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",Python,"import base64

raku_example = '
VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY2
9tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=
'
print(base64.b64decode(raku_example))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",Python,"import re
 
string = ""This is a string""
 
if re.search('string$', string):
    print(""Ends with string."")
 
string = re.sub("" a "", "" another "", string)
print(string)",Human_written,Python_from_C
http://rosettacode.org/wiki/Weird_numbers,Weird numbers,"In number theory, a weird number is a natural number that is abundant but not semiperfect (and therefore not perfect either).

In other words, the sum of the proper divisors of the number (divisors including 1 but not itself) is greater than the number itself (the number is abundant), but no subset of those divisors sums to the number itself (the number is not semiperfect).

For example:

 12 is not a weird number.
 It is abundant; its proper divisors 1, 2, 3, 4, 6 sum to 16 (which is > 12),
 but it is semiperfect, e.g.:     6 + 4 + 2 == 12.
 70 is a weird number.
 It is abundant; its proper divisors 1, 2, 5, 7, 10, 14, 35 sum to 74 (which is > 70),
 and there is no subset of proper divisors that sum to 70.


Task

Find and display, here on this page, the first 25 weird numbers.



Related tasks

 Abundant, deficient and perfect number classifications
 Proper divisors


See also

 OEIS: A006037 weird numbers
 Wikipedia: weird number
 MathWorld: weird number

",Python,"from functools import reduce
from itertools import takewhile
 
def divisors(n):
    divs = [1]
    divs2 = []
 
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            j = n // i
            divs.append(i)
            if i!= j:
                divs2.append(j)
 
    divs.reverse()
    divs2.extend(divs)
    return divs2
 
def abundant(n, divs):
    return sum(divs) > n
 
def semiperfect(n, divs):
    if len(divs) > 0:
        h = divs[0]
        t = divs[1:]
        if n < h:
            return semiperfect(n, t)
        else:
            return n == h or semiperfect(n - h, t) or semiperfect(n, t)
    else:
        return False
 
def sieve(limit):
    # false denotes abundant and not semi-perfect.
    # Only interested in even numbers >= 2
    w = [False] * limit
    for i in range(2, limit, 2):
        if w[i]:
            continue
        divs = divisors(i)
        if not abundant(i, divs):
            w[i] = True
        elif semiperfect(i, divs):
            for j in range(i, limit, i):
                w[j] = True
    return w
 
def main():
    w = sieve(17_000)
    count = 0
    max = 25
    print(""The first 25 weird numbers:"")
    for n in range(2, 17_000, 2):
        if not w[n]:
            print(n, end="" "")
            count += 1
            if count == max:
                break
    print()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Symmetric_difference,Symmetric difference,"Task
Given two sets A and B, compute 



(
A
∖
B
)
∪
(
B
∖
A
)
.


{\displaystyle (A\setminus B)\cup (B\setminus A).}



That is, enumerate the items that are in A or B but not both. This set is called the symmetric difference of A and B.

In other words: 



(
A
∪
B
)
∖
(
A
∩
B
)


{\displaystyle (A\cup B)\setminus (A\cap B)}

 (the set of items that are in at least one of A or B minus the set of items that are in both A and B).

Optionally, give the individual differences (



A
∖
B


{\displaystyle A\setminus B}

 and 



B
∖
A


{\displaystyle B\setminus A}

) as well.



Test cases
A = {John, Bob, Mary, Serena}
B = {Jim, Mary, John, Bob}



Notes
 If your code uses lists of items to represent sets then ensure duplicate items in lists are correctly handled. For example two lists representing sets of a = [""John"", ""Serena"", ""Bob"", ""Mary"", ""Serena""] and b = [""Jim"", ""Mary"", ""John"", ""Jim"", ""Bob""] should produce the result of just two strings: [""Serena"", ""Jim""], in any order.
 In the mathematical notation above A \ B gives the set of items in A that are not in B; A ∪ B gives the set of items in both A and B, (their union); and A ∩ B gives the set of items that are in both A and B (their intersection).

",Python,">>> setA = {""John"", ""Bob"", ""Mary"", ""Serena""}
>>> setB = {""Jim"", ""Mary"", ""John"", ""Bob""}
>>> setA ^ setB # symmetric difference of A and B
{'Jim', 'Serena'}
>>> setA - setB # elements in A that are not in B
{'Serena'}
>>> setB - setA # elements in B that are not in A
{'Jim'}
>>> setA | setB # elements in A or B (union)
{'John', 'Bob', 'Jim', 'Serena', 'Mary'}
>>> setA & setB # elements in both A and B (intersection)
{'Bob', 'John', 'Mary'}",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Empty_directory,Empty directory,"Starting with a path to some directory, determine whether the directory is empty.

An empty directory contains no files nor subdirectories.
With Unix or Windows systems, every directory contains an entry for “.” and almost every directory contains “..” (except for a root directory); an empty directory contains no other entries.
",Python,"import os;
if os.listdir(raw_input(""directory"")):
    print ""not empty""
else:
    print ""empty""",Human_written,Python_from_Rust
http://rosettacode.org/wiki/XML/Output,XML/Output,"Create a function that takes a list of character names and a list of corresponding remarks and returns an XML document of <Character> elements each with a name attributes and each enclosing its remarks.
All <Character> elements are to be enclosed in turn, in an outer <CharacterRemarks> element.

As an example, calling the function with the three names of:

April
Tam O'Shanter
Emily
And three remarks of:

Bubbly: I'm > Tam and <= Emily
Burns: ""When chapman billies leave the street ...""
Short & shrift
Should produce the XML (but not necessarily with the indentation):

<CharacterRemarks>
    <Character name=""April"">Bubbly: I'm &gt; Tam and &lt;= Emily</Character>
    <Character name=""Tam O'Shanter"">Burns: ""When chapman billies leave the street ...""</Character>
    <Character name=""Emily"">Short &amp; shrift</Character>
</CharacterRemarks>
The document may include an <?xml?> declaration and document type declaration, but these are optional. If attempting this task by direct string manipulation, the implementation must include code to perform entity substitution for the characters that have entities defined in the XML 1.0 specification.

Note: the example is chosen to show correct escaping of XML strings.
Note too that although the task is written to take two lists of corresponding data, a single mapping/hash/dictionary of names to remarks is also acceptable.

Note to editors: Program output with escaped characters will be viewed as the character on the page so you need to 'escape-the-escapes' to make the RC entry display what would be shown in a plain text viewer (See this).
Alternately, output can be placed in <lang xml></lang> tags without any special treatment.
",Python,">>> from xml.etree import ElementTree as ET
>>> from itertools import izip
>>> def characterstoxml(names, remarks):
	root = ET.Element(""CharacterRemarks"")
	for name, remark in izip(names, remarks):
		c = ET.SubElement(root, ""Character"", {'name': name})
		c.text = remark
	return ET.tostring(root)
 
>>> print characterstoxml(
	names = [""April"", ""Tam O'Shanter"", ""Emily""],
	remarks = [ ""Bubbly: I'm > Tam and <= Emily"",
		    'Burns: ""When chapman billies leave the street ...""',
		    'Short & shrift' ] ).replace('><','>\n<')",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",Python,"import math
 
x = 1.5 # type of x determined by literal
# that this compiles demonstrates that NaN returns same type as x,
# the type specified by the task.
x = math.nan                     # test function
print(x, math.isnan(x)) # demonstrate result",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/AKS_test_for_primes,AKS test for primes,"The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

   a number   



p


{\displaystyle p}

   is prime   if and only if   all the coefficients of the polynomial expansion of
 



(
x
−
1

)

p


−
(

x

p


−
1
)


{\displaystyle (x-1)^{p}-(x^{p}-1)}


are divisible by   



p


{\displaystyle p}

.



Example

Using   



p
=
3


{\displaystyle p=3}

:

         (x-1)^3 - (x^3 - 1)
            = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
            = -3x^2 + 3x



And all the coefficients are divisible by 3,   so 3 is prime.





 Note:
This task is not the AKS primality test.   It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.



Task



 Create a function/subroutine/method that given   



p


{\displaystyle p}

   generates the coefficients of the expanded polynomial representation of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

.
 Use the function to show here the polynomial expansions of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

   for   



p


{\displaystyle p}

   in the range   0   to at least   7,   inclusive.
 Use the previous function in creating another function that when given   



p


{\displaystyle p}

   returns whether   



p


{\displaystyle p}

   is prime using the theorem.
 Use your test to generate a list of all primes under   35.
 As a stretch goal,   generate all primes under   50   (needs integers larger than 31-bit).


References

 Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) 
 Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed -- at best it is an oversimplification.

",Python,"import sys
c = [0] * 100
def coef(n):
    if n < 0 or n > 63:
        sys.exit(0)
    for i in range(0, n):
        c[0] = -c[0]
        for j in range(i, 0, -1):
            c[j] = c[j - 1] - c[j]
    c[0] = 1
def is_prime(n):
    coef(n)
    c[0] += 1
    c[n] -= 1
    i = n
    while i > 0 and c[i] % n == 0:
        i -= 1
    return i < 0
def show(n):
    while n > 0:
        print(""+"", c[n], ""x^"", n, sep="""", end="""")
        n -= 1
for n in range(0, 10):
    coef(n)
    print(""(x-1)^"", n, "" = "", sep="""", end="""")
    show(n)
    print()
print(""Primes:"", end="""")
for n in range(1, 64):
    if is_prime(n):
        print(n, end="" "")
print()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Cramer%27s_rule,Cramer's rule,"linear algebra
Cramer's rule
system of linear equations


Given


 




{





a

1


x
+

b

1


y
+

c

1


z


=



d

1









a

2


x
+

b

2


y
+

c

2


z


=



d

2









a

3


x
+

b

3


y
+

c

3


z


=



d

3












{\displaystyle \left\{{\begin{matrix}a_{1}x+b_{1}y+c_{1}z&={\color {red}d_{1}}\\a_{2}x+b_{2}y+c_{2}z&={\color {red}d_{2}}\\a_{3}x+b_{3}y+c_{3}z&={\color {red}d_{3}}\end{matrix}}\right.}




which in matrix format is



 





[




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





]




[



x




y




z



]


=


[






d

1











d

2











d

3







]


.


{\displaystyle {\begin{bmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{bmatrix}}{\begin{bmatrix}x\\y\\z\end{bmatrix}}={\begin{bmatrix}{\color {red}d_{1}}\\{\color {red}d_{2}}\\{\color {red}d_{3}}\end{bmatrix}}.}




Then the values of 



x
,
y


{\displaystyle x,y}

 and 



z


{\displaystyle z}

 can be found as follows:







x
=



|






d

1







b

1





c

1









d

2







b

2





c

2









d

3







b

3





c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

y
=



|




a

1







d

1







c

1







a

2







d

2







c

2







a

3







d

3







c

3





|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



,

 and 

z
=



|




a

1





b

1







d

1









a

2





b

2







d

2









a

3





b

3







d

3







|


|




a

1





b

1





c

1







a

2





b

2





c

2







a

3





b

3





c

3





|



.


{\displaystyle x={\frac {\begin{vmatrix}{\color {red}d_{1}}&b_{1}&c_{1}\\{\color {red}d_{2}}&b_{2}&c_{2}\\{\color {red}d_{3}}&b_{3}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},\quad y={\frac {\begin{vmatrix}a_{1}&{\color {red}d_{1}}&c_{1}\\a_{2}&{\color {red}d_{2}}&c_{2}\\a_{3}&{\color {red}d_{3}}&c_{3}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}},{\text{ and }}z={\frac {\begin{vmatrix}a_{1}&b_{1}&{\color {red}d_{1}}\\a_{2}&b_{2}&{\color {red}d_{2}}\\a_{3}&b_{3}&{\color {red}d_{3}}\end{vmatrix}}{\begin{vmatrix}a_{1}&b_{1}&c_{1}\\a_{2}&b_{2}&c_{2}\\a_{3}&b_{3}&c_{3}\end{vmatrix}}}.}






Task
Given the following system of equations:









{



2
w
−
x
+
5
y
+
z
=
−
3




3
w
+
2
x
+
2
y
−
6
z
=
−
32




w
+
3
x
+
3
y
−
z
=
−
47




5
w
−
2
x
−
3
y
+
3
z
=
49








{\displaystyle {\begin{cases}2w-x+5y+z=-3\\3w+2x+2y-6z=-32\\w+3x+3y-z=-47\\5w-2x-3y+3z=49\\\end{cases}}}




solve for 



w


{\displaystyle w}

, 



x


{\displaystyle x}

, 



y


{\displaystyle y}

 and 



z


{\displaystyle z}

, using Cramer's rule.



",Python,"import numpy as np

m = np.array([[2, -1, 5, 1],
              [3, 2, 2, -6],
              [1, 3, 3, -1],
              [5, -2, -3, 3]])

v = np.array([-3, -32, -47, 49])

x = np.linalg.solve(m, v)

print(x)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/SHA-256,SHA-256,"SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string ""Rosetta code"" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
",Python,"import hashlib
 
def hex_string(input):
    return ''.join(format(x, 'x') for x in input)
 
def main():
    # create a Sha256 object
    hasher = hashlib.sha256()
 
    # write input message
    hasher.update(b""Rosetta code"")
 
    # read hash digest and consume hasher
    result = hasher.digest()
 
    hex = hex_string(result)
 
    assert hex == ""764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf""
 
    print(hex)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Mad_Libs,Mad Libs,"

 This page uses content from Wikipedia. The original article was at Mad Libs. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Mad Libs is a phrasal template word game where one player prompts another for a list of words to substitute for blanks in a story, usually with funny results.



Task;
Write a program to create a Mad Libs like story.

The program should read an arbitrary multiline story from input.

The story will be terminated with a blank line.

Then, find each replacement to be made within the story, ask the user for a word to replace it with, and make all the replacements.

Stop when there are none left and print the final story.



The input should be an arbitrary story in the form:

<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.

Given this example, it should then ask for a name, a he or she and a noun (<name> gets replaced both times with the same value).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
# Optional Python 2.x compatibility
#try: input = raw_input
#except: pass
 
template = '''<name> went for a walk in the park. <he or she>
found a <noun>. <name> decided to take it home.'''
 
def madlibs(template):
    print('The story template is:\n' + template)
    fields = sorted(set( re.findall('<[^>]+>', template) ))
    values = input('\nInput a comma-separated list of words to replace the following items'
                   '\n  %s: ' % ','.join(fields)).split(',')
    story = template
    for f,v in zip(fields, values):
        story = story.replace(f, v)
    print('\nThe story becomes:\n\n' + story)
 
madlibs(template)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Modular_inverse,Modular inverse,"From Wikipedia:

In modular arithmetic,   the modular multiplicative inverse of an integer    a    modulo    m    is an integer    x    such that





a

x
≡
1


(
mod

m
)

.


{\displaystyle a\,x\equiv 1{\pmod {m}}.}


Or in other words, such that:





∃
k
∈

Z

,

a

x
=
1
+
k

m


{\displaystyle \exists k\in \mathbb {Z} ,\qquad a\,x=1+k\,m}


It can be shown that such an inverse exists   if and only if    a    and    m    are coprime,   but we will ignore this for this task.



Task

Either by implementing the algorithm, by using a dedicated library or by using a built-in function in
your language,   compute the modular inverse of   42 modulo 2017.



",Python,"# version 1.0.6
 
from math import gcd
 
def main():
    a = 42
    m = 2017
    print(mod_inverse(a, m))
 
def mod_inverse(a, m):
    g, x, y = egcd(a, m)
    if g!= 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
 
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Loops/N_plus_one_half,Loops/N plus one half,"Quite often one needs loops which, in the last iteration, execute only part of the loop body.



Goal

Demonstrate the best way to do this.



Task

Write a loop which writes the comma-separated list

1, 2, 3, 4, 5, 6, 7, 8, 9, 10

using separate output statements for the number
and the comma from within the body of the loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"print ( ', '.join(str(i+1) for i in range(10)) )",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,">>> def sort_disjoint_sublist(data, indices):
	indices = sorted(indices)
	values  = sorted(data[i] for i in indices)
	for index, value in zip(indices, values):
		data[index] = value
 
 
>>> d = [7, 6, 5, 4, 3, 2, 1, 0]
>>> i = set([6, 1, 7])
>>> sort_disjoint_sublist(d, i)
>>> d
[7, 0, 5, 4, 3, 2, 1, 6]
>>> # Which could be more cryptically written as:
>>> def sort_disjoint_sublist(data, indices):
	for index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value
 
 
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Variable-length_quantity,Variable-length quantity,"Implement some operations on variable-length quantities, at least including conversions from a normal number in the language to the binary representation of the variable-length quantity for that number, and vice versa. Any variants are acceptable.



Task

With above operations,

convert these two numbers 0x200000 (2097152 in decimal) and 0x1fffff (2097151 in decimal) into sequences of octets (an eight-bit byte); 
display these sequences of octets;
convert these sequences of octets back to numbers, and check that they are equal to original numbers.

",Python,"for i in range(0x200000, 0x1fffff):
    # Encode i => BER
    ber = i.to_bytes(3, byteorder='big')
    hex = ':'.join(['%02x' % c for c in ber])
    print(""%s => %s"" % (i, hex))

    # Decode BER => j
    j = int.from_bytes(ber, byteorder='big')
    if i!= j:
        raise Exception(""BER not preserve integer"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Variadic_function,Variadic function,"Task

Create a function which takes in a variable number of arguments and prints each one on its own line.

Also show, if possible in your language, how to call the function on a list of arguments constructed at runtime.



Functions of this type are also known as Variadic Functions.



Related task

   Call a function

",Python,"def print_all(*things):
    for x in things:
        print x",Human_written,Python_from_C
http://rosettacode.org/wiki/Diversity_prediction_theorem,Diversity prediction theorem,"The   wisdom of the crowd   is the collective opinion of a group of individuals rather than that of a single expert.

Wisdom-of-the-crowds research routinely attributes the superiority of crowd averages over individual judgments to the elimination of individual noise,   an explanation that assumes independence of the individual judgments from each other.

Thus the crowd tends to make its best decisions if it is made up of diverse opinions and ideologies.



Scott E. Page introduced the diversity prediction theorem:

 The squared error of the collective prediction equals the average squared error minus the predictive diversity. 


Therefore,   when the diversity in a group is large,   the error of the crowd is small.



Definitions

   Average Individual Error:   Average of the individual squared errors
   Collective Error:   Squared error of the collective prediction
   Prediction Diversity:   Average squared distance from the individual predictions to the collective prediction
   Diversity Prediction Theorem:   Given a crowd of predictive models,     then
   Collective Error   =   Average Individual Error   ─   Prediction Diversity
Task

For a given   true   value and a number of number of estimates (from a crowd),   show   (here on this page):

   the true value   and   the crowd estimates
   the average error
   the crowd error
   the prediction diversity


Use   (at least)   these two examples:

   a true value of   49   with crowd estimates of:    48   47   51
   a true value of   49   with crowd estimates of:    48   47   51   42


Also see

   Wikipedia entry:   Wisdom of the crowd
   University of Michigan: PDF paper         (exists on a web archive,   the Wayback Machine).

",Python,"# version 1.1.4-3
 
def square(d):
    return d * d
 
def averageSquareDiff(d, predictions):
    return sum(map(lambda x: square(x - d), predictions)) / len(predictions)
 
def diversityTheorem(truth, predictions):
    average = sum(predictions) / len(predictions)
    f = ""%6.3f""
    return ""average-error : "" + f % averageSquareDiff(truth, predictions) + ""\n"" + \
           ""crowd-error   : "" + f % square(truth - average) + ""\n"" + \
           ""diversity     : "" + f % averageSquareDiff(average, predictions) + ""\n""
 
print(diversityTheorem(49.0, [48.0, 47.0, 51.0]))
print(diversityTheorem(49.0, [48.0, 47.0, 51.0, 42.0]))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/RPG_attributes_generator,RPG attributes generator,"RPG   =   Role Playing Game.



You're running a tabletop RPG, and your players are creating characters.

Each character has six core attributes: strength, dexterity, constitution, intelligence, wisdom, and charisma.

One way of generating values for these attributes is to roll four, 6-sided dice (d6) and sum the three highest rolls, discarding the lowest roll.

Some players like to assign values to their attributes in the order they're rolled.

To ensure generated characters don't put players at a disadvantage, the following requirements must be satisfied:

 The total of all character attributes must be at least 75.
 At least two of the attributes must be at least 15.

However, this can require a lot of manual dice rolling. A programatic solution would be much faster.



Task

Write a program that:

 Generates 4 random, whole values between 1 and 6.
 Saves the sum of the 3 largest values.
 Generates a total of 6 values this way.
 Displays the total, and all 6 values once finished.

 The order in which each value was generated must be preserved.
 The total of all 6 values must be at least 75.
 At least 2 of the values must be 15 or more.
",Python,"import random
random.seed()
attributes_total = 0
count = 0
 
while attributes_total < 75 or count < 2:
    attributes = []
 
    for attribute in range(0, 6):
        rolls = []
 
        for roll in range(0, 4):
            result = random.randint(1, 6)
            rolls.append(result)
 
        sorted_rolls = sorted(rolls)
        largest_3 = sorted_rolls[1:]
        rolls_total = sum(largest_3)
 
        if rolls_total >= 15:
            count += 1
 
        attributes.append(rolls_total)
 
    attributes_total = sum(attributes)
 
print(attributes_total, attributes)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Here_document,Here document,"A   here document   (or ""heredoc"")   is a way of specifying a text block, preserving the line breaks, indentation and other whitespace within the text.

Depending on the language being used, a   here document   is constructed using a command followed by ""<<"" (or some other symbol) followed by a token string.

The text block will then start on the next line, and will be followed by the chosen token at the beginning of the following line, which is used to mark the end of the text block.



Task

Demonstrate the use of   here documents   within the language.

Related task

   Documentation

",Python,"print(""""""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
"""""")",Human_written,Python_from_C#
http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",Python,"import re
 
string = ""This is a string""
 
if re.search('string$', string):
    print(""Ends with string."")
 
string = re.sub("" a "", "" another "", string)
print(string)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/One-dimensional_cellular_automata,One-dimensional cellular automata,"Assume an array of cells with an initial distribution of live and dead cells,
and imaginary cells off the end of the array having fixed values.

Cells in the next generation of the array are calculated based on the value of the cell and its left and right nearest neighbours in the current generation.

If, in the following table, a live cell is represented by 1 and a dead cell by 0 then to generate the value of the cell at a particular index in the array of cellular values you use the following table:

000 -> 0  # 
001 -> 0  #
010 -> 0  # Dies without enough neighbours
011 -> 1  # Needs one neighbour to survive
100 -> 0  #
101 -> 1  # Two neighbours giving birth
110 -> 1  # Needs one neighbour to survive
111 -> 0  # Starved to death.
",Python,"import random
 
printdead, printlive = '_#'
maxgenerations = 10
cellcount = 20
offendvalue = '0'
 
universe = ''.join(random.choice('01') for i in range(cellcount))
 
neighbours2newstate = {
 '000': '0',
 '001': '0',
 '010': '0',
 '011': '1',
 '100': '0',
 '101': '1',
 '110': '1',
 '111': '0',
 }
 
for i in range(maxgenerations):
    print ""Generation %3i:  %s"" % ( i,
          universe.replace('0', printdead).replace('1', printlive) )
    universe = offendvalue + universe + offendvalue
    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))",Human_written,Python_from_Java
http://rosettacode.org/wiki/AKS_test_for_primes,AKS test for primes,"The AKS algorithm for testing whether a number is prime is a polynomial-time algorithm based on an elementary theorem about Pascal triangles.

The theorem on which the test is based can be stated as follows:

   a number   



p


{\displaystyle p}

   is prime   if and only if   all the coefficients of the polynomial expansion of
 



(
x
−
1

)

p


−
(

x

p


−
1
)


{\displaystyle (x-1)^{p}-(x^{p}-1)}


are divisible by   



p


{\displaystyle p}

.



Example

Using   



p
=
3


{\displaystyle p=3}

:

         (x-1)^3 - (x^3 - 1)
            = (x^3 - 3x^2 + 3x - 1) - (x^3 - 1)
            = -3x^2 + 3x



And all the coefficients are divisible by 3,   so 3 is prime.





 Note:
This task is not the AKS primality test.   It is an inefficient exponential time algorithm discovered in the late 1600s and used as an introductory lemma in the AKS derivation.



Task



 Create a function/subroutine/method that given   



p


{\displaystyle p}

   generates the coefficients of the expanded polynomial representation of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

.
 Use the function to show here the polynomial expansions of   



(
x
−
1

)

p




{\displaystyle (x-1)^{p}}

   for   



p


{\displaystyle p}

   in the range   0   to at least   7,   inclusive.
 Use the previous function in creating another function that when given   



p


{\displaystyle p}

   returns whether   



p


{\displaystyle p}

   is prime using the theorem.
 Use your test to generate a list of all primes under   35.
 As a stretch goal,   generate all primes under   50   (needs integers larger than 31-bit).


References

 Agrawal-Kayal-Saxena (AKS) primality test (Wikipedia) 
 Fool-Proof Test for Primes - Numberphile (Video). The accuracy of this video is disputed -- at best it is an oversimplification.

",Python,"from polynomial import Polynomial
 
def x_minus_1_to_the(p):
    return Polynomial(-1,1)**p
 
def prime(p):
    return False if p < 2 else all(n%p==0 for n in (x_minus_1_to_the(p) - Polynomial.from_string(""x**%d-1""%p)).coefs)
 
for n in range(8):
    # the default Polynomial#to_s would be OK here; the substitutions just make the
    # output match the other version below.
    print(""(x-1)^%d = %s""%(n,str(x_minus_1_to_the(n)).replace('**','^').replace('*','')))
 
print(""\nPrimes below 50:"", ','.join(str(n) for n in range(50) if prime(n)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Quaternion_type,Quaternion type,"Quaternions   are an extension of the idea of   complex numbers.

A complex number has a real and complex part,   sometimes written as     a + bi,  

where     a     and     b     stand for real numbers, and     i     stands for the square root of minus 1.

An example of a complex number might be     -3 + 2i,    

where the real part,     a     is     -3.0     and the complex part,     b     is     +2.0.  

A quaternion has one real part and three imaginary parts,     i,       j,     and     k.  

A quaternion might be written as     a + bi + cj + dk.  

In the quaternion numbering system:

     i∙i = j∙j = k∙k = i∙j∙k = -1,         or more simply,
     ii  = jj  = kk  = ijk   = -1.  
The order of multiplication is important, as, in general, for two quaternions:

     q1     and     q2:         q1q2 ≠ q2q1.  
An example of a quaternion might be     1 +2i +3j +4k  

There is a list form of notation where just the numbers are shown and the imaginary multipliers    i,       j,     and     k     are assumed by position.

So the example above would be written as     (1, 2, 3, 4)  



Task

Given the three quaternions and their components: 

   q  = (1, 2, 3, 4) = (a,  b,  c,  d)
   q1 = (2, 3, 4, 5) = (a1, b1, c1, d1)
   q2 = (3, 4, 5, 6) = (a2, b2, c2, d2) 

And a wholly real number     r = 7.  



Create functions   (or classes)   to perform simple maths with quaternions including computing:

 The norm of a quaternion: 




=



a

2


+

b

2


+

c

2


+

d

2






{\displaystyle ={\sqrt {a^{2}+b^{2}+c^{2}+d^{2}}}}

 
 The negative of a quaternion: 
   = (-a, -b, -c, -d)  
 The conjugate of a quaternion: 
   = ( a, -b, -c, -d)  
 Addition of a real number     r     and a quaternion     q:  
  r + q = q + r = (a+r, b, c, d)  
 Addition of two quaternions: 
   q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2)  
 Multiplication of a real number and a quaternion: 
   qr = rq = (ar, br, cr, dr)  
 Multiplication of two quaternions     q1     and   q2     is given by: 
   ( a1a2 − b1b2 − c1c2 − d1d2, 
   a1b2 + b1a2 + c1d2 − d1c2, 
   a1c2 − b1d2 + c1a2 + d1b2, 
   a1d2 + b1c2 − c1b2 + d1a2 )  
 Show that, for the two quaternions     q1     and     q2: 
 q1q2 ≠ q2q1  


If a language has built-in support for quaternions, then use it.



C.f.

   Vector products
   On Quaternions;   or on a new System of Imaginaries in Algebra.   By Sir William Rowan Hamilton LL.D, P.R.I.A., F.R.A.S., Hon. M. R. Soc. Ed. and Dub., Hon. or Corr. M. of the Royal or Imperial Academies of St. Petersburgh, Berlin, Turin and Paris, Member of the American Academy of Arts and Sciences, and of other Scientific Societies at Home and Abroad, Andrews' Prof. of Astronomy in the University of Dublin, and Royal Astronomer of Ireland.

",Python,"class Quaternion(list):
    def __init__(self, *args):
        super().__init__(args)

    @property
    def a(self):
        return self[0]

    @property
    def b(self):
        return self[1]

    @property
    def c(self):
        return self[2]

    @property
    def d(self):
        return self[3]

    def norm(self):
        return math.sqrt(sum(x*x for x in self))

    def negate(self):
        return Quaternion(*(-x for x in self))

    def conjugate(self):
        return Quaternion(self[0], *(x for x in self[1:]))

    def add(self, x):
        if isinstance(x, (int, float)):
            return Quaternion(*(self[0] + x, *self[1:]))
        else:
            return Quaternion(*(v + x[i] for i, v in enumerate(self)))

    def mul(self, r):
        q = self
        if isinstance(r, (int, float)):
            return Quaternion(*(q[0] * r, *q[1:]))
        else:
            return Quaternion(q[0] * r[0] - q[1] * r[1] - q[2] * r[2] - q[3] * r[3],
                              q[0] * r[1] + q[1] * r[0] + q[2] * r[3] - q[3] * r[2],
                              q[0] * r[2] - q[1] * r[3] + q[2] * r[0] + q[3] * r[1],
                              q[0] * r[3] + q[1] * r[2] - q[2] * r[1] + q[3] * r[0])

    def equals(self, q):
        return all(v == q[i] for i, v in enumerate(self))

    def __str__(self):
        return (str(self[0]) + "" + "" + str(self[1]) + ""i + "" + str(self[2]) + ""j + "" + str(self[3]) + ""k"").replace(""+-"", ""- "")",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Partition_function_P,Partition function P,"

The Partition Function P, often notated P(n) is the number of solutions where n∈ℤ can be expressed as the sum of a set of positive integers.



Example

 P(4) = 5   because   4 = Σ(4) = Σ(3,1) = Σ(2,2) = Σ(2,1,1) = Σ(1,1,1,1)



P(n) can be expressed as the recurrence relation:

 P(n) = P(n-1) +P(n-2) -P(n-5) -P(n-7) +P(n-12) +P(n-15) -P(n-22) -P(n-26) +P(n-35) +P(n-40) ...

The successive numbers in the above equation have the differences:   1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8 ...

This task may be of popular interest because Mathologer made the video, The hardest ""What comes next?"" (Euler's pentagonal formula), where he asks the programmers among his viewers to calculate P(666). The video has been viewed more than 100,000 times in the first couple of weeks since its release.

In Wolfram Language, this function has been implemented as PartitionsP.



Task

Write a function which returns the value of PartitionsP(n). Solutions can be iterative or recursive.

Bonus task: show how long it takes to compute PartitionsP(6666).



References

 The hardest ""What comes next?"" (Euler's pentagonal formula) The explanatory video by Mathologer that makes this task a popular interest.
 Partition Function P Mathworld entry for the Partition function.
 Partition function (number theory) Wikipedia entry for the Partition function.


Related tasks

 9 billion names of God the integer



",Python,"from itertools import islice
 
def posd():
    ""diff between position numbers. 1, 2, 3... interleaved with  3, 5, 7...""
    count, odd = 1, 3
    while True:
        yield count
        yield odd
        count, odd = count + 1, odd + 2
 
def pos_gen():
    ""position numbers. 1 3 2 5 7 4 9 ...""
    val = 1
    diff = posd()
    while True:
        yield val
        val += next(diff)
 
def plus_minus():
    ""yield (list_offset, sign) or zero for Partition calc""
    n, sign = 0, [1, 1]
    p_gen = pos_gen()
    out_on = next(p_gen)
    while True:
        n += 1
        if n == out_on:
            next_sign = sign.pop(0)
            if not sign:
                sign = [-next_sign] * 2
            yield -n, next_sign
            out_on = next(p_gen)
        else:
            yield 0
 
def part(n):
    ""Partition numbers""
    p = [1]
    p_m = plus_minus()
    mods = []
    for _ in range(n):
        next_plus_minus = next(p_m)
        if next_plus_minus:
            mods.append(next_plus_minus)
        p.append(sum(p[offset] * sign for offset, sign in mods))
    return p[-1]
 
print(""(Intermediaries):"")
print(""    posd:"", list(islice(posd(), 10)))
print(""    pos_gen:"", list(islice(pos_gen(), 10)))
print(""    plus_minus:"", list(islice(plus_minus(), 15)))
print(""\nPartitions:"", [part(x) for x in range(15)])",Human_written,Python_from_JavaScript
"http://rosettacode.org/wiki/Abbreviations,_easy","Abbreviations, easy","This task is an easier (to code) variant of the Rosetta Code task:    Abbreviations, simple.



For this task, the following   command table   will be used:

   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   A valid abbreviation is a word that has:
   at least the minimum length of the number of capital letters of the word in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTer
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTer
   The number of capital letters in   ALTer   indicates that any abbreviation for   ALTer   must be at least three letters
   Any word longer than five characters can't be an abbreviation for   ALTer
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   Overlay
   if there isn't any lowercase letters in the word in the command table,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"command_table_text = \
""""""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up""""""
 
user_words = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
def find_abbreviations_length(command_table_text):
    """""" find the minimal abbreviation length for each word by counting capital letters.
        a word that does not have capital letters gets it's full length as the minimum.
    """"""
    command_table = dict()
    for word in command_table_text.split():
        abbr_len = sum(1 for c in word if c.isupper())
        if abbr_len == 0:
            abbr_len = len(word)
        command_table[word] = abbr_len
    return command_table
 
def find_abbreviations(command_table):
    """""" for each command insert all possible abbreviations""""""
    abbreviations = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations
 
def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, ""*error*"") for user_word in user_words]
    return "" "".join(commands)
 
command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)
 
full_words = parse_user_string(user_words, abbreviations_table)
 
print(""user words:"", user_words)
print(""full words:"", full_words)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Hough_transform,Hough transform,"Task

Implement the Hough transform, which is used as part of feature extraction with digital images.

It is a tool that makes it far easier to identify straight lines in the source image, whatever their orientation.

The transform maps each point in the target image, 



(
ρ
,
θ
)


{\displaystyle (\rho ,\theta )}

, to the average color of the pixels on the corresponding line of the source image (in 



(
x
,
y
)


{\displaystyle (x,y)}

-space, where the line corresponds to points of the form 



x
cos
⁡
θ
+
y
sin
⁡
θ
=
ρ


{\displaystyle x\cos \theta +y\sin \theta =\rho }

). The idea is that where there is a straight line in the original image, it corresponds to a bright (or dark, depending on the color of the background field) spot; by applying a suitable filter to the results of the transform, it is possible to extract the locations of the lines in the original image.

 Sample PNG image to use for the Hough transform.
The target space actually uses polar coordinates, but is conventionally plotted on rectangular coordinates for display. There's no specification of exactly how to map polar coordinates to a flat surface for display, but a convenient method is to use one axis for 



θ


{\displaystyle \theta }

 and the other for 



ρ


{\displaystyle \rho }

, with the center of the source image being the origin.

There is also a spherical Hough transform, which is more suited to identifying planes in 3D data.



",Python,"import math
import gd
import Image

def hough_transform(img):
    mx, my = img.size[0] * 0.5, img.size[1] * 0.5
    max_d = math.sqrt(mx ** 2 + my ** 2)
    min_d = max_d * -1
    hough = {}
    for x in range(img.size[0]):
        print(x, img.size[0])
        for y in range(img.size[1]):
            if img.getpixel((x, y))[1] > 32:
                for a in range(180):
                    rad = a * (math.pi / 180.0)
                    d = (x - mx) * math.cos(rad) + (y - my) * math.sin(rad)
                    hough[""%d_%d"" % (a, d)] = hough.get(""%d_%d"" % (a, d), 0) + 1
    heat = Image.open('heatmap.png')
    out = Image.new('RGB', (180, int(max_d * 2)))
    max = max(hough.values())
    for k, v in hough.items():
        a, d = map(int, k.split('_'))
        c = int((v / max) * 255)
        c = heat.getpixel((c, 0))
        out.putpixel((a, int(max_d + d)), c)
    return out",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.1.2
 
import os
 
def main():
    text = open(""input.txt"").read().lower()
    letter_map = {letter: list(text) for letter in text if letter.isalpha()}
    for letter in sorted(letter_map):
        print(f""{letter} = {len(letter_map[letter])}"")
    print(f""\nTotal letters = {sum(len(letter_map[letter]) for letter in letter_map)}"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Python,"def first(function):
    return function()
 
def second():
    return ""second""
 
result = first(second)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort,Sorting Algorithms/Circle Sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of integers (of any convenient size) into ascending order using Circlesort.

In short, compare the first element to the last element, then the second element to the second last element, etc.

Then split the array in two and recurse until there is only one single element in the array, like this:

Before:
6 7 8 9 2 5 3 4 1
After:
1 4 3 5 2 9 8 7 6

Repeat this procedure until quiescence (i.e. until there are no swaps).

Show both the initial, unsorted list and the final sorted list. (Intermediate steps during sorting are optional.)

Optimizations (like doing 0.5 log2(n) iterations and then continue with an Insertion sort) are optional. 


Pseudo code:

 function circlesort (index lo, index hi, swaps)
 {
   if lo == hi return (swaps)
   high := hi
   low := lo
   mid := int((hi-lo)/2)
   while lo < hi {
     if  (value at lo) > (value at hi) {
        swap.values (lo,hi)
        swaps++
     }
     lo++
     hi--
   }
   if lo == hi
     if (value at lo) > (value at hi+1) {
         swap.values (lo,hi+1)
         swaps++
     }
   swaps := circlesort(low,low+mid,swaps)
   swaps := circlesort(low+mid+1,high,swaps)
   return(swaps)
 }
 while circlesort (0, sizeof(array)-1, 0)



See also

 For more information on Circle sorting, see Sourceforge.

",Python,"def circle_sort_inner(start, end):
	p, q, t, swapped = start, end, 0, 0
	if start == end:
		return 0
	for swapped in range(0, 1):
		if p < q or (p == q and p + 1 < end):
			if start[p] > start[q]:
				t = start[p]
				start[p] = start[q]
				start[q] = t
				swapped = 1
			p += 1
			q -= 1
	return swapped | circle_sort_inner(start, q) | circle_sort_inner(p, end)
 
def circle_sort(x, n):
	while circle_sort_inner(x, x + (n - 1)):
		for i in range(0, n):
			print(x[i], end=' ')
		print()
 
x = [5, -1, 101, -4, 0, 1, 8, 6, 2, 3]
circle_sort(x, len(x))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Introspection,Introspection,"Task

 verify the version/revision of your currently running (compiler/interpreter/byte-compiler/runtime environment/whatever your language uses) and exit if it is too old.
 check whether the variable ""bloop"" exists and whether the math-function ""abs()"" is available and if yes compute abs(bloop).


Extra credit

 Report the number of integer variables in global scope, and their sum.

",Python,"# Checking for system version
 import sys
 major, minor, bugfix = sys.version_info[:3]
 if major < 2:
     sys.exit('Python 2 is required')
 
 
 def defined(name): # LBYL (Look Before You Leap)
     return name in globals() or name in locals() or name in vars(__builtins__)
 
 def defined2(name): # EAFP (Easier to Ask Forgiveness than Permission)
     try:
          eval(name)
          return True
     except NameError:
          return False
 
 if defined('bloop') and defined('abs') and callable(abs):
     print abs(bloop)
 
 if defined2('bloop') and defined2('abs') and callable(abs):
     print abs(bloop)",Human_written,Python_from_C
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import csv
 
class CSV:
    def __init__(self):
        self.m_nCols = 0
        self.m_nRows = 0
        self.m_oData = {}
 
    def open(self, filename, delim = ','):
        self.clear()
        with open(filename, 'rb') as csvfile:
            reader = csv.reader(csvfile, delimiter=delim)
            for row in reader:
                nCol = 0
                for cell in row:
                    self.m_oData[(nCol, self.m_nRows)] = cell.strip()
                    nCol += 1
                self.m_nCols = max(self.m_nCols, nCol)
                self.m_nRows += 1
 
    def save(self, filename, delim = ','):
        with open(filename, 'wb') as csvfile:
            writer = csv.writer(csvfile, delimiter=delim)
            for nRow in range(self.m_nRows):
                row = []
                for nCol in range(self.m_nCols):
                    row.append(self.m_oData[(nCol, nRow)])
                writer.writerow(row)
 
    def clear(self):
        self.m_oData = {}
        self.m_nRows = self.m_nCols = 0
 
    def __call__(self, nCol, nRow):
        self.m_nCols = max(self.m_nCols, nCol+1)
        self.m_nRows = max(self.m_nRows, nRow+1)
        return self.m_oData[(nCol, nRow)]
 
    def GetRows(self):
        return self.m_nRows
 
    def GetCols(self):
        return self.m_nCols
 
if __name__ == '__main__':
    oCSV = CSV()
    oCSV.open('test_in.csv')
    oCSV(0, 0) = 'Column0'
    oCSV(1, 1) = '100'
    oCSV(2, 2) = '200'
    oCSV(3, 3) = '300'
    oCSV(4, 4) = '400'
    oCSV.save('test_out.csv')",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Pythagorean_triples,Pythagorean triples,"A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a,b,c)}

 where 



a
<
b
<
c


{\displaystyle a<b<c}

, and 




a

2


+

b

2


=

c

2


.


{\displaystyle a^{2}+b^{2}=c^{2}.}



They are called primitive triples if 



a
,
b
,
c


{\displaystyle a,b,c}

 are co-prime, that is, if their pairwise greatest common divisors 





g
c
d


(
a
,
b
)
=


g
c
d


(
a
,
c
)
=


g
c
d


(
b
,
c
)
=
1


{\displaystyle {\rm {gcd}}(a,b)={\rm {gcd}}(a,c)={\rm {gcd}}(b,c)=1}

.

Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (





g
c
d


(
a
,
b
)
=
1


{\displaystyle {\rm {gcd}}(a,b)=1}

).  

Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.



Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.



Extra credit
 
Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?

Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.



Related tasks

   Euler's sum of powers conjecture 
   List comprehensions
   Pythagorean quadruples 

",Python,"from fractions import gcd
 
 
def pt1(maxperimeter=100):
    '''
# Naive method
    '''
    trips = []
    for a in range(1, maxperimeter):
        aa = a*a
        for b in range(a, maxperimeter-a+1):
            bb = b*b
            for c in range(b, maxperimeter-b-a+1):
                cc = c*c
                if a+b+c > maxperimeter or cc > aa + bb: break
                if aa + bb == cc:
                    trips.append((a,b,c, gcd(a, b) == 1))
    return trips
 
def pytrip(trip=(3,4,5),perim=100, prim=1):
    a0, b0, c0 = a, b, c = sorted(trip)
    t, firstprim = set(), prim>0
    while a + b + c <= perim:
        t.add((a, b, c, firstprim>0))
        a, b, c, firstprim = a+a0, b+b0, c+c0, False
    #
    t2 = set()
    for a, b, c, firstprim in t:
        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7
        if  a5 - b5 + c7 <= perim:
            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)
        if  a5 + b5 + c7 <= perim:
            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)
        if -a5 + b5 + c7 <= perim:
            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)
    return t | t2
 
def pt2(maxperimeter=100):
    '''
# Parent/child relationship method:
# http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples#XI.
    '''
    trips = pytrip((3,4,5), maxperimeter, 1)
    return trips
 
def printit(maxperimeter=100, pt=pt1):
    trips = pt(maxperimeter)
    print(""  Up to a perimeter of %i there are %i triples, of which %i are primitive""
          % (maxperimeter,
             len(trips),
             len([prim for a,b,c,prim in trips if prim])))
 
for algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):
    print(algo.__doc__)
    for maxperimeter in range(mn, mx+1, mn):
        printit(maxperimeter, algo)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",Python,"def bubble_sort(seq):
    """"""Inefficiently sort the mutable sequence (list) in place.
       seq MUST BE A MUTABLE SEQUENCE.
 
       As with list.sort() and random.shuffle this does NOT return 
    """"""
    changed = True
    while changed:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i]
                changed = True
    return seq
 
if __name__ == ""__main__"":
   """"""Sample usage and simple test suite""""""
 
   from random import shuffle
 
   testset = [_ for _ in range(100)]
   testcase = testset.copy() # make a copy
   shuffle(testcase)
   assert testcase != testset  # we've shuffled it
   bubble_sort(testcase)
   assert testcase == testset  # we've unshuffled it back into a copy",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Calculating_the_value_of_e,Calculating the value of e,"Task

Calculate the value of   e.



(e   is also known as   Euler's number   and   Napier's constant.)



See details: Calculating the value of e
",Python,"from math import fabs
 
EPSILON = 1.0e-15
fact = 1
e = 2.0
e0 = 0.0
n = 2
while fabs(e - e0) >= EPSILON:
    e0 = e
    fact *= n
    n += 1
    e += 1.0 / fact
print(""e = "", e)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Python,"import random
 
def s_of_n_creator(n):
    sample = []
    i = 0
    def s_of_n(item):
        nonlocal i
        i += 1
        if i <= n:
            sample.append(item)
        elif random.randint(0, i - 1) < n:
            sample[random.randint(0, n - 1)] = item
        return sample
    return s_of_n
 
bin = [0] * 10
for trial in range(100000):
    s_of_n = s_of_n_creator(3)
    sample = []
    for i in range(10):
        sample = s_of_n(i)
    for s in sample:
        bin[s] += 1
 
for x in bin:
    print(x)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Respond_to_an_unknown_method_call,Respond to an unknown method call,"Task

Demonstrate how to make the object respond (sensibly/usefully) to an invocation of a method on it that it does not support through its class definitions.

Note that this is not the same as just invoking a defined method whose name is given dynamically; the method named at the point of invocation must not be defined.

This task is intended only for object systems that use a dynamic dispatch mechanism without static checking.



Related task

   Send an unknown method call.

",Python,"class Example(object):
    def foo(self):
        print(""this is foo"")
    def bar(self):
        print(""this is bar"")
    def __getattr__(self, name):
        def method(*args):
            print(""tried to handle unknown method "" + name)
            if args:
                print(""it had arguments: "" + str(args))
        return method
 
example = Example()
 
example.foo()        # prints “this is foo”
example.bar()        # prints “this is bar”
example.grill()      # prints “tried to handle unknown method grill”
example.ding(""dong"") # prints “tried to handle unknown method ding”
                     # prints “it had arguments: ('dong',)”",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Send_email,Send email,"Task

Write a function to send an email.

The function should have parameters for setting From, To and Cc addresses; the Subject, and the message text, and optionally fields for the server name and login details.

 If appropriate, explain what notifications of problems/success are given.
 Solutions using libraries or functions from the language are preferred, but failing that, external programs can be used with an explanation.
 Note how portable the solution given is between operating systems when multi-OS languages are used.


(Remember to obfuscate any sensitive data used in examples)



",Python,"import smtplib
 
def sendemail(from_addr, to_addr_list, cc_addr_list,
              subject, message,
              login, password,
              smtpserver='smtp.gmail.com:587'):
    header  = 'From: %s\n' % from_addr
    header += 'To: %s\n' % ','.join(to_addr_list)
    header += 'Cc: %s\n' % ','.join(cc_addr_list)
    header += 'Subject: %s\n\n' % subject
    message = header + message
 
    server = smtplib.SMTP(smtpserver)
    server.starttls()
    server.login(login,password)
    problems = server.sendmail(from_addr, to_addr_list, message)
    server.quit()
    return problems",Human_written,Python_from_C
http://rosettacode.org/wiki/Zeckendorf_number_representation,Zeckendorf number representation,"Just as numbers can be represented in a positional notation as sums of multiples of the powers of ten (decimal) or two (binary); all the positive integers can be represented as the sum of one or zero times the distinct members of the Fibonacci series.

Recall that the first six distinct Fibonacci numbers are: 1, 2, 3, 5, 8, 13.

The decimal number eleven can be written as 0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1 or 010100 in positional notation where the columns represent multiplication by a particular member of the sequence. Leading zeroes are dropped so that 11 decimal becomes 10100.

10100 is not the only way to make 11 from the Fibonacci numbers however; 0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1 or 010011 would also represent decimal 11. For a true Zeckendorf number there is the added restriction that no two consecutive Fibonacci numbers can be used which leads to the former unique solution.



Task

Generate and show here a table of the Zeckendorf number representations of the decimal numbers zero to twenty, in order.

The intention in this task to find the Zeckendorf form of an arbitrary integer. The Zeckendorf form can be iterated by some bit twiddling rather than calculating each value separately but leave that to another separate task.



Also see

   OEIS A014417   for the the sequence of required results.
   Brown's Criterion - Numberphile


Related task

   Fibonacci sequence

",Python,"def zeckendorf(n):
    return zr(1, 1, n, 0)[1]
 
def zr(fib0, fib1, n, bit):
    if fib1 > n:
        return n, 0
    remaining, set = zr(fib1, fib0 + fib1, n, bit + 1)
    if fib1 <= remaining:
        set |= 1 << bit
        remaining -= fib1
    return remaining, set
 
if __name__ == ""__main__"":
    for i in range(21):
        print(""%2d %7b"" % (i, zeckendorf(i)))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",Python,">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
0.9999999999999999
>>> from math import fsum
>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
1.0",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Interactive_programming_(repl),Interactive programming (repl),"Many language implementations come with an interactive mode.

This is a command-line interpreter that reads lines from the user and evaluates these lines as statements or expressions.

An interactive mode may also be known as a command mode,   a read-eval-print loop (REPL),   or a shell.



Task

Show how to start this mode.

Then, as a small example of its use, interactively create a function of two strings and a separator that returns the strings separated by two concatenated instances of the separator   (the 3rd argument).



Example

             f('Rosetta',  'Code',  ':')   

should return

             'Rosetta::Code'               



Note

This task is   not   about creating your own interactive mode.



",Python,"**********************************************************************
** Visual Studio 2017 Developer Command Prompt v15.9.14
** Copyright (c) 2017 Microsoft Corporation
**********************************************************************

C:\Program Files (x86)\Microsoft Visual Studio\2017\Community>python
Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 22:22:05) [MSC v.1916 64 bit (AMD64)] on win32
Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.
>>> /?
SyntaxError: invalid syntax
>>> /help
SyntaxError: invalid syntax
>>> /version
SyntaxError: invalid syntax
>>> /i
SyntaxError: invalid syntax
>>> /r:<file>
SyntaxError: invalid syntax
>>> /r:<file list>
SyntaxError: invalid syntax
>>> /lib:<path list>
SyntaxError: invalid syntax
>>> /u:<namespace>
SyntaxError: invalid syntax
>>> @<file>
SyntaxError: invalid syntax
>>> --
SyntaxError: invalid syntax
>>>",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/URL_encoding,URL encoding,"Task

Provide a function or mechanism to convert a provided string into URL encoding representation.

In URL encoding, special characters, control characters and extended characters
are converted into a percent symbol followed by a two digit hexadecimal code,
So a space character encodes into %20 within the string.

For the purposes of this task, every character except 0-9, A-Z and a-z requires conversion, so the following characters all require conversion by default:

 ASCII control codes (Character ranges 00-1F hex (0-31 decimal) and 7F (127 decimal).
 ASCII symbols (Character ranges 32-47 decimal (20-2F hex))
 ASCII symbols (Character ranges 58-64 decimal (3A-40 hex))
 ASCII symbols (Character ranges 91-96 decimal (5B-60 hex))
 ASCII symbols (Character ranges 123-126 decimal (7B-7E hex))
 Extended characters with character codes of 128 decimal (80 hex) and above.


Example

The string ""http://foo bar/"" would be encoded as ""http%3A%2F%2Ffoo%20bar%2F"".



Variations

 Lowercase escapes are legal, as in ""http%3a%2f%2ffoo%20bar%2f"".
 Some standards give different rules: RFC 3986, Uniform Resource Identifier (URI): Generic Syntax, section 2.3, says that ""-._~"" should not be encoded. HTML 5, section 4.10.22.5 URL-encoded form data, says to preserve ""-._*"", and to encode space "" "" to ""+"". The options below provide for utilization of an exception string, enabling preservation (non encoding) of particular characters to meet specific standards.


Options

It is permissible to use an exception string (containing a set of symbols
that do not need to be converted).
However, this is an optional feature and is not a requirement of this task.



Related tasks
 
   URL decoding
   URL parser

",Python,"import urllib
s = 'http://foo/bar/'
s = urllib.quote(s)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Averages/Root_mean_square,Averages/Root mean square,"Task[edit]
Compute the   Root mean square   of the numbers 1..10.



The   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.

The RMS is calculated as the mean of the squares of the numbers, square-rooted:



 




x


r
m
s



=







x

1




2


+



x

2




2


+
⋯
+



x

n




2



n



.


{\displaystyle x_{\mathrm {rms} }={\sqrt {{{x_{1}}^{2}+{x_{2}}^{2}+\cdots +{x_{n}}^{2}} \over n}}.}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,">>> from math import sqrt
>>> def qmean(num):
	return sqrt(sum(n*n for n in num)/len(num))
 
>>> qmean(range(1,11))
6.2048368229954285",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Factors_of_an_integer,Factors of an integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Compute the   factors   of a positive integer.

These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.

(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).

Note that every prime number has two factors:   1   and itself.



Related tasks

   count in factors
   prime decomposition
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division
   sequence: smallest number greater than previous term with exactly n divisors

",Python,">>> def factors(n):
      return [i for i in range(1, n + 1) if not n%i]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Josephus_problem,Josephus problem,"Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.

An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

,
removing every 



k


{\displaystyle k}

-th prisoner and killing him.

As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >

For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.



Task

Given any   



n
,
k
>
0


{\displaystyle n,k>0}

,   find out which prisoner will be the final survivor.

In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).

Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.

Which number was he?



Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free,

and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.

Provide a way to calculate which prisoner is at any given position on the killing sequence.



Notes

 You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way. This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

. However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
 If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
 An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.

",Python,"from typing import List

def execute(n: int, k: int) -> int:
    kill_idx = 0
    prisoners = list(range(n))
    print(""Prisoners executed in order:"")
    while len(prisoners) > 1:
        kill_idx = (kill_idx + k - 1) % len(prisoners)
        print(prisoners[kill_idx], end="" "")
        del prisoners[kill_idx]
    print()
    return prisoners[0]

def execute_all_but_m(n: int, k: int, m: int) -> List[int]:
    kill_idx = 0
    prisoners = list(range(n))
    print(""Prisoners executed in order:"")
    while len(prisoners) > m:
        kill_idx = (kill_idx + k - 1) % len(prisoners)
        print(prisoners[kill_idx], end="" "")
        del prisoners[kill_idx]
    print()
    return prisoners

if __name__ == ""__main__"":
    print(""Survivor:"", execute(41, 3))
    print(""Survivors:"", execute_all_but_m(41, 3, 3))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm,Trabb Pardo–Knuth algorithm,"The TPK algorithm is an early example of a programming chrestomathy.
It was used in Donald Knuth and Luis Trabb Pardo's Stanford tech report The Early Development of Programming Languages.
The report traces the early history of work in developing computer languages in the 1940s and 1950s, giving several translations of the algorithm.

From the wikipedia entry:

ask for 11 numbers to be read into a sequence S
reverse sequence S
for each item in sequence S
    result := call a function to do an operation
    if result overflows
        alert user
    else
        print result

The task is to implement the algorithm:

 Use the function:     



f
(
x
)
=

|

x


|


0.5


+
5

x

3




{\displaystyle f(x)=|x|^{0.5}+5x^{3}}


 The overflow condition is an answer of greater than 400.
 The 'user alert' should not stop processing of other items of the sequence.
 Print a prompt before accepting eleven, textual, numeric inputs.
 You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
 The sequence    S    may be 'implied' and so not shown explicitly.
 Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).

",Python,"Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> def f(x): return abs(x) ** 0.5 + 5 * x**3
 
>>> print(', '.join('%s:%s' % (x, v if v<=400 else ""TOO LARGE!"")
	           for x,v in ((y, f(float(y))) for y in input('\nnumbers: ').strip().split()[:11][::-1])))
 
11 numbers: 1 2 3 4 5 6 7 8 9 10 11
11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Singly-linked_list/Element_insertion,Singly-linked list/Element insertion,"Singly-Linked List (element)
singly-linked list
Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"# version 1.1.2
 
class Node(data, next=None):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
    def __str__(self):
        sb = str(self.data)
        node = self.next
        while node:
            sb += "" -> "" + str(node.data)
            node = node.next
        return sb
 
def insertAfter(prev, new):
    new.next = prev.next
    prev.next = new
 
if __name__ == ""__main__"":
    b = Node(3)
    a = Node(1, b)
    print(""Before insertion : {}"".format(a))
    c = Node(2)
    insertAfter(a, c)
    print(""After  insertion : {}"".format(a))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sudoku,Sudoku,"Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format.

references

 Algorithmics of Sudoku   may help implement this.
 Python Sudoku Solver Computerphile video.

",Python,"def read_matrix(data):
    lines = data.splitlines()
    return [[int(lines[i][j]) for j in range(9)] for i in range(9)]

def permissible(matrix, i, j):
    ok = [None] + list(range(1, 10))
    def check(x, y):
        if matrix[x][y]:
            ok[matrix[x][y]] = None
    # Same as another in the column isn't permissible...
    for x in range(9):
        check(x, j)
    # Same as another in the row isn't permissible...
    for y in range(9):
        check(i, y)
    # Same as another in the 3x3 block isn't permissible...
    xary = list(range((i // 3) * 3, (i // 3) * 3 + 3))
    yary = list(range((j // 3) * 3, (j // 3) * 3 + 3))
    for x, y in [(x, y) for x in xary for y in yary]:
        check(x, y)
    # Gathering only permitted one
    return [x for x in ok if x]

def deep_copy_sudoku(matrix):
    return [row[:] for row in matrix]

def solve_sudoku(matrix):
    while True:
        options = []
        for i in range(9):
            for j in range(9):
                if not matrix[i][j]:
                    p = permissible(matrix, i, j)
                    # If nothing is permissible, there is no solution at this level.
                    if not p:
                        return
                    options.append((i, j, p))
        # If the matrix is complete, we have a solution...
        if not options:
            return matrix
        i, j, permissible = min(options, key=lambda x: len(x[2]))
        # If there is an option with only one solution, set it and re-check permissibility
        if len(permissible) == 1:
            matrix[i][j] = permissible[0]
            continue
        # We have two or more choices. We need to search both...
        for v in permissible:
            mtmp = deep_copy_sudoku(matrix)
            mtmp[i][j] = v
            ret = solve_sudoku(mtmp)
            if ret:
                return ret
        # We did an exhaustive search on this branch and nothing worked out.
        return

def print_matrix(matrix):
    if not matrix:
        print(""Impossible"")
        return
    border = ""+-----+-----+-----+""
    for i in range(9):
        if i % 3 == 0:
            print(border)
        for j in range(9):
            if j % 3 == 0:
                print(""|"", end="""")
            print("" "" if matrix[i][j] == 0 else matrix[i][j], end="""")
        print(""|"")
    print(border)

data = """"""
394__267_
___3__4__
5__69__2_
_45___9__
6_______7
__7___58_
_1__67__8
__9__8___
_264__735
""""""

matrix = read_matrix(data)
print_matrix(matrix)
print()
print_matrix(solve_sudoku(matrix))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sieve_of_Eratosthenes,Sieve of Eratosthenes,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


The Sieve of Eratosthenes is a simple algorithm that finds the prime numbers up to a given integer.



Task

Implement the   Sieve of Eratosthenes   algorithm, with the only allowed optimization that the outer loop can stop at the square root of the limit, and the inner loop may start at the square of the prime just found.

That means especially that you shouldn't optimize by using pre-computed wheels, i.e. don't assume you need only to cross out odd numbers (wheel based on 2), numbers equal to 1 or 5 modulo 6 (wheel based on 2 and 3), or similar wheels based on low primes.

If there's an easy way to add such a wheel based optimization, implement it as an alternative version.



Note

 It is important that the sieve algorithm be the actual algorithm used to find prime numbers for the task.


Related tasks

   Emirp primes
   count in factors
   prime decomposition
   factors of an integer
   extensible prime generator
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def eratosthenes2(n):
    multiples = set()
    for i in range(2, n+1):
        if i not in multiples:
            yield i
            multiples.update(range(i*i, n+1, i))
 
print(list(eratosthenes2(100)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running,Determine if only one instance is running,"This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.
",Python,"import __main__, os
 
def isOnlyInstance():
    # Determine if there are more than the current instance of the application
    # running at the current time.
    return os.system(""(( $(ps -ef | grep python | grep '["" +
                     __main__.__file__[0] + ""]"" + __main__.__file__[1:] +
                     ""' | wc -l) > 1 ))"") != 0",Human_written,Python_from_Go
http://rosettacode.org/wiki/Nim_game,Nim game,"Nim game

You are encouraged to solve this task according to the task description, using any language you may know.
Nim is a simple game where the second player ─── if they know the trick ─── will always win.



The game has only 3 rules:

   start with   12   tokens
   each player takes   1,  2,  or  3   tokens in turn
  the player who takes the last token wins.


To win every time,   the second player simply takes 4 minus the number the first player took.   So if the first player takes 1,   the second takes 3 ─── if the first player takes 2,   the second should take 2 ─── and if the first player takes 3,   the second player will take 1.



Task

Design a simple Nim game where the human player goes first, and the computer always wins. The game should enforce the rules.



",Python,"import sys
 
def show_tokens(tokens):
    print(""Tokens remaining"", tokens, ""\n"")
 
def main():
    tokens = 12
    while True:
        show_tokens(tokens)
        print(""  How many tokens 1, 2 or 3? "", end="""")
        try:
            t = int(input())
        except ValueError:
            print(""\nMust be a number between 1 and 3, try again.\n"")
            continue
        if t < 1 or t > 3:
            print(""\nMust be a number between 1 and 3, try again.\n"")
        else:
            ct = 4 - t
            s = ""s""
            if ct == 1:
                s = """"
            print(""  Computer takes "", ct, "" token"", s, ""\n\n"")
            tokens -= 4
        if tokens == 0:
            show_tokens(0)
            print(""  Computer wins!"")
            return
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Polymorphic_copy,Polymorphic copy,"An object is polymorphic when its specific type may vary.
The types a specific value may take, is called class.

It is trivial to copy an object if its type is known:

int x;
int y = x;
Here x is not polymorphic, so y is declared of same type (int) as x.
But if the specific type of x were unknown, then y could not be declared of any specific type.

The task: let a polymorphic object contain an instance of some specific type S derived from a type T.
The type T is known.
The type S is possibly unknown until run time.
The objective is to create an exact copy of such polymorphic object (not to create a reference, nor a pointer to).
Let further the type T have a method overridden by S.
This method is to be called on the copy to demonstrate that the specific type of the copy is indeed S.
",Python,"import copy
 
class T:
   def classname(self): 
      return self.__class__.__name__
 
   def __init__(self):
      self.myValue = ""I'm a T.""
 
   def speak(self):
      print self.classname(), 'Hello', self.myValue
 
   def clone(self):
      return copy.copy(self)
 
class S1(T):
   def speak(self):
      print self.classname(),""Meow"", self.myValue
 
class S2(T):
   def speak(self):
      print self.classname(),""Woof"", self.myValue
 
 
print ""creating initial objects of types S1, S2, and T""
a = S1()
a.myValue = 'Green'
a.speak()
 
b = S2()
b.myValue = 'Blue'
b.speak()
 
u = T()
u.myValue = 'Purple'
u.speak()
 
print ""Making copy of a as u, colors and types should match""
u = a.clone()
u.speak()
a.speak()
print ""Assigning new color to u, A's color should be unchanged.""
u.myValue = ""Orange""
u.speak()
a.speak()
 
print ""Assigning u to reference same object as b, colors and types should match""
u = b
u.speak()
b.speak()
print ""Assigning new color to u. Since u,b references same object b's color changes as well""
u.myValue = ""Yellow""
u.speak()
b.speak()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Strong_and_weak_primes,Strong and weak primes,"

Definitions   (as per number theory)

   The   prime(p)   is the    pth   prime.
   prime(1)   is   2
   prime(4)   is   7
   A    strong   prime   is when     prime(p)   is   >   [prime(p-1) + prime(p+1)] ÷ 2
   A     weak    prime   is when     prime(p)   is   <   [prime(p-1) + prime(p+1)] ÷ 2


Note that the definition for   strong primes   is different when used in the context of   cryptography.



Task

   Find and display (on one line) the first   36   strong primes.
   Find and display the   count   of the strong primes below   1,000,000.
   Find and display the   count   of the strong primes below 10,000,000.
   Find and display (on one line) the first   37   weak primes.
   Find and display the   count   of the weak primes below   1,000,000.
   Find and display the   count   of the weak primes below 10,000,000.
   (Optional)   display the   counts   and   ""below numbers""   with commas.
Show all output here.



Related Task

   Safe primes and unsafe primes.


Also see

   The OEIS article A051634: strong primes.
   The OEIS article A051635: weak primes.

",Python,"import math
 
def sieve(limit):
    limit += 1
    # True denotes composite, false denotes prime.
    # Don't bother marking even numbers >= 4 as composite.
    c = [True] * limit
    c[0] = True
    c[1] = True
 
    p = 3 # start from 3
    while True:
        p2 = p * p
        if p2 >= limit:
            break
        for i in range(p2, limit, 2 * p):
            c[i] = True
        while True:
            p += 2
            if not c[p]:
                break
    return c
 
def commatize(n):
    s = str(n)
    le = len(s)
    for i in range(le - 3, 0, -3):
        s = s[:i] + "","" + s[i:]
    return s
 
# sieve up to 10,000,019 - the first prime after 10 million
limit = 1e7 + 19
sieved = sieve(limit)
# extract primes
primes = [2]
for i in range(3, limit + 1, 2):
    if not sieved[i]:
        primes.append(i)
# extract strong and weak primes
strong = []
weak = [3]                  # so can use integer division for rest
for i in range(2, len(primes) - 1): # start from 5
    if primes[i] > (primes[i-1] + primes[i+1]) // 2:
        strong.append(primes[i])
    elif primes[i] < (primes[i-1] + primes[i+1]) // 2:
        weak.append(primes[i])
 
print(""The first 36 strong primes are:"")
print(strong[:36])
count = 0
for p in strong:
    if p >= 1e6:
        break
    count += 1
print(""\nThe number of strong primes below 1,000,000 is"", commatize(count))
print(""\nThe number of strong primes below 10,000,000 is"", commatize(len(strong)))
 
print(""\nThe first 37 weak primes are:"")
print(weak[:37])
count = 0
for p in weak:
    if p >= 1e6:
        break
    count += 1
print(""\nThe number of weak primes below 1,000,000 is"", commatize(count))
print(""\nThe number of weak primes below 10,000,000 is"", commatize(len(weak)))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"import math
 
def binomial(n, k):
    if n < k:
        return 0
    if n == 0 or k == 0:
        return 1
    num = 1
    for i in range(k + 1, n + 1):
        num *= i
    den = 1
    for i in range(2, n - k + 1):
        den *= i
    return num // den
 
def pascal_upper_triangular(n):
    m = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            m[i][j] = binomial(j, i)
    return m
 
def pascal_lower_triangular(n):
    m = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            m[i][j] = binomial(i, j)
    return m
 
def pascal_symmetric(n):
    m = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            m[i][j] = binomial(i + j, i)
    return m
 
def print_matrix(title, m):
    n = len(m)
    print(title)
    print(""["", end="""")
    for i in range(n):
        if i > 0:
            print("" "", end="""")
        mi = str(m[i]).replace("" "", "", "")
        print(mi, end="""")
        if i < n - 1:
            print("","", end="""")
        else:
            print(""]\n"")
 
def main():
    print_matrix(""Pascal upper-triangular matrix"", pascal_upper_triangular(5))
    print_matrix(""Pascal lower-triangular matrix"", pascal_lower_triangular(5))
    print_matrix(""Pascal symmetric matrix"", pascal_symmetric(5))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences,Fibonacci n-step number sequences,"These number series are an expansion of the ordinary Fibonacci sequence where:

 For 



n
=
2


{\displaystyle n=2}

 we have the Fibonacci sequence; with initial values 



[
1
,
1
]


{\displaystyle [1,1]}

 and 




F

k


2


=

F

k
−
1


2


+

F

k
−
2


2




{\displaystyle F_{k}^{2}=F_{k-1}^{2}+F_{k-2}^{2}}


 For 



n
=
3


{\displaystyle n=3}

 we have the tribonacci sequence; with initial values 



[
1
,
1
,
2
]


{\displaystyle [1,1,2]}

 and 




F

k


3


=

F

k
−
1


3


+

F

k
−
2


3


+

F

k
−
3


3




{\displaystyle F_{k}^{3}=F_{k-1}^{3}+F_{k-2}^{3}+F_{k-3}^{3}}


 For 



n
=
4


{\displaystyle n=4}

 we have the tetranacci sequence; with initial values 



[
1
,
1
,
2
,
4
]


{\displaystyle [1,1,2,4]}

 and 




F

k


4


=

F

k
−
1


4


+

F

k
−
2


4


+

F

k
−
3


4


+

F

k
−
4


4




{\displaystyle F_{k}^{4}=F_{k-1}^{4}+F_{k-2}^{4}+F_{k-3}^{4}+F_{k-4}^{4}}


...
 For general 



n
>
2


{\displaystyle n>2}

 we have the Fibonacci 



n


{\displaystyle n}

-step sequence - 




F

k


n




{\displaystyle F_{k}^{n}}

; with initial values of the first 



n


{\displaystyle n}

 values of the 



(
n
−
1
)


{\displaystyle (n-1)}

'th Fibonacci 



n


{\displaystyle n}

-step sequence 




F

k


n
−
1




{\displaystyle F_{k}^{n-1}}

; and 



k


{\displaystyle k}

'th value of this 



n


{\displaystyle n}

'th sequence being 




F

k


n


=

∑

i
=
1


(
n
)




F

k
−
i


(
n
)





{\displaystyle F_{k}^{n}=\sum _{i=1}^{(n)}{F_{k-i}^{(n)}}}


For small values of 



n


{\displaystyle n}

, Greek numeric prefixes are sometimes used to individually name each series.


 Fibonacci 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Series name 
 Values


 2 
 fibonacci 
 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...


 3 
 tribonacci 
 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...


 4 
 tetranacci 
 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...


 5 
 pentanacci 
 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...


 6 
 hexanacci 
 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...


 7 
 heptanacci 
 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...


 8 
 octonacci 
 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...


 9 
 nonanacci 
 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...


 10 
 decanacci 
 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...

Allied sequences can be generated where the initial values are changed:

 The Lucas series sums the two preceding values like the fibonacci series for 



n
=
2


{\displaystyle n=2}

 but uses 



[
2
,
1
]


{\displaystyle [2,1]}

 as its initial values.


Task

 Write a function to generate Fibonacci 



n


{\displaystyle n}

-step number sequences given its initial values and assuming the number of initial values determines how many previous values are summed to make the next number of the series.
 Use this to print and show here at least the first ten members of the Fibo/tribo/tetra-nacci and Lucas sequences.


Related tasks

   Fibonacci sequence
   Wolfram Mathworld
   Hofstadter Q sequence‎
   Leonardo numbers


Also see

   Lucas Numbers - Numberphile (Video)
   Tribonacci Numbers (and the Rauzy Fractal) - Numberphile (Video)
   Wikipedia, Lucas number
   MathWorld, Fibonacci Number
   Some identities for r-Fibonacci numbers
   OEIS Fibonacci numbers
   OEIS Lucas numbers

",Python,"def anynacci(start_sequence, count):
    n = len(start_sequence)
    result = start_sequence[:]
    for i in range(count-n):
        result.append(sum(result[-n:]))
    return result
 
naccis = { 'lucas':      [2,1],
           'fibonacci':  [1,1],
           'tribonacci': [1,1,2],
           'tetranacci': [1,1,2,4],
           'pentanacci': [1,1,2,4,8],
           'hexanacci':  [1,1,2,4,8,16],
           'heptanacci': [1,1,2,4,8,16,32],
           'octonacci':  [1,1,2,4,8,16,32,64],
           'nonanacci':  [1,1,2,4,8,16,32,64,128],
           'decanacci':  [1,1,2,4,8,16,32,64,128,256] }
 
for name, seq in naccis.items():
    print(""%12s : %s"" % (name, anynacci(seq, 15)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Fivenum,Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",Python,"from __future__ import division
import math
import sys
 
def fivenum(array):
    n = len(array)
    if n == 0:
        print(""you entered an empty array."")
        sys.exit()
    x = sorted(array)
 
    n4 = math.floor((n+3.0)/2.0)/2.0
    d = [1, n4, (n+1)/2, n+1-n4, n]
    sum_array = []
 
    for e in range(5):
        floor = int(math.floor(d[e] - 1))
        ceil = int(math.ceil(d[e] - 1))
        sum_array.append(0.5 * (x[floor] + x[ceil]))
 
    return sum_array
 
x = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,
-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,
1.04312009, -0.10305385, 0.75775634, 0.32566578]
 
y = fivenum(x)
print(y)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Farey_sequence,Farey sequence,"The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.

The   Farey sequence   is sometimes incorrectly called a   Farey series.



Each Farey sequence:

   starts with the value   0   (zero),   denoted by the fraction     





0
1




{\displaystyle {\frac {0}{1}}}


   ends with the value   1   (unity),   denoted by the fraction   





1
1




{\displaystyle {\frac {1}{1}}}

.


The Farey sequences of orders   1   to   5   are:

 







F




1


=


0
1


,


1
1




{\displaystyle {\bf {\it {F}}}_{1}={\frac {0}{1}},{\frac {1}{1}}}



 







F




2


=


0
1


,


1
2


,


1
1




{\displaystyle {\bf {\it {F}}}_{2}={\frac {0}{1}},{\frac {1}{2}},{\frac {1}{1}}}



 







F




3


=


0
1


,


1
3


,


1
2


,


2
3


,


1
1




{\displaystyle {\bf {\it {F}}}_{3}={\frac {0}{1}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {1}{1}}}



 







F




4


=


0
1


,


1
4


,


1
3


,


1
2


,


2
3


,


3
4


,


1
1




{\displaystyle {\bf {\it {F}}}_{4}={\frac {0}{1}},{\frac {1}{4}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {3}{4}},{\frac {1}{1}}}



 







F




5


=


0
1


,


1
5


,


1
4


,


1
3


,


2
5


,


1
2


,


3
5


,


2
3


,


3
4


,


4
5


,


1
1




{\displaystyle {\bf {\it {F}}}_{5}={\frac {0}{1}},{\frac {1}{5}},{\frac {1}{4}},{\frac {1}{3}},{\frac {2}{5}},{\frac {1}{2}},{\frac {3}{5}},{\frac {2}{3}},{\frac {3}{4}},{\frac {4}{5}},{\frac {1}{1}}}


Task
   Compute and show the Farey sequence for orders   1   through   11   (inclusive).
   Compute and display the   number   of fractions in the Farey sequence for order   100   through   1,000   (inclusive)   by hundreds.
   Show the fractions as    n/d    (using the solidus [or slash] to separate the numerator from the denominator). 


The length   (the number of fractions)   of a Farey sequence asymptotically approaches:

  3 × n2   ÷   



π


{\displaystyle \pi }

2 
See also

   OEIS sequence   A006842 numerators of Farey series of order 1, 2, ··· 
   OEIS sequence   A006843 denominators of Farey series of order 1, 2, ··· 
   OEIS sequence   A005728 number of fractions in Farey series of order n 
   MathWorld entry   Farey sequence
   Wikipedia   entry   Farey sequence

",Python,"from fractions import Fraction
 
 
class Fr(Fraction):
    def __repr__(self):
        return '(%s/%s)' % (self.numerator, self.denominator)
 
 
def farey(n, length=False):
    if not length:
        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})
    else:
        #return 1         +    len({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})
        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))
 
if __name__ == '__main__':
    print('Farey sequence for order 1 through 11 (inclusive):')
    for n in range(1, 12): 
        print(farey(n))
    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')
    print([farey(i, length=True) for i in range(100, 1001, 100)])",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",Python,"from shoes import *

PI = TWO_PI/2

def yin_yang(x, y, radius):
    fill(black); stroke(black)
    arc(x, y, radius, radius, -PI/2, PI/2)

    fill(white); stroke(white)
    arc(x, y, radius, radius, PI/2, -PI/2)
    oval(x-radius/4, y-radius/2, radius/2-1)

    fill(black); stroke(black)
    oval(x-radius/4, y, radius/2-1)
    oval(x-radius/12, y-radius/4-radius/12, radius/6-1)

    fill(white); stroke(white)
    oval(x-radius/12, y+radius/4-radius/12, radius/6-1)

    nofill()
    stroke(black)
    oval(x-radius/2, y-radius/2, radius)

Shoes.app(width=470, height=380, strokewidth=1,
    yin_yang(190, 190, 360),
    yin_yang(410, 90, 90))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Discordian_date,Discordian date,"

Task

Convert a given date from the   Gregorian calendar   to the   Discordian calendar.



",Python,"import datetime
 
seasons = [""Chaos"", ""Discord"", ""Confusion"", ""Bureaucracy"", ""The Aftermath""]
 
weekday = [""Sweetmorn"", ""Boomtime"", ""Pungenday"", ""Prickle-Prickle"", ""Setting Orange""]
 
apostle = [""Mungday"", ""Mojoday"", ""Syaday"", ""Zaraday"", ""Maladay""]
 
holiday = [""Chaoflux"", ""Discoflux"", ""Confuflux"", ""Bureflux"", ""Afflux""]
 
def discordian_date(date):
    y = date.year
    yold = y + 1166
    day_of_year = date.timetuple().tm_yday
 
    if date.is_leap_year():
        if day_of_year == 60:
            return ""St. Tib's Day, in the YOLD "" + str(yold)
        elif day_of_year > 60:
            day_of_year -= 1
 
    day_of_year -= 1
 
    season_day = day_of_year % 73 + 1
    if season_day == 5:
        return apostle[day_of_year / 73] + "", in the YOLD "" + str(yold)
    if season_day == 50:
        return holiday[day_of_year / 73] + "", in the YOLD "" + str(yold)
 
    season = seasons[day_of_year / 73]
    day_of_week = weekday[day_of_year % 5]
 
    return ""%s, day %s of %s in the YOLD %s"" % (day_of_week, season_day, season, yold)
 
def test(y, m, d, result):
    assert (discordian_date(datetime.date(y, m + 1, d)) == result)
 
if __name__ == ""__main__"":
    print discordian_date(datetime.date.today())
 
    test(2010, 6, 22, ""Pungenday, day 57 of Confusion in the YOLD 3176"")
    test(2012, 1, 28, ""Prickle-Prickle, day 59 of Chaos in the YOLD 3178"")
    test(2012, 1, 29, ""St. Tib's Day, in the YOLD 3178"")
    test(2012, 2, 1, ""Setting Orange, day 60 of Chaos in the YOLD 3178"")
    test(2010, 0, 5, ""Mungday, in the YOLD 3176"")
    test(2011, 4, 3, ""Discoflux, in the YOLD 3177"")
    test(2015, 9, 19, ""Boomtime, day 73 of Bureaucracy in the YOLD 3181"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Find_Chess960_starting_position_identifier,Find Chess960 starting position identifier,"As described on the Chess960 page, Chess960 (a.k.a Fischer Random Chess, Chess9LX) is a variant of chess where the array of pieces behind the pawns is randomized at the start of the game to minimize the value of opening theory ""book knowledge"". That task is to generate legal starting positions, and some of the solutions accept a standard Starting Position Identifier number (""SP-ID""), and generate the corresponding position.

Task

This task is to go the other way: given a starting array of pieces (provided in any form that suits your implementation, whether string or list or array, of letters or Unicode chess symbols or enum values, etc.), derive its unique SP-ID. For example, given the starting array QNRBBNKR (or ♕♘♖♗♗♘♔♖ or ♛♞♜♝♝♞♚♜), your (sub)program should return 105; given the starting lineup of standard chess, it should return 518.

You may assume the input is a valid Chess960 position; detecting invalid input (including illegal characters or starting arrays with the bishops on the same color square or the king not between the two rooks) is optional.

Algorithm

The derivation is the inverse of the algorithm given at Wikipedia, and goes like this (we'll use the standard chess setup as an example):

1. Ignoring the Queen and Bishops, find the positions of the Knights within the remaining five spaces (in the standard array they're in the second and fourth positions), and then find the index number of that combination. There's a table at the above Wikipedia article, but it's just the possible positions sorted left to right and numbered 0 to 9: 0=NN---, 1=N-N--, 2=N--N-, 3=N---N, 4=-NN--, etc; our pair is combination number 5. Call this number N. N=5

2. Now ignoring the Knights (but including the Queen and Bishops), find the position of the Queen in the remaining 6 spaces; number them 0..5 from left to right and call the index of the Queen's position Q. In our example, Q=2.

3. Finally, find the positions of the two bishops within their respective sets of four like-colored squares. It's important to note here that the board in chess is placed such that the leftmost position on the home row is on a dark square and the rightmost a light. So if we number the squares of each color 0..3 from left to right, the dark bishop in the standard position is on square 1 (D=1), and the light bishop is on square 2 (L=2).

4. Then the position number is given by 4(4(6N + Q)+D)+L, which reduces to 96N + 16Q + 4D + L. In our example, that's 96×5 + 16×2 + 4×1 + 2 = 480 + 32 + 4 + 2 = 518.
",Python,"# optional, but task function depends on it as written
def validate_position(candidate: str):
    assert (
        len(candidate) == 8
    ), f""candidate position has invalide len = {len(candidate)}""
 
    valid_pieces = {""R"": 2, ""N"": 2, ""B"": 2, ""Q"": 1, ""K"": 1}
    assert {
        piece for piece in candidate
    } == valid_pieces.keys(), f""candidate position contains invalid pieces""
    for piece_type in valid_pieces.keys():
        assert (
            candidate.count(piece_type) == valid_pieces[piece_type]
        ), f""piece type '{piece_type}' has invalid count""
 
    bishops_pos = [index for index, value in enumerate(candidate) if value == ""B""]
    assert (
        bishops_pos[0] % 2 != bishops_pos[1] % 2
    ), f""candidate position has both bishops in the same color""
 
    assert [piece for piece in candidate if piece in ""RK""] == [
        ""R"",
        ""K"",
        ""R"",
    ], ""candidate position has K outside of RR""
 
 
def calc_position(start_pos: str):
    try:
        validate_position(start_pos)
    except AssertionError:
        raise AssertionError
    # step 1
    subset_step1 = [piece for piece in start_pos if piece not in ""QB""]
    nights_positions = [
        index for index, value in enumerate(subset_step1) if value == ""N""
    ]
    nights_table = {
        (0, 1): 0,
        (0, 2): 1,
        (0, 3): 2,
        (0, 4): 3,
        (1, 2): 4,
        (1, 3): 5,
        (1, 4): 6,
        (2, 3): 7,
        (2, 4): 8,
        (3, 4): 9,
    }
    N = nights_table.get(tuple(nights_positions))
 
    # step 2
    subset_step2 = [piece for piece in start_pos if piece != ""N""]
    Q = subset_step2.index(""Q"")
 
    # step 3
    dark_squares = [
        piece for index, piece in enumerate(start_pos) if index in range(0, 9, 2)
    ]
    light_squares = [
        piece for index, piece in enumerate(start_pos) if index in range(1, 9, 2)
    ]
    D = dark_squares.index(""B"")
    L = light_squares.index(""B"")
 
    return 4 * (4 * (6*N + Q) + D) + L",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Five_weekends,Five weekends,"The month of October in 2010 has five Fridays, five Saturdays, and five Sundays.



Task

 Write a program to show all months that have this same characteristic of five full weekends from the year 1900 through 2100 (Gregorian calendar). 
 Show the number of months with this property (there should be 201).
 Show at least the first and last five dates, in order.

Algorithm suggestions

 Count the number of Fridays, Saturdays, and Sundays in every month.
 Find all of the 31-day months that begin on Friday.

Extra credit

Count and/or show all of the years which do not have at least one five-weekend month (there should be 29).



Related tasks
 Day of the week
 Last Friday of each month
 Find last sunday of each month

",Python,"from datetime import timedelta, date
 
DAY     = timedelta(days=1)
START, STOP = date(1900, 1, 1), date(2101, 1, 1)
WEEKEND = {6, 5, 4}     # Sunday is day 6
FMT     = '%Y %m(%B)'
 
def fiveweekendspermonth(start=START, stop=STOP):
    'Compute months with five weekends between dates'
 
    when = start
    lastmonth = weekenddays = 0
    fiveweekends = []
    while when < stop:
        year, mon, _mday, _h, _m, _s, wday, _yday, _isdst = when.timetuple()
        if mon != lastmonth:
            if weekenddays >= 15:
                fiveweekends.append(when - DAY)
            weekenddays = 0
            lastmonth = mon
        if wday in WEEKEND:
            weekenddays += 1
        when += DAY
    return fiveweekends
 
dates = fiveweekendspermonth()
indent = '  '
print('There are %s months of which the first and last five are:' % len(dates))
print(indent +('\n'+indent).join(d.strftime(FMT) for d in dates[:5]))
print(indent +'...')
print(indent +('\n'+indent).join(d.strftime(FMT) for d in dates[-5:]))
 
print('\nThere are %i years in the range that do not have months with five weekends'
      % len(set(range(START.year, STOP.year)) - {d.year for d in dates}))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Loops/Nested,Loops/Nested,"Show a nested loop which searches a two-dimensional array filled with random numbers uniformly distributed over 



[
1
,
…
,
20
]


{\displaystyle [1,\ldots ,20]}

.

The loops iterate rows and columns of the array printing the elements until the value 



20


{\displaystyle 20}

 is met.

Specifically, this task also shows how to break out of nested loops.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"from random import randint
 
def do_scan(mat):
    for row in mat:
        for item in row:
            print item,
            if item == 20:
                print
                return
        print
    print
 
mat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]
do_scan(mat)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Sum_of_a_series,Sum of a series,"Compute the   nth   term of a series,   i.e. the sum of the   n   first terms of the corresponding sequence.

Informally this value, or its limit when   n   tends to infinity, is also called the sum of the series, thus the title of this task.

For this task, use:

 




S

n


=

∑

k
=
1


n




1

k

2






{\displaystyle S_{n}=\sum _{k=1}^{n}{\frac {1}{k^{2}}}}




 and compute   




S

1000




{\displaystyle S_{1000}}




This approximates the   zeta function   for   S=2,   whose exact value

 



ζ
(
2
)
=



π

2


6




{\displaystyle \zeta (2)={\pi ^{2} \over 6}}


is the solution of the Basel problem.



",Python,"print ( sum(1.0 / (x * x) for x in range(1, 1001)) )",Human_written,Python_from_Rust
http://rosettacode.org/wiki/HTTPS,HTTPS,"Task

Send a GET request to obtain the resource located at the URL ""https://www.w3.org/"", then print it to the console.

Checking the host certificate for validity is recommended.

Do not authenticate. That is the subject of other tasks.

Readers may wish to contrast with the HTTP Request task, and also the task on HTTPS request with authentication.

",Python,"import urllib2
 
client = urllib2.urlopen(""https://www.google.com"")
data = client.read()
 
print data",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Holidays_related_to_Easter,Holidays related to Easter,"Task

Calculate the dates of:

   Easter
   Ascension Thursday
   Pentecost
   Trinity Sunday
   Corpus Christi feast (for Catholic)
   All Saints' Sunday (for Orthodox)


As an example, calculate for the first year of each century from;

   years     400   to   2100 CE   and for 
   years   2010   to   2020 CE.
Note

From the year 325 CE on,   Easter Sunday   has been defined as the first Sunday after the first full moon on or after the day of the March equinox. However, the actual astronomical values for the moments of the full moon and equinox are not used. Instead, approximations are used, the first one being that the equinox is assumed to fall on March 21st every year. The tracking of the moon phases is similarly done with relatively straightforward arithmetic (compared to the sort required for astronomical accuracy) which amounts to maintaining a lunisolar calendar in parallel to our standard purely-solar one.

When Pope Gregory reformed the Catholic calendar in 1582 CE, the drifting of Easter with respect to the seasons was the driving motivation, and the rules for determining it (called the computus) were altered to correct that drift. Catholic nations adopted both the new calendar and the new computus right away, while Western Protestant nations adopted them more gradually over the next 350 years or so. Eventually, even nations dominated by the Eastern Orthodox church adopted a similar calendar reform (the Revised Julian calendar), so pretty much the whole world agrees on what day it is for civil purposes. But the Eastern churches never adopted the corresponding Easter rule changes; they still use the original Julian calendar and computus to determine the date of what is known in the West as ""Orthodox Easter"". Therefore, your output should indicate which computus was used to calculate the dates and, at least for historical dates where the calendar can't be assumed or is location-dependent, which calendar those dates are given in.

You may find algorithms on the Computus Wikipedia page. Some of the results:

In the year 400 CE, Easter Sunday was April 1st (in the contemporary Julian calendar), making Ascension Thursday May 10th and Pentecost May 20th. It is ahistorical to give a date so far back for either Trinity Sunday or Corpus Christi, neither of which were observed until centuries later, but they would have been May 27th and 31st. If you extend the modern civil calendar back that far, those days are instead assigned the subsequent dates: Easter on April 2nd, Ascension on May 11th, Pentecost on May 21st.

Skipping forward to the year 2100 CE, assuming the rules don't change between now and then, the Western churches will observe Easter on March 28, Ascension Thursday May 6th, Pentecost May 16th, Trinity Sunday May 23rd and Corpus Christi May 27th. Heading East, the Orthodox rules place Easter on April 18 in the original Julian calendar; the corresponding civil date is May 2nd. That puts the Ascension on June 10th and Pentecost June 20th. Orthodox Trinity Sunday is the same day as Pentecost, but they observe All Saints' Sunday the following week, June 27th. Corpus Christi is a purely Catholic date that has no Orthodox version.

Test values of Easter dates



 Year

 Orthodox

 Catholic

 Calendar


400

01 Apr

 —

Jul.


800

19 Apr

 —

Jul.


1200

09 Apr

 —

Jul.


2000

30 Apr

23 Apr

Gr.


2020

19 Apr

12 Apr

Gr.


",Python,"from dateutil.easter import *
import datetime, calendar
 
class Holiday(object):
    def __init__(self, date, offset=0):
        self.holiday = date + datetime.timedelta(days=offset)
 
    def __str__(self):
        dayofweek = calendar.day_name[self.holiday.weekday()][0:3]
        month = calendar.month_name[self.holiday.month][0:3]
        return '{0} {1:2d} {2}'.format(dayofweek, self.holiday.day, month)
 
def get_holiday_values(year):
    holidays = {'year': year}
    easterDate = easter(year)
    holidays['easter'] = Holiday(easterDate) 
    holidays['ascension'] = Holiday(easterDate, 39)
    holidays['pentecost'] = Holiday(easterDate, 49)
    holidays['trinity'] = Holiday(easterDate, 56)
    holidays['corpus'] = Holiday(easterDate, 60)
    return holidays
 
def print_holidays(holidays):
    print '{year:4d} Easter: {easter}, Ascension: {ascension}, Pentecost: {pentecost}, Trinity: {trinity}, Corpus: {corpus}'.format(**holidays)
 
if __name__ == ""__main__"":
    print ""Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:""
    for year in range(400, 2200, 100):
        print_holidays(get_holiday_values(year))
 
    print ''
    print ""Christian holidays, related to Easter, for years from 2010 to 2020 CE:""
    for year in range(2010, 2021):
        print_holidays(get_holiday_values(year))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Colour_pinstripe/Display,Colour pinstripe/Display,"The task is to create 1 pixel wide coloured vertical pinstripes with a sufficient number of pinstripes to span the entire width of the graphics display.



The pinstripes should either follow the system palette sequence,   or a sequence that includes:

black,   red,   green,   blue,   magenta,   cyan,   yellow,   and   white:

   after filling the top quarter, switch to a wider 2 pixel wide vertical pinstripe pattern,
   halfway down the display, switch to 3 pixel wide vertical pinstripe,
   finally to a 4 pixels wide vertical pinstripe for the last quarter of the display.


See also

   display black and white 
   print colour

",Python,"from turtle import *
 
colors = [""black"", ""red"", ""green"", ""blue"", ""magenta"", ""cyan"", ""yellow"", ""white""]
 
# Middle of screen is 0,0
 
screen = getscreen()
 
left_edge = -screen.window_width()//2
 
right_edge = screen.window_width()//2
 
quarter_height = screen.window_height()//4
 
half_height = quarter_height * 2
 
speed(""fastest"")
 
for quarter in range(4):
    pensize(quarter+1)
    colornum = 0
 
    min_y = half_height - ((quarter + 1) * quarter_height)
    max_y = half_height - ((quarter) * quarter_height)
 
    for x in range(left_edge,right_edge,quarter+1):
        penup()
        pencolor(colors[colornum])
        colornum = (colornum + 1) % len(colors)
        setposition(x,min_y)
        pendown()
        setposition(x,max_y)
 
notused = input(""Hit enter to continue: "")",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Factors_of_an_integer,Factors of an integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Compute the   factors   of a positive integer.

These factors are the positive integers by which the number being factored can be divided to yield a positive integer result.

(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases).

Note that every prime number has two factors:   1   and itself.



Related tasks

   count in factors
   prime decomposition
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division
   sequence: smallest number greater than previous term with exactly n divisors

",Python,">>> def factors(n):
      return [i for i in range(1, n + 1) if not n%i]",Human_written,Python_from_C#
http://rosettacode.org/wiki/Van_Eck_sequence,Van Eck sequence,"The sequence is generated by following this pseudo-code:

A:  The first term is zero.
    Repeatedly apply:
        If the last term is *new* to the sequence so far then:
B:          The next term is zero.
        Otherwise:
C:          The next term is how far back this last term occured previously.



Example

Using A:

0
Using B:

0 0
Using C:

0 0 1
Using B:

0 0 1 0
Using C: (zero last occurred two steps back - before the one)

0 0 1 0 2
Using B:

0 0 1 0 2 0
Using C: (two last occurred two steps back - before the zero)

0 0 1 0 2 0 2 2
Using C: (two last occurred one step back)

0 0 1 0 2 0 2 2 1
Using C: (one last appeared six steps back)

0 0 1 0 2 0 2 2 1 6
...



Task

 Create a function/procedure/method/subroutine/... to generate the Van Eck sequence of numbers.
 Use it to display here, on this page:
 The first ten terms of the sequence.
 Terms 991 - to - 1000 of the sequence.


References

 Don't Know (the Van Eck Sequence) - Numberphile video.
 Wikipedia Article: Van Eck's Sequence.
  OEIS sequence: A181391.

",Python,"def van_eck():
    n, seen, val = 0, {}, 0
    while True:
        yield val
        last = {val: n}
        val = n - seen.get(val, n)
        seen.update(last)
        n += 1
#%%
if __name__ == '__main__':
    print(""Van Eck: first 10 terms:  "", list(islice(van_eck(), 10)))
    print(""Van Eck: terms 991 - 1000:"", list(islice(van_eck(), 1000))[-10:])",Human_written,Python_from_C#
http://rosettacode.org/wiki/Catalan_numbers/Pascal%27s_triangle,Catalan numbers/Pascal's triangle,"Task

Print out the first   15   Catalan numbers by extracting them from Pascal's triangle.



See

   Catalan Numbers and the Pascal Triangle.     This method enables calculation of Catalan Numbers using only addition and subtraction.
   Catalan's Triangle for a Number Triangle that generates Catalan Numbers using only addition.
   Sequence A000108 on OEIS has a lot of information on Catalan Numbers.
Related Tasks

Pascal's triangle
",Python,"def catalan(num):
    t = [0, 1] #grows as needed
    for i in range(1, num+1):
        for j in range(i, 0, -1):
            t[j] += t[j-1]
        t[i+1] = t[i]
        for j in range(i+1, 0, -1):
            t[j] += t[j-1]
        t[i+1] -= t[i]
    return t
 
print(catalan(15))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Exponentiation_order,Exponentiation order,"This task will demonstrate the order of exponentiation   (xy)    when there are multiple exponents.

(Many programming languages,   especially those with extended─precision integer arithmetic,   usually support one of  **, ^, ↑  or some such for exponentiation.)



Task requirements
Show the result of a language's evaluation of multiple exponentiation (either as an integer or floating point).

If your language's exponentiation operator is not one of the usual ones, please comment on how to recognize it.



Using whatever operator or syntax your language supports (if any), show the results in three lines (with identification):


   5**3**2 
   (5**3)**2
   5**(3**2)




If there are other methods (or formats) of multiple exponentiations, show them as well.



See also

 MathWorld entry:   exponentiation


Related tasks

   exponentiation operator
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"# version 1.0.5-2
 
def ipow(base, exp):
    if exp < 0:
        raise ValueError(""negative exponents not allowed"")
    elif exp == 0:
        return 1
    else:
        ans = 1
        e = exp
        while e!= 0:
            if e & 1 == 1:
                ans *= base
            e >>= 1
            base *= base
        return ans
 
print(""5**3**2   ="", ipow(5, ipow(3, 2)))
print(""(5**3)**2 ="", ipow(ipow(5, 3), 2))
print(""5**(3**2) ="", ipow(5, ipow(3, 2)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Josephus_problem,Josephus problem,"Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.

An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

,
removing every 



k


{\displaystyle k}

-th prisoner and killing him.

As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >

For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.



Task

Given any   



n
,
k
>
0


{\displaystyle n,k>0}

,   find out which prisoner will be the final survivor.

In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).

Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.

Which number was he?



Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free,

and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.

Provide a way to calculate which prisoner is at any given position on the killing sequence.



Notes

 You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way. This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

. However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
 If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
 An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.

",Python,">>> def j(n, k):
	p, i, seq = list(range(n)), 0, []
	while p:
		i = (i+k-1) % len(p)
		seq.append(p.pop(i))
	return 'Prisoner killing order: %s.\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])
 
>>> print(j(5, 2))
Prisoner killing order: 1, 3, 0, 4.
Survivor: 2
>>> print(j(41, 3))
Prisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.
Survivor: 30
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Subtractive_generator,Subtractive generator,"A subtractive generator calculates a sequence of random numbers, where each number is congruent to the subtraction of two previous numbers from the sequence. 

The formula is

 




r

n


=

r

(
n
−
i
)


−

r

(
n
−
j
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-i)}-r_{(n-j)}{\pmod {m}}}


for some fixed values of 



i


{\displaystyle i}

, 



j


{\displaystyle j}

 and 



m


{\displaystyle m}

, all positive integers. Supposing that 



i
>
j


{\displaystyle i>j}

, then the state of this generator is the list of the previous numbers from 




r

n
−
i




{\displaystyle r_{n-i}}

 to 




r

n
−
1




{\displaystyle r_{n-1}}

. Many states generate uniform random integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

, but some states are bad. A state, filled with zeros, generates only zeros. If 



m


{\displaystyle m}

 is even, then a state, filled with even numbers, generates only even numbers. More generally, if 



f


{\displaystyle f}

 is a factor of 



m


{\displaystyle m}

, then a state, filled with multiples of 



f


{\displaystyle f}

, generates only multiples of 



f


{\displaystyle f}

.

All subtractive generators have some weaknesses. The formula correlates 




r

n




{\displaystyle r_{n}}

, 




r

(
n
−
i
)




{\displaystyle r_{(n-i)}}

 and 




r

(
n
−
j
)




{\displaystyle r_{(n-j)}}

; these three numbers are not independent, as true random numbers would be. Anyone who observes 



i


{\displaystyle i}

 consecutive numbers can predict the next numbers, so the generator is not cryptographically secure. The authors of Freeciv (utility/rand.c) and xpat2 (src/testit2.c) knew another problem: the low bits are less random than the high bits.

The subtractive generator has a better reputation than the linear congruential generator, perhaps because it holds more state. A subtractive generator might never multiply numbers: this helps where multiplication is slow. A subtractive generator might also avoid division: the value of 




r

(
n
−
i
)


−

r

(
n
−
j
)




{\displaystyle r_{(n-i)}-r_{(n-j)}}

 is always between 



−
m


{\displaystyle -m}

 and 



m


{\displaystyle m}

, so a program only needs to add 



m


{\displaystyle m}

 to negative numbers.

The choice of 



i


{\displaystyle i}

 and 



j


{\displaystyle j}

 affects the period of the generator. A popular choice is 



i
=
55


{\displaystyle i=55}

 and 



j
=
24


{\displaystyle j=24}

, so the formula is

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod

m
)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {m}}}


The subtractive generator from xpat2 uses

 




r

n


=

r

(
n
−
55
)


−

r

(
n
−
24
)




(
mod


10

9


)



{\displaystyle r_{n}=r_{(n-55)}-r_{(n-24)}{\pmod {10^{9}}}}


The implementation is by J. Bentley and comes from program_tools/universal.c of the DIMACS (netflow) archive at Rutgers University. It credits Knuth, TAOCP, Volume 2, Section 3.2.2 (Algorithm A).

Bentley uses this clever algorithm to seed the generator.

 Start with a single 



s
e
e
d


{\displaystyle seed}

 in range 



0


{\displaystyle 0}

 to 




10

9


−
1


{\displaystyle 10^{9}-1}

.
 Set 




s

0


=
s
e
e
d


{\displaystyle s_{0}=seed}

 and 




s

1


=
1


{\displaystyle s_{1}=1}

. The inclusion of 




s

1


=
1


{\displaystyle s_{1}=1}

 avoids some bad states (like all zeros, or all multiples of 10).
 Compute 




s

2


,

s

3


,
.
.
.
,

s

54




{\displaystyle s_{2},s_{3},...,s_{54}}

 using the subtractive formula 




s

n


=

s

(
n
−
2
)


−

s

(
n
−
1
)




(
mod


10

9


)



{\displaystyle s_{n}=s_{(n-2)}-s_{(n-1)}{\pmod {10^{9}}}}

.
 Reorder these 55 values so 




r

0


=

s

34




{\displaystyle r_{0}=s_{34}}

, 




r

1


=

s

13




{\displaystyle r_{1}=s_{13}}

, 




r

2


=

s

47




{\displaystyle r_{2}=s_{47}}

, ..., 




r

n


=

s

(
34
∗
(
n
+
1
)


(
mod

55
)

)




{\displaystyle r_{n}=s_{(34*(n+1){\pmod {55}})}}

.
 This is the same order as 




s

0


=

r

54




{\displaystyle s_{0}=r_{54}}

, 




s

1


=

r

33




{\displaystyle s_{1}=r_{33}}

, 




s

2


=

r

12




{\displaystyle s_{2}=r_{12}}

, ..., 




s

n


=

r

(
(
34
∗
n
)
−
1


(
mod

55
)

)




{\displaystyle s_{n}=r_{((34*n)-1{\pmod {55}})}}

.
 This rearrangement exploits how 34 and 55 are relatively prime.
 Compute the next 165 values 




r

55




{\displaystyle r_{55}}

 to 




r

219




{\displaystyle r_{219}}

. Store the last 55 values.
This generator yields the sequence 




r

220




{\displaystyle r_{220}}

, 




r

221




{\displaystyle r_{221}}

, 




r

222




{\displaystyle r_{222}}

 and so on. For example, if the seed is 292929, then the sequence begins with 




r

220


=
467478574


{\displaystyle r_{220}=467478574}

, 




r

221


=
512932792


{\displaystyle r_{221}=512932792}

, 




r

222


=
539453717


{\displaystyle r_{222}=539453717}

. By starting at 




r

220




{\displaystyle r_{220}}

, this generator avoids a bias from the first numbers of the sequence. This generator must store the last 55 numbers of the sequence, so to compute the next 




r

n




{\displaystyle r_{n}}

. Any array or list would work; a ring buffer is ideal but not necessary.

Implement a subtractive generator that replicates the sequences from xpat2.



",Python,"import sys
 
MOD = 1000000000
state = [0] * 55
si = 0
sj = 0
 
def subrand():
	global si, sj
	if si == sj:
		subrand_seed(0)
 
	if not si:
		si = 54
	if not sj:
		sj = 54
	x = state[si] - state[sj]
	if x < 0:
		x += MOD
	state[si] = x
	si -= 1
	sj -= 1
	return x
 
def subrand_seed(p1):
	global si, sj
	p2 = 1
	state[0] = p1 % MOD
	for i in range(1, 55):
		j = i + 21
		if j >= 55:
			j -= 55
		state[j] = p2
		if (p2 = p1 - p2) < 0:
			p2 += MOD
		p1 = state[j]
	si = 0
	sj = 24
	for i in range(165):
		subrand()
 
subrand_seed(292929)
for i in range(10):
	print subrand()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Python,"class Animal:
  pass #functions go here...
 
class Dog(Animal):
  pass #functions go here...
 
class Cat(Animal):
  pass #functions go here...
 
class Lab(Dog):
  pass #functions go here...
 
class Collie(Dog):
  pass #functions go here...",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort,Sorting algorithms/Counting sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Counting sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Implement the Counting sort.   This is a way of sorting integers when the minimum and maximum value are known.



Pseudocode

function countingSort(array, min, max):
    count: array of (max - min + 1) elements
    initialize count with 0
    for each number in array do
        count[number - min] := count[number - min] + 1
    done
    z := 0
    for i from min to max do
        while ( count[i - min] > 0 ) do
            array[z] := i
            z := z+1
            count[i - min] := count[i - min] - 1
        done
    done

The min and max can be computed apart, or be known a priori.


Note:   we know that, given an array of integers,   its maximum and minimum values can be always found;   but if we imagine the worst case for an array that can hold up to 32 bit integers,   we see that in order to hold the counts,   an array of up to 232 elements may be needed.   I.E.:   we need to hold a count value up to 232-1,   which is a little over 4.2 Gbytes.   So the counting sort is more practical when the range is (very) limited,   and minimum and maximum values are known   a priori.     (However, as a counterexample,   the use of   sparse arrays   minimizes the impact of the memory usage,   as well as removing the need of having to know the minimum and maximum values   a priori.)



",Python,">>> from collections import defaultdict
>>> def countingSort(array, mn, mx):
	count = defaultdict(int)
	for i in array:
		count[i] += 1
	result = []
	for j in range(mn,mx+1):
		result += [j]* count[j]
	return result
 
>>> data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]
>>> mini,maxi = 1,10
>>> countingSort(data, mini, maxi) == sorted(data)
True",Human_written,Python_from_C
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"# version 1.1.2
 
def recurse(i):
    try:
        recurse(i + 1)
    except StackOverflowError:
        print(""Limit of recursion is "" + str(i))
 
recurse(0)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Averages/Arithmetic_mean,Averages/Arithmetic mean,"Task[edit]
Write a program to find the mean (arithmetic average) of a numeric vector.

In case of a zero-length input, since the mean of an empty set of numbers is ill-defined, the program may choose to behave in any way it deems appropriate, though if the programming language has an established convention for conveying math errors or undefined values, it's preferable to follow it.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"import math
import sys
 
def mean(v):
    if len(v) == 0:
        return
    # an algorithm that attempts to retain accuracy
    # with widely different values.
    parts = []
    for x in v:
        i = 0
        for p in parts:
            sum = p + x
            err = 0
            if abs(x) < abs(p):
                err = x - (sum - p)
            elif abs(p) < abs(x):
                err = p - (sum - x)
            if err!= 0:
                parts[i] = err
                i += 1
            x = sum
        parts.append(x)
    sum = 0
    for x in parts:
        sum += x
    return sum / float(len(v))
 
for v in [
    [],                         # mean returns ok = false
    [math.inf, math.inf], # answer is +Inf
 
    # answer is NaN, and mean returns ok = true, indicating NaN
    # is the correct result
    [math.inf, -math.inf],
 
    [3, 1, 4, 1, 5, 9],
 
    # large magnitude numbers cancel. answer is mean of small numbers.
    [1e20, 3, 1, 4, 1, 5, 9, -1e20],
 
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0,.11],
    [10, 20, 30, 40, 50, -100, 4.7, -11e2],
]:
    print(""Vector:"", v)
    try:
        m = mean(v)
        print(""Mean of %d numbers is %g\n\n"" % (len(v), m))
    except:
        print(""Mean undefined\n"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Anagrams/Deranged_anagrams,Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.0.6
 
import urllib.request
 
def is_deranged(s1, s2):
    return not any(s1[i] == s2[i] for i in range(len(s1)))
 
url = ""http://www.puzzlers.org/pub/wordlists/unixdict.txt""
with urllib.request.urlopen(url) as f:
    anagrams = {}
    count = 0
    for word in f.read().decode().split():
        chars = list(word)
        chars.sort()
        key = """".join(chars)
        if key not in anagrams:
            anagrams[key] = [word]
        else:
            deranged = any(is_deranged(w, word) for w in anagrams[key])
            if deranged:
                anagrams[key].append(word)
                count = max(count, len(word))
    for key in anagrams:
        if len(anagrams[key]) > 1 and len(anagrams[key][0]) == count:
            print(anagrams[key])",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/JSON,JSON,"Load a JSON string into a data structure.
Also, create a new data structure and serialize it into JSON.

Use objects and arrays (as appropriate for your language)
and make sure your JSON is valid (https://jsonformatter.org).
",Python,"import json
 
people = {""1"": ""John"", ""2"": ""Susan""}
 
json_string = json.dumps(people)
print(json_string)
 
deserialized = json.loads(json_string)
print(deserialized[""2""])
 
json_object = json.loads('{""foo"": 1, ""bar"": [10, ""apples""]}')
data = json_object
array = data[""bar""]
print(array[1])",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Brownian_tree,Brownian tree,"Brownian tree

You are encouraged to solve this task according to the task description, using any language you may know.



Task

Generate and draw a   Brownian Tree.



A Brownian Tree is generated as a result of an initial seed, followed by the interaction of two processes.

 The initial ""seed"" is placed somewhere within the field. Where is not particularly important; it could be randomized, or it could be a fixed point.
 Particles are injected into the field, and are individually given a (typically random) motion pattern.
 When a particle collides with the seed or tree, its position is fixed, and it's considered to be part of the tree.

Because of the lax rules governing the random nature of the particle's placement and motion, no two resulting trees are really expected to be the same, or even necessarily have the same general shape. 


",Python,"import random
import time
import math
from PIL import Image
 
NUM_PARTICLES = 1000
SIZE = 800
 
def draw_brownian_tree(world):
  px, py = 0, 0 # particle values
  dx, dy = 0, 0 # offsets
  i = 0
 
  # set the seed
  world[random.randint(0, SIZE)][random.randint(0, SIZE)] = 1
 
  for i in range(NUM_PARTICLES):
    # set particle's initial position
    px = random.randint(0, SIZE)
    py = random.randint(0, SIZE)
 
    while True:
      # randomly choose a direction
      dx = random.randint(-1, 1)
      dy = random.randint(-1, 1)
 
      if dx + px < 0 or dx + px >= SIZE or dy + py < 0 or dy + py >= SIZE:
        # plop the particle into some other random location
        px = random.randint(0, SIZE)
        py = random.randint(0, SIZE)
      elif world[py + dy][px + dx]!= 0:
        # bumped into something
        world[py][px] = 1
        break
      else:
        py += dy
        px += dx
 
if __name__ == '__main__':
  world = [[0 for x in range(SIZE)] for y in range(SIZE)]
  random.seed(time.time())
 
  draw_brownian_tree(world)
 
  img = Image.new('RGB', (SIZE, SIZE))
 
  for y in range(SIZE):
    for x in range(SIZE):
      if world[y][x] == 1:
        img.putpixel((x, y), (255, 255, 255))
 
  img.save('brownian_tree.bmp')",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Flow-control_structures,Flow-control structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Task

Document common flow-control structures.



One common example of a flow-control structure is the    goto    construct.

Note that   Conditional Structures   and   Loop Structures   have their own articles/categories.



Related tasks

   Conditional Structures
   Loop Structures 

",Python,"import sys

def main():
    while True:
        print(""Hello, World!"")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sierpinski_triangle,Sierpinski triangle,"Task
Produce an ASCII representation of a Sierpinski triangle of order   N.



Example
The Sierpinski triangle of order   4   should look like this:

                       *
                      * *
                     *   *
                    * * * *
                   *       *
                  * *     * *
                 *   *   *   *
                * * * * * * * *
               *               *
              * *             * *
             *   *           *   *
            * * * *         * * * *
           *       *       *       *
          * *     * *     * *     * *
         *   *   *   *   *   *   *   *
        * * * * * * * * * * * * * * * *



Related tasks
 Sierpinski triangle/Graphical for graphics images of this pattern. 
 Sierpinski carpet

",Python,"from itertools import chain, repeat
 
def sierpinski(n):
    if n == 0:
        yield '*'
    else:
        prev = sierpinski(n-1)
        sp ='' * (1 << (n-1))
        for x in prev:
            yield sp + x + sp
            yield x +'' + x
 
print('\n'.join(sierpinski(4)))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Caesar_cipher,Caesar cipher,"

Task

Implement a Caesar cipher, both encoding and decoding. 

The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).

So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"".

This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigenère cipher with a key of length 1. 

Also, Rot-13 is identical to Caesar cipher with key 13.



Related tasks

 Rot-13
 Substitution Cipher
 Vigenère Cipher/Cryptanalysis

",Python,"# version 1.0.5-2
 
class Caesar:
    def encrypt(self, s, key):
        offset = key % 26
        if offset == 0:
            return s
        d = None
        chars = []
        for index, c in enumerate(s):
            if c in 'A'..'Z':
                d = c + offset
                if d > 'Z':
                    d -= 26
            elif c in 'a'..'z':
                d = c + offset
                if d > 'z':
                    d -= 26
            else:
                d = c
            chars.append(d)
        return ''.join(chars)
 
    def decrypt(self, s, key):
        return self.encrypt(s, 26 - key)
 
if __name__ == '__main__':
    caesar = Caesar()
    encoded = caesar.encrypt(""Bright vixens jump; dozy fowl quack."", 8)
    print(encoded)
    decoded = caesar.decrypt(encoded, 8)
    print(decoded)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Peano_curve,Peano curve,"

Task
Produce a graphical or ASCII-art representation of a Peano curve of at least order 3.
",Python,"import turtle as tt
import inspect
 
stack = [] # Mark the current stacks in run.
def peano(iterations=1):
    global stack
 
    # The turtle Ivan:
    ivan = tt.Turtle(shape = ""classic"", visible = True)
 
 
    # The app window:
    screen = tt.Screen()
    screen.title(""Desenhin do Peano"")
    screen.bgcolor(""#232323"")
    screen.delay(0) # Speed on drawing (if higher, more slow)
    screen.setup(width=0.95, height=0.9)
 
    # The size of each step walked (here, named simply ""walk""). It's not a pixel scale. This may stay still:
    walk = 1
 
    def screenlength(k):
        # A function to make the image good to see (without it would result in a partial image).
        # This will guarantee that we can see the the voids and it's steps.
        if k != 0:
            length = screenlength(k-1)
            return 2*length + 1
        else: return 0
 
    kkkj = screenlength(iterations)
    screen.setworldcoordinates(-1, -1, kkkj + 1, kkkj + 1)
    ivan.color(""#EEFFFF"", ""#FFFFFF"")
 
 
    # The magic  \(^-^)/:
    def step1(k):
        global stack
        stack.append(len(inspect.stack()))
        if k != 0:
            ivan.left(90)
            step2(k - 1)
            ivan.forward(walk)
            ivan.right(90)
            step1(k - 1)
            ivan.forward(walk)
            step1(k - 1)
            ivan.right(90)
            ivan.forward(walk)
            step2(k - 1)
            ivan.left(90)
    def step2(k):
        global stack
        stack.append(len(inspect.stack()))
        if k != 0:
            ivan.right(90)
            step1(k - 1)
            ivan.forward(walk)
            ivan.left(90)
            step2(k - 1)
            ivan.forward(walk)
            step2(k - 1)
            ivan.left(90)
            ivan.forward(walk)
            step1(k - 1)
            ivan.right(90)
 
    # Making the program work:
    ivan.left(90)
    step2(iterations)
 
    tt.done()
 
if __name__ == ""__main__"":
    peano(4)
    import pylab as P # This plot, after closing the drawing window, the ""stack"" graphic.
    P.plot(stack)
    P.show()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Checkpoint_synchronization,Checkpoint synchronization,"The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.

The task

Implement checkpoint synchronization in your language.

Make sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.
",Python,"""""""
 
Based on https://pymotw.com/3/threading/
 
""""""
 
import threading
import time
import random
 
 
def worker(workernum, barrier):
    # task 1
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 1, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
    barrier.wait()
    # task 2
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 2, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
 
barrier = threading.Barrier(3)
 
w1 = threading.Thread(target=worker, args=((1,barrier)))
w2 = threading.Thread(target=worker, args=((2,barrier)))
w3 = threading.Thread(target=worker, args=((3,barrier)))
 
w1.start()
w2.start()
w3.start()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> def stripchars(s, chars):
...     return s.translate(None, chars)
... 
>>> stripchars(""She was a soul stripper. She took my heart!"", ""aei"")
'Sh ws  soul strppr. Sh took my hrt!'",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"import random
 
def is_sorted(list):
    if len(list) <= 1:
        return True
    for i in range(1, len(list)):
        if list[i] < list[i-1]:
            return False
    return True
 
def shuffle(list):
    for i in range(len(list)):
        swap_index = random.randint(0, len(list)-1)
        temp = list[swap_index]
        list[swap_index] = list[i]
        list[i] = temp
 
def bogo_sort(list):
    while not is_sorted(list):
        shuffle(list)
 
test_list = [3, 4, 1, 8, 7, 4, -2]
bogo_sort(test_list)
print(test_list)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Jewels_and_stones,Jewels and stones,"Jewels and stones

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.

Both strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.

The function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.



Note that:

 Only letters in the ISO basic Latin alphabet i.e. 'A to Z' or 'a to z' need be considered. 
 A lower case letter is considered to be different from its upper case equivalent for this purpose, i.e., 'a' != 'A'.
 The parameters do not need to have exactly the same names.
 Validating the arguments is unnecessary. 
So, for example, if passed ""aAAbbbb"" for 'stones' and ""aA"" for 'jewels', the function should return 3.

This task was inspired by this problem.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_palindrome(s)
  s == s.reverse
end",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Web_scraping,Web scraping,"Task

Create a program that downloads the time from this URL:   http://tycho.usno.navy.mil/cgi-bin/timer.pl   and then prints the current UTC time by extracting just the UTC time from the web page's HTML. Alternatively, if the above url is not working, grab the first date/time off this page's talk page.



If possible, only use libraries that come at no extra monetary cost with the programming language and that are widely available and popular such as CPAN for Perl or Boost for C++.



",Python,"import urllib
page = urllib.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl')
for line in page:
    if ' UTC' in line:
        print line.strip()[4:]
        break
page.close()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sum_of_squares,Sum of squares,"Task

Write a program to find the sum of squares of a numeric vector.

The program should work on a zero-length vector (with an answer of   0).



Related task

   Mean

",Python,"nums = [1,2,3,4,5]
sum = 0
for i in nums:
    sum += i * i
print(""The sum of the squares is: "" + str(sum))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/GUI_component_interaction,GUI component interaction,"

Almost every application needs to communicate with the user in some way.
Therefore, a substantial part of the code deals with the interaction
of program logic with GUI components.

Typically, the following is needed:

 put values into input fields under program control
 read and check input from the user
 pop up dialogs to query the user for further information


Task

For a minimal ""application"", write a program that presents a form with three components to the user:

 a numeric input field (""Value"") 
 a button (""increment"")
 a button (""random"")


The field is initialized to zero.

The user may manually enter a new value into the field,
or increment its value with the ""increment"" button.

Entering a non-numeric value should be either impossible,
or issue an error message.

Pressing the ""random"" button presents a confirmation dialog,
and resets the field's value to a random value if the answer is ""Yes"".

(This task may be regarded as an extension of the task Simple windowed application).


",Python,"import random, tkMessageBox
from Tkinter import *
window = Tk()
window.geometry(""300x50+100+100"")
options = { ""padx"":5, ""pady"":5}
s=StringVar()
s.set(1)
def increase():
    s.set(int(s.get())+1)
def rand():
    if tkMessageBox.askyesno(""Confirmation"", ""Reset to random value ?""):
        s.set(random.randrange(0,5000))
def update(e):
    if not e.char.isdigit():
        tkMessageBox.showerror('Error', 'Invalid input !') 
        return ""break""
e = Entry(text=s)
e.grid(column=0, row=0, **options)
e.bind('<Key>', update)
b1 = Button(text=""Increase"", command=increase, **options )
b1.grid(column=1, row=0, **options)
b2 = Button(text=""Random"", command=rand, **options)
b2.grid(column=2, row=0, **options)
mainloop()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def prime(a):
    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))",Human_written,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort,Sorting algorithms/Stooge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Stooge sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Show the   Stooge Sort   for an array of integers.



The Stooge Sort algorithm is as follows:

algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t := (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L


",Python,"def Sort(list):
    if len(list) > 1:
        StoogeSort(list, 0, len(list) - 1)

def StoogeSort(L, i, j):
    if L[j] < L[i]:
        L[i], L[j] = L[j], L[i]
    if j - i > 1:
        t = (j - i + 1) // 3
        StoogeSort(L, i, j - t)
        StoogeSort(L, i + t, j)
        StoogeSort(L, i, j - t)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Primes_-_allocate_descendants_to_their_ancestors,Primes - allocate descendants to their ancestors,"The concept, is to add the decomposition into prime factors of a number to get its 'ancestors'.



The objective is to demonstrate that the choice of the algorithm can be crucial in term of performance.
This solution could be compared to the solution that would use the decomposition into primes for all the numbers between 1 and 333.



The problem is to list, for a delimited set of ancestors (from 1 to 99) :

- the total of their own ancestors (LEVEL),

- their own ancestors (ANCESTORS),

- the total of the direct descendants (DESCENDANTS),

- all the direct descendants.



You only have to consider the prime factors < 100.

A grand total of the descendants has to be printed at the end of the list.

The task should be accomplished in a reasonable time-frame.



Example :

46 = 2*23 --> 2+23 = 25, is the parent of 46.
25 = 5*5  --> 5+5  = 10, is the parent of 25.
10 = 2*5  --> 2+5  = 7,  is the parent of 10.
7 is a prime factor and, as such, has no parent.

46 has 3 ancestors (7, 10 and 25).
46 has 557 descendants.
The list layout and the output for Parent [46] :

[46] Level: 3
Ancestors: 7, 10, 25
Descendants: 557
129, 205, 246, 493, 518, 529, 740, 806, 888, 999, 1364, 1508, 1748, 2552, 2871, 3128, 3255, 3472, 3519, 3875, 3906, 4263, 4650, 4960, 5075, 5415, 5580, 5776, 5952, 6090, 6279, 6496, 6498, 6696, 6783, 7250, 7308, 7475, 7533, 8075, 8151, 8619, 8700, 8855, 8970, 9280, 9568, 9690, 10115, 10336, 10440, 10626, 10764, 11136, 11495, 11628, 11745, 12103, 12138, 12155, 12528, 12650, 13794, 14094, 14399, 14450, 14586, 15180, 15379, 15778, 16192, 17290, 17303, 17340, 18216, 18496, 20482, 20493, 20570, 20748, 20808, 21658, 21970, 22540, 23409, 24684, 24700, 26026, 26364, 27048, 29260, 29282, 29640, 30429, 30940, 31616, 32200, 33345, 35112, 35568, 36225, 36652, 37128, 37180, 38640, 39501, 40014, 41216, 41769, 41800, 43125, 43470, 44044, 44200, 44616, 46000, 46368, 47025, 49725, 50160, 50193, 51750, 52136, 52164, 52360, 53040, 53504, 55200, 56430, 56576, 58653, 58880, 58905, 59670, 60192, 62100, 62832, 62920, 63648, 66240, 66248, 67716, 69825, 70125, 70656, 70686, 70785, 71604, 74480, 74520, 74529, 74536, 74800, 75504, 79488, 83125, 83790, 83835, 83853, 84150, 84942, 87465, 88725, 89376, 89424, 89760, 93296, 94640, 95744, 99750, 99825, 100548, 100602, 100980, 104125, 104958, 105105, 105625, 106400, 106470, 106480, 107712, 112112, 113568, 118750, 119700, 119790, 121176, 124509, 124950, 125125, 126126, 126750, 127680, 127764, 127776, 133280, 135200, 136192, 136323, 142500, 143640, 143748, 148225, 148750, 149940, 150150, 152000, 152100, 153216, 156065, 159936, 160160, 161595, 162240, 171000, 172368, 173056, 177870, 178500, 178750, 179928, 180180, 182400, 182520, 184877, 187278, 189728, 190400, 192192, 192375, 193914, 194560, 194688, 202419, 205200, 205335, 211750, 212500, 213444, 214200, 214500, 216216, 218880, 219024, 222950, 228480, 228800, 230850, 233472, 240975, 243243, 243712, 246240, 246402, 254100, 255000, 257040, 257400, 262656, 264110, 267540, 271040, 272000, 274176, 274560, 277020, 285376, 286875, 289170, 289575, 292864, 295488, 302500, 304920, 306000, 308448, 308880, 316932, 318500, 321048, 325248, 326400, 329472, 332424, 343035, 344250, 347004, 347490, 348160, 361179, 363000, 365904, 367200, 370656, 373977, 377300, 382200, 387200, 391680, 407680, 408375, 411642, 413100, 416988, 417792, 429975, 435600, 440640, 452760, 455000, 458640, 464640, 470016, 470596, 482944, 489216, 490050, 495616, 495720, 509355, 511875, 515970, 522720, 528768, 539000, 543312, 546000, 550368, 557568, 557685, 582400, 588060, 594864, 606375, 609375, 611226, 614250, 619164, 627264, 646800, 650000, 655200, 669222, 672280, 689920, 698880, 705672, 721875, 727650, 731250, 737100, 745472, 756315, 770000, 776160, 780000, 786240, 793881, 806736, 827904, 832000, 838656, 859375, 866250, 873180, 877500, 884520, 900375, 907578, 924000, 931392, 936000, 943488, 960400, 985600, 995085, 998400, 1031250, 1039500, 1047816, 1053000, 1061424, 1064960, 1071875, 1080450, 1100000, 1108800, 1123200, 1152480, 1178793, 1182720, 1184625, 1194102, 1198080, 1229312, 1237500, 1247400, 1261568, 1263600, 1277952, 1286250, 1296540, 1320000, 1330560, 1347840, 1372000, 1382976, 1403325, 1408000, 1419264, 1421550, 1437696, 1485000, 1496880, 1516320, 1531250, 1543500, 1555848, 1584000, 1596672, 1617408, 1646400, 1670625, 1683990, 1689600, 1705860, 1750329, 1756160, 1782000, 1796256, 1802240, 1819584, 1837500, 1852200, 1900800, 1960000, 1975680, 2004750, 2020788, 2027520, 2047032, 2083725, 2107392, 2138400, 2162688, 2187500, 2205000, 2222640, 2280960, 2302911, 2352000, 2370816, 2405700, 2433024, 2480625, 2500470, 2508800, 2566080, 2625000, 2646000, 2667168, 2737152, 2800000, 2822400, 2886840, 2953125, 2976750, 3000564, 3010560, 3079296, 3125000, 3150000, 3175200, 3211264, 3247695, 3360000, 3386880, 3464208, 3515625, 3543750, 3572100, 3584000, 3612672, 3750000, 3780000, 3810240, 3897234, 4000000, 4032000, 4064256, 4218750, 4252500, 4286520, 4300800, 4500000, 4536000, 4572288, 4587520, 4800000, 4822335, 4838400, 5062500, 5103000, 5120000, 5143824, 5160960, 5400000, 5443200, 5505024, 5740875, 5760000, 5786802, 5806080, 6075000, 6123600, 6144000, 6193152, 6480000, 6531840, 6553600, 6834375, 6889050, 6912000, 6967296, 7290000, 7348320, 7372800, 7776000, 7838208, 7864320, 8201250, 8266860, 8294400, 8388608, 8748000, 8817984, 8847360, 9331200, 9437184, 9841500, 9920232, 9953280, 10497600, 10616832, 11160261, 11197440, 11809800, 11943936, 12597120, 13286025, 13436928, 14171760, 15116544, 15943230, 17006112, 19131876
Some figures :

The biggest descendant number : 3^33 = 5.559.060.566.555.523 (parent 99)

Total Descendants 546.986
",Python,"from __future__ import print_function
from itertools import takewhile
 
maxsum = 99
 
def get_primes(max):
    if max < 2:
        return []
    lprimes = [2]
    for x in range(3, max + 1, 2):
        for p in lprimes:
            if x % p == 0:
                break
        else:
            lprimes.append(x)
    return lprimes
 
descendants = [[] for _ in range(maxsum + 1)]
ancestors = [[] for _ in range(maxsum + 1)]
 
primes = get_primes(maxsum)
 
for p in primes:
    descendants[p].append(p)
    for s in range(1, len(descendants) - p):
        descendants[s + p] += [p * pr for pr in descendants[s]]
 
for p in primes + [4]:
    descendants[p].pop()
 
total = 0
for s in range(1, maxsum + 1):
    descendants[s].sort()
    for d in takewhile(lambda x: x <= maxsum, descendants[s]):
        ancestors[d] = ancestors[s] + [s]
    print([s], ""Level:"", len(ancestors[s]))
    print(""Ancestors:"", ancestors[s] if len(ancestors[s]) else ""None"")
    print(""Descendants:"", len(descendants[s]) if len(descendants[s]) else ""None"")
    if len(descendants[s]):
        print(descendants[s])
    print()
    total += len(descendants[s])
 
print(""Total descendants"", total)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/The_sieve_of_Sundaram,The sieve of Sundaram,"The sieve of Eratosthenes: you've been there; done that; have the T-shirt. The sieve of Eratosthenes was ancient history when Euclid was a schoolboy. You are ready for something less than 3000 years old. You are ready for The sieve of Sundaram.

Starting with the ordered set of +ve integers, mark every third starting at 4 (4;7;10...).

Step through the set and if the value is not marked output 2*n+1. So from 1 to 4 output 3 5 7.

4 is marked so skip for 5 and 6 output 11 and 13.

7 is marked, so no output but now also mark every fifth starting at 12 (12;17;22...)

as per to 10 and now mark every seventh starting at 17 (17;24;31....)

as per for every further third element (13;16;19...) mark every (9th;11th;13th;...) element.

The output will be the ordered set of odd primes.

Using your function find and output the first 100 and the millionth Sundaram prime.

The faithless amongst you may compare the results with those generated by The sieve of Eratosthenes.

References

 The article on Wikipedia.

",Python,"from numpy import log
 
def sieve_of_Sundaram(nth, print_all=True):
    """"""
    The sieve of Sundaram is a simple deterministic algorithm for finding all the
    prime numbers up to a specified integer. This function is modified from the
    Wikipedia entry wiki/Sieve_of_Sundaram, to give primes to their nth rather
    than the Wikipedia function that gives primes less than n.
    """"""
    assert nth > 0, ""nth must be a positive integer""
    k = int((2.4 * nth * log(nth)) // 2)  # nth prime is at about n * log(n)
    integers_list = [True] * k
    for i in range(1, k):
        j = i
        while i + j + 2 * i * j < k:
            integers_list[i + j + 2 * i * j] = False
            j += 1
    pcount = 0
    for i in range(1, k + 1):
        if integers_list[i]:
            pcount += 1
            if print_all:
                print(f""{2 * i + 1:4}"", end=' ')
                if pcount % 10 == 0:
                    print()
 
            if pcount == nth:
                print(f""\nSundaram primes start with 3. The {nth}th Sundaram prime is {2 * i + 1}.\n"")
                break
 
 
 
sieve_of_Sundaram(100, True)
 
sieve_of_Sundaram(1000000, False)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Hostname,Hostname,"Task

Find the name of the host on which the routine is running.



",Python,"import socket
socket.gethostbyname(socket.gethostname())",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort,Sorting algorithms/Selection sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of elements using the Selection sort algorithm.



It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.



Its asymptotic complexity is    O(n2)    making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.



References

   Rosetta Code:   O     (complexity).
   Wikipedia:   Selection sort.
   Wikipedia:   [Big O notation].

",Python,"def selection_sort(lst):
    for i, e in enumerate(lst):
        mn = min(range(i,len(lst)), key=lst.__getitem__)
        lst[i], lst[mn] = lst[mn], e
    return lst",Human_written,Python_from_C#
http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Python,"from random import randrange
 
def s_of_n_creator(n):
    sample, i = [], 0
    def s_of_n(item):
        nonlocal i
 
        i += 1
        if i <= n:
            # Keep first n items
            sample.append(item)
        elif randrange(i) < n:
            # Keep item
            sample[randrange(n)] = item
        return sample
    return s_of_n
 
if __name__ == '__main__':
    bin = [0]* 10
    items = range(10)
    print(""Single run samples for n = 3:"")
    s_of_n = s_of_n_creator(3)
    for item in items:
        sample = s_of_n(item)
        print(""  Item: %i -> sample: %s"" % (item, sample))
    #
    for trial in range(100000):
        s_of_n = s_of_n_creator(3)
        for item in items:
            sample = s_of_n(item)
        for s in sample:
            bin[s] += 1
    print(""\nTest item frequencies for 100000 runs:\n "",
          '\n  '.join(""%i:%i"" % x for x in enumerate(bin)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sort_an_array_of_composite_structures,Sort an array of composite structures,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of composite structures by a key.



For example, if you define a composite structure that presents a name-value pair (in pseudo-code):

Define structure pair such that: 
   name as a string
   value as a string

and an array of such pairs:

   x: array of pairs

then define a sort routine that sorts the array x by the key name.

This task can always be accomplished with Sorting Using a Custom Comparator.

If your language is not listed here, please see the other article.



",Python,"# version 1.1
 
class Employee(name, category):
    def __init__(self, name, category):
        self.name = name
        self.category = category
    def __lt__(self, other):
        return self.name < other.name
 
def main():
    employees = [
        Employee(""David"", ""Manager""),
        Employee(""Alice"", ""Sales""),
        Employee(""Joanna"", ""Director""),
        Employee(""Henry"", ""Admin""),
        Employee(""Tim"", ""Sales""),
        Employee(""Juan"", ""Admin"")
    ]
    employees.sort()
    for employee in employees:
        print(f""{employee.name.ljust(6)} : {employee.category}"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number,Validate International Securities Identification Number,"An International Securities Identification Number (ISIN) is a unique international identifier for a financial security such as a stock or bond.



Task

Write a function or program that takes a string as input, and checks whether it is a valid ISIN.

It is only valid if it has the correct format,   and   the embedded checksum is correct.

Demonstrate that your code passes the test-cases listed below.



Details

The format of an ISIN is as follows:


┌───────────── a 2-character ISO country code (A-Z)
│ ┌─────────── a 9-character security code (A-Z, 0-9)
│ │        ┌── a checksum digit (0-9)
AU0000XVGZA3



For this task, you may assume that any 2-character alphabetic sequence is a valid country code.

The checksum can be validated as follows:

 Replace letters with digits, by converting each character from base 36 to base 10, e.g. AU0000XVGZA3 →1030000033311635103.
 Perform the Luhn test on this base-10 number.
There is a separate task for this test: Luhn test of credit card numbers.
You don't have to replicate the implementation of this test here   ───   you can just call the existing function from that task.   (Add a comment stating if you did this.)


Test cases



 ISIN

 Validity

 Comment


 US0378331005 
 valid 



 US0373831005 
 not valid 
 The transposition typo is caught by the checksum constraint.


 U50378331005 
 not valid 
 The substitution typo is caught by the format constraint.


 US03378331005 
 not valid 
 The duplication typo is caught by the format constraint.


 AU0000XVGZA3 
 valid 



 AU0000VXGZA3 
 valid 
 Unfortunately, not all transposition typos are caught by the checksum constraint.


 FR0000988040 
 valid 


(The comments are just informational.   Your function should simply return a Boolean result.   See #Raku for a reference solution.)



Related task:

 Luhn test of credit card numbers


Also see

 Interactive online ISIN validator
 Wikipedia article: International Securities Identification Number

",Python,"import luhn_cc
 
def validate_isin(isin):
    # Preliminary checks to avoid working on non-ASCII stuff
    if not isin.isalnum() or len(isin)!= 12:
        return False
    if not isin[:2].isalpha() or not isin[2:11].isalnum() or not isin[11:].isdigit():
        return False
 
    # Converts the alphanumeric string in a numeric-only string
    s2 = ''.join(chr(ord(c) + 10 - ord('A')) if c.isalpha() else c for c in isin)
 
    return luhn_cc.compute_luhn(int(s2))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",Python,"from typing import List, Tuple
 
Vector = List[float]
Matrix = List[Vector]
 
def mul(m1: Matrix, m2: Matrix) -> Matrix:
    rows1, cols1 = len(m1), len(m1[0])
    rows2, cols2 = len(m2), len(m2[0])
    if cols1!= rows2:
        raise ValueError(""Matrices cannot be multiplied."")
    result = [[0.0] * cols2 for _ in range(rows1)]
    for i in range(rows1):
        for j in range(cols2):
            for k in range(rows2):
                result[i][j] += m1[i][k] * m2[k][j]
    return result
 
def identity_matrix(n: int) -> Matrix:
    if n < 1:
        raise ValueError(""Size of identity matrix can't be less than 1"")
    ident = [[0.0] * n for _ in range(n)]
    for i in range(n):
        ident[i][i] = 1
    return ident
 
def pow(m: Matrix, n: int) -> Matrix:
    le = len(m)
    if le!= len(m[0]):
        raise ValueError(""Not a square matrix"")
    if n < 0:
        raise ValueError(""Negative exponents not supported"")
    if n == 0:
        return identity_matrix(le)
    if n == 1:
        return m
    pow = identity_matrix(le)
    base = m
    e = n
    while e > 0:
        if (e & 1) == 1:
            pow = mul(pow, base)
        e >>= 1
        base = mul(base, base)
    return pow
 
if __name__ == ""__main__"":
    m = [[3, 2], [2, 1]]
    for i in range(11):
        print(""** Power of"", i, ""**"")
        print(pow(m, i))
        print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/McNuggets_problem,McNuggets problem,"Wikipedia
The McNuggets version of the coin problem was introduced by Henri Picciotto,
who included it in his algebra textbook co-authored with Anita Wah. Picciotto
thought of the application in the 1980s while dining with his son at
McDonald's, working the problem out on a napkin. A McNugget number is
the total number of McDonald's Chicken McNuggets in any number of boxes.
In the United Kingdom, the original boxes (prior to the introduction of
the Happy Meal-sized nugget boxes) were of 6, 9, and 20 nuggets.

Task

Calculate (from 0 up to a limit of 100) the largest non-McNuggets
number (a number n which cannot be expressed with 6x + 9y + 20z = n
where x, y and z are natural numbers).



",Python,"isMcNuggetNumber = [False] * 101

for x in range(0, 100/6 + 1):
    for y in range(0, 100/9 + 1):
        for z in range(0, 100/20 + 1):
            mcNuggetNumber = x*6 + y*9 + z*20
            if mcNuggetNumber <= 100:
                isMcNuggetNumber[mcNuggetNumber] = True

for mnnCheck in range(len(isMcNuggetNumber)-1, -1, -1):
    if not isMcNuggetNumber[mnnCheck]:
        print(""Largest non-McNuggett Number less than 100: "" + str(mnnCheck))
        break",Ai_generated,Python_from_C#
"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence","Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",Python,"from __future__ import division
 
def maxandmallows(nmaxpower2):
    nmax = 2**nmaxpower2
    mx = (0.5, 2)
    mxpow2 = []
    mallows = None
 
    # Hofstadter-Conway sequence starts at hc[1],
    # hc[0] is not part of the series.
    hc = [None, 1, 1]
 
    for n in range(2, nmax + 1):
        ratio = hc[n] / n
        if ratio > mx[0]:
            mx = (ratio, n)
        if ratio >= 0.55:
            mallows = n
        if ratio == 0.5:
            print(""In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i"" %
		  (n//2, n, mx[0], mx[1]))
            mxpow2.append(mx[0])
            mx = (ratio, n)
        hc.append(hc[hc[n]] + hc[-hc[n]])
 
    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None
 
if __name__ == '__main__':
    hc, mallows = maxandmallows(20)
    if mallows:
        print(""\nYou too might have won $1000 with the mallows number of %i"" % mallows)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Maze_solving,Maze solving,"Task

For a maze generated by this task, write a function
that finds (and displays) the shortest path between two cells.



Note that because these mazes are generated by the Depth-first search algorithm, they contain no circular paths,
and a simple depth-first tree search can be used.



",Python,"class Maze:
    # Solve via breadth-first algorithm.
    # Each queue entry is a path, that is list of coordinates with the
    # last coordinate being the one that shall be visited next.
    def solve(self):
        # Clean up.
        self.reset_visiting_state()
        # Enqueue start position.
        self.queue = []
        self.enqueue_cell([], self.start_x, self.start_y)
        # Loop as long as there are cells to visit and no solution has
        # been found yet.
        path = None
        while path is None and len(self.queue) > 0:
            path = self.solve_visit_cell()
        if path:
            # Mark the cells that make up the shortest path.
            for x, y in path:
                self.path[x][y] = True
        else:
            print(""No solution found?!"")
    def solve_visit_cell(self):
        # Get the next path.
        path = self.queue.pop(0)
        # The cell to visit is the last entry in the path.
        x, y = path[-1]
        # Have we reached the end yet?
        if x == self.end_x and y == self.end_y:
            return path
        # Mark cell as visited.
        self.visited[x][y] = True
        for dx, dy in DIRECTIONS:
            if dx:
                # Left / Right
                new_x = x + dx
                if self.move_valid(new_x, y) and not self.vertical_walls[min(x, new_x)][y]:
                    self.enqueue_cell(path, new_x, y)
            else:
                # Top / Bottom
                new_y = y + dy
                if self.move_valid(x, new_y) and not self.horizontal_walls[x][min(y, new_y)]:
                    self.enqueue_cell(path, x, new_y)
        return None         # No solution yet.
    # Enqueue a new coordinate to visit.
    def enqueue_cell(self, path, x, y):
        # Add new coordinates to the current path and enqueue the new path.
        self.queue.append(path + [[x, y]])
# Demonstration:
maze = Maze(20, 10)
maze.solve()
maze.print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Read_entire_file,Read entire file,"Task

Load the entire contents of some text file as a single string variable.

If applicable, discuss: encoding selection, the possibility of memory-mapping.

Of course, in practice one should avoid reading an entire file at once
if the file is large and the task can be accomplished incrementally instead
(in which case check File IO);
this is for those cases where having the entire file is actually what is wanted.



",Python,open(filename).read(),Human_written,Python_from_C++
http://rosettacode.org/wiki/Mind_boggling_card_trick,Mind boggling card trick,"Mind boggling card trick

You are encouraged to solve this task according to the task description, using any language you may know.
Matt Parker of the ""Stand Up Maths channel"" has a   YouTube video   of a card trick that creates a semblance of order from chaos.

The task is to simulate the trick in a way that mimics the steps shown in the video.

 1. Cards.
 Create a common deck of cards of 52 cards   (which are half red, half black).
 Give the pack a good shuffle.
 2. Deal from the shuffled deck, you'll be creating three piles.
 Assemble the cards face down.
 Turn up the   top card   and hold it in your hand.
 if the card is   black,   then add the   next   card (unseen) to the ""black"" pile. 
 If the card is     red,    then add the   next   card (unseen) to the   ""red""  pile.
 Add the   top card   that you're holding to the discard pile.   (You might optionally show these discarded cards to get an idea of the randomness).
 Repeat the above for the rest of the shuffled deck.
 3. Choose a random number   (call it X)   that will be used to swap cards from the ""red"" and ""black"" piles.
 Randomly choose   X   cards from the   ""red""  pile (unseen), let's call this the   ""red""  bunch. 
 Randomly choose   X   cards from the ""black"" pile (unseen), let's call this the ""black"" bunch.
 Put the     ""red""    bunch into the   ""black"" pile.
 Put the   ""black""   bunch into the     ""red""  pile.
 (The above two steps complete the swap of   X   cards of the ""red"" and ""black"" piles. 
 (Without knowing what those cards are --- they could be red or black, nobody knows).
 4. Order from randomness?
 Verify (or not) the mathematician's assertion that: 
     The number of black cards in the ""black"" pile equals the number of red cards in the ""red"" pile. 



(Optionally, run this simulation a number of times, gathering more evidence of the truthfulness of the assertion.)

Show output on this page.



",Python,"import random
 
## 1. Cards
n = 52
Black, Red = 'Black', 'Red'
blacks = [Black] * (n // 2) 
reds = [Red] * (n // 2)
pack = blacks + reds
# Give the pack a good shuffle.
random.shuffle(pack)
 
## 2. Deal from the randomised pack into three stacks
black_stack, red_stack, discard = [], [], []
while pack:
    top = pack.pop()
    if top == Black:
        black_stack.append(pack.pop())
    else:
        red_stack.append(pack.pop())
    discard.append(top)
print('(Discards:', ' '.join(d[0] for d in discard), ')\n')
 
## 3. Swap the same, random, number of cards between the two stacks.
# We can't swap more than the number of cards in a stack.
max_swaps = min(len(black_stack), len(red_stack))
# Randomly choose the number of cards to swap.
swap_count = random.randint(0, max_swaps)
print('Swapping', swap_count)
# Randomly choose that number of cards out of each stack to swap.
def random_partition(stack, count):
    ""Partition the stack into 'count' randomly selected members and the rest""
    sample = random.sample(stack, count)
    rest = stack[::]
    for card in sample:
        rest.remove(card)
    return rest, sample
 
black_stack, black_swap = random_partition(black_stack, swap_count)
red_stack, red_swap = random_partition(red_stack, swap_count)
 
# Perform the swap.
black_stack += red_swap
red_stack += black_swap
 
## 4. Order from randomness?
if black_stack.count(Black) == red_stack.count(Red):
    print('Yeha! The mathematicians assertion is correct.')
else:
    print('Whoops - The mathematicians (or my card manipulations) are flakey')",Human_written,Python_from_Go
http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",Python,"print(""\n"".join([i * ""*"" for i in range(1, 6)]))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Bell_numbers,Bell numbers,"Bell or exponential numbers are enumerations of the number of different ways to partition a set that has exactly n elements. Each element of the sequence Bn is the number of partitions of a set of size n where order of the elements and order of the partitions are non-significant. E.G.: {a b} is the same as {b a} and {a} {b} is the same as {b} {a}.



So

B0 = 1 trivially. There is only one way to partition a set with zero elements. { }
B1 = 1 There is only one way to partition a set with one element. {a}
B2 = 2 Two elements may be partitioned in two ways. {a} {b}, {a b}
B3 = 5 Three elements may be partitioned in five ways {a} {b} {c}, {a b} {c}, {a} {b c}, {a c} {b}, {a b c}
 and so on.


A simple way to find the Bell numbers is construct a Bell triangle, also known as an Aitken's array or Peirce triangle, and read off the numbers in the first column of each row. There are other generating algorithms though, and you are free to choose the best / most appropriate for your case.



Task

Write a routine (function, generator, whatever) to generate the Bell number sequence and call the routine to show here, on this page at least the first 15 and (if your language supports big Integers) 50th elements of the sequence.

If you do use the Bell triangle method to generate the numbers, also show the first ten rows of the Bell triangle.



See also

 OEIS:A000110 Bell or exponential numbers
 OEIS:A011971 Aitken's array",Python,"def bellTriangle(n):
    tri = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        for j in range(i):
            tri[i][j] = 0
    tri[1][0] = 1
    for i in range(2, n):
        tri[i][0] = tri[i - 1][i - 2]
        for j in range(1, i):
            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]
    return tri
 
def main():
    bt = bellTriangle(51)
    print(""First fifteen and fiftieth Bell numbers:"")
    for i in range(1, 16):
        print(""%2d: %d"" % (i, bt[i][0]))
    print(""50: %d"" % (bt[50][0]))
    print()
    print(""The first ten rows of Bell's triangle:"")
    for i in range(1, 11):
        print(bt[i])
 
main()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",Python,"def shell(seq):
    inc = len(seq) // 2
    while inc:
        for i, el in enumerate(seq[inc:], inc):
            while i >= inc and seq[i - inc] > el:
                seq[i] = seq[i - inc]
                i -= inc
            seq[i] = el
        inc = 1 if inc == 2 else inc * 5 // 11",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/String_prepend,String prepend,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Create a string variable equal to any text value.

Prepend the string variable with another string literal.

If your language supports any idiomatic ways to do this without referring to the variable twice in one expression, include such solutions.



To illustrate the operation, show the content of the variable.



",Python,"# version 1.0.6
 
def main(args):
    s = ""Obama""
    s = ""Barack "" + s
    print(s)
 
    # It's also possible to use this standard library function
    # though this is not what it's really intended for
    t = ""Trump""
    t = t.prependIndent(""Donald "")
    print(t)
 
if __name__ == '__main__':
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Associative_array/Merging,Associative array/Merging,"Task

Define two associative arrays, where one represents the following ""base"" data:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 12.75


 ""color"" 
 ""yellow""

And the other represents ""update"" data:





 Key 
 Value


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974

Merge these into a new associative array that contains every key found in either of the source ones. Each key should map to the value in the second (update) table if that exists, or else to the value in the first (base) table. If possible, do this in a way that does not mutate the original two associative arrays. Obviously this should be done in a way that would work for any data, not just the specific data given here, but in this example the result should be:





 Key 
 Value


 ""name"" 
 ""Rocket Skates""


 ""price"" 
 15.25


 ""color"" 
 ""red""


 ""year"" 
 1974


",Python,"base = {""name"":""Rocket Skates"", ""price"":12.75, ""color"":""yellow""}
update = {""price"":15.25, ""color"":""red"", ""year"":1974}
 
result = {**base, **update}
 
print(result)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Order_disjoint_list_items,Order disjoint list items,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given   M   as a list of items and another list   N   of items chosen from   M,   create   M'   as a list with the first occurrences of items from   N   sorted to be in one of the set of indices of their original occurrence in   M   but in the order given by their order in   N.

That is, items in   N   are taken from   M   without replacement, then the corresponding positions in   M'   are filled by successive items from   N.



For example

if   M   is   'the cat sat on the mat'
And   N   is   'mat cat' 
Then the result   M'   is   'the mat sat on the cat'. 
The words not in   N   are left in their original positions.



If there are duplications then only the first instances in   M   up to as many as are mentioned in   N   are potentially re-ordered.



For example

  M = 'A B C A B C A B C' 
  N = 'C A C A' 
Is ordered as:

 M' = 'C B A C B A A B C' 


Show the output, here, for at least the following inputs:

Data M: 'the cat sat on the mat' Order N: 'mat cat'
Data M: 'the cat sat on the mat' Order N: 'cat mat'
Data M: 'A B C A B C A B C'      Order N: 'C A C A'
Data M: 'A B C A B D A B E'      Order N: 'E A D A'
Data M: 'A B'                    Order N: 'B'      
Data M: 'A B'                    Order N: 'B A'    
Data M: 'A B B A'                Order N: 'B A'



Cf

 Sort disjoint sublist

",Python,"from __future__ import print_function
 
def order_disjoint_list_items(data, items):
    #Modifies data list in-place
    itemindices = []
    for item in set(items):
        itemcount = items.count(item)
        #assert data.count(item) >= itemcount, 'More of %r than in data' % item
        lastindex = [-1]
        for i in range(itemcount):
            lastindex.append(data.index(item, lastindex[-1] + 1))
        itemindices += lastindex[1:]
    itemindices.sort()
    for index, item in zip(itemindices, items):
        data[index] = item
 
if __name__ == '__main__':
    tostring = ' '.join
    for data, items in [ (str.split('the cat sat on the mat'), str.split('mat cat')),
                         (str.split('the cat sat on the mat'), str.split('cat mat')),
                         (list('ABCABCABC'), list('CACA')),
                         (list('ABCABDABE'), list('EADA')),
                         (list('AB'), list('B')),
                         (list('AB'), list('BA')),
                         (list('ABBA'), list('BA')),
                         (list(''), list('')),
                         (list('A'), list('A')),
                         (list('AB'), list('')),
                         (list('ABBA'), list('AB')),
                         (list('ABAB'), list('AB')),
                         (list('ABAB'), list('BABA')),
                         (list('ABCCBA'), list('ACAC')),
                         (list('ABCCBA'), list('CACA')),
                       ]:
        print('Data M: %-24r Order N: %-9r' % (tostring(data), tostring(items)), end=' ')
        order_disjoint_list_items(data, items)
        print(""-> M' %r"" % tostring(data))",Human_written,Python_from_C++
http://rosettacode.org/wiki/A%2BB,A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",Python,"try: raw_input
except: raw_input = input
 
print(sum(map(int, raw_input().split())))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Rock-paper-scissors,Rock-paper-scissors,"Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive   AI   (artificial intelligence)   player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

   Rock beats scissors
   Scissors beat paper
   Paper beats rock


If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.



Extra credit

Support additional choices   additional weapons.



",Python,"from random import choice
 
rules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}
previous = ['rock', 'paper', 'scissors']
 
while True:
    human = input('\nchoose your weapon: ')
    computer = rules[choice(previous)]  # choose the weapon which beats a randomly chosen weapon from ""previous""
 
    if human in ('quit', 'exit'): break
 
    elif human in rules:
        previous.append(human)
        print('the computer played', computer, end='; ')
 
        if rules[computer] == human:  # if what beats the computer's choice is the human's choice...
            print('yay you win!')
        elif rules[human] == computer:  # if what beats the human's choice is the computer's choice...
            print('the computer beat you... :(')
        else: print(""it's a tie!"")
 
    else: print(""that's not a valid choice"")",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",Python,"from __future__ import print_function
 
def getDifference(b1, b2):
	r = (b2 - b1) % 360.0
	# Python modulus has same sign as divisor, which is positive here,
	# so no need to consider negative case
	if r >= 180.0:
		r -= 360.0
	return r
 
if __name__ == ""__main__"":
	print (""Input in -180 to +180 range"")
	print (getDifference(20.0, 45.0))
	print (getDifference(-45.0, 45.0))
	print (getDifference(-85.0, 90.0))
	print (getDifference(-95.0, 90.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(-45.0, 125.0))
	print (getDifference(-45.0, 145.0))
	print (getDifference(29.4803, -88.6381))
	print (getDifference(-78.3251, -159.036))
 
	print (""Input in wider range"")
	print (getDifference(-70099.74233810938, 29840.67437876723))
	print (getDifference(-165313.6666297357, 33693.9894517456))
	print (getDifference(1174.8380510598456, -154146.66490124757))
	print (getDifference(60175.77306795546, 42213.07192354373))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Comma_quibbling,Comma quibbling,"Comma quibbling is a task originally set by Eric Lippert in his blog.



Task

Write a function to generate a string output which is the concatenation of input words from a list/sequence where:

 An input of no words produces the output string of just the two brace characters ""{}"".
 An input of just one word, e.g. [""ABC""], produces the output string of the word inside the two braces, e.g. ""{ABC}"".
 An input of two words, e.g. [""ABC"", ""DEF""], produces the output string of the two words inside the two braces with the words separated by the string "" and "", e.g. ""{ABC and DEF}"".
 An input of three or more words, e.g. [""ABC"", ""DEF"", ""G"", ""H""], produces the output string of all but the last word separated by "", "" with the last word separated by "" and "" and all within braces; e.g. ""{ABC, DEF, G and H}"".


Test your function with the following series of inputs showing your output here on this page:

 [] # (No input words).
 [""ABC""]
 [""ABC"", ""DEF""]
 [""ABC"", ""DEF"", ""G"", ""H""]


Note: Assume words are non-empty strings of uppercase characters for this task.



",Python,"import itertools
 
def quibble(input):
    return '{{{0}}}'.format(
        ''.join(
            itertools.chain.from_iterable(
                itertools.izip_longest(
                    input[::-1],
                    itertools.cycle([', ','and ']),
                    fillvalue=''))))
 
print(quibble([]))
print(quibble(['ABC']))
print(quibble(['ABC', 'DEF']))
print(quibble(['ABC', 'DEF', 'G', 'H']))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Permutation_test,Permutation test,"Permutation test

You are encouraged to solve this task according to the task description, using any language you may know.
A new medical treatment was tested on a population of 



n
+
m


{\displaystyle n+m}


volunteers, with each volunteer randomly assigned either to a group of




n


{\displaystyle n}

 treatment subjects, or to a group of 



m


{\displaystyle m}

 control subjects.

Members of the treatment group were given the treatment,
and members of the control group were given a placebo.
The effect of the treatment or placebo on each volunteer
was measured and reported in this table.


 Table of experimental results


 Treatment group 
 Control group


 85 
 68


 88 
 41


 75 
 10


 66 
 49


 25 
 16


 29 
 65


 83 
 32


 39 
 92


 97 
 28


 
 98

Write a program that performs a
permutation test to judge
whether the treatment had a significantly stronger effect than the
placebo.

 Do this by considering every possible alternative assignment from the same pool of volunteers to a treatment group of size 



n


{\displaystyle n}

 and a control group of size 



m


{\displaystyle m}

 (i.e., the same group sizes used in the actual experiment but with the group members chosen differently), while assuming that each volunteer's effect remains constant regardless.
 Note that the number of alternatives will be the binomial coefficient 







(



n
+
m

n


)






{\displaystyle {\tbinom {n+m}{n}}}

.
 Compute the mean effect for each group and the difference in means between the groups in every case by subtracting the mean of the control group from the mean of the treatment group.
 Report the percentage of alternative groupings for which the difference in means is less or equal to the actual experimentally observed difference in means, and the percentage for which it is greater.
 Note that they should sum to 100%.


Extremely dissimilar values are evidence of an effect not entirely due
to chance, but your program need not draw any conclusions.

You may assume the experimental data are known at compile time if
that's easier than loading them at run time. Test your solution on the
data given above.



",Python,"from itertools import combinations as comb
 
def statistic(ab, a):
    sumab, suma = sum(ab), sum(a)
    return ( suma / len(a) -
             (sumab -suma) / (len(ab) - len(a)) )
 
def permutationTest(a, b):
    ab = a + b
    Tobs = statistic(ab, a)
    under = 0
    for count, perm in enumerate(comb(ab, len(a)), 1):
        if statistic(ab, perm) <= Tobs:
            under += 1
    return under * 100. / count
 
treatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]
controlGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]
under = permutationTest(treatmentGroup, controlGroup)
print(""under=%.2f%%, over=%.2f%%"" % (under, 100. - under))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Next_highest_int_from_digits,Next highest int from digits,"Given a zero or positive integer, the task is to generate the next largest
integer using only the given digits*1.

   Numbers will not be padded to the left with zeroes.
   Use all given digits, with their given multiplicity. (If a digit appears twice in the input number, it should appear twice in the result).
   If there is no next highest integer return zero.


*1   Alternatively phrased as:   ""Find the smallest integer larger than the (positive or zero) integer   N
 which can be obtained by reordering the (base ten) digits of   N"".


Algorithm 1

   Generate all the permutations of the digits and sort into numeric order.
   Find the number in the list.
   Return the next highest number from the list.


The above could prove slow and memory hungry for numbers with large numbers of
digits, but should be easy to reason about its correctness.



Algorithm 2

   Scan right-to-left through the digits of the number until you find a digit with a larger digit somewhere to the right of it.
   Exchange that digit with the digit on the right that is both more than it, and closest to it.
   Order the digits to the right of this position, after the swap; lowest-to-highest, left-to-right. (I.e. so they form the lowest numerical representation)

E.g.:

    n = 12453
<scan>
    12_4_53
<swap>
    12_5_43
<order-right>
    12_5_34

    return: 12534

This second algorithm is faster and more memory efficient, but implementations
may be harder to test.

One method of testing, (as used in developing the task),   is to compare results from both
algorithms for random numbers generated from a range that the first algorithm can handle.



Task requirements

Calculate the next highest int from the digits of the following numbers:

   0
   9
   12
   21
   12453
   738440
   45072010
   95322020


Optional stretch goal

   9589776899767587796600

",Python,"def closest_more_than(n, lst):
    ""(index of) closest int from lst, to n that is also > n""
    large = max(lst) + 1
    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))
 
def nexthigh(n):
    ""Return nxt highest number from n's digits using scan & re-order""
    assert n == int(abs(n)), ""n >= 0""
    this = list(int(digit) for digit in str(int(n)))[::-1]
    mx = this[0]
    for i, digit in enumerate(this[1:], 1):
        if digit < mx:
            mx_index = closest_more_than(digit, this[:i + 1])
            this[mx_index], this[i] = this[i], this[mx_index]
            this[:i] = sorted(this[:i], reverse=True)
            return int(''.join(str(d) for d in this[::-1]))
        elif digit > mx:
            mx, mx_index = digit, i
    return 0
 
 
if __name__ == '__main__':
    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,
              9589776899767587796600]:
        print(f""{x:>12_d} -> {nexthigh(x):>12_d}"")",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/24_game/Solve,24 game/Solve,"task

Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.

Show examples of solutions generated by the program.



Related task

   Arithmetic Evaluator

",Python,"'''
 The 24 Game Player
 
 Given any four digits in the range 1 to 9, which may have repetitions,
 Using just the +, -, *, and / operators; and the possible use of
 brackets, (), show how to make an answer of 24.
 
 An answer of ""q""  will quit the game.
 An answer of ""!""  will generate a new set of four digits.
 An answer of ""!!"" will ask you for a new set of four digits.
 An answer of ""?""  will compute an expression for the current digits.
 
 Otherwise you are repeatedly asked for an expression until it evaluates to 24
 
 Note: you cannot form multiple digit numbers from the supplied digits,
 so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.
 
'''
 
from   __future__ import division, print_function
from   itertools  import permutations, combinations, product, \
                         chain
from   pprint     import pprint as pp
from   fractions  import Fraction as F
import random, ast, re
import sys
 
if sys.version_info[0] < 3:
    input = raw_input
    from itertools import izip_longest as zip_longest
else:
    from itertools import zip_longest
 
 
def choose4():
    'four random digits >0 as characters'
    return [str(random.randint(1,9)) for i in range(4)]
 
def ask4():
    'get four random digits >0 from the player'
    digits = ''
    while len(digits) != 4 or not all(d in '123456789' for d in digits):
        digits = input('Enter the digits to solve for: ')
        digits = ''.join(digits.strip().split())
    return list(digits)
 
def welcome(digits):
    print (__doc__)
    print (""Your four digits: "" + ' '.join(digits))
 
def check(answer, digits):
    allowed = set('() +-*/\t'+''.join(digits))
    ok = all(ch in allowed for ch in answer) and \
         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \
         and not re.search('\d\d', answer)
    if ok:
        try:
            ast.parse(answer)
        except:
            ok = False
    return ok
 
def solve(digits):
    """"""\
    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():
            solve(list(digits))
 
 
    Solution found: 2 + 3 * 6 + 4
    '2 + 3 * 6 + 4'
    Solution found: ( 4 + 7 - 8 ) * 8
    '( 4 + 7 - 8 ) * 8'
    No solution found for: 1 1 1 1
    '!'
    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6
    '1 + 2 + 3 * ( 4 + 5 ) - 6'
    Solution found: ( 1 + 2 ) * ( 1 + 7 )
    '( 1 + 2 ) * ( 1 + 7 )'
    Solution found: 8 / ( 3 - 8 / 3 )
    '8 / ( 3 - 8 / 3 )'
    >>> """"""
    digilen = len(digits)
    # length of an exp without brackets 
    exprlen = 2 * digilen - 1
    # permute all the digits
    digiperm = sorted(set(permutations(digits)))
    # All the possible operator combinations
    opcomb   = list(product('+-*/', repeat=digilen-1))
    # All the bracket insertion points:
    brackets = ( [()] + [(x,y)
                         for x in range(0, exprlen, 2)
                         for y in range(x+4, exprlen+2, 2)
                         if (x,y) != (0,exprlen+1)]
                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case
    for d in digiperm:
        for ops in opcomb:
            if '/' in ops:
                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy
            else:
                d2 = d
            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))
            for b in brackets:
                exp = ex[::]
                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):
                    exp.insert(insertpoint, bracket)
                txt = ''.join(exp)
                try:
                    num = eval(txt)
                except ZeroDivisionError:
                    continue
                if num == 24:
                    if '/' in ops:
                        exp = [ (term if not term.startswith('F(') else term[2])
                               for term in exp ]
                    ans = ' '.join(exp).rstrip()
                    print (""Solution found:"",ans)
                    return ans
    print (""No solution found for:"", ' '.join(digits))            
    return '!'
 
def main():    
    digits = choose4()
    welcome(digits)
    trial = 0
    answer = ''
    chk = ans = False
    while not (chk and ans == 24):
        trial +=1
        answer = input(""Expression %i: "" % trial)
        chk = check(answer, digits)
        if answer == '?':
            solve(digits)
            answer = '!'
        if answer.lower() == 'q':
            break
        if answer == '!':
            digits = choose4()
            trial = 0
            print (""\nNew digits:"", ' '.join(digits))
            continue
        if answer == '!!':
            digits = ask4()
            trial = 0
            print (""\nNew digits:"", ' '.join(digits))
            continue
        if not chk:
            print (""The input '%s' was wonky!"" % answer)
        else:
            if '/' in answer:
                # Use Fractions for accuracy in divisions
                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)
                                  for char in answer )
            ans = eval(answer)
            print ("" = "", ans)
            if ans == 24:
                print (""Thats right!"")
    print (""Thank you and goodbye"")   
 
main()",Human_written,Python_from_C
http://rosettacode.org/wiki/Fractal_tree,Fractal tree,"Generate and draw a fractal tree.

 Draw the trunk
 At the end of the trunk, split by some angle and draw two branches
 Repeat at the end of each branch until a sufficient level of branching is reached


Related tasks
 Pythagoras Tree

",Python,"import pygame, math
 
pygame.init()
window = pygame.display.set_mode((600, 600))
pygame.display.set_caption(""Fractal Tree"")
screen = pygame.display.get_surface()
 
def drawTree(x1, y1, angle, depth):
    fork_angle = 20
    base_len = 10.0
    if depth > 0:
        x2 = x1 + int(math.cos(math.radians(angle)) * depth * base_len)
        y2 = y1 + int(math.sin(math.radians(angle)) * depth * base_len)
        pygame.draw.line(screen, (255,255,255), (x1, y1), (x2, y2), 2)
        drawTree(x2, y2, angle - fork_angle, depth - 1)
        drawTree(x2, y2, angle + fork_angle, depth - 1)
 
def input(event):
    if event.type == pygame.QUIT:
        exit(0)
 
drawTree(300, 550, -90, 9)
pygame.display.flip()
while True:
    input(pygame.event.wait())",Human_written,Python_from_C
http://rosettacode.org/wiki/Random_number_generator_(device),Random number generator (device),"Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:

show how to obtain a random 32-bit number from that mechanism.

Related task
 Random_number_generator_(included)

",Python,"import random
 
rd = random.SystemRandom()
dist = random.randint(0, 2**32-1)
 
print(""Random Number: "", dist)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas,The Twelve Days of Christmas,"Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas.
The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from __future__ import print_function
 
days = [
    ""first"",
    ""second"",
    ""third"",
    ""fourth"",
    ""fifth"",
    ""sixth"",
    ""seventh"",
    ""eighth"",
    ""ninth"",
    ""tenth"",
    ""eleventh"",
    ""twelfth""
]
 
gifts = [
    ""And a partridge in a pear tree"",
    ""Two turtle doves"",
    ""Three french hens"",
    ""Four calling birds"",
    ""FIVE GOLDEN RINGS"",
    ""Six geese a-laying"",
    ""Seven swans a-swimming"",
    ""Eight maids a-milking"",
    ""Nine ladies dancing"",
    ""Ten lords a-leaping"",
    ""Eleven pipers piping"",
    ""Twelve drummers drumming""
]
 
for i in range(len(days)):
    print(""On the"", days[i], ""day of christmas, my true love gave to me"")
 
    if i == 0:
        print(""A partridge in a pear tree"")
    else:
        j = i + 1
        while j > 0:
            print(gifts[j - 1])
            j -= 1
 
    print()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Consecutive_primes_with_ascending_or_descending_differences,Consecutive primes with ascending or descending differences,"Task




Find and display here on this page, the longest sequence of consecutive prime numbers where the differences between the primes are strictly ascending.


Do the same for sequences of primes where the differences are strictly descending.



In both cases, show the sequence for primes   <   1,000,000.



If there are multiple sequences of the same length, only the first need be shown.


",Python,"from itertools import islice
from math import sqrt
from operator import itemgetter
from sys import stdout
 
def primes(limit):
    flags = [False] * (limit + 1)
    j = 3
    lj = 2
    for d in range(8, limit + 1, 8):
        sq = d * d
        if not flags[j]:
            yield (j, j - lj)
            lj = j
            for k in range(sq, limit + 1, j << 1):
                flags[k] = True
        j += 2
    for j in range(j, limit + 1, 2):
        if not flags[j]:
            yield (j, j - lj)
            lj = j
 
def main():
    mil = 1000000
    for amt in (1, 2, 6, 12, 18):
        lmt = mil * amt
        lg = 0
        ng = 0
        d = 0
        ld = 0
        desc = (""A"", """", ""De"")
        mx = [0, 0, 0]
        bi = [0, 0, 0]
        c = [2, 2, 2]
        stdout.write(""For primes up to {0:n0}:\n"".format(lmt))
        pr = list(islice(primes(lmt), lmt))
        for i in range(len(pr)):
            ng = pr[i][1]
            d = cmp(ng, lg) + 1
            if ld == d:
                c[2 - d] += 1
            else:
                if c[d] > mx[d]:
                    mx[d] = c[d]
                    bi[d] = i - mx[d] - 1
                c[d] = 2
            ld = d
            lg = ng
        for r in range(0, 3, 2):
            stdout.write(""{0}scending, found run of {1} consecutive primes:\n  {2} "".format(desc[r], mx[r] + 1, pr[bi[r]][0]))
            for itm in islice(pr, bi[r] + 1, bi[r] + mx[r] + 1):
                stdout.write(""({0}) {1} "".format(itm[1], itm[0]))
            stdout.write(""\n"" if r == 0 else """")
        stdout.write(""\n"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Long_primes,Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",Python,"def sieve(limit):
    primes = []
    c = [False] * (limit + 1) # composite = true
    # no need to process even numbers
    p = 3
    while True:
        p2 = p * p
        if p2 > limit: break
        for i in range(p2, limit, 2 * p): c[i] = True
        while True:
            p += 2
            if not c[p]: break
 
    for i in range(3, limit, 2):
        if not c[i]: primes.append(i)
    return primes
 
# finds the period of the reciprocal of n
def findPeriod(n):
    r = 1
    for i in range(1, n): r = (10 * r) % n
    rr = r
    period = 0
    while True:
        r = (10 * r) % n
        period += 1
        if r == rr: break
    return period
 
primes = sieve(64000)
longPrimes = []
for prime in primes:
    if findPeriod(prime) == prime - 1:
        longPrimes.append(prime)
numbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]
count = 0
index = 0
totals = [0] * len(numbers)
for longPrime in longPrimes:
    if longPrime > numbers[index]:
        totals[index] = count
        index += 1
    count += 1
totals[-1] = count
print('The long primes up to 500 are:')
print(str(longPrimes[:totals[0]]).replace(',', ''))
print('\nThe number of long primes up to:')
for (i, total) in enumerate(totals):
    print('  %5d is %d' % (numbers[i], total))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sum_and_product_of_an_array,Sum and product of an array,"Task

Compute the sum and product of an array of integers.



",Python,"numbers = [1, 2, 3]
total = sum(numbers)
 
product = 1
for i in numbers:
    product *= i",Human_written,Python_from_C++
http://rosettacode.org/wiki/Strip_comments_from_a_string,Strip comments from a string,"Strip comments from a string

You are encouraged to solve this task according to the task description, using any language you may know.
The task is to remove text that follow any of a set of comment markers, (in these examples either a hash or a semicolon) from a string or input line.


Whitespace debacle:   There is some confusion about whether to remove any whitespace from the input line.

As of 2 September 2011, at least 8 languages (C, C++, Java, Perl, Python, Ruby, sed, UNIX Shell) were incorrect, out of 36 total languages, because they did not trim whitespace by 29 March 2011 rules. Some other languages might be incorrect for the same reason.

Please discuss this issue at Talk:Strip comments from a string.

 From 29 March 2011, this task required that: ""The comment marker and any whitespace at the beginning or ends of the resultant line should be removed. A line without comments should be trimmed of any leading or trailing whitespace before being produced as a result."" The task had 28 languages, which did not all meet this new requirement.
 From 28 March 2011, this task required that: ""Whitespace before the comment marker should be removed.""
 From 30 October 2010, this task did not specify whether or not to remove whitespace.


The following examples will be truncated to either ""apples, pears "" or ""apples, pears"".

(This example has flipped between ""apples, pears "" and ""apples, pears"" in the past.)

apples, pears # and bananas
apples, pears ; and bananas




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
 
def strip_white(input):
    b = input.find_first_not_of(' ')
    if b == std::string::npos:
        b = 0
    return input.substr(b, input.find_last_not_of(' ') + 1 - b)
 
def strip_comments(input, delimiters):
    return strip_white(input.substr(0, input.find_first_of(delimiters)))
 
input = ''
delimiters = '#;'
while getline(std::cin, input) and not input.empty():
    print strip_comments(input, delimiters)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"import sys
print(sys.getrecursionlimit())",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sort_using_a_custom_comparator,Sort using a custom comparator,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of strings in order of descending length, and in ascending lexicographic order for strings of equal length.

Use a sorting facility provided by the language/library, combined with your own callback comparison function.


Note:   Lexicographic order is case-insensitive.



",Python,"strings = ""here are Some sample strings to be sorted"".split()
 
def mykey(x):
    return -len(x), x.upper()
 
print sorted(strings, key=mykey)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/List_rooted_trees,List rooted trees,"You came back from grocery shopping.   After putting away all the goods, you are left with a pile of plastic bags, which you want to save for later use, so you take one bag and stuff all the others into it, and throw it under the sink.   In doing so, you realize that there are various ways of nesting the bags, with all bags viewed as identical.

If we use a matching pair of parentheses to represent a bag, the ways are:

For 1 bag, there's one way:

 ()	<- a bag

for 2 bags, there's one way:

 (())	<- one bag in another

for 3 bags, there are two:

 ((())) <- 3 bags nested Russian doll style
 (()()) <- 2 bags side by side, inside the third

for 4 bags, four:

 (()()())
 ((())())
 ((()()))
 (((())))

Note that because all bags are identical, the two 4-bag strings ((())()) and (()(())) represent the same configuration.

It's easy to see that each configuration for n bags represents a n-node rooted tree, where a bag is a tree node, and a bag with its content forms a subtree. The outermost bag is the tree root. Number of configurations for given n is given by OEIS A81.



Task
 
Write a program that, when given n, enumerates all ways of nesting n bags.   You can use the parentheses notation above, or any tree representation that's unambiguous and preferably intuitive.

This task asks for enumeration of trees only; for counting solutions without enumeration, that OEIS page lists various formulas, but that's not encouraged by this task, especially if implementing it would significantly increase code size.

As an example output, run 5 bags.   There should be 9 ways.



",Python,"TREE_LIST = []
OFFSET = []
 
def init():
    for i in range(32):
        if i == 1:
            OFFSET.append(1)
        else:
            OFFSET.append(0)
 
def append(t):
    TREE_LIST.append(1 | (t << 1))
 
def show(t, l):
    while l > 0:
        if t % 2 == 1:
            print('(', end='')
        else:
            print(')', end='')
        t = t >> 1
        l -= 1
 
def listTrees(n):
    for i in range(OFFSET[n], OFFSET[n + 1]):
        show(TREE_LIST[i], 2 * n)
        print()
 
def assemble(n, t, sl, pos, rem):
    if rem == 0:
        append(t)
        return
 
    pp = pos
    ss = sl
 
    if sl > rem:
        ss = rem
        pp = OFFSET[ss]
    elif pp >= OFFSET[ss + 1]:
        ss -= 1
        if ss == 0:
            return
        pp = OFFSET[ss]
 
    assemble(n, t << (2 * ss) | TREE_LIST[pp], ss, pp, rem - ss)
    assemble(n, t, ss, pp + 1, rem)
 
def makeTrees(n):
    if OFFSET[n + 1]!= 0:
        return
    if n > 0:
        makeTrees(n - 1)
    assemble(n, 0, n - 1, OFFSET[n - 1], n - 1)
    OFFSET[n + 1] = len(TREE_LIST)
 
def test(n):
    if n < 1 or n > 12:
        raise ValueError(""Argument must be between 1 and 12"")
 
    append(0)
 
    makeTrees(n)
    print(""Number of {}-trees: {}"".format(n, OFFSET[n + 1] - OFFSET[n]))
    listTrees(n)
 
if __name__ == ""__main__"":
    init()
    test(5)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Accumulator_factory,Accumulator factory,"A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).



Rules

The detailed rules are at http://paulgraham.com/accgensub.html and are reproduced here for simplicity (with additions in small italic text).

Before you submit an example, make sure the function
 Takes a number n and returns a function (lets call it g), that takes a number i, and returns n incremented by the accumulation of i from every call of function g(i).
Although these exact function and parameter names need not be used
 Works for any numeric type-- i.e. can take both ints and floats and returns functions that can take both ints and floats. (It is not enough simply to convert all input to floats. An accumulator that has only seen integers must return integers.) (i.e., if the language doesn't allow for numeric polymorphism, you have to use overloading or something like that)
 Generates functions that return the sum of every number ever passed to them, not just the most recent. (This requires a piece of state to hold the accumulated value, which in turn means that pure functional languages can't be used for this task.)
 Returns a real function, meaning something that you can use wherever you could use a function you had defined in the ordinary way in the text of your program. (Follow your language's conventions here.)
 Doesn't store the accumulated value or the returned functions in a way that could cause them to be inadvertently modified by other code. (No global variables or other such things.)
 E.g. if after the example, you added the following code (in a made-up language) where the factory function is called foo:
 x = foo(1); 
x(5); 
foo(3);
print x(2.3);
 It should print 8.3. (There is no need to print the form of the accumulator function returned by foo(3); it's not part of the task at all.)


Task

Create a function that implements the described rules.



It need not handle any special error cases not described above. The simplest way to implement the task as described is typically to use a closure, providing the language supports them.

Where it is not possible to hold exactly to the constraints above, describe the deviations.



",Python,">>> def accumulator(sum):
  def f(n):
    f.sum += n
    return f.sum
  f.sum = sum
  return f
 
>>> x = accumulator(1)
>>> x(5)
6
>>> x(2.3)
8.3000000000000007
>>> x = accumulator(1)
>>> x(5)
6
>>> x(2.3)
8.3000000000000007
>>> x2 = accumulator(3)
>>> x2(5)
8
>>> x2(3.3)
11.300000000000001
>>> x(0)
8.3000000000000007
>>> x2(0)
11.300000000000001",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Partial_function_application,Partial function application,"Partial function application   is the ability to take a function of many
parameters and apply arguments to some of the parameters to create a new
function that needs only the application of the remaining arguments to
produce the equivalent of applying all arguments to the original function.

E.g:

 Given values v1, v2
 Given f(param1, param2)
 Then partial(f, param1=v1) returns f'(param2)
 And f(param1=v1, param2=v2) == f'(param2=v2) (for any value v2)


Note that in the partial application of a parameter, (in the above case param1), other parameters are not explicitly mentioned. This is a recurring feature of partial function application.



Task 
 Create a function fs( f, s ) that takes a function, f( n ), of one value and a sequence of values s.
 Function fs should return an ordered sequence of the result of applying function f to every value of s in turn.
 Create function f1 that takes a value and returns it multiplied by 2.
 Create function f2 that takes a value and returns it squared.
 Partially apply f1 to fs to form function fsf1( s )
 Partially apply f2 to fs to form function fsf2( s )
 Test fsf1 and fsf2 by evaluating them with s being the sequence of integers from 0 to 3 inclusive and then the sequence of even integers from 2 to 8 inclusive.


Notes
 In partially applying the functions f1 or f2 to fs, there should be no explicit mention of any other parameters to fs, although introspection of fs within the partial applicator to find its parameters is allowed.
 This task is more about how results are generated rather than just getting results.

",Python,"from functools import partial, reduce
from operator import mul, pow

def fs(f, s):
    return list(map(f, s))

f1 = partial(mul, 2)
f2 = partial(pow, 2)
fsf1 = partial(fs, f1)
fsf2 = partial(fs, f2)

for e in [range(4), range(2, 9, 2)]:
    print(fsf1(e))
    print(fsf2(e))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Echo_server,Echo server,"Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.

The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.

The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.
",Python,"import socket
import threading
 
def handle_client(client_socket):
    while True:
        buf = client_socket.recv(1024)
        if not buf:
            break
        client_socket.send(buf)
 
def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('127.0.0.1', 12321))
    server_socket.listen(5)
    print('server is running on 127.0.0.1:12321...')
 
    while True:
        client_socket, client_address = server_socket.accept()
        threading.Thread(target=handle_client, args=(client_socket,)).start()
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Loops/Infinite,Loops/Infinite,"Task

Print out        SPAM        followed by a   newline   in an infinite loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"names = []
names.append(""John"")
names.append(""Jane"")
names.append(""Bob"")

for name in names:
    print(name)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Anti-primes,Anti-primes,"The anti-primes
(or highly composite numbers, sequence A002182 in the OEIS)
are the natural numbers with more factors than any smaller than itself.



Task

Generate and show here, the first twenty anti-primes.



Related tasks

   Factors of an integer
   Sieve of Eratosthenes

",Python,"# Version 1.3.10
 
def countDivisors(n):
    if n < 2:
        return 1
    count = 2 # 1 and n
    for i in range(2, n // 2 + 1):
        if n % i == 0:
            count += 1
    return count
 
def main():
    print(""The first 20 anti-primes are:"")
    maxDiv = 0
    count = 0
    n = 1
    while count < 20:
        d = countDivisors(n)
        if d > maxDiv:
            print(n, end="" "")
            maxDiv = d
            count += 1
        n += 1
    print()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"from itertools import product, combinations, izip
 
scoring = [0, 1, 3]
histo = [[0] * 10 for _ in xrange(4)]
 
for results in product(range(3), repeat=6):
    s = [0] * 4
    for r, g in izip(results, combinations(range(4), 2)):
        s[g[0]] += scoring[r]
        s[g[1]] += scoring[2 - r]
 
    for h, v in izip(histo, sorted(s)):
        h[v] += 1
 
for x in reversed(histo):
    print x",Human_written,Python_from_Java
http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",Python,"f = lambda x: x * x * x - 3 * x * x + 2 * x
 
step = 0.001 # Smaller step values produce more accurate and precise results
start = -1
stop = 3
 
sign = f(start) > 0
 
x = start
while x <= stop:
    value = f(x)
 
    if value == 0:
        # We hit a root
        print ""Root found at"", x
    elif (value > 0) != sign:
        # We passed a root
        print ""Root found near"", x
 
    # Update our sign
    sign = value > 0
 
    x += step",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/String_append,String append,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Most languages provide a way to concatenate two string values, but some languages also provide a convenient way to append in-place to an existing string variable without referring to the variable twice.



Task

Create a string variable equal to any text value.

Append the string variable with another string literal in the most idiomatic way, without double reference if your language supports it.

Show the contents of the variable after the append operation.



",Python,"s = ""Hello wo""
s = s + ""rld"" # new string object
s = s + ""!""   # mutates in place, same object
print(s)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sorting_Algorithms/Circle_Sort,Sorting Algorithms/Circle Sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Sort an array of integers (of any convenient size) into ascending order using Circlesort.

In short, compare the first element to the last element, then the second element to the second last element, etc.

Then split the array in two and recurse until there is only one single element in the array, like this:

Before:
6 7 8 9 2 5 3 4 1
After:
1 4 3 5 2 9 8 7 6

Repeat this procedure until quiescence (i.e. until there are no swaps).

Show both the initial, unsorted list and the final sorted list. (Intermediate steps during sorting are optional.)

Optimizations (like doing 0.5 log2(n) iterations and then continue with an Insertion sort) are optional. 


Pseudo code:

 function circlesort (index lo, index hi, swaps)
 {
   if lo == hi return (swaps)
   high := hi
   low := lo
   mid := int((hi-lo)/2)
   while lo < hi {
     if  (value at lo) > (value at hi) {
        swap.values (lo,hi)
        swaps++
     }
     lo++
     hi--
   }
   if lo == hi
     if (value at lo) > (value at hi+1) {
         swap.values (lo,hi+1)
         swaps++
     }
   swaps := circlesort(low,low+mid,swaps)
   swaps := circlesort(low+mid+1,high,swaps)
   return(swaps)
 }
 while circlesort (0, sizeof(array)-1, 0)



See also

 For more information on Circle sorting, see Sourceforge.

",Python,"#python3
#tests: expect no output.
#doctest with  python3 -m doctest thisfile.py
#additional tests:  python3 thisfile.py
 
def circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':
    '''
        >>> L = [3, 2, 8, 28, 2,]
        >>> circle_sort(L)
        3
        >>> print(L)
        [2, 2, 3, 8, 28]
        >>> L = [3, 2, 8, 28,]
        >>> circle_sort(L)
        1
        >>> print(L)
        [2, 3, 8, 28]
    '''
    n = R-L
    if n < 2:
        return 0
    swaps = 0
    m = n//2
    for i in range(m):
        if A[R-(i+1)] < A[L+i]:
            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)
            swaps += 1
    if (n & 1) and (A[L+m] < A[L+m-1]):
        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)
        swaps += 1
    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)
 
def circle_sort(L:list)->'sort A in place, returning the number of swaps':
    swaps = 0
    s = 1
    while s:
        s = circle_sort_backend(L, 0, len(L))
        swaps += s
    return swaps
 
# more tests!
if __name__ == '__main__':
    from random import shuffle
    for i in range(309):
        L = list(range(i))
        M = L[:]
        shuffle(L)
        N = L[:]
        circle_sort(L)
        if L != M:
            print(len(L))
            print(N)
            print(L)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"import sys
print(sys.getrecursionlimit())",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Quine,Quine,"A quine is a self-referential program that can,
without any external access, output its own source.



A   quine   (named after Willard Van Orman Quine)   is also known as:

   self-reproducing automata   (1972)
   self-replicating program         or   self-replicating computer program
   self-reproducing program      or   self-reproducing computer program
   self-copying program             or   self-copying computer program


It is named after the philosopher and logician
who studied self-reference and quoting in natural language,
as for example in the paradox ""'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation.""

""Source"" has one of two meanings. It can refer to the text-based program source.
For languages in which program source is represented as a data structure, ""source"" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.



Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

 Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on.
 Some languages have a function for getting the ""source code representation"" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem.
 Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39.
 Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. ""\n""). This causes the same problem as above, where the escaping character needs to itself be escaped, etc.
 If the language has a way of getting the ""source code representation"", it usually handles the escaping of characters, so this is not a problem.
 Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping.
 Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.



Related task

   print itself.

",Python,"#include <stdio.h>
 
static char sym[] = ""\n\t\\\"""";
 
int main(void) {
	const char *code = ""#include <stdio.h>%c%cstatic char sym[] = %c%cn%ct%c%c%c%c%c;%c%cint main(void) {%c%cconst char *code = %c%s%c;%c%cprintf(code, sym[0], sym[0], sym[3], sym[2], sym[2], sym[2], sym[2], sym[2], sym[3], sym[3], sym[0], sym[0], sym[0], sym[1], sym[3], code, sym[3], sym[0], sym[1], sym[0], sym[0], sym[1], sym[0], sym[0]);%c%c%creturn 0;%c}%c"";
	printf(code, sym[0], sym[0], sym[3], sym[2], sym[2], sym[2], sym[2], sym[2], sym[3], sym[3], sym[0], sym[0], sym[0], sym[1], sym[3], code, sym[3], sym[0], sym[1], sym[0], sym[0], sym[1], sym[0], sym[0]);
 
	return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Semordnilap,Semordnilap,"A semordnilap is a word (or phrase) that spells a different word (or phrase) backward. ""Semordnilap"" is a word that itself is a semordnilap.

Example: lager and regal

Task
This task does not consider semordnilap phrases, only single words.
Using only words from this list, report the total number of unique semordnilap pairs, and print 5 examples.
Two matching semordnilaps, such as lager and regal, should be counted as one unique pair.
(Note that the word ""semordnilap"" is not in the above dictionary.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> with open('unixdict.txt') as f:
	wordset = set(f.read().strip().split())
 
>>> revlist = (''.join(word[::-1]) for word in wordset)
>>> pairs   = set((word, rev) for word, rev in zip(wordset, revlist) 
                  if word < rev and rev in wordset)
>>> len(pairs)
158
>>> sorted(pairs, key=lambda p: (len(p[0]), p))[-5:]
[('damon', 'nomad'), ('lager', 'regal'), ('leper', 'repel'), ('lever', 'revel'), ('kramer', 'remark')]
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Permutations_by_swapping,Permutations by swapping,"Task

Generate permutations of n items in which successive permutations differ from each other by the swapping of any two items.

Also generate the sign of the permutation which is +1 when the permutation is generated from an even number of swaps from the initial state, and -1 for odd.

Show the permutations and signs of three items, in order of generation here.

Such data are of use in generating the determinant of a square matrix and any functions created should bear this in mind.

Note: The Steinhaus–Johnson–Trotter algorithm generates successive permutations where adjacent items are swapped, but from this discussion adjacency is not a requirement.



References

 Steinhaus–Johnson–Trotter algorithm
 Johnson-Trotter Algorithm Listing All Permutations
 Heap's algorithm
 [1] Tintinnalogia


Related tasks

   Matrix arithmetic
   Gray code

",Python,"from itertools import permutations
 
def heaps_algorithm(n):
    for p in permutations(range(n)):
        print(p)
 
heaps_algorithm(4)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort,Sorting algorithms/Radix sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Task

Sort an integer array with the   radix sort algorithm.

The primary purpose is to complete the characterization of sort algorithms task.



",Python,"import struct
 
data = [170, 45, 75, -90, -802, 24, 2, 66]
 
def sort(data):
    word_len = 4
    high_bit = -1 << 31
    ds = [[] for _ in range(len(data))]
    for i, x in enumerate(data):
        ds[i] = struct.pack(""<i"", x ^ high_bit)
    bins = [[] for _ in range(256)]
    for i in range(word_len):
        for b in ds:
            bins[b[i]].append(b)
        j = 0
        for k, bs in enumerate(bins):
            ds[j:j+len(bs)] = bs
            j += len(bs)
            bins[k] = []
    return [struct.unpack(""<i"", b)[0] ^ high_bit for b in ds]
 
print(""original:"", data)
print(""sorted:  "", sort(data))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/HTTP,HTTP,"Task

Access and print a URL's content (the located resource) to the console.

There is a separate task for HTTPS Requests.



",Python,"import urllib2
import sys
 
def main():
    url = ""http://rosettacode.org/robots.txt""
    response = urllib2.urlopen(url)
    print response.read()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Add_a_variable_to_a_class_instance_at_runtime,Add a variable to a class instance at runtime,"Demonstrate how to dynamically add variables to an object (a class instance) at runtime.

This is useful when the methods/variables of an instance are based on a data file that isn't available until runtime. Hal Fulton gives an example of creating an OO CSV parser at An Exercise in Metaprogramming with Ruby. This is referred to as ""monkeypatching"" by Pythonistas and some others.
",Python,"class Foo:
    def bar(self):
        print ""instance method""
 
    def baz(self):
        print ""public method""
 
f = Foo()
f.bar()
f.baz()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Pell%27s_equation,Pell's equation,"Pell's equation   (also called the Pell–Fermat equation)   is a   Diophantine equation   of the form:

   x2   -   ny2   =   1  
with integer solutions for   x   and   y,   where   n   is a given non-square positive integer.



Task requirements

   find the smallest solution in positive integers to Pell's equation for   n = {61, 109, 181, 277}.


See also

   Wikipedia entry: Pell's equation.

",Python,"from __future__ import print_function
from math import sqrt
from fractions import Fraction
 
def solve_pell(n):
    x = int(sqrt(n))
    if x * x == n:
        return 1, 0
    y = x
    z = 1
    r = 2 * x
    e = 1, 0
    f = 0, 1
    a = 0
    b = 0
    while a * a - n * b * b!= 1:
        y = r * z - y
        z = (n - y * y) // z
        r = (x + y) // z
        e = f[1], r * f[1] + f[0]
        f = f[1], r * f[1] + f[0]
        a = e[1] + x * f[1]
        b = f[1]
    return a, b
 
def test(n):
    a, b = solve_pell(n)
    print(""x^2 - {} * y^2 = 1 for x = {} and y = {}"".format(n, a, b))
 
if __name__ == ""__main__"":
    test(61)
    test(109)
    test(181)
    test(277)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Floyd%27s_triangle,Floyd's triangle,"Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where

 the first row is   1     (unity)
 successive rows start towards the left with the next number followed by successive naturals listing one more number than the line above.


The first few lines of a Floyd triangle looks like this:

 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15



Task

 Write a program to generate and display here the first   n   lines of a Floyd triangle. 
(Use   n=5   and   n=14   rows).
 Ensure that when displayed in a mono-space font, the numbers line up in vertical columns as shown and that only one space separates numbers of the last row.

",Python,"def floyd(n):
    print(""Floyd"", n, "":"")
    lowerLeftCorner = n * (n - 1) // 2 + 1
    lastInColumn = lowerLeftCorner
    lastInRow = 1
    for i, row in enumerate(range(1, n + 1), 1):
        w = len(str(lastInColumn))
        if i < lastInRow:
            print(str(i).rjust(w), end="" "")
            lastInColumn += 1
        else:
            print(str(i).rjust(w))
            row += 1
            lastInRow += row
            lastInColumn = lowerLeftCorner
 
floyd(5)
floyd(14)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",Python,"def ffr(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return ffr.r[n]
    except IndexError:
        r, s = ffr.r, ffs.s
        ffr_n_1 = ffr(n-1)
        lastr = r[-1]
        # extend s up to, and one past, last r 
        s += list(range(s[-1] + 1, lastr))
        if s[-1] < lastr: s += [lastr + 1]
        # access s[n-1] temporarily extending s if necessary
        len_s = len(s)
        ffs_n_1 = s[n-1] if len_s > n else (n - len_s) + s[-1]
        ans = ffr_n_1 + ffs_n_1
        r.append(ans)
        return ans
ffr.r = [None, 1]
 
def ffs(n):
    if n < 1 or type(n) != int: raise ValueError(""n must be an int >= 1"")
    try:
        return ffs.s[n]
    except IndexError:
        r, s = ffr.r, ffs.s
        for i in range(len(r), n+2):
            ffr(i)
            if len(s) > n:
                return s[n]
        raise Exception(""Whoops!"")
ffs.s = [None, 2]
 
if __name__ == '__main__':
    first10 = [ffr(i) for i in range(1,11)]
    assert first10 == [1, 3, 7, 12, 18, 26, 35, 45, 56, 69], ""ffr() value error(s)""
    print(""ffr(n) for n = [1..10] is"", first10)
    #
    bin = [None] + [0]*1000
    for i in range(40, 0, -1):
        bin[ffr(i)] += 1
    for i in range(960, 0, -1):
        bin[ffs(i)] += 1
    if all(b == 1 for b in bin[1:1000]):
        print(""All Integers 1..1000 found OK"")
    else:
        print(""All Integers 1..1000 NOT found only once: ERROR"")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Harshad_or_Niven_series,Harshad or Niven series,"The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.

For example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.

Assume that the series is defined as the numbers in increasing order.



Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to:

   list the first 20 members of the sequence,   and
   list the first Harshad number greater than 1000.


Show your output here.



Related task
   Increasing gaps between consecutive Niven numbers


See also
    OEIS: A005349

",Python,">>> import itertools
>>> def harshad():
	for n in itertools.count(1):
		if n % sum(int(ch) for ch in str(n)) == 0:
			yield n
 
 
>>> list(itertools.islice(harshad(), 0, 20))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]
>>> for n in harshad():
	if n > 1000:
		print(n)
		break
 
 
1002
>>>",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion,Parsing/RPN to infix conversion,"Parsing/RPN to infix conversion

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a program that takes an RPN representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in infix notation.

 Assume an input of a correct, space separated, string of tokens
 Generate a space separated output string representing the same expression in infix notation
 Show how the major datastructure of your algorithm changes with each new token parsed.
 Test with the following input RPN strings then print and display the output here.


 RPN input 
 sample output


 3 4 2 * 1 5 - 2 3 ^ ^ / +
 3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3


 1 2 + 3 4 + ^ 5 6 + ^
 ( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )

 Operator precedence and operator associativity is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



See also

   Parsing/Shunting-yard algorithm   for a method of generating an RPN from an infix expression.
   Parsing/RPN calculator algorithm   for a method of calculating a final value from this output RPN expression.
   Postfix to infix   from the RubyQuiz site.

",Python,"import re
from collections import namedtuple
from collections import deque

def postfix_to_infix(postfix):
    Expression = namedtuple('Expression', 'ex op prec')
    ops = '-+/*^'
    expr = deque()
    for token in re.split(r'\s+', postfix):
        idx = ops.find(token)
        if idx!= -1 and len(token) == 1:
            r = expr.pop()
            l = expr.pop()
            op_prec = idx // 2
            if l.prec < op_prec or (l.prec == op_prec and token == '^'):
                l = Expression(f'({l.ex})', l.op, l.prec)
            if r.prec < op_prec or (r.prec == op_prec and token!= '^'):
                r = Expression(f'({r.ex})', r.op, r.prec)
            expr.append(Expression(f'{l.ex} {token} {r.ex}', token, op_prec))
        else:
            expr.append(Expression(token, None, 3))
        print(f'{token} -> {expr}')
    return expr[-1].ex

if __name__ == '__main__':
    for e in ('3 4 2 * 1 5 - 2 3 ^ ^ / +', '1 2 + 3 4 + ^ 5 6 + ^'):
        print(f'Postfix: {e}')
        print(f'Infix: {postfix_to_infix(e)}')
        print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Python,"class animal:
    def __init__(self):
        self.alive = False
 
    def speak(self):
        return ""I'm an animal""
 
class dog(animal):
    def __init__(self):
        super().__init__()
        self.obedienceTrained = False
 
    def speak(self):
        return ""woof""
 
class cat(animal):
    def __init__(self):
        super().__init__()
        self.litterBoxTrained = False
 
    def speak(self):
        return ""meow""
 
def main():
    pet = dog()
    print(pet.speak())
    pet = cat()
    print(pet.speak())
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/9_billion_names_of_God_the_integer,9 billion names of God the integer,"This task is a variation of the short story by Arthur C. Clarke.

(Solvers should be aware of the consequences of completing this task.)

In detail, to specify what is meant by a   “name”:

The integer 1 has 1 name     “1”.
The integer 2 has 2 names   “1+1”,   and   “2”.
The integer 3 has 3 names   “1+1+1”,   “2+1”,   and   “3”.
The integer 4 has 5 names   “1+1+1+1”,   “2+1+1”,   “2+2”,   “3+1”,   “4”.
The integer 5 has 7 names   “1+1+1+1+1”,   “2+1+1+1”,   “2+2+1”,   “3+1+1”,   “3+2”,   “4+1”,   “5”.


Task
Display the first 25 rows of a number triangle which begins:

                                      1
                                    1   1
                                  1   1   1 
                                1   2   1   1
                              1   2   2   1   1
                            1   3   3   2   1   1

Where row   



n


{\displaystyle n}

   corresponds to integer   



n


{\displaystyle n}

,   and each column   



C


{\displaystyle C}

   in row   



m


{\displaystyle m}

   from left to right corresponds to the number of names beginning with   



C


{\displaystyle C}

.

A function   



G
(
n
)


{\displaystyle G(n)}

   should return the sum of the   



n


{\displaystyle n}

-th   row.

Demonstrate this function by displaying:   



G
(
23
)


{\displaystyle G(23)}

,   



G
(
123
)


{\displaystyle G(123)}

,   



G
(
1234
)


{\displaystyle G(1234)}

,   and   



G
(
12345
)


{\displaystyle G(12345)}

.

Optionally note that the sum of the   



n


{\displaystyle n}

-th   row   



P
(
n
)


{\displaystyle P(n)}

   is the     integer partition function.

Demonstrate this is equivalent to   



G
(
n
)


{\displaystyle G(n)}

   by displaying:   



P
(
23
)


{\displaystyle P(23)}

,   



P
(
123
)


{\displaystyle P(123)}

,   



P
(
1234
)


{\displaystyle P(1234)}

,   and   



P
(
12345
)


{\displaystyle P(12345)}

.



Extra credit
If your environment is able, plot   



P
(
n
)


{\displaystyle P(n)}

   against   



n


{\displaystyle n}

   for   



n
=
1
…
999


{\displaystyle n=1\ldots 999}

.

Related tasks
 Partition function P

",Python,"from functools import lru_cache
from itertools import accumulate
from operator import add
from math import factorial
 
@lru_cache(maxsize=None)
def row(n):
    return [factorial(n) // (factorial(i) * factorial(n - i)) for i in range(n + 1)]
 
def cumu(n):
    return list(accumulate(row(n), add))
 
def main():
    print('rows:')
    for x in range(1, 26):
        print(f'{x}: {"" "".join(map(str, row(x)))}')
 
    print('sums:')
    for x in (23, 123, 1234, 12345):
        print(f'{x}: {cumu(x)[-1]}')
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort,Sorting algorithms/Merge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The   merge sort   is a recursive sort of order    n*log(n). 

It is notable for having a worst case and average complexity of    O(n*log(n)),    and a best case complexity of    O(n)    (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements   (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its   divide and conquer   description.



Task

Write a function to sort a collection of integers using the merge sort.



The merge sort algorithm comes in two parts:

   a sort function     and 
   a merge function 

The functions in pseudocode look like this:

function mergesort(m)
   var list left, right, result
   if length(m) ≤ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ≤ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ≤ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result



See also

   the Wikipedia entry:    merge sort


Note:   better performance can be expected if, rather than recursing until    length(m) ≤ 1,    an insertion sort is used for    length(m)    smaller than some threshold larger than   1.   However, this complicates the example code, so it is not shown here.



",Python,"from heapq import merge
 
def merge_sort(m):
    if len(m) <= 1:
        return m
 
    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]
 
    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Gray_code,Gray code,"Gray code
Karnaugh maps
Create functions to encode a number to and decode a number from Gray code.

Display the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).

There are many possible Gray codes. The following encodes what is called ""binary reflected Gray code.""

Encoding (MSB is bit 0, b is binary, g is Gray code):

if b[i-1] = 1
   g[i] = not b[i]
else
   g[i] = b[i]
Or:

g = b xor (b logically right shifted 1 time)
Decoding (MSB is bit 0, b is binary, g is Gray code):

b[0] = g[0]

for other bits:
b[i] = g[i] xor b[i-1]
Reference
 Converting Between Gray and Binary Codes. It includes step-by-step animations.",Python,"def gray_encode(n):
    return n ^ n >> 1
 
def gray_decode(n):
    m = n >> 1
    while m:
        n ^= m
        m >>= 1
    return n
 
 
if __name__ == '__main__':
    print(""DEC,   BIN =>  GRAY => DEC"")
    for i in range(32):
        gray = gray_encode(i)
        dec = gray_decode(gray)
        print(f"" {i:>2d}, {i:>05b} => {gray:>05b} => {dec:>2d}"")",Human_written,Python_from_Java
http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",Python,"from __future__ import division
from __future__ import print_function
 
def mapRange(a1,a2,b1,b2,s):
	return b1 + (s-a1)*(b2-b1)/(a2-a1)
 
if __name__ == ""__main__"":
	print(""Mapping [0,10] to [-1,0] at intervals of 1:"")
 
	for i in range(11):
		print(""f({0}) = {1}"".format(i,mapRange(0,10,-1,0,i)))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/User_input/Graphical,User input/Graphical,"

In this task, the goal is to input a string and the integer 75000, from graphical user interface.



See also: User input/Text
",Python,"import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
import random
import time
 
def validate_input(window, str1, str2):
    try:
        n = float(str2)
    except ValueError:
        dialog = Gtk.MessageDialog(
            window, 0, Gtk.MessageType.ERROR,
            Gtk.ButtonsType.OK, ""Invalid input"")
        dialog.run()
        dialog.destroy()
        return False
    if len(str1) == 0 or n!= 75000:
        dialog = Gtk.MessageDialog(
            window, 0, Gtk.MessageType.ERROR,
            Gtk.ButtonsType.OK, ""Invalid input"")
        dialog.run()
        dialog.destroy()
        return False
    return True
 
class MyWindow(Gtk.Window):
    def __init__(self):
        Gtk.Window.__init__(self, title=""Rosetta Code"")
        self.set_border_width(1)
        self.set_position(Gtk.WindowPosition.CENTER)
        self.connect(""destroy"", Gtk.main_quit)
 
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=1)
        self.add(vbox)
 
        hbox1 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=1)
        vbox.pack_start(hbox1, False, False, 2)
 
        hbox2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=1)
        vbox.pack_start(hbox2, False, False, 2)
 
        label = Gtk.Label(""Enter a string and the number 75000   \n"")
        vbox.pack_start(label, False, False, 2)
 
        sel = Gtk.Label(""String:      "")
        hbox1.pack_start(sel, False, False, 2)
 
        nel = Gtk.Label(""Number: "")
        hbox2.pack_start(nel, False, False, 2)
 
        self.se = Gtk.Entry()
        hbox1.pack_start(self.se, False, False, 2)
 
        self.ne = Gtk.Entry()
        hbox2.pack_start(self.ne, False, False, 2)
 
        # button to accept
        ab = Gtk.Button(label=""Accept"")
        ab.connect(""clicked"", self.on_accept_clicked)
        vbox.pack_start(ab, False, False, 2)
 
    def on_accept_clicked(self, widget):
        # read and validate the entered values
        str1 = self.se.get_text()
        str2 = self.ne.get_text()
        if validate_input(self, str1, str2):
            self.destroy()
 
random.seed(time.time())
win = MyWindow()
win.show_all()
Gtk.main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Solve_the_no_connection_puzzle,Solve the no connection puzzle,"You are given a box with eight holes labelled   A-to-H,   connected by fifteen straight lines in the pattern as shown below:

             A   B
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         C───D───E───F
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             G   H

You are also given eight pegs numbered   1-to-8.



Objective

Place the eight pegs in the holes so that the (absolute) difference between any two numbers connected by any line is greater than one.



Example

In this attempt:

             4   7
            /│\ /│\
           / │ X │ \
          /  │/ \│  \
         8───1───6───2
          \  │\ /│  /
           \ │ X │ /
            \│/ \│/
             3   5

Note that   7   and   6   are connected and have a difference of   1,   so it is   not   a solution.



Task
Produce and show here   one   solution to the puzzle.



Related tasks

   A* search algorithm
   Solve a Holy Knight's tour
   Knight's tour
   N-queens problem
   Solve a Hidato puzzle
   Solve a Holy Knight's tour
   Solve a Hopido puzzle
   Solve a Numbrix puzzle
   4-rings or 4-squares puzzle


See also
No Connection Puzzle (youtube).



",Python,"#  Solve No Connection Puzzle
#
#  Nigel_Galloway
#  October 6th., 2014
ADJACENT = [[0,0]]
A,B,C,D,E,F,G,H = [0,1],[0,2],[1,0],[1,1],[1,2],[1,3],[2,1],[2,2]
 
board1 = """"""
 . 0 0.
  0 0 1 0 
 . 0 0.
 
""""""
g = HLPsolver(board1)
g.board[A[0]][A[1]].adj = [B,G,H,F]            
g.board[B[0]][B[1]].adj = [A,C,G,H]            
g.board[C[0]][C[1]].adj = [B,E,F,H]          
g.board[D[0]][D[1]].adj = [F]                
g.board[E[0]][E[1]].adj = [C]                
g.board[F[0]][F[1]].adj = [A,C,D,G]          
g.board[G[0]][G[1]].adj = [A,B,F,H]            
g.board[H[0]][H[1]].adj = [A,B,C,G]            
g.solve",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Fractran,Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",Python,"from __future__ import division
from fractions import Fraction
from gmpy2 import popcount, scan1
from gmpy2 import mpz
 
def run(v, s):
	p = [Fraction(x) for x in s.split()]
	val = mpz(v)
 
loop:
	n = p
	if popcount(val) == 1:
		print ""\n[2^%d = %s]"" % (scan1(val, 0), val)
	else:
		print "" %s"" % val
 
	for n in p:
		# assuming the fractions are not reducible
		if not val % n.denominator == 0: continue
 
		val = val // n.denominator * n.numerator
		goto loop
 
	print ""\nhalt: %s has no divisors\n"" % val
 
run(2, ""17/91 78/85 19/51 23/38 29/33 77/29 95/23 ""
	""77/19 1/17 11/13 13/11 15/14 15/2 55/1"")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Padovan_sequence,Padovan sequence,"

The Padovan sequence is similar to the Fibonacci sequence in several ways.
Some are given in the table below, and the referenced video shows some of the geometric
similarities.



 Comment 
 Padovan 
 Fibonacci


 
 



 Named after. 
 Richard Padovan 
 Leonardo of Pisa: Fibonacci


 
 



 Recurrence initial values. 
 P(0)=P(1)=P(2)=1 
 F(0)=0, F(1)=1


 Recurrence relation. 
 P(n)=P(n-2)+P(n-3) 
 F(n)=F(n-1)+F(n-2)


 
 



 First 10 terms. 
 1,1,1,2,2,3,4,5,7,9 
 0,1,1,2,3,5,8,13,21,34


 
 



 Ratio of successive terms... 
 Plastic ratio, p 
 Golden ratio, g


 
 1.324717957244746025960908854… 
 1.6180339887498948482...


 Exact formula of ratios p and q. 
 ((9+69**.5)/18)**(1/3) + ((9-69**.5)/18)**(1/3) 
 (1+5**0.5)/2


 Ratio is real root of polynomial. 
 p: x**3-x-1 
 g: x**2-x-1


 
 



 Spirally tiling the plane using. 
 Equilateral triangles 
 Squares


 
 



 Constants for ... 
 s= 1.0453567932525329623 
 a=5**0.5


 ... Computing by truncation. 
 P(n)=floor(p**(n-1) / s + .5) 
 F(n)=floor(g**n / a + .5)


 
 



 L-System Variables. 
 A,B,C 
 A,B


 L-System Start/Axiom. 
 A 
 A


 L-System Rules. 
 A->B,B->C,C->AB 
 A->B,B->AB

Task

 Write a function/method/subroutine to compute successive members of the Padovan series using the recurrence relation.
 Write a function/method/subroutine to compute successive members of the Padovan series using the floor function.
 Show the first twenty terms of the sequence.
 Confirm that the recurrence and floor based functions give the same results for 64 terms,
 Write a function/method/... using the L-system to generate successive strings.
 Show the first 10 strings produced from the L-system
 Confirm that the length of the first 32 strings produced is the Padovan sequence.
Show output here, on this page.

Ref

 The Plastic Ratio - Numberphile video.

",Python,"from math import floor
from math import log
from math import sqrt
from fractions import Fraction
from functools import lru_cache
from itertools import accumulate
from operator import add
 
def padovan_recur(n):
    p = [0] * n
    p[0], p[1], p[2] = 1, 1, 1
    for i in range(3, n):
        p[i] = p[i-2] + p[i-3]
    return p
 
def padovan_floor(n):
    p = Fraction(1, 1)
    s = Fraction(1, 1)
    f = [0] * n
    pow = 1
    u = Fraction(1, 2)
    t = pow / p / s + u
    f[0] = floor(t)
    for i in range(1, n):
        t = pow / s + u
        f[i] = floor(t)
        pow *= p
    return f
 
@lru_cache(maxsize=None)
def padovan_lsys(n):
    rules = {'A': 'B', 'B': 'C', 'C': 'AB'}
    init = 'A'
    current = ''
    for i in range(n):
        if current == '':
            current = init
        else:
            current = ''.join(rules[c] for c in current)
    return current
 
def padovan_lsys_len(n):
    return [len(padovan_lsys(i)) for i in range(n)]
 
def are_same(l1, l2):
    return all(l1[i] == l2[i] for i in range(len(l1)))
 
if __name__ == '__main__':
    print('First 20 members of the Padovan sequence:')
    print(padovan_recur(20))
    recur = padovan_recur(64)
    floor = padovan_floor(64)
    same = are_same(recur, floor)
    s = 'give'
    if not same:
        s = 'do not give'
    print('\nThe recurrence and floor based functions', s, 'the same results for 64 terms.')
 
    p = padovan_lsys(32)
    lsyst = padovan_lsys_len(32)
    print('\nFirst 10 members of the Padovan L-System:')
    print(p[:10])
    print('\nand their lengths:')
    print(lsyst[:10])
 
    same = are_same(recur[:32], lsyst)
    s = 'give'
    if not same:
        s = 'do not give'
    print('\nThe recurrence and L-system based functions', s, 'the same results for 32 terms.')",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Dining_philosophers,Dining philosophers,"The dining philosophers problem illustrates non-composability of low-level synchronization primitives like semaphores. It is a modification of a problem posed by Edsger Dijkstra.

Five philosophers, Aristotle, Kant, Spinoza, Marx, and Russell (the tasks) spend their time thinking and eating spaghetti. They eat at a round table with five individual seats. For eating each philosopher needs two forks (the resources). There are five forks on the table, one left and one right of each seat. When a philosopher cannot grab both forks it sits and waits. Eating takes random time, then the philosopher puts the forks down and leaves the dining room. After spending some random time thinking about the nature of the universe, he again becomes hungry, and the circle repeats itself.

It can be observed that a straightforward solution, when forks are implemented by semaphores, is exposed to deadlock. There exist two deadlock states when all five philosophers are sitting at the table holding one fork each. One deadlock state is when each philosopher has grabbed the fork left of him, and another is when each has the fork on his right.

There are many solutions of the problem, program at least one, and explain how the deadlock is prevented.
",Python,"import threading
import time
import random
 
class Philosopher(threading.Thread):
    def __init__(self, name, left_fork, right_fork):
        threading.Thread.__init__(self)
        self.name = name
        self.left_fork = left_fork
        self.right_fork = right_fork
        self.meals = 0
 
    def run(self):
        while self.meals < 5:
            self.think()
            self.dine()
        print ""philosopher %s is full!"" % self.name
 
    def think(self):
        print ""philosopher %s is thinking..."" % self.name
        time.sleep(random.random())
        print ""philosopher %s is hungry..."" % self.name
 
    def dine(self):
        fork1, fork2 = self.left_fork, self.right_fork
        while True:
            self.pickup(fork1, True)
            print ""philosopher %s has fork %s..."" % (self.name, fork1.fork_id)
            if self.pickup(fork2, False):
                break
            print ""philosopher %s cannot pickup second fork %s..."" % (self.name, fork2.fork_id)
            self.release(fork1)
            fork1, fork2 = fork2, fork1
        print ""philosopher %s has the second fork %s..."" % (self.name, fork2.fork_id)
 
        print ""philosopher %s eats..."" % self.name
        time.sleep(random.random())
        print ""philosopher %s belches"" % self.name
        self.meals += 1
 
        self.release(self.left_fork)
        self.release(self.right_fork)
 
    def pickup(self, fork, wait):
        print ""philosopher %s attempts to pickup fork %s..."" % (self.name, fork.fork_id)
        if wait:
            fork.mutex.acquire()
        else:
            return fork.mutex.acquire(False)
 
    def release(self, fork):
        print ""philosopher %s releases fork %s..."" % (self.name, fork.fork_id)
        fork.mutex.release()
 
n = 5
 
Fork = lambda fork_id: {'fork_id': fork_id,'mutex': threading.Lock()}
forks = [Fork(i) for i in range(n)]
 
philosophers = [Philosopher(i, forks[i], forks[(i+1)%n]) for i in range(n)]
 
for philosopher in philosophers:
    philosopher.start()
 
for philosopher in philosophers:
    philosopher.join()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Command-line_arguments,Command-line arguments,"Command-line arguments is part of Short Circuit's Console Program Basics selection.
Scripted main
See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

myprogram -c ""alpha beta"" -h ""gamma""
",Python,"import sys
 
print(""This program is named "" + sys.argv[0])
print(""There are "" + str(len(sys.argv)-1) + "" arguments given."")
for i in range(1, len(sys.argv)):
    print(""the argument #"" + str(i) + "" is "" + sys.argv[i])",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Singly-linked_list/Element_definition,Singly-linked list/Element definition,"singly-linked list
See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Python,"class link:
    def __init__(self, next, data):
        self.next = next
        self.data = data",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/CRC-32,CRC-32,"

Task

Demonstrate a method of deriving the Cyclic Redundancy Check from within the language.



The result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.

Algorithms are described on Computation of CRC in Wikipedia.
This variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.

For the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:

 The quick brown fox jumps over the lazy dog

",Python,">>> s = 'The quick brown fox jumps over the lazy dog'
>>> import zlib
>>> hex(zlib.crc32(s))
'0x414fa339'
 
>>> import binascii
>>> hex(binascii.crc32(s))
'0x414fa339'",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Enforced_immutability,Enforced immutability,"Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.



",Python,"PI = 3.14159265358979323
MINSIZE = 10
MAXSIZE = 100",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Look-and-say_sequence,Look-and-say sequence,"The   Look and say sequence   is a recursively defined sequence of numbers studied most notably by   John Conway.



The   look-and-say sequence   is also known as the   Morris Number Sequence,   after cryptographer Robert Morris,   and the puzzle   What is the next number in the sequence 1,   11,   21,   1211,   111221?   is sometimes referred to as the Cuckoo's Egg,   from a description of Morris in Clifford Stoll's book   The Cuckoo's Egg.


Sequence Definition

 Take a decimal number
 Look at the number, visually grouping consecutive runs of the same digit.
 Say the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.
 This becomes the next number of the sequence.

An example:

 Starting with the number 1,   you have one 1 which produces 11
 Starting with 11,   you have two 1's.   I.E.:   21
 Starting with 21,   you have one 2, then one 1.   I.E.:   (12)(11) which becomes 1211
 Starting with 1211,   you have one 1, one 2, then two 1's.   I.E.:   (11)(12)(21) which becomes 111221


Task

Write a program to generate successive members of the look-and-say sequence.



Related tasks

   Fours is the number of letters in the ...
   Number names
   Self-describing numbers
   Self-referential sequence
   Spelling of ordinal numbers


See also

   Look-and-Say Numbers (feat John Conway), A Numberphile Video.
   This task is related to, and an application of, the Run-length encoding task.
   Sequence A005150 on The On-Line Encyclopedia of Integer Sequences.

",Python,"def lookandsay(number):
    result = """"
 
    repeat = number[0]
    number = number[1:]+"" ""
    times = 1
 
    for actual in number:
        if actual != repeat:
            result += str(times)+repeat
            times = 1
            repeat = actual
        else:
            times += 1
 
    return result
 
num = ""1""
 
for i in range(10):
    print num
    num = lookandsay(num)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file,Bitmap/Write a PPM file,"Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered).

(Read the definition of PPM file on Wikipedia.)



",Python,"import io
import struct
 
class PPMWriter:
 
    def bitmap_to_ppm(self, file, bitmap):
        file.delete()
 
        with open(file, 'wb') as f:
            header = f""P6\n{bitmap.get_width()} {bitmap.get_height()}\n255\n""
 
            f.write(header.encode('ascii'))
 
            for y in range(bitmap.get_height()):
                for x in range(bitmap.get_width()):
                    pixel = bitmap.get_pixel(x, y)
                    f.write(struct.pack('BBB', pixel.get_red(), pixel.get_green(), pixel.get_blue()))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Modular_arithmetic,Modular arithmetic,"Modular arithmetic is a form of arithmetic (a calculation technique involving the concepts of addition and multiplication) which is done on numbers with a defined equivalence relation called congruence.

For any positive integer 



p


{\displaystyle p}

 called the congruence modulus,
two numbers 



a


{\displaystyle a}

 and 



b


{\displaystyle b}

 are said to be congruent modulo p whenever there exists an integer 



k


{\displaystyle k}

 such that:





a
=
b
+
k

p


{\displaystyle a=b+k\,p}


The corresponding set of equivalence classes forms a ring denoted 






Z


p

Z






{\displaystyle {\frac {\mathbb {Z} }{p\mathbb {Z} }}}

.

Addition and multiplication on this ring have the same algebraic structure as in usual arithmetics, so that a function such as a polynomial expression could receive a ring element as argument and give a consistent result.

The purpose of this task is to show, if your programming language allows it,
how to redefine operators so that they can be used transparently on modular integers.
You can do it either by using a dedicated library, or by implementing your own class.

You will use the following function for demonstration:





f
(
x
)
=

x

100


+
x
+
1


{\displaystyle f(x)=x^{100}+x+1}


You will use 



13


{\displaystyle 13}

 as the congruence modulus and you will compute 



f
(
10
)


{\displaystyle f(10)}

.

It is important that the function 



f


{\displaystyle f}

 is agnostic about whether or not its argument is modular; it should behave the same way with normal and modular integers.
In other words, the function is an algebraic expression that could be used with any ring, not just integers.



",Python,"import math
 
def f(x):
    return pow(x, 100) + x + 1
 
class ModularInteger:
    def __init__(self, v, m):
        self.modulus = m
        self.value = v % m
 
    def getValue(self):
        return self.value
 
    def getModulus(self):
        return self.modulus
 
    def __add__(self, rhs):
        if self.modulus!= rhs.modulus:
            raise RuntimeError(""Left-hand modulus does not match right-hand modulus."")
        return ModularInteger(self.value + rhs.value, self.modulus)
 
    def __mul__(self, rhs):
        if self.modulus!= rhs.modulus:
            raise RuntimeError(""Left-hand modulus does not match right-hand modulus."")
        return ModularInteger(self.value * rhs.value, self.modulus)
 
    def __str__(self):
        return ""ModularInteger("" + str(self.value) + "", "" + str(self.modulus) + "")""
 
def pow(lhs, pow):
    if pow < 0:
        raise RuntimeError(""Power must not be negative."")
 
    base = ModularInteger(1, lhs.getModulus())
    while pow > 0:
        base = base * lhs
        pow -= 1
    return base
 
if __name__ == ""__main__"":
    input = ModularInteger(10, 13)
    output = f(input)
    print(""f("" + str(input) + "") = "" + str(output))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Get_system_command_output,Get system command output,"Task
Execute a system command and get its output into the program. The output may be stored in any kind of collection (array, list, etc.).




Related task
  Execute a system command

",Python,">>> import subprocess
>>> returned_text = subprocess.check_output(""dir"", shell=True, universal_newlines=True)
>>> type(returned_text)
<class 'str'>
>>> print(returned_text)
 Volume in drive C is Windows
 Volume Serial Number is 44X7-73CE
 
 Directory of C:\Python33
 
04/07/2013  06:40    <DIR>          .
04/07/2013  06:40    <DIR>          ..
27/05/2013  07:10    <DIR>          DLLs
27/05/2013  07:10    <DIR>          Doc
27/05/2013  07:10    <DIR>          include
27/05/2013  07:10    <DIR>          Lib
27/05/2013  07:10    <DIR>          libs
16/05/2013  00:15            33,326 LICENSE.txt
15/05/2013  22:49           214,554 NEWS.txt
16/05/2013  00:03            26,624 python.exe
16/05/2013  00:03            27,136 pythonw.exe
15/05/2013  22:49             6,701 README.txt
27/05/2013  07:10    <DIR>          tcl
27/05/2013  07:10    <DIR>          Tools
16/05/2013  00:02            43,008 w9xpopen.exe
               6 File(s)        351,349 bytes
               9 Dir(s)  46,326,947,840 bytes free
 
>>> # Ref: https://docs.python.org/3/library/subprocess.html",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Combinations_with_repetitions,Combinations with repetitions,"The set of combinations with repetitions is computed from a set, 



S


{\displaystyle S}

 (of cardinality 



n


{\displaystyle n}

), and a size of resulting selection, 



k


{\displaystyle k}

, by reporting the sets of cardinality 



k


{\displaystyle k}

 where each member of those sets is chosen from 



S


{\displaystyle S}

.
In the real world, it is about choosing sets where there is a “large” supply of each type of element and where the order of choice does not matter.
For example:

Q: How many ways can a person choose two doughnuts from a store selling three types of doughnut: iced, jam, and plain? (i.e., 



S


{\displaystyle S}

 is 



{

i
c
e
d

,

j
a
m

,

p
l
a
i
n

}


{\displaystyle \{\mathrm {iced} ,\mathrm {jam} ,\mathrm {plain} \}}

, 




|

S

|

=
3


{\displaystyle |S|=3}

, and 



k
=
2


{\displaystyle k=2}

.)
A: 6: {iced, iced}; {iced, jam}; {iced, plain}; {jam, jam}; {jam, plain}; {plain, plain}.
Note that both the order of items within a pair, and the order of the pairs given in the answer is not significant; the pairs represent multisets.
Also note that doughnut can also be spelled donut.



Task

 Write a function/program/routine/.. to generate all the combinations with repetitions of 



n


{\displaystyle n}

 types of things taken 



k


{\displaystyle k}

 at a time and use it to show an answer to the doughnut example above.
 For extra credit, use the function to compute and show just the number of ways of choosing three doughnuts from a choice of ten types of doughnut. Do not show the individual choices for this part.


References

 k-combination with repetitions


See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"# Iterator for the combinations of `arr` with `k` elements with repetitions.
# Yields the combinations in lexicographical order.
class CombinationsWithRepetitions(object):
    # source array to get combinations from
    # length of the combinations
    # current counts of each object that represent the next combination
    # whether there are any combinations left
    def __init__(self, arr, k):
        self.arr = arr
        self.k = k
        self.counts = [0] * len(arr)
        self.counts[len(arr) - 1] = k
        self.remaining = True
 
    def __iter__(self):
        return self
 
    def __next__(self):
        if not self.remaining:
            raise StopIteration
        comb = []
        for count, item in zip(self.counts, self.arr):
            for _ in range(count):
                comb.append(item)
        # this is lexicographically largest, and thus the last combination
        if self.counts[0] == self.k:
            self.remaining = False
        else:
            n = len(self.counts)
            for i in range(n - 1, 0, -1):
                if self.counts[i] > 0:
                    original_value = self.counts[i]
                    self.counts[i - 1] += 1
                    for j in range(i, n - 1):
                        self.counts[j] = 0
                    self.counts[n - 1] = original_value - 1
                    break
        return comb
 
if __name__ == '__main__':
    collection = [""iced"", ""jam"", ""plain""]
    for comb in CombinationsWithRepetitions(collection, 2):
        print("" "".join(comb))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Null_object,Null object,"
Null (or nil) is the computer science concept of an undefined or unbound object.
Some languages have an explicit way to access the null object, and some don't.
Some languages distinguish the null object from undefined values, and some don't.



Task

Show how to access null in your language by checking to see if an object is equivalent to the null object.


This task is not about whether a variable is defined. The task is about ""null""-like values in various languages, which may or may not be related to the defined-ness of variables in your language.
",Python,"x = None
if x is None:
  print ""x is None""
else:
  print ""x is not None""",Human_written,Python_from_C
http://rosettacode.org/wiki/Host_introspection,Host introspection,"Print the word size and endianness of the host machine.

See also: Variable size/Get
",Python,">>> import platform, sys, socket
>>> platform.architecture()
('64bit', 'ELF')
>>> platform.machine()
'x86_64'
>>> platform.node()
'yourhostname'
>>> platform.system()
'Linux'
>>> sys.byteorder
little
>>> socket.gethostname()
'yourhostname'
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Fork,Fork,"Task

Spawn a new process which can run simultaneously with, and independently of, the original parent process.



",Python,"import os
import time
import sys
 
def main():
	pid = os.fork()
	if pid == 0:
		time.sleep(0.01)
		print ""\tchild process: done""
	elif pid < 0:
		sys.exit(1)
	else:
		print ""waiting for child %d..."" % pid
		print ""child %d finished"" % os.wait()
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/N-queens_problem,N-queens problem,"

Solve the eight queens puzzle.



You can extend the problem to solve the puzzle with a board of size   NxN.

For the number of solutions for small values of   N,   see   OEIS: A000170.



Related tasks

 A* search algorithm
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Knight's tour
 Peaceful chess queen armies
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"# A fairly literal translation of the example program on the referenced
# WP page.  Well, it happened to be the example program the day I completed
# the task.  It seems from the WP history that there has been some churn
# in the posted example program.  The example program of the day was in
# Pascal and was credited to, from his ""Algorithms +
# Data Structures = Programs.""
 
i = 0
q = False
a = [True] * 9
b = [True] * 17
c = [True] * 15 # offset by 7 relative to the Pascal version
x = [0] * 9
 
def try(i):
    global q
    for j in range(1, 9):
        q = False
        if a[j] and b[i+j] and c[i-j+7]:
            x[i] = j
            a[j] = False
            b[i+j] = False
            c[i-j+7] = False
            if i < 8:
                try(i + 1)
                if not q:
                    a[j] = True
                    b[i+j] = True
                    c[i-j+7] = True
            else:
                q = True
        if q or j == 8:
            break
 
for i in range(1, 9):
    a[i] = True
for i in range(2, 17):
    b[i] = True
for i in range(0, 15):
    c[i] = True
try(1)
if q:
    for i in range(1, 9):
        print(i, x[i])",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Partition_an_integer_x_into_n_primes,Partition an integer x into n primes,"Task

Partition a positive integer   X   into   N   distinct primes.



Or, to put it in another way:

Find   N   unique primes such that they add up to   X.



Show in the output section the sum   X   and the   N   primes in ascending order separated by plus (+) signs:

     •    partition  99809  with   1 prime.
     •    partition    18   with   2 primes.
     •    partition    19   with   3 primes.
     •    partition    20   with   4 primes.
     •    partition   2017  with  24 primes.
     •    partition  22699  with   1,  2,  3,  and  4  primes.
     •    partition  40355  with   3 primes.

The output could/should be shown in a format such as:

    Partitioned  19  with  3  primes:  3+5+11

   Use any spacing that may be appropriate for the display.
   You need not validate the input(s).
   Use the lowest primes possible;   use  18 = 5+13,   not   18 = 7+11.
   You only need to show one solution.
This task is similar to factoring an integer.



Related tasks

   Count in factors
   Prime decomposition
   Factors of an integer
   Sieve of Eratosthenes
   Primality by trial division
   Factors of a Mersenne number
   Factors of a Mersenne number
   Sequence of primes by trial division

",Python,"from itertools import combinations as cmb
 
 
def isP(n):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    return all(n % x > 0 for x in range(3, int(n ** 0.5) + 1, 2))
 
 
def genP(n):
    p = [2]
    p.extend([x for x in range(3, n + 1, 2) if isP(x)])
    return p
 
 
data = [
    (99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),
    (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]
 
 
for n, cnt in data:
    ci = iter(cmb(genP(n), cnt))
    while True:
        try:
            c = next(ci)
            if sum(c) == n:
                print(' '.join(
                    [repr((n, cnt)), ""->"", '+'.join(str(s) for s in c)]
                ))
                break
        except StopIteration:
            print(repr((n, cnt)) + "" -> Not possible"")
            break",Human_written,Python_from_C#
http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation,Permutations/Rank of a permutation,"A particular ranking of a permutation associates an integer with a particular ordering of all the permutations of a set of distinct items.
For our purposes the ranking will assign integers 



0..
(
n
!
−
1
)


{\displaystyle 0..(n!-1)}

 to an ordering of all the permutations of the integers 



0..
(
n
−
1
)


{\displaystyle 0..(n-1)}

.

For example, the permutations of the digits zero to 3 arranged lexicographically have the following rank:

  PERMUTATION      RANK
  (0, 1, 2, 3) ->  0
  (0, 1, 3, 2) ->  1
  (0, 2, 1, 3) ->  2
  (0, 2, 3, 1) ->  3
  (0, 3, 1, 2) ->  4
  (0, 3, 2, 1) ->  5
  (1, 0, 2, 3) ->  6
  (1, 0, 3, 2) ->  7
  (1, 2, 0, 3) ->  8
  (1, 2, 3, 0) ->  9
  (1, 3, 0, 2) -> 10
  (1, 3, 2, 0) -> 11
  (2, 0, 1, 3) -> 12
  (2, 0, 3, 1) -> 13
  (2, 1, 0, 3) -> 14
  (2, 1, 3, 0) -> 15
  (2, 3, 0, 1) -> 16
  (2, 3, 1, 0) -> 17
  (3, 0, 1, 2) -> 18
  (3, 0, 2, 1) -> 19
  (3, 1, 0, 2) -> 20
  (3, 1, 2, 0) -> 21
  (3, 2, 0, 1) -> 22
  (3, 2, 1, 0) -> 23
Algorithms exist that can generate a rank from a permutation for some particular ordering of permutations, and that can generate the same rank from the given individual permutation (i.e. given a rank of 17 produce (2, 3, 1, 0) in the example above).

One use of such algorithms could be in generating a small, random, sample of permutations of 



n


{\displaystyle n}

 items without duplicates when the total number of permutations is large. Remember that the total number of permutations of 



n


{\displaystyle n}

 items is given by 



n
!


{\displaystyle n!}

 which grows large very quickly: A 32 bit integer can only hold 



12
!


{\displaystyle 12!}

, a 64 bit integer only 



20
!


{\displaystyle 20!}

. It becomes difficult to take the straight-forward approach of generating all permutations then taking a random sample of them.

A question on the Stack Overflow site asked how to generate one million random and indivudual permutations of 144 items.



Task

 Create a function to generate a permutation from a rank.
 Create the inverse function that given the permutation generates its rank.
 Show that for 



n
=
3


{\displaystyle n=3}

 the two functions are indeed inverses of each other.
 Compute and show here 4 random, individual, samples of permutations of 12 objects.


Stretch goal

 State how reasonable it would be to use your program to address the limits of the Stack Overflow question.


References

 Ranking and Unranking Permutations in Linear Time by Myrvold & Ruskey. (Also available via Google here).
 Ranks on the DevData site.
 Another answer on Stack Overflow to a different question that explains its algorithm in detail.


Related tasks

Factorial_base_numbers_indexing_permutations_of_a_collection

",Python,"import math
import random
 
# returns permutation q of n items, using Myrvold-Ruskey rank.
def MRPerm(q, n):
    p = ident(n)
    r = 0
    while n > 0:
        q, r = divmod(q, n)
        n -= 1
        p[n], p[r] = p[r], p[n]
    return p
 
# returns identity permutation of n items.
def ident(n):
    return list(range(n))
 
# returns Myrvold-Ruskey rank of permutation p
def MRRank(p):
    p = p[:]
    inv = inverse(p)
    for i in range(len(p) - 1, 0, -1):
        s = p[i]
        p[inv[i]] = s
        inv[s] = inv[i]
    r = 0
    for i in range(1, len(p)):
        r = r * (i + 1) + p[i]
    return r
 
# returns inverse of a permutation.
def inverse(p):
    return [p.index(i) for i in range(len(p))]
 
# returns n!
def fact(n):
    f = n
    while n > 2:
        n -= 1
        f *= n
    return f
 
if __name__ == '__main__':
    n = 3
    print(""permutations of"", n, ""items"")
    f = fact(n)
    for i in range(f):
        p = MRPerm(i, n)
        print(i, p, MRRank(p))
    n = 12
    print(""permutations of"", n, ""items"")
    f = fact(n)
    m = {}
    while len(m) < 4:
        r = random.randint(0, f - 1)
        if r in m:
            continue
        m[r] = True
        print(r, MRPerm(r, n))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",Python,"# version 1.2

import re

r = re.compile(r""-?\d+[ ]+-?\d+"")
while True:
    print(""Enter two integers separated by space(s) or q to quit: "", end="""")
    input = input().strip()
    if input == ""q"" or input == ""Q"":
        break
    if not r.match(input):
        print(""Invalid input, try again"")
        continue
    index = input.rfind(' ')
    a = int(input[:index].strip())
    b = int(input[index + 1:])
    print(f""{a} + {b} = {a + b}"")
    print(f""{a} - {b} = {a - b}"")
    print(f""{a} * {b} = {a * b}"")
    if b!= 0:
        print(f""{a} / {b} = {a // b}"")  # rounds towards zero
        print(f""{a} % {b} = {a % b}"")  # if non-zero, matches sign of first operand
    else:
        print(f""{a} / {b} = undefined"")
        print(f""{a} % {b} = undefined"")
    d = a ** b
    print(f""{a} ^ {b} = "", end="""")
    if d % 1 == 0:
        if d >= -2 ** 63 and d <= 2 ** 63 - 1:
            print(int(d))
        else:
            print(""out of range"")
    elif not d.is_integer():
        print(""not integral"")
    else:
        print(""not finite"")
    print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number,Validate International Securities Identification Number,"An International Securities Identification Number (ISIN) is a unique international identifier for a financial security such as a stock or bond.



Task

Write a function or program that takes a string as input, and checks whether it is a valid ISIN.

It is only valid if it has the correct format,   and   the embedded checksum is correct.

Demonstrate that your code passes the test-cases listed below.



Details

The format of an ISIN is as follows:


┌───────────── a 2-character ISO country code (A-Z)
│ ┌─────────── a 9-character security code (A-Z, 0-9)
│ │        ┌── a checksum digit (0-9)
AU0000XVGZA3



For this task, you may assume that any 2-character alphabetic sequence is a valid country code.

The checksum can be validated as follows:

 Replace letters with digits, by converting each character from base 36 to base 10, e.g. AU0000XVGZA3 →1030000033311635103.
 Perform the Luhn test on this base-10 number.
There is a separate task for this test: Luhn test of credit card numbers.
You don't have to replicate the implementation of this test here   ───   you can just call the existing function from that task.   (Add a comment stating if you did this.)


Test cases



 ISIN

 Validity

 Comment


 US0378331005 
 valid 



 US0373831005 
 not valid 
 The transposition typo is caught by the checksum constraint.


 U50378331005 
 not valid 
 The substitution typo is caught by the format constraint.


 US03378331005 
 not valid 
 The duplication typo is caught by the format constraint.


 AU0000XVGZA3 
 valid 



 AU0000VXGZA3 
 valid 
 Unfortunately, not all transposition typos are caught by the checksum constraint.


 FR0000988040 
 valid 


(The comments are just informational.   Your function should simply return a Boolean result.   See #Raku for a reference solution.)



Related task:

 Luhn test of credit card numbers


Also see

 Interactive online ISIN validator
 Wikipedia article: International Securities Identification Number

",Python,"def check_isin(a):
    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):
        return False
    s = """".join(str(int(c, 36)) for c in a)
    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +
                 sum(ord(c) - 48 for c in s[::-2])) % 10
 
# A more readable version 
def check_isin_alt(a):
    if len(a) != 12:
        return False
    s = []
    for i, c in enumerate(a):
        if c.isdigit():
            if i < 2:
                return False
            s.append(ord(c) - 48)
        elif c.isupper():
            if i == 11:
                return False
            s += divmod(ord(c) - 55, 10)
        else:
            return False
    v = sum(s[::-2])
    for k in s[-2::-2]:
        k = 2 * k
        v += k - 9 if k > 9 else k
    return v % 10 == 0
 
[check_isin(s) for s in [""US0378331005"", ""US0373831005"", ""U50378331005"", ""US03378331005"",
                         ""AU0000XVGZA3"", ""AU0000VXGZA3"", ""FR0000988040""]]
 
# [True, False, False, False, True, True, True]",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,">>> def sort_disjoint_sublist(data, indices):
	indices = sorted(indices)
	values  = sorted(data[i] for i in indices)
	for index, value in zip(indices, values):
		data[index] = value
 
 
>>> d = [7, 6, 5, 4, 3, 2, 1, 0]
>>> i = set([6, 1, 7])
>>> sort_disjoint_sublist(d, i)
>>> d
[7, 0, 5, 4, 3, 2, 1, 6]
>>> # Which could be more cryptically written as:
>>> def sort_disjoint_sublist(data, indices):
	for index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value
 
 
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/HTTPS/Client-authenticated,HTTPS/Client-authenticated,"Demonstrate how to connect to a web server over HTTPS where that server requires that the client present a certificate to prove who (s)he is. Unlike with the HTTPS request with authentication task, it is not acceptable to perform the authentication by a username/password or a set cookie.

This task is in general useful for use with webservice clients as it offers a high level of assurance that the client is an acceptable counterparty for the server. For example, Amazon Web Services uses this style of authentication.
",Python,"reqwest = {version = ""0.11"", features = [""native-tls"", ""blocking""]}",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Find_limit_of_recursion,Find limit of recursion,"Find limit of recursion is part of Short Circuit's Console Program Basics selection.
Task

Find the limit of recursion.



",Python,"import sys
print(sys.getrecursionlimit())",Human_written,Python_from_Go
http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",Python,"import string, sys
if sys.version_info[0] < 3:
    input = raw_input
 
def ispangram(sentence, alphabet=string.ascii_lowercase):
    alphaset = set(alphabet)
    return alphaset <= set(sentence.lower())
 
print ( ispangram(input('Sentence: ')) )",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",Python,"def bubble_sort(seq):
    """"""Inefficiently sort the mutable sequence (list) in place.
       seq MUST BE A MUTABLE SEQUENCE.
 
       As with list.sort() and random.shuffle this does NOT return 
    """"""
    changed = True
    while changed:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i]
                changed = True
    return seq
 
if __name__ == ""__main__"":
   """"""Sample usage and simple test suite""""""
 
   from random import shuffle
 
   testset = [_ for _ in range(100)]
   testcase = testset.copy() # make a copy
   shuffle(testcase)
   assert testcase != testset  # we've shuffled it
   bubble_sort(testcase)
   assert testcase == testset  # we've unshuffled it back into a copy",Human_written,Python_from_Java
http://rosettacode.org/wiki/Power_set,Power set,"A   set   is a collection (container) of certain values,
without any particular order, and no repeated values.

It corresponds with a finite set in mathematics.

A set can be implemented as an associative array (partial mapping)
in which the value of each key-value pair is ignored.

Given a set S, the power set (or powerset) of S, written P(S), or 2S, is the set of all subsets of S.



Task

By using a library or built-in set type, or by defining a set type with necessary operations, write a function with a set S as input that yields the power set 2S of S.



For example, the power set of     {1,2,3,4}     is

 {{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}, {4}, {1,4}, {2,4}, {1,2,4}, {3,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}.
For a set which contains n elements, the corresponding power set has 2n elements, including the edge cases of empty set.


The power set of the empty set is the set which contains itself (20 = 1):


 





P




{\displaystyle {\mathcal {P}}}

(



∅


{\displaystyle \varnothing }

) = { 



∅


{\displaystyle \varnothing }

 }

And the power set of the set which contains only the empty set, has two subsets, the empty set and the set which contains the empty set (21 = 2):


 





P




{\displaystyle {\mathcal {P}}}

({



∅


{\displaystyle \varnothing }

}) = { 



∅


{\displaystyle \varnothing }

, { 



∅


{\displaystyle \varnothing }

 } }


Extra credit:  Demonstrate that your language supports these last two powersets.



",Python,"from typing import Set, List, TypeVar
from itertools import chain, combinations
 
T = TypeVar('T')
 
def powerset(s: Set[T]) -> Set[Set[T]]:
    return set(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))
 
if __name__ == '__main__':
    set = {1, 2, 3, 4}
    print(powerset(set))
 
    set = {'a', 'b', 'c', 'd'}
    print(powerset(set))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"a, b = map(int, input().split())
 
if a < b:
    print(a, ""is less than"", b)
 
if a == b:
    print(a, ""is equal to"", b)
 
if a > b:
    print(a, ""is greater than"", b)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Inverted_syntax,Inverted syntax,"Inverted syntax with conditional expressions

In traditional syntax conditional expressions are usually shown before the action within a statement or code block:

 IF raining=true THEN needumbrella=true 
In inverted syntax, the action is listed before the conditional expression in the statement or code block:

 needumbrella=true IF raining=true 
Inverted syntax with assignment

In traditional syntax, assignments are usually expressed with the variable appearing before the expression:

 a = 6
In inverted syntax, the expression appears before the variable:

 6 = a
Task

The task is to demonstrate support for inverted syntax forms within the language by showing both the traditional and inverted forms.
",Python,"# version 1.0.6
 
def iif(cond):
    return cond
 
raining = True
needUmbrella = iif(raining)
print(""Do I need an umbrella?  "" + (""Yes"" if needUmbrella else ""No""))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail,Strip whitespace from a string/Top and tail,"Task

Demonstrate how to strip leading and trailing whitespace from a string.

The solution should demonstrate how to achieve the following three results:

 String with leading whitespace removed
 String with trailing whitespace removed
 String with both leading and trailing whitespace removed


For the purposes of this task whitespace includes non printable characters such as the space character, the tab character, and other such characters that have no corresponding graphical representation.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> s = ' \t \r \n String with spaces  \t  \r  \n  '
>>> s
' \t \r \n String with spaces  \t  \r  \n  '
>>> s.lstrip()
'String with spaces  \t  \r  \n  '
>>> s.rstrip()
' \t \r \n String with spaces'
>>> s.strip()
'String with spaces'
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Move-to-front_algorithm,Move-to-front algorithm,"Given a symbol table of a zero-indexed array of all possible input symbols
this algorithm reversibly transforms a sequence
of input symbols into an array of output numbers (indices).

The transform in many cases acts to give frequently repeated input symbols
lower indices which is  useful in some compression algorithms.



Encoding algorithm

    for each symbol of the input sequence:
        output the index of the symbol in the symbol table
        move that symbol to the front of the symbol table



Decoding algorithm

    # Using the same starting symbol table
    for each index of the input sequence:
        output the symbol at that index of the symbol table
        move that symbol to the front of the symbol table



Example

Encoding the string of character symbols 'broood' using a symbol table of the lowercase characters   a-to-z



 Input

 Output

 SymbolTable


 broood

 1

 'abcdefghijklmnopqrstuvwxyz'


 broood

 1 17

 'bacdefghijklmnopqrstuvwxyz'


 broood

 1 17 15

 'rbacdefghijklmnopqstuvwxyz'


 broood

 1 17 15 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0

 'orbacdefghijklmnpqstuvwxyz'


 broood

 1 17 15 0 0 5

 'orbacdefghijklmnpqstuvwxyz'



Decoding the indices back to the original symbol order:



 Input

 Output

 SymbolTable


 1 17 15 0 0 5

 b

 'abcdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 br

 'bacdefghijklmnopqrstuvwxyz'


 1 17 15 0 0 5

 bro

 'rbacdefghijklmnopqstuvwxyz'


 1 17 15 0 0 5

 broo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 brooo

 'orbacdefghijklmnpqstuvwxyz'


 1 17 15 0 0 5

 broood

 'orbacdefghijklmnpqstuvwxyz'



Task

   Encode and decode the following three strings of characters using the symbol table of the lowercase characters   a-to-z   as above. 
   Show the strings and their encoding here.
   Add a check to ensure that the decoded string is the same as the original.


The strings are:

   broood          
   bananaaa     
   hiphophiphop  


(Note the misspellings in the above strings.)
",Python,"def encodeMTF(word):
    init = {'wordAsNumbers': [], 'charList': list('abcdefghijklmnopqrstuvwxyz')}

    return [charNum for char in word for charNum in [init['charList'].index(char)]]

def decodeMTF(numList):
    init = {'word': '', 'charList': list('abcdefghijklmnopqrstuvwxyz')}

    return ''.join([init['charList'][num] for num in numList])

#test our algorithms
words = ['broood', 'bananaaa', 'hiphophiphop']
encoded = [encodeMTF(word) for word in words]
decoded = [decodeMTF(numList) for numList in encoded]

#print results
print(""from encoded:"")
print(encoded)
print(""from decoded:"")
print(decoded)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Harshad_or_Niven_series,Harshad or Niven series,"The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.

For example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.

Assume that the series is defined as the numbers in increasing order.



Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to:

   list the first 20 members of the sequence,   and
   list the first Harshad number greater than 1000.


Show your output here.



Related task
   Increasing gaps between consecutive Niven numbers


See also
    OEIS: A005349

",Python,"def digsum(n):
    sum = 0
    while n > 0:
        sum += n % 10
        n //= 10
    return sum
 
n = 1
done = found = 0
while not done:
    if n % digsum(n) == 0:
        if found < 20:
            print(n, end=' ')
            found += 1
        if n > 1000:
            done = 1
            print()
            print(n)
    n += 1",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Python,"width = int(raw_input(""Width of myarray: ""))
height = int(raw_input(""Height of Array: ""))
myarray = [[0] * width for i in range(height)]
myarray[0][0] = 3.5
print (myarray[0][0])",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Checkpoint_synchronization,Checkpoint synchronization,"The checkpoint synchronization is a problem of synchronizing multiple tasks. Consider a workshop where several workers (tasks) assembly details of some mechanism. When each of them completes his work they put the details together. There is no store, so a worker who finished its part first must wait for others before starting another one. Putting details together is the checkpoint at which tasks synchronize themselves before going their paths apart.

The task

Implement checkpoint synchronization in your language.

Make sure that the solution is race condition-free. Note that a straightforward solution based on events is exposed to race condition. Let two tasks A and B need to be synchronized at a checkpoint. Each signals its event (EA and EB correspondingly), then waits for the AND-combination of the events (EA&EB) and resets its event. Consider the following scenario: A signals EA first and gets blocked waiting for EA&EB. Then B signals EB and loses the processor. Then A is released (both events are signaled) and resets EA. Now if B returns and enters waiting for EA&EB, it gets lost.

When a worker is ready it shall not continue before others finish. A typical implementation bug is when a worker is counted twice within one working cycle causing its premature completion. This happens when the quickest worker serves its cycle two times while the laziest one is lagging behind.

If you can, implement workers joining and leaving.
",Python,"""""""
 
Based on https://pymotw.com/3/threading/
 
""""""
 
import threading
import time
import random
 
 
def worker(workernum, barrier):
    # task 1
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 1, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
    barrier.wait()
    # task 2
    sleeptime = random.random()
    print('Starting worker '+str(workernum)+"" task 2, sleeptime=""+str(sleeptime))
    time.sleep(sleeptime)
    print('Exiting worker'+str(workernum))
 
barrier = threading.Barrier(3)
 
w1 = threading.Thread(target=worker, args=((1,barrier)))
w2 = threading.Thread(target=worker, args=((2,barrier)))
w3 = threading.Thread(target=worker, args=((3,barrier)))
 
w1.start()
w2.start()
w3.start()",Human_written,Python_from_Java
http://rosettacode.org/wiki/File_modification_time,File modification time,"Task

Get and set the modification time of a file.



",Python,"import os
 
#Get modification time:
modtime = os.path.getmtime('filename')
 
#Set the access and modification times:
os.utime('path', (actime, mtime))
 
#Set just the modification time:
os.utime('path', (os.path.getatime('path'), mtime))
 
#Set the access and modification times to the current time:
os.utime('path', None)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds,Sorting algorithms/Cocktail sort with shifting bounds,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   cocktail sort   is an improvement on the   Bubble Sort.



A cocktail sort is also known as:

   cocktail shaker sort
   happy hour sort
   bidirectional bubble sort
   a bubble sort variation
   a selection sort variation
   ripple sort
   shuffle sort
   shuttle sort


The improvement is basically that values ""bubble""   (migrate)   both directions through the
array,   because on each iteration the cocktail sort   bubble sorts   once
forwards and once backwards.

After   ii   passes,   the first   ii   and the
last   ii   elements in the array are in their correct
positions,   and don't have to be checked (again).

By shortening the part of the array that is sorted each time,   the number of
comparisons can be halved.



Pseudocode for the    2nd    algorithm   (from
Wikipedia)   with an added comment and changed indentations:

function A = cocktailShakerSort(A)
% `beginIdx` and `endIdx` marks the first and last index to check.
beginIdx = 1;
endIdx = length(A) - 1;
 
    while beginIdx <= endIdx
    newBeginIdx = endIdx;
    newEndIdx = beginIdx;
        for ii = beginIdx:endIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newEndIdx = ii;
            end
        end
 
    % decreases `endIdx` because the elements after `newEndIdx` are in correct order
    endIdx = newEndIdx - 1;
 
    % (FOR  (below)  decrements the  II  index by -1.
 
        for ii = endIdx:-1:beginIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newBeginIdx = ii;
            end
        end
 
    % increases `beginIdx` because the elements before `newBeginIdx` are in correct order.
    beginIdx = newBeginIdx + 1;
    end
end
%   indicates a comment,   and   deal   indicates a   swap.



Task

Implement a   cocktail sort   and optionally show the sorted output here on this page.

See the   discussion   page for some timing comparisons.



Related task

   cocktail sort

",Python,"def swap(array, i, j):
    temp = array[i]
    array[i] = array[j]
    array[j] = temp
 
def cocktail_sort(array):
    begin = 0
    end = len(array)
    if end == 0:
        return
    end -= 1
    while begin < end:
        new_begin = end
        new_end = begin
        for i in range(begin, end):
            c1 = array[i]
            c2 = array[i + 1]
            if c1 > c2:
                swap(array, i, i + 1)
                new_end = i
        end = new_end
        for i in range(end, begin + 1, -1):
            c1 = array[i - 1]
            c2 = array[i]
            if c1 > c2:
                swap(array, i, i - 1)
                new_begin = i
        begin = new_begin
 
if __name__ == '__main__':
    array = [5, 1, -6, 12, 3, 13, 2, 4, 0, 15]
    print('before:', array)
    cocktail_sort(array)
    print('after:', array)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Elementary_cellular_automaton/Random_Number_Generator,Elementary cellular automaton/Random Number Generator,"Rule 30 is considered to be chaotic enough to generate good pseudo-random numbers. As a matter of fact, rule 30 is used by the Mathematica software for its default random number generator.

Steven Wolfram's recommendation for random number generation from rule 30 consists in extracting successive bits in a fixed position in the array of cells, as the automaton changes state.

The purpose of this task is to demonstrate this. With the code written in the parent task, which you don't need to re-write here, show the ten first bytes that emerge from this recommendation. To be precise, you will start with a state of all cells but one equal to zero, and you'll follow the evolution of the particular cell whose state was initially one. Then you'll regroup those bits by packets of eight, reconstituting bytes with the first bit being the most significant.

You can pick which ever length you want for the initial array but it should be visible in the code so that your output can be reproduced with an other language.

For extra-credits, you will make this algorithm run as fast as possible in your language, for instance with an extensive use of bitwise logic.

Reference

 Cellular automata: Is Rule 30 random? (PDF).

",Python,"from elementary_cellular_automaton import eca, eca_wrap
 
def rule30bytes(lencells=100):
    cells = '1' + '0' * (lencells - 1)
    gen = eca(cells, 30)
    while True:
        yield int(''.join(next(gen)[0] for i in range(8)), 2)
 
if __name__ == '__main__':
    print([b for i,b in zip(range(10), rule30bytes())])",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion,Doubly-linked list/Element insertion,"Doubly-Linked List (element)
This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Python,"class DListNode:
    def __init__(self, value, prev, succ):
        self.value = value
        self.prev = prev
        self.succ = succ

    @classmethod
    def from_array(cls, array):
        if len(array) == 0:
            return None
        head = cls(array[0], None, None)
        current = head
        for value in array[1:]:
            new_node = cls(value, current, None)
            current.succ = new_node
            current = new_node
        return head

    def insert_after(self, search_value, new_value):
        if self.value == search_value:
            new_node = self.__class__(new_value, None, None)
            next_node = self.succ
            self.succ = new_node
            new_node.prev = self
            new_node.succ = next_node
            next_node.prev = new_node
        elif self.succ is None:
            raise ValueError(""value {} not found in list"".format(search_value))
        else:
            self.succ.insert_after(search_value, new_value)
 
head = DListNode.from_array([""a"", ""b""])
head.insert_after(""a"", ""c"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Padovan_n-step_number_sequences,Padovan n-step number sequences,"As the Fibonacci sequence expands to the Fibonacci n-step number sequences; We similarly expand the Padovan sequence to form these Padovan n-step number sequences.

The Fibonacci-like sequences can be defined like this:

   For n == 2:
       start:      1, 1
       Recurrence: R(n, x) = R(n, x-1) + R(n, x-2); for n == 2
   For n == N:
       start:      First N terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-1) + R(N, x-2) + ... R(N, x-N))

For this task we similarly define terms of the first 2..n-step Padovan sequences as:

   For n == 2:
       start:      1, 1, 1
       Recurrence: R(n, x) = R(n, x-2) + R(n, x-3); for n == 2
   For n == N:
       start:      First N + 1 terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-2) + R(N, x-3) + ... R(N, x-N-1))

The initial values of the sequences are:


 Padovan 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Values 
 OEIS Entry


 2 
 1,1,1,2,2,3,4,5,7,9,12,16,21,28,37, ... 
 A134816: 'Padovan's spiral numbers'


 3 
 1,1,1,2,3,4,6,9,13,19,28,41,60,88,129, ... 
 A000930: 'Narayana's cows sequence'


 4 
 1,1,1,2,3,5,7,11,17,26,40,61,94,144,221, ... 
 A072465: 'A Fibonacci-like model in which each pair of rabbits dies after the birth of their 4th litter'


 5 
 1,1,1,2,3,5,8,12,19,30,47,74,116,182,286, ... 
 A060961: 'Number of compositions (ordered partitions) of n into 1's, 3's and 5's'


 6 
 1,1,1,2,3,5,8,13,20,32,51,81,129,205,326, ... 
 <not found>


 7 
 1,1,1,2,3,5,8,13,21,33,53,85,136,218,349, ... 
 A117760: 'Expansion of 1/(1 - x - x^3 - x^5 - x^7)'


 8 
 1,1,1,2,3,5,8,13,21,34,54,87,140,225,362, ... 
 <not found>




Task

 Write a function to generate the first 



t


{\displaystyle t}

 terms, of the first 2..max_n Padovan 



n


{\displaystyle n}

-step number sequences as defined above.
 Use this to print and show here at least the first t=15 values of the first 2..8 



n


{\displaystyle n}

-step sequences.
 (The OEIS column in the table above should be omitted).

",Python,"import numpy as np
 
def padovanN(n, t, p):
    if n < 2 or t < 3:
        for i in range(t):
            p[i] = 1
        return
    padovanN(n-1, t, p)
    for i in range(n, t):
        p[i] = 0
        for j in range(i - 2, i - n - 1, -1):
            p[i] += p[j]
 
t = 15
p = np.zeros(t, dtype=int)
print(""First %d terms of the Padovan n-step number sequences:"" % t)
for n in range(2, 9):
    padovanN(n, t, p)
    print(""%d: "" % n, end="""")
    for i in range(t):
        print(""%3d "" % p[i], end="""")
    print()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Factorial,Factorial,"Definitions

   The factorial of   0   (zero)   is defined as being   1   (unity).
   The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number.

Solutions can be iterative or recursive.

Support for trapping negative    n    errors is optional.



Related task

   Primorial numbers

",Python,"import math
math.factorial(n)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Return_multiple_values,Return multiple values,"Task

Show how to return more than one value from a function.



",Python,"def addsub(x, y):
  return x + y, x - y",Human_written,Python_from_Go
http://rosettacode.org/wiki/Benford%27s_law,Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",Python,"import math
import random

EXPECTED = [math.log10(1+1.0/d) for d in range(1,10)]

def fib(n):
    a,b = 0,1
    for k in range(n):
        a, b = b, a+b
        yield a

def power_of_threes(n):
    for k in range(n):
        yield 3**k

def heads(s):
    return [int(str(a)[0]) for a in s]

def show_dist(title, s):
    s = heads(s)
    c = [0]*10
    for x in s:
        c[x] += 1
    size = float(len(s))
    res = [c[d]/size for d in range(1,10)]
    print(""\n    %s Benfords deviation"" % title)
    for i, (r, e) in enumerate(zip(res, EXPECTED), 1):
        print(""%2d: %5.1f%%  %5.1f%%  %5.1f%%"" % (i, r*100, e*100, (r - e).abs()*100))

def random(n):
    for k in range(n):
        yield random.randint(1,n)

show_dist(""fibbed"", fib(1000))
show_dist(""threes"", power_of_threes(1000))

# just to show that not all kind-of-random sets behave like that
show_dist(""random"", random(10000))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Generate_Chess960_starting_position,Generate Chess960 starting position,"Chess960 is a variant of chess created by world champion Bobby Fischer. Unlike other variants of the game, Chess960 does not require a different material, but instead relies on a random initial position, with a few constraints:

 as in the standard chess game, all eight white pawns must be placed on the second rank.
 White pieces must stand on the first rank as in the standard game, in random column order but with the two following constraints:
 the bishops must be placed on opposite color squares (i.e. they must be an odd number of spaces apart or there must be an even number of spaces between them)
 the King must be between two rooks (with any number of other pieces between them all)
 Black pawns and pieces must be placed respectively on the seventh and eighth ranks, mirroring the white pawns and pieces, just as in the standard game. (That is, their positions are not independently randomized.)


With those constraints there are 960 possible starting positions, thus the name of the variant.



Task

The purpose of this task is to write a program that can randomly generate any one of the 960 Chess960 initial positions. You will show the result as the first rank displayed with Chess symbols in Unicode: ♔♕♖♗♘ or with the letters King Queen Rook Bishop kNight.



",Python,"import random
 
class Symbols:
    def __init__(self, k, q, r, b, n):
        self.k = k
        self.q = q
        self.r = r
        self.b = b
        self.n = n
 
A = Symbols('K', 'Q', 'R', 'B', 'N')
W = Symbols('♔', '♕', '♖', '♗', '♘')
B = Symbols('♚', '♛', '♜', '♝', '♞')
 
krn = [
    ""nnrkr"", ""nrnkr"", ""nrknr"", ""nrkrn"",
    ""rnnkr"", ""rnknr"", ""rnkrn"",
    ""rknnr"", ""rknrn"",
    ""rkrnn""]
 
def chess960(sym, id):
    pos = [0] * 8
    q, r = divmod(id, 4)
    pos[r*2+1] = sym.b
    q, r = divmod(q, 4)
    pos[r*2] = sym.b
    q, r = divmod(q, 6)
    for i in range(8):
        if pos[i]!= 0:
            continue
        if r == 0:
            pos[i] = sym.q
            break
        r -= 1
    i = 0
    for f in krn[q]:
        while pos[i]!= 0:
            i += 1
        if f == 'k':
            pos[i] = sym.k
        elif f == 'r':
            pos[i] = sym.r
        else:
            pos[i] = sym.n
    return ''.join(pos)
 
print("" ID  Start position"")
for id in [0, 518, 959]:
    print(""{:3d}  {}"".format(id, chess960(A, id)))
 
print(""\nRandom"")
for i in range(5):
    print(chess960(W, random.randint(0, 959)))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Prime_decomposition,Prime decomposition,"The prime decomposition of a number is defined as a list of prime numbers
which when all multiplied together, are equal to that number.



Example

 12 = 2 × 2 × 3,  so its prime decomposition is  {2, 2, 3}



Task

Write a function which returns an array or collection which contains the prime decomposition of a given number   



n


{\displaystyle n}

   greater than   1.

If your language does not have an isPrime-like function available,
you may assume that you have a function which determines
whether a number is prime (note its name before your code).

If you would like to test code from this task, you may use code from trial division or the Sieve of Eratosthenes.

Note: The program must not be limited by the word size of your computer or some other artificial limit; it should work for any number regardless of size (ignoring the physical limits of RAM etc).



Related tasks

   count in factors
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"from __future__ import print_function
 
import sys
from itertools import islice, cycle, count
 
try:
    from itertools import compress
except ImportError:
    def compress(data, selectors):
        """"""compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F""""""
        return (d for d, s in zip(data, selectors) if s)
 
 
def is_prime(n):
    return list(zip((True, False), decompose(n)))[-1][0]
 
class IsPrimeCached(dict):
    def __missing__(self, n):
        r = is_prime(n)
        self[n] = r
        return r
 
is_prime_cached = IsPrimeCached()
 
def croft():
    """"""Yield prime integers using the Croft Spiral sieve.
 
    This is a variant of wheel factorisation modulo 30.
    """"""
    # Copied from:
    #   https://code.google.com/p/pyprimes/source/browse/src/pyprimes.py
    # Implementation is based on erat3 from here:
    #   http://stackoverflow.com/q/2211990
    # and this website:
    #   http://www.primesdemystified.com/
    # Memory usage increases roughly linearly with the number of primes seen.
    # dict ``roots`` stores an entry x:p for every prime p.
    for p in (2, 3, 5):
        yield p
    roots = {9: 3, 25: 5}  # Map d**2 -> d.
    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))
    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)
    for q in compress(
            # Iterate over prime candidates 7, 9, 11, 13, ...
            islice(count(7), 0, None, 2),
            # Mask out those that can't possibly be prime.
            cycle(selectors)
            ):
        # Using dict membership testing instead of pop gives a
        # 5-10% speedup over the first three million primes.
        if q in roots:
            p = roots[q]
            del roots[q]
            x = q + 2*p
            while x in roots or (x % 30) not in primeroots:
                x += 2*p
            roots[x] = p
        else:
            roots[q*q] = q
            yield q
primes = croft
 
def decompose(n):
    for p in primes():
        if p*p > n: break
        while n % p == 0:
            yield p
            n //=p
    if n > 1:
        yield n
 
 
if __name__ == '__main__':
    # Example: calculate factors of Mersenne numbers to M59 #
 
    import time
 
    for m in primes():
        p = 2 ** m - 1
        print( ""2**{0:d}-1 = {1:d}, with factors:"".format(m, p) )
        start = time.time()
        for factor in decompose(p):
            print(factor, end=' ')
            sys.stdout.flush()
 
        print( ""=> {0:.2f}s"".format( time.time()-start ) )
        if m >= 59:
            break",Human_written,Python_from_C#
http://rosettacode.org/wiki/Wieferich_primes,Wieferich primes,"

 This page uses content from Wikipedia. The original article was at Wieferich prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In number theory, a Wieferich prime is a prime number  p  such that  p2  evenly divides  2(p − 1) − 1 .



It is conjectured that there are infinitely many Wieferich primes, but as of March 2021,only two have been identified.



Task 
 Write a routine (function procedure, whatever) to find Wieferich primes.
 Use that routine to identify and display all of the Wieferich primes less than 5000.


See also
 OEIS A001220 - Wieferich primes

",Python,"#!/usr/bin/python
 
def isPrime(n):
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False        
    return True
 
def isWeiferich(p):
    if not isPrime(p):
        return False
    q = 1
    p2 = p ** 2
    while p > 1:
        q = (2 * q) % p2
        p -= 1
    if q == 1:
        return True
    else:
        return False
 
 
if __name__ == '__main__':
    print(""Wieferich primes less than 5000: "")
    for i in range(2, 5001):
        if isWeiferich(i):
            print(i)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Empty_program,Empty program,"Task

Create the simplest possible program that is still considered ""correct.""



",Python,"def main():
    a = 10
    b = 20
    c = a + b
    return 0",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Inverted_syntax,Inverted syntax,"Inverted syntax with conditional expressions

In traditional syntax conditional expressions are usually shown before the action within a statement or code block:

 IF raining=true THEN needumbrella=true 
In inverted syntax, the action is listed before the conditional expression in the statement or code block:

 needumbrella=true IF raining=true 
Inverted syntax with assignment

In traditional syntax, assignments are usually expressed with the variable appearing before the expression:

 a = 6
In inverted syntax, the expression appears before the variable:

 6 = a
Task

The task is to demonstrate support for inverted syntax forms within the language by showing both the traditional and inverted forms.
",Python,x = truevalue if condition else falsevalue,Human_written,Python_from_C
http://rosettacode.org/wiki/Grayscale_image,Grayscale image,"Many image processing algorithms are defined for grayscale (or else monochromatic) images.



Task

Extend the data storage type defined on this page to support grayscale images.

Define two operations, one to convert a color image to a grayscale image and one for the backward conversion.

To get luminance of a color use the formula recommended by CIE:

 L  =  0.2126 × R   +   0.7152 × G   +   0.0722 × B 

When using floating-point arithmetic make sure that rounding errors would not cause run-time problems or else distorted results when calculated luminance is stored as an unsigned integer.



",Python,"class RGBColour(object):
    def __init__(self, red, green, blue):
        self.red = red
        self.green = green
        self.blue = blue

    def to_grayscale(self):
        luminosity = int(0.2126*self.red + 0.7152*self.green + 0.0722*self.blue)
        return RGBColour(luminosity, luminosity, luminosity)

class Pixmap(object):
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.pixels = [[RGBColour(0,0,0) for y in range(height)] for x in range(width)]

    def __getitem__(self, key):
        x, y = key
        return self.pixels[x][y]

    def __setitem__(self, key, value):
        x, y = key
        self.pixels[x][y] = value

    def to_grayscale(self):
        gray = Pixmap(self.width, self.height)
        for x in range(self.width):
            for y in range(self.height):
                gray[x,y] = self[x,y].to_grayscale()
        return gray",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Polynomial_regression,Polynomial regression,"Find an approximating polynomial of known degree for a given data.

Example:
For input data:

x = {0,  1,  2,  3,  4,  5,  6,   7,   8,   9,   10};
y = {1,  6,  17, 34, 57, 86, 121, 162, 209, 262, 321};

The approximating polynomial is:

3 x2 + 2 x + 1

Here, the polynomial's coefficients are (3, 2, 1).

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.
",Python,"import numpy as np

def regress(x, y, degree):
    x_data = np.array([x**i for i in range(degree+1)]).T
    mx = np.matrix(x_data)
    my = np.matrix(y).T
    return np.array(np.dot(np.dot(mx.T, mx).I, np.dot(mx.T, my)).T)[0]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Sierpinski_square_curve,Sierpinski square curve,"

Task
Produce a graphical or ASCII-art representation of a Sierpinski square curve of at least order 3.
",Python,"import math
import numpy as np
import matplotlib.pyplot as plt

two_pi = 2 * math.pi

width = 770
height = 770

cx, cy = 10, height/2+5
h = 6
theta = 0

def main():
    global cx, cy, h, theta
    axiom = ""F+XF+F+XF""
    rules = {""X"": ""XF-F+F-XF+F+XF-F+F-X""}
    angle = math.pi / 2
    result = iterate(axiom, rules, 5)
    operations = {
        ""F"": lambda: draw_line(cx, cy, h, theta),
        ""+"": lambda: turn_right(angle),
        ""-"": lambda: turn_left(angle),
    }
    process(result, operations)
    # needed to close the square at the extreme left
    turn_right(angle)
    draw_line(cx, cy, h, theta)
    plt.savefig(""sierpinski_square_curve.png"")

def iterate(axiom, rules, n):
    result = axiom
    for _ in range(n):
        result = """".join(rules.get(c, c) for c in result)
    return result

def process(result, operations):
    for c in result:
        if c in operations:
            operations[c]()

def draw_line(cx, cy, h, theta):
    global cx, cy
    new_x, new_y = cx+h*math.sin(theta), cy-h*math.cos(theta)
    plt.plot([cx, new_x], [cy, new_y], color=""yellow"", linewidth=2)
    cx, cy = new_x, new_y

def turn_right(angle):
    global theta
    theta = math.fmod(theta+angle, two_pi)

def turn_left(angle):
    global theta
    theta = math.fmod(theta-angle, two_pi)

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Test_a_function,Test a function,"

Task

Using a well-known testing-specific library/module/suite for your language, write some tests for your language's entry in Palindrome.

If your language does not have a testing specific library well known to the language's community then state this or omit the language.


",Python,"def is_palindrome(s):
    '''
        >>> is_palindrome('')
        True
        >>> is_palindrome('a')
        True
        >>> is_palindrome('aa')
        True
        >>> is_palindrome('baa')
        False
        >>> is_palindrome('baab')
        True
        >>> is_palindrome('ba_ab')
        True
        >>> is_palindrome('ba_ ab')
        False
        >>> is_palindrome('ba _ ab')
        True
        >>> is_palindrome('ab'*2)
        False
        >>> x = 'ab' *2**15
        >>> len(x)
        65536
        >>> xreversed = x[::-1]
        >>> is_palindrome(x+xreversed)
        True
        >>> len(x+xreversed)
        131072
        >>> 
    '''
    return s == s[::-1]
 
def _test():
    import doctest
    doctest.testmod()
    #doctest.testmod(verbose=True)
 
if __name__ == ""__main__"":
    _test()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Monads/Writer_monad,Monads/Writer monad,"The Writer monad is a programming design pattern which makes it possible to compose functions which return their result values paired with a log string. The final result of a composed function yields both a value, and a concatenation of the logs from each component function application.

Demonstrate in your programming language the following:

 Construct a Writer monad by writing the 'bind' function and the 'unit' (sometimes known as 'return') function for that monad (or just use what the language already provides)
 Write three simple functions: root, addOne, and half
 Derive Writer monad versions of each of these functions
 Apply a composition of the Writer versions of root, addOne, and half to the integer 5, deriving both a value for the Golden Ratio φ, and a concatenated log of the function applications (starting with the initial value, and followed by the application of root, etc.)",Python,"""""""A Writer Monad. Requires Python >= 3.7 for type hints.""""""
from __future__ import annotations
 
import functools
import math
import os
 
from typing import Any
from typing import Callable
from typing import Generic
from typing import List
from typing import TypeVar
from typing import Union
 
 
T = TypeVar(""T"")
 
 
class Writer(Generic[T]):
    def __init__(self, value: Union[T, Writer[T]], *msgs: str):
        if isinstance(value, Writer):
            self.value: T = value.value
            self.msgs: List[str] = value.msgs + list(msgs)
        else:
            self.value = value
            self.msgs = list(f""{msg}: {self.value}"" for msg in msgs)
 
    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        writer = func(self.value)
        return Writer(writer, *self.msgs)
 
    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:
        return self.bind(func)
 
    def __str__(self):
        return f""{self.value}\n{os.linesep.join(reversed(self.msgs))}""
 
    def __repr__(self):
        return f""Writer({self.value}, \""{', '.join(reversed(self.msgs))}\"")""
 
 
def lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:
    """"""Return a writer monad version of the simple function `func`.""""""
 
    @functools.wraps(func)
    def wrapped(value):
        return Writer(func(value), msg)
 
    return wrapped
 
 
if __name__ == ""__main__"":
    square_root = lift(math.sqrt, ""square root"")
    add_one = lift(lambda x: x + 1, ""add one"")
    half = lift(lambda x: x / 2, ""div two"")
 
    print(Writer(5, ""initial"") >> square_root >> add_one >> half)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Object_serialization,Object serialization,"Create a set of data types based upon inheritance. Each data type or class should have a print command that displays the contents of an instance of that class to standard output. Create instances of each class in your inheritance hierarchy and display them to standard output. Write each of the objects to a file named objects.dat in binary form using serialization or marshalling. Read the file objects.dat and print the contents of each serialized object.
",Python,"# Object Serialization in Python
# serialization in python is accomplished via the Pickle module.
# Alternatively, one can use the cPickle module if speed is the key,
# everything else in this example remains the same.
 
import pickle
 
class Entity:
	def __init__(self):
		self.name = ""Entity""
	def printName(self):
		print self.name
 
class Person(Entity): #OldMan inherits from Entity
	def __init__(self): #override constructor
		self.name = ""Cletus"" 
 
instance1 = Person()
instance1.printName()
 
instance2 = Entity()
instance2.printName()
 
target = file(""objects.dat"", ""w"") # open file
 
#  Serialize
pickle.dump((instance1, instance2), target) # serialize `instance1` and `instance2`to `target`
target.close() # flush file stream
print ""Serialized...""
 
# Unserialize
target = file(""objects.dat"") # load again
i1, i2 = pickle.load(target)
print ""Unserialized...""
 
i1.printName()
i2.printName()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/String_prepend,String prepend,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Create a string variable equal to any text value.

Prepend the string variable with another string literal.

If your language supports any idiomatic ways to do this without referring to the variable twice in one expression, include such solutions.



To illustrate the operation, show the content of the variable.



",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
s = ""12345678""
s = ""0"" + s  # by concatenation
print(s)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Dice_game_probabilities,Dice game probabilities,"Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.

They roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?

Later the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?

This task was adapted from the Project Euler Problem n.205:
https://projecteuler.net/problem=205
",Python,"from itertools import product
 
def gen_dict(n_faces, n_dice):
    counts = [0] * ((n_faces + 1) * n_dice)
    for t in product(range(1, n_faces + 1), repeat=n_dice):
        counts[sum(t)] += 1
    return counts, n_faces ** n_dice
 
def beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):
    c1, p1 = gen_dict(n_sides1, n_dice1)
    c2, p2 = gen_dict(n_sides2, n_dice2)
    p12 = float(p1 * p2)
 
    return sum(p[1] * q[1] / p12
               for p, q in product(enumerate(c1), enumerate(c2))
               if p[0] > q[0])
 
print beating_probability(4, 9, 6, 6)
print beating_probability(10, 5, 7, 6)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Execute_a_Markov_algorithm,Execute a Markov algorithm,"Execute a Markov algorithm

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Create an interpreter for a Markov Algorithm.

Rules have the syntax:

<ruleset> ::= ((<comment> | <rule>) <newline>+)*
<comment> ::= # {<any character>}
<rule> ::= <pattern> <whitespace> -> <whitespace> [.] <replacement>
<whitespace> ::= (<tab> | <space>) [<whitespace>]

There is one rule per line.

If there is a   .   (period)   present before the   <replacement>,   then this is a terminating rule in which case the interpreter must halt execution.

A ruleset consists of a sequence of rules, with optional comments.


 Rulesets 

Use the following tests on entries:



Ruleset 1

# This rules file is extracted from Wikipedia:
# http://en.wikipedia.org/wiki/Markov_Algorithm
A -> apple
B -> bag
S -> shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

  I bought a B of As from T S. 
Should generate the output:

  I bought a bag of apples from my brother. 


Ruleset 2

A test of the terminating rule

# Slightly modified from the rules on Wikipedia
A -> apple
B -> bag
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule
Sample text of:

 I bought a B of As from T S.
Should generate:

 I bought a bag of apples from T shop.


Ruleset 3

This tests for correct substitution order and may trap simple regexp based replacement routines if special regexp characters are not escaped.

# BNF Syntax testing rules
A -> apple
WWWW -> with
Bgage -> ->.*
B -> bag
->.* -> money
W -> WW
S -> .shop
T -> the
the shop -> my brother
a never used -> .terminating rule

Sample text of:

 I bought a B of As W my Bgage from T S.
Should generate:

 I bought a bag of apples with my money from T shop.


Ruleset 4

This tests for correct order of scanning of rules, and may trap replacement routines that scan in the wrong order.   It implements a general unary multiplication engine.   (Note that the input expression must be placed within underscores in this implementation.)

### Unary Multiplication Engine, for testing Markov Algorithm implementations
### By Donal Fellows.
# Unary addition engine
_+1 -> _1+
1+1 -> 11+
# Pass for converting from the splitting of multiplication into ordinary
# addition
1! -> !1
,! -> !+
_! -> _
# Unary multiplication by duplicating left side, right side times
1*1 -> x,@y
1x -> xX
X, -> 1,1
X1 -> 1X
_x -> _X
,x -> ,X
y1 -> 1y
y_ -> _
# Next phase of applying
1@1 -> x,@y
1@_ -> @_
,@_ -> !_
++ -> +
# Termination cleanup for addition
_1 -> 1
1+_ -> 1
_+_ -> 

Sample text of:

  _1111*11111_ 
should generate the output:

  11111111111111111111 


Ruleset 5

A simple Turing machine,
implementing a three-state busy beaver.

The tape consists of 0s and 1s,   the states are A, B, C and H (for Halt), and the head position is indicated by writing the state letter before the character where the head is.
All parts of the initial tape the machine operates on have to be given in the input.

Besides demonstrating that the Markov algorithm is Turing-complete, it also made me catch a bug in the C++ implementation which wasn't caught by the first four rulesets.

# Turing machine: three-state busy beaver
#
# state A, symbol 0 => write 1, move right, new state B
A0 -> 1B
# state A, symbol 1 => write 1, move left, new state C
0A1 -> C01
1A1 -> C11
# state B, symbol 0 => write 1, move left, new state A
0B0 -> A01
1B0 -> A11
# state B, symbol 1 => write 1, move right, new state B
B1 -> 1B
# state C, symbol 0 => write 1, move left, new state B
0C0 -> B01
1C0 -> B11
# state C, symbol 1 => write 1, move left, halt
0C1 -> H01
1C1 -> H11

This ruleset should turn

  000000A000000 
into

  00011H1111000 

",Python,"import re
import os
 
def read_tests(path):
    with open(path, 'r') as f:
        return f.read().splitlines()
 
def read_rules(path):
    with open(path, 'r') as f:
        return [line.splitlines() for line in f.read().split('\n\n')]
 
def main():
    rules = read_rules('markov_rules.txt')
    tests = read_tests('markov_tests.txt')
 
    pattern = re.compile(r'^([^#]*?)\s+->\s+(\.?)(.*)')
 
    for i in range(len(tests)):
        orig_test = tests[i]
 
        captures = []
        for rule in rules[i]:
            m = pattern.match(rule)
            if m:
                captures.append(m.groups())
 
        test = orig_test
        copy = test
        for j in range(len(captures)):
            c = captures[j]
            test = test.replace(c[0], c[2])
            if c[1] == '.':
                break
            if test!= copy:
                j = -1
                copy = test
 
        print(orig_test)
        print(test)
        print()
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Video_display_modes,Video display modes,"The task is to demonstrate how to switch video display modes within the language. A brief description of the supported video modes would be useful.
",Python,"# version 1.1.51
 
import subprocess
import time
 
def runSystemCommand(command):
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
    (out, err) = proc.communicate()
    print(out)
    proc.wait()
    print()
 
def main():
    # query supported display modes  
    runSystemCommand(""xrandr -q"")
    time.sleep(3)
 
    # change display mode to 1024x768 say (no text output)
    runSystemCommand(""xrandr -s 1024x768"")
    time.sleep(3)
 
    # change it back again to 1366x768 (or whatever is optimal for your system)
    runSystemCommand(""xrandr -s 1366x768"")
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Thiele%27s_interpolation_formula,Thiele's interpolation formula,"

 This page uses content from Wikipedia. The original article was at Thiele's interpolation formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Thiele's interpolation formula is an interpolation formula for a function f(•) of a single variable.   It is expressed as a continued fraction:

 



f
(
x
)
=
f
(

x

1


)
+








x
−

x

1












ρ

1


(

x

1


,

x

2


)
+








x
−

x

2












ρ

2


(

x

1


,

x

2


,

x

3


)
−
f
(

x

1


)
+








x
−

x

3












ρ

3


(

x

1


,

x

2


,

x

3


,

x

4


)
−

ρ

1


(

x

1


,

x

2


)
+
⋯

















{\displaystyle f(x)=f(x_{1})+{\cfrac {x-x_{1}}{\rho _{1}(x_{1},x_{2})+{\cfrac {x-x_{2}}{\rho _{2}(x_{1},x_{2},x_{3})-f(x_{1})+{\cfrac {x-x_{3}}{\rho _{3}(x_{1},x_{2},x_{3},x_{4})-\rho _{1}(x_{1},x_{2})+\cdots }}}}}}}






ρ


{\displaystyle \rho }

   represents the   reciprocal difference,   demonstrated here for reference:

 




ρ

1


(

x

0


,

x

1


)
=




x

0


−

x

1




f
(

x

0


)
−
f
(

x

1


)





{\displaystyle \rho _{1}(x_{0},x_{1})={\frac {x_{0}-x_{1}}{f(x_{0})-f(x_{1})}}}


 




ρ

2


(

x

0


,

x

1


,

x

2


)
=




x

0


−

x

2





ρ

1


(

x

0


,

x

1


)
−

ρ

1


(

x

1


,

x

2


)



+
f
(

x

1


)


{\displaystyle \rho _{2}(x_{0},x_{1},x_{2})={\frac {x_{0}-x_{2}}{\rho _{1}(x_{0},x_{1})-\rho _{1}(x_{1},x_{2})}}+f(x_{1})}


 




ρ

n


(

x

0


,

x

1


,
…
,

x

n


)
=




x

0


−

x

n





ρ

n
−
1


(

x

0


,

x

1


,
…
,

x

n
−
1


)
−

ρ

n
−
1


(

x

1


,

x

2


,
…
,

x

n


)



+

ρ

n
−
2


(

x

1


,
…
,

x

n
−
1


)


{\displaystyle \rho _{n}(x_{0},x_{1},\ldots ,x_{n})={\frac {x_{0}-x_{n}}{\rho _{n-1}(x_{0},x_{1},\ldots ,x_{n-1})-\rho _{n-1}(x_{1},x_{2},\ldots ,x_{n})}}+\rho _{n-2}(x_{1},\ldots ,x_{n-1})}


Demonstrate Thiele's interpolation function by:

 Building a   32   row trig table of values   for   



x


{\displaystyle x}

   from   0   by   0.05   to   1.55   of the trig functions:
   sin
   cos
   tan
 Using columns from this table define an inverse - using Thiele's interpolation - for each trig function;
 Finally: demonstrate the following well known trigonometric identities:
    6 × sin-1 ½ = 



π


{\displaystyle \pi }


    3 × cos-1 ½ = 



π


{\displaystyle \pi }


    4 × tan-1 1 = 



π


{\displaystyle \pi }

 

",Python,"N = 32
STEP = 0.05
 
def main():
    x = [i * STEP for i in range(N)]
    sin = [math.sin(i) for i in x]
    cos = [math.cos(i) for i in x]
    tan = [math.tan(i) for i in x]
 
    print(6. * thiele(sin, x, 0.5))
    print(3. * thiele(cos, x, 0.5))
    print(4. * thiele(tan, x, 1.))
 
def thiele(x, y, xin):
    p = [[0.0 for _ in range(N)] for _ in range(N)]
 
    for i in range(N):
        p[i][0] = y[i]
 
    for i in range(N - 1):
        p[i][1] = (x[i] - x[i + 1]) / (p[i][0] - p[i + 1][0])
 
    for i in range(2, N):
        for j in range(N - i):
            p[j][i] = (x[j] - x[j + i]) / (p[j][i - 1] - p[j + 1][i - 1]) + p[j + 1][i - 2]
 
    a = 0.0
    for i in range(N - 2, 1, -1):
        a = (xin - x[i - 1]) / (p[0][i] - p[0][i - 2] + a)
 
    return y[0] + (xin - x[0]) / (p[0][1] + a)
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Python,"import sys
 
def catcmp(a, b):
	ab = str(a) + str(b)
	ba = str(b) + str(a)
	return cmp(ba, ab)
 
def maxcat(a):
	a.sort(catcmp)
	for i in a:
		sys.stdout.write(str(i))
	print
 
x = [1, 34, 3, 98, 9, 76, 45, 4]
y = [54, 546, 548, 60]
 
maxcat(x)
maxcat(y)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Playing_cards,Playing cards,"Task

Create a data structure and the associated methods to define and manipulate a deck of   playing cards.

The deck should contain 52 unique cards.

The methods must include the ability to:

   make a new deck
   shuffle (randomize) the deck
   deal from the deck
   print the current contents of a deck 
Each card must have a pip value and a suit value which constitute the unique value of the card.

Related tasks:

 Card shuffles
 Deal cards_for_FreeCell
 War Card_Game
 Poker hand_analyser
 Go Fish

",Python,"import random
 
class Card(object):
    suits = (""Clubs"",""Hearts"",""Spades"",""Diamonds"")
    pips = (""2"",""3"",""4"",""5"",""6"",""7"",""8"",""9"",""10"",""Jack"",""Queen"",""King"",""Ace"")
 
    def __init__(self, pip,suit):
        self.pip=pip
        self.suit=suit
 
    def __str__(self):
        return ""%s %s""%(self.pip,self.suit)
 
class Deck(object):
    def __init__(self):
        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]
 
    def __str__(self):
        return ""[%s]""%"", "".join( (str(card) for card in self.deck))
 
    def shuffle(self):
        random.shuffle(self.deck)
 
    def deal(self):
        self.shuffle()  # Can't tell what is next from self.deck
        return self.deck.pop(0)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Dice_game_probabilities,Dice game probabilities,"Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.

They roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?

Later the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?

This task was adapted from the Project Euler Problem n.205:
https://projecteuler.net/problem=205
",Python,"from __future__ import division
from __future__ import print_function
 
def ipow(x, y):
    result = 1
    for i in range(1, y + 1):
        result *= x
    return result
 
def min(x, y):
    return x if x < y else y
 
def throw_die(n_sides, n_dice, s, counts):
    if n_dice == 0:
        counts[s] += 1
        return
 
    for i in range(1, n_sides + 1):
        throw_die(n_sides, n_dice - 1, s + i, counts)
 
def beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):
    len1 = (n_sides1 + 1) * n_dice1
    C1 = [0] * len1
    throw_die(n_sides1, n_dice1, 0, C1)
 
    len2 = (n_sides2 + 1) * n_dice2
    C2 = [0] * len2
    throw_die(n_sides2, n_dice2, 0, C2)
 
    p12 = ipow(n_sides1, n_dice1) * ipow(n_sides2, n_dice2)
 
    tot = 0
    for i in range(len1):
        for j in range(min(i, len2)):
            tot += C1[i] * C2[j] / p12
    return tot
 
if __name__ == '__main__':
    print(beating_probability(4, 9, 6, 6))
    print(beating_probability(10, 5, 7, 6))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",Python,"from string import letters
from random import choice, random
 
target  = list(""METHINKS IT IS LIKE A WEASEL"")
charset = letters + ' '
parent  = [choice(charset) for _ in range(len(target))]
minmutaterate  = .09
C = range(100)
 
perfectfitness = float(len(target))
 
def fitness(trial):
    'Sum of matching chars by position'
    return sum(t==h for t,h in zip(trial, target))
 
def mutaterate():
    'Less mutation the closer the fit of the parent'
    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))
 
def mutate(parent, rate):
    return [(ch if random() <= rate else choice(charset)) for ch in parent]
 
def que():
    '(from the favourite saying of Manuel in Fawlty Towers)'
    print (""#%-4i, fitness: %4.1f%%, '%s'"" %
           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))
 
def mate(a, b):
    place = 0
    if choice(xrange(10)) < 7:
        place = choice(xrange(len(target)))
    else:
        return a, b
 
    return a, b, a[:place] + b[place:], b[:place] + a[place:]
 
iterations = 0
center = len(C)/2
while parent != target:
    rate = mutaterate()
    iterations += 1
    if iterations % 100 == 0: que()
    copies = [ mutate(parent, rate) for _ in C ]  + [parent]
    parent1 = max(copies[:center], key=fitness)
    parent2 = max(copies[center:], key=fitness)
    parent = max(mate(parent1, parent2), key=fitness)
que()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def prime(a):
    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Caesar_cipher,Caesar cipher,"

Task

Implement a Caesar cipher, both encoding and decoding. 

The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).

So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"".

This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigenère cipher with a key of length 1. 

Also, Rot-13 is identical to Caesar cipher with key 13.



Related tasks

 Rot-13
 Substitution Cipher
 Vigenère Cipher/Cryptanalysis

",Python,"class String:
    ALFABET = [chr(i) for i in range(65, 91)]
 
    def caesar_cipher(self, num):
        return self.translate(self.maketrans(self.ALFABET, self.ALFABET[num:]+self.ALFABET[:num]))
 
#demo:
encypted  = ""THEYBROKEOURCIPHEREVERYONECANREADTHIS"".caesar_cipher(3)
decrypted = encypted.caesar_cipher(-3)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Boolean_values,Boolean values,"Task

Show how to represent the boolean states ""true"" and ""false"" in a language.

If other objects represent ""true"" or ""false"" in conditionals, note it.



Related tasks

   Logical operations

",Python,">>> import json
>>> json.loads('{""foo"":123}')
{'foo': 123}
>>> json.loads('{""foo"":123}') + json.loads('{""bar"":456}')
{'foo': 123, 'bar': 456}",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Random_number_generator_(included),Random number generator (included),"The task is to:

 State the type of random number generator algorithm used in a language's built-in random number generator. If the language or its immediate libraries don't provide a random number generator, skip this task.
 If possible, give a link to a wider explanation of the algorithm used.
Note: the task is not to create an RNG, but to report on the languages in-built RNG that would be the most likely RNG used.

The main types of pseudo-random number generator (PRNG) that are in use are the Linear Congruential Generator (LCG), and the Generalized Feedback Shift Register (GFSR), (of which the Mersenne twister generator is a subclass). The last main type is where the output of one of the previous ones (typically a Mersenne twister) is fed through a cryptographic hash function to maximize unpredictability of individual bits.

Note that neither LCGs nor GFSRs should be used for the most demanding applications (cryptography) without additional steps.
",Python,"import random
random.seed(3)
random.randint(1,6)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously,Loop over multiple arrays simultaneously,"Task

Loop over multiple arrays   (or lists or tuples or whatever they're called in
your language)   and display the    i th    element of each.

Use your language's   ""for each""   loop if it has one, otherwise iterate
through the collection in order with some other loop.



For this example, loop over the arrays:

    (a,b,c)
    (A,B,C) 
    (1,2,3) 

to produce the output:

    aA1
    bB2
    cC3



If possible, also describe what happens when the arrays are of different lengths.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,">>> print ( '\n'.join(''.join(x) for x in 
zip('abc', 'ABC', '123')) )
aA1
bB2
cC3
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort,Sorting algorithms/Bead sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of positive integers using the Bead Sort Algorithm.

A   bead sort   is also known as a   gravity sort.



Algorithm has   O(S),   where   S   is the sum of the integers in the input set:   Each bead is moved individually.

This is the case when bead sort is implemented without a mechanism to assist in finding empty spaces below the beads, such as in software implementations.



",Python,"class Array(object):
    def beadsort(self):
        return [len(column) for column in self.columns()]

    def columns(self):
        y = len(self)
        x = max(len(row) for row in self)
        return [[self[column][row] for column in range(y) if row < len(self[column])] for row in range(x)]

# Demonstration code:
print([5,3,1,7,4,1,1].beadsort())",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Textonyms,Textonyms,"When entering text on a phone's digital pad it is possible that a particular combination of digits corresponds to more than one word. Such are called textonyms.

Assuming the digit keys are mapped to letters as follows:

    2 -> ABC
    3 -> DEF
    4 -> GHI
    5 -> JKL
    6 -> MNO
    7 -> PQRS
    8 -> TUV
    9 -> WXYZ  



Task

Write a program that finds textonyms in a list of words such as  
Textonyms/wordlist   or  
unixdict.txt.

The task should produce a report:

There are #{0} words in #{1} which can be represented by the digit key mapping.
They require #{2} digit combinations to represent them.
#{3} digit combinations represent Textonyms.

Where:

#{0} is the number of words in the list which can be represented by the digit key mapping.
#{1} is the URL of the wordlist being used.
#{2} is the number of digit combinations required to represent the words in #{0}.
#{3} is the number of #{2} which represent more than one word.

At your discretion show a couple of examples of your solution displaying Textonyms.

E.G.:

 2748424767 -> ""Briticisms"", ""criticisms""



Extra credit

Use a word list and keypad mapping other than English.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from collections import defaultdict
import urllib.request
 
CH2NUM = {ch: str(num) for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(), 2) for ch in chars}
URL = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'
 
 
def getwords(url):
 return urllib.request.urlopen(url).read().decode(""utf-8"").lower().split()
 
def mapnum2words(words):
    number2words = defaultdict(list)
    reject = 0
    for word in words:
        try:
            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)
        except KeyError:
            # Reject words with non a-z e.g. '10th'
            reject += 1
    return dict(number2words), reject
 
def interactiveconversions():
    global inp, ch, num
    while True:
        inp = input(""\nType a number or a word to get the translation and textonyms: "").strip().lower()
        if inp:
            if all(ch in '23456789' for ch in inp):
                if inp in num2words:
                    print(""  Number {0} has the following textonyms in the dictionary: {1}"".format(inp, ', '.join(
                        num2words[inp])))
                else:
                    print(""  Number {0} has no textonyms in the dictionary."".format(inp))
            elif all(ch in CH2NUM for ch in inp):
                num = ''.join(CH2NUM[ch] for ch in inp)
                print(""  Word {0} is{1} in the dictionary and is number {2} with textonyms: {3}"".format(
                    inp, ('' if inp in wordset else ""n't""), num, ', '.join(num2words[num])))
            else:
                print(""  I don't understand %r"" % inp)
        else:
            print(""Thank you"")
            break
 
 
if __name__ == '__main__':
    words = getwords(URL)
    print(""Read %i words from %r"" % (len(words), URL))
    wordset = set(words)
    num2words, reject = mapnum2words(words)
    morethan1word = sum(1 for w in num2words if len(num2words[w]) > 1)
    maxwordpernum = max(len(values) for values in num2words.values())
    print(""""""
There are {0} words in {1} which can be represented by the Textonyms mapping.
They require {2} digit combinations to represent them.
{3} digit combinations represent Textonyms.\
"""""".format(len(words) - reject, URL, len(num2words), morethan1word))
 
    print(""\nThe numbers mapping to the most words map to %i words each:"" % maxwordpernum)
    maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)
    for num, wrds in maxwpn:
        print(""  %s maps to: %s"" % (num, ', '.join(wrds)))
 
    interactiveconversions()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Abundant_odd_numbers,Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",Python,"from itertools import count
from math import sqrt
 
def abundant_numbers(start=3):
    for n in count(start, 2):
        if sum(divisors(n)) > n:
            yield n
 
def divisors(n):
    for i in range(3, int(sqrt(n)) + 1, 2):
        if n % i == 0:
            yield i
            yield n // i
    yield 1
 
print(""First 25 abundant odd numbers:"")
for x in list(zip(abundant_numbers(), range(25)))[1:]:
    print(f""{x[0]:,} with sum {sum(divisors(x[0])):,}"")
 
print(f""\nThe 1000th abundant odd number: {list(zip(abundant_numbers(), range(1000)))[-1][0]:,}"")
 
print(f""\nFirst abundant odd number > 1b: {next(abundant_numbers(1_000_000_001)):,}"")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Arithmetic-geometric_mean,Arithmetic-geometric mean,"

 This page uses content from Wikipedia. The original article was at Arithmetic-geometric mean. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Write a function to compute the arithmetic-geometric mean of two numbers.



The arithmetic-geometric mean of two numbers can be (usefully) denoted as 




a
g
m

(
a
,
g
)


{\displaystyle \mathrm {agm} (a,g)}

, and is equal to the limit of the sequence:

 




a

0


=
a
;


g

0


=
g


{\displaystyle a_{0}=a;\qquad g_{0}=g}


 




a

n
+
1


=



1
2



(

a

n


+

g

n


)
;


g

n
+
1


=



a

n



g

n




.


{\displaystyle a_{n+1}={\tfrac {1}{2}}(a_{n}+g_{n});\quad g_{n+1}={\sqrt {a_{n}g_{n}}}.}


Since the limit of 




a

n


−

g

n




{\displaystyle a_{n}-g_{n}}

 tends (rapidly) to zero with iterations, this is an efficient method.

Demonstrate the function by calculating:






a
g
m

(
1
,
1

/



2


)


{\displaystyle \mathrm {agm} (1,1/{\sqrt {2}})}




Also see

   mathworld.wolfram.com/Arithmetic-Geometric Mean

",Python,"from math import sqrt
 
def agm(a0, g0, tolerance=1e-10):
    """"""
    Calculating the arithmetic-geometric mean of two numbers a0, g0.
 
    tolerance     the tolerance for the converged 
                  value of the arithmetic-geometric mean
                  (default value = 1e-10)
    """"""
    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)
    while abs(an - gn) > tolerance:
        an, gn = (an + gn) / 2.0, sqrt(an * gn)
    return an
 
print agm(1, 1 / sqrt(2))",Human_written,Python_from_C
http://rosettacode.org/wiki/Integer_sequence,Integer sequence,"Task

Create a program that, when run, would display all integers from   1   to      ∞      (or any relevant implementation limit),   in sequence   (i.e.   1, 2, 3, 4, etc)   if given enough time.



An example may not be able to reach arbitrarily-large numbers based on implementations limits.   For example, if integers are represented as a 32-bit unsigned value with 0 as the smallest representable value, the largest representable value would be 4,294,967,295.   Some languages support arbitrarily-large numbers as a built-in feature, while others make use of a module or library.

If appropriate, provide an example which reflect the language implementation's common built-in limits as well as an example which supports arbitrarily large numbers, and describe the nature of such limitations—or lack thereof.



",Python,"i=1
while i:
    print(i)
    i += 1",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Simulate_input/Mouse,Simulate input/Mouse,,Python,"p = component.getLocation()
pyautogui.moveTo(p.getX(), p.getY())
pyautogui.click()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/N-smooth_numbers,N-smooth numbers,"n-smooth   numbers are positive integers which have no prime factors  >  n.

The   n   (when using it in the expression)   n-smooth   is always prime,

there are   no   9-smooth numbers.

1   (unity)   is always included in n-smooth numbers.




2-smooth   numbers are non-negative powers of two.

5-smooth   numbers are also called   Hamming numbers.

7-smooth   numbers are also called    humble   numbers.



A way to express   11-smooth   numbers is:

  11-smooth  =  2i × 3j × 5k × 7m × 11p

           where     i, j, k, m, p ≥ 0  



Task

   calculate and show the first   25   n-smooth numbers   for   n=2   ───►   n=29
   calculate and show   three numbers starting with   3,000   n-smooth numbers   for   n=3   ───►   n=29
   calculate and show twenty numbers starting with  30,000   n-smooth numbers   for   n=503   ───►   n=521   (optional)


All ranges   (for   n)   are to be inclusive, and only prime numbers are to be used.

The (optional) n-smooth numbers for the third range are:   503,   509,   and   521.

Show all n-smooth numbers for any particular   n   in a horizontal list.

Show all output here on this page.



Related tasks

   Hamming numbers
   humble numbers


References

   Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
   Wikipedia entry:   Smooth number
   OEIS entry:   A000079    2-smooth numbers or non-negative powers of two
   OEIS entry:   A003586    3-smooth numbers
   OEIS entry:   A051037    5-smooth numbers or Hamming numbers
   OEIS entry:   A002473    7-smooth numbers or humble numbers
   OEIS entry:   A051038   11-smooth numbers
   OEIS entry:   A080197   13-smooth numbers
   OEIS entry:   A080681   17-smooth numbers
   OEIS entry:   A080682   19-smooth numbers
   OEIS entry:   A080683   23-smooth numbers

",Python,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
 
def isPrime(n):
    if n < 2:
        return False
 
    for i in primes:
        if n == i:
            return True
        if n % i == 0:
            return False
        if i * i > n:
            return True
    print ""Oops,"", n, "" is too large""
 
def init():
    s = 24
    while s < 600:
        if isPrime(s - 1) and s - 1 > primes[-1]:
            primes.append(s - 1)
        if isPrime(s + 1) and s + 1 > primes[-1]:
            primes.append(s + 1)
        s += 6
 
def nsmooth(n, size):
    if n < 2 or n > 521:
        raise Exception(""n"")
    if size < 1:
        raise Exception(""n"")
 
    bn = n
    ok = False
    for prime in primes:
        if bn == prime:
            ok = True
            break
    if not ok:
        raise Exception(""must be a prime number: n"")
 
    ns = [0] * size
    ns[0] = 1
 
    next = []
    for prime in primes:
        if prime > bn:
            break
        next.append(prime)
 
    indicies = [0] * len(next)
    for m in xrange(1, size):
        ns[m] = min(next)
        for i in xrange(0, len(indicies)):
            if ns[m] == next[i]:
                indicies[i] += 1
                next[i] = primes[i] * ns[indicies[i]]
 
    return ns
 
def main():
    init()
 
    for p in primes:
        if p >= 30:
            break
        print ""The first"", p, ""-smooth numbers are:""
        print nsmooth(p, 25)
        print
 
    for p in primes[1:]:
        if p >= 30:
            break
        print ""The 3000 to 3202"", p, ""-smooth numbers are:""
        print nsmooth(p, 3002)[2999:]
        print
 
    for p in [503, 509, 521]:
        print ""The 30000 to 3019"", p, ""-smooth numbers are:""
        print nsmooth(p, 30019)[29999:]
        print
 
main()",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Loops/Nested,Loops/Nested,"Show a nested loop which searches a two-dimensional array filled with random numbers uniformly distributed over 



[
1
,
…
,
20
]


{\displaystyle [1,\ldots ,20]}

.

The loops iterate rows and columns of the array printing the elements until the value 



20


{\displaystyle 20}

 is met.

Specifically, this task also shows how to break out of nested loops.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"from random import randint
 
def do_scan(mat):
    for row in mat:
        for item in row:
            print item,
            if item == 20:
                print
                return
        print
    print
 
mat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]
do_scan(mat)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Chinese_zodiac,Chinese zodiac,"Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the ""celestial stems"") and one of length 12 (the ""terrestrial branches""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known ""Chinese zodiac"", assigning each year to a given animal. For example, Tuesday, February 1, 2022 CE (in the common Gregorian calendar) will begin the lunisolar Year of the Tiger.

The celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.

Thus, 2022 is also the yang year of Water. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the specifically-male English animal name and the female aspect denoted by yin.

Task
 Create a subroutine or program that will return or output the animal, yin/yang association, and element for the lunisolar year that begins in a given CE year.
You may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).

Requisite information

 The animal cycle runs in this order: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.
 The element cycle runs in this order: Wood, Fire, Earth, Metal, Water.
 The yang year precedes the yin year within each element.
 The current 60-year cycle began in 1984 CE; the first cycle of the Common Era began in 4 CE.
Thus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2022 - which, as already noted, is the year of the Water Tiger (yang) - is the 39th year of the current cycle.

Information for optional task

 The ten celestial stems are 甲 jiă, 乙 yĭ, 丙 bĭng, 丁 dīng, 戊 wù, 己 jĭ, 庚 gēng, 辛 xīn, 壬 rén, and 癸 gŭi. With the ASCII version of Pinyin tones, the names are written ""jia3"", ""yi3"", ""bing3"", ""ding1"", ""wu4"", ""ji3"", ""geng1"", ""xin1"", ""ren2"", and ""gui3"".
 The twelve terrestrial branches are 子 zĭ, 丑 chŏu, 寅 yín, 卯 măo, 辰 chén, 巳 sì, 午 wŭ, 未 wèi, 申 shēn, 酉 yŏu, 戌 xū, 亥 hài. In ASCII Pinyin, those are ""zi3"", ""chou3"", ""yin2"", ""mao3"", ""chen2"", ""si4"", ""wu3"", ""wei4"", ""shen1"", ""you3"", ""xu1"", and ""hai4"".
Therefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2022 is 壬寅 (rén-yín or ren2-yin2).
",Python,"# coding: utf-8
 
from __future__ import print_function
from datetime import datetime
 
pinyin = {
  '甲': 'jiă',
  '乙': 'yĭ',
  '丙': 'bĭng',
  '丁': 'dīng',
  '戊': 'wù',
  '己': 'jĭ',
  '庚': 'gēng',
  '辛': 'xīn',
  '壬': 'rén',
  '癸': 'gŭi',
 
  '子': 'zĭ',
  '丑': 'chŏu',
  '寅': 'yín',
  '卯': 'măo',
  '辰': 'chén',
  '巳': 'sì',
  '午': 'wŭ',
  '未': 'wèi',
  '申': 'shēn',
  '酉': 'yŏu',
  '戌': 'xū',
  '亥': 'hài'
}
 
animals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',
           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']
elements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']
 
celestial = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸']
terrestrial = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥']
aspects = ['yang', 'yin']
 
 
def calculate(year):
    BASE = 4
    year = int(year)
    cycle_year = year - BASE
    stem_number = cycle_year % 10
    stem_han = celestial[stem_number]
    stem_pinyin = pinyin[stem_han]
    element_number = stem_number // 2
    element = elements[element_number]
    branch_number = cycle_year % 12
    branch_han = terrestrial[branch_number]
    branch_pinyin = pinyin[branch_han]
    animal = animals[branch_number]
    aspect_number = cycle_year % 2
    aspect = aspects[aspect_number]
    index = cycle_year % 60 + 1
    print(""{}: {}{} ({}-{}, {} {}; {} - year {} of the cycle)""
          .format(year, stem_han, branch_han,
                  stem_pinyin, branch_pinyin, element, animal, aspect, index))
 
 
current_year = datetime.now().year
years = [1935, 1938, 1968, 1972, 1976, current_year]
for year in years:
    calculate(year)",Human_written,Python_from_C#
http://rosettacode.org/wiki/MD5,MD5,"Task

Encode a string using an MD5 algorithm.   The algorithm can be found on   Wikipedia.



Optionally, validate your implementation by running all of the test values in   IETF RFC (1321)   for MD5.

Additionally,   RFC 1321   provides more precise information on the algorithm than the Wikipedia article.



 Warning:   MD5 has known weaknesses, including collisions and forged signatures.   Users may consider a stronger alternative when doing production-grade cryptography, such as SHA-256 (from the SHA-2 family), or the upcoming SHA-3.

If the solution on this page is a library solution, see   MD5/Implementation   for an implementation from scratch.



",Python,"# version 1.0.6
import hashlib
 
text = ""The quick brown fox jumped over the lazy dog's back""
bytes = text.encode('utf-8')
md = hashlib.md5()
md.update(bytes)
digest = md.digest()
for byte in digest: print(""%02x"" % byte, end='')
print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Rot-13,Rot-13,"

Task

Implement a   rot-13   function   (or procedure, class, subroutine, or other ""callable"" object as appropriate to your programming environment).

Optionally wrap this function in a utility program   (like tr,   which acts like a common UNIX utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line,   or (if no filenames are passed thereon) acting as a filter on its   ""standard input.""



(A number of UNIX scripting languages and utilities, such as   awk   and   sed   either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g.,   Perl   and   Python).

The   rot-13   encoding is commonly known from the early days of Usenet ""Netnews"" as a way of obfuscating text to prevent casual reading of   spoiler   or potentially offensive material.

Many news reader and mail user agent programs have built-in rot-13 encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.

The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is ""rotated"" 13 characters ""around"" the 26 letter alphabet from its normal cardinal position   (wrapping around from   z   to   a   as necessary).

Thus the letters   abc   become   nop   and so on.

Technically rot-13 is a   ""mono-alphabetic substitution cipher""   with a trivial   ""key"".

A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters
in the input stream through without alteration.



Related tasks

   Caesar cipher
   Substitution Cipher
   Vigenère Cipher/Cryptanalysis



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> u'foo'.encode('rot13')
'sbb'
>>> 'sbb'.decode('rot13')
u'foo'",Human_written,Python_from_C#
http://rosettacode.org/wiki/Runtime_evaluation,Runtime evaluation,"Task

Demonstrate a language's ability for programs to execute code written in the language provided at runtime.

Show what kind of program fragments are permitted (e.g. expressions vs. statements), and how to get values in and out (e.g. environments, arguments, return values), if applicable what lexical/static environment the program is evaluated in, and what facilities for restricting (e.g. sandboxes, resource limits) or customizing (e.g. debugging facilities) the execution.

You may not invoke a separate evaluator program, or invoke a compiler and then its output, unless the interface of that program, and the syntax and means of executing it, are considered part of your language/library/platform.

For a more constrained task giving a specific program fragment to evaluate, see Eval in environment.



",Python,">>> exec '''
x = sum([1,2,3,4])
print x
'''
10",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Magic_squares_of_odd_order,Magic squares of odd order,"A magic square is an   NxN   square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,   and   both long (main) diagonals are equal to the same sum (which is called the   magic number   or   magic constant).

The numbers are usually (but not always) the first   N2   positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.



 8 
 1 
 6


 3 
 5 
 7


 4 
 9 
 2



Task
For any odd   N,   generate a magic square with the integers    1 ──► N,   and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for   N = 5.



 Related tasks
 Magic squares of singly even order
 Magic squares of doubly even order



 See also

 MathWorld™ entry: Magic_square 
 Odd Magic Squares (1728.org)

",Python,"# version 1.0.6
 
def f(n, x, y):
    return (x + y * 2 + 1) % n
 
n = int(input(""Enter the order of the magic square : ""))
while n < 1 or n % 2 == 0:
    print(""Must be odd and >= 1, try again"")
    n = int(input(""Enter the order of the magic square : ""))
print()
for i in range(n):
    for j in range(n):
        print(""%4d"" % (f(n, n - j - 1, i) * n + f(n, j, i) + 1), end='')
    print()
print(""\nThe magic constant is %d"" % ((n * n + 1) / 2 * n))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",Python,">>> def maprange( a, b, s):
	(a1, a2), (b1, b2) = a, b
	return  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))
 
>>> for s in range(11):
	print(""%2g maps to %g"" % (s, maprange( (0, 10), (-1, 0), s)))
 
 
 0 maps to -1
 1 maps to -0.9
 2 maps to -0.8
 3 maps to -0.7
 4 maps to -0.6
 5 maps to -0.5
 6 maps to -0.4
 7 maps to -0.3
 8 maps to -0.2
 9 maps to -0.1
10 maps to 0",Human_written,Python_from_Java
http://rosettacode.org/wiki/Dice_game_probabilities,Dice game probabilities,"Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.

They roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?

Later the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?

This task was adapted from the Project Euler Problem n.205:
https://projecteuler.net/problem=205
",Python,"def roll_dice(n_dice, n_faces):
    if n_dice == 0:
        return [[0,1]]
    one  = [1] * n_faces
    zero = [0] * (n_faces-1)
    for _ in range(1, n_dice):
        ary = zero + ary + zero
        for a in zip(*[iter(ary)]*n_faces):
            yield sum(a)
    return [[sum(a), n] for a, n in zip(ary, n_faces)]

def game(dice1, faces1, dice2, faces2):
    p1 = roll_dice(dice1, faces1)
    p2 = roll_dice(dice2, faces2)
    win = [0, 0, 0]
    for (sum1, n1), (sum2, n2) in product(p1, p2):
        win[sum1 <=> sum2] += n1 * n2
    return win

for d1, f1, d2, f2 in [[9, 4, 6, 6], [5, 10, 6, 7]]:
    print(""player 1 has {} dice with {} faces each"".format(d1, f1))
    print(""player 2 has {} dice with {} faces each"".format(d2, f2))
    win = game(d1, f1, d2, f2)
    sum = sum(win)
    print(""Probability for player 1 to win: {} / {}"".format(win[1], sum))
    print(""                              -> {}"".format(win[1] / sum))
    print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Number_names,Number names,"Task

Show how to spell out a number in English.

You can use a preexisting implementation or roll your own, but you should support inputs up to at least one million (or the maximum value of your language's default bounded integer type, if that's less).

Support for inputs other than positive integers (like zero, negative integers, and floating-point numbers) is optional.



Related task

   Spelling of ordinal numbers.

",Python,"import sys
 
incrementsOfOne = [ ""zero"",    ""one"",     ""two"",       ""three"",    ""four"",
                    ""five"",    ""six"",     ""seven"",     ""eight"",    ""nine"",
                    ""ten"",     ""eleven"",  ""twelve"",    ""thirteen"", ""fourteen"",
                    ""fifteen"", ""sixteen"", ""seventeen"", ""eighteen"", ""nineteen"" ]
 
incrementsOfTen = [ """",      """",      ""twenty"",  ""thirty"", ""fourty"",
                    ""fifty"", ""sixty"", ""seventy"", ""eighty"", ""ninety"" ]
 
millionName = ""million""
thousandName = ""thousand""
hundredName = ""hundred""
andName = ""and""
 
def GetName( i ):
    output = """"
    if i >= 1000000:
        output += ParseTriplet( i / 1000000 ) + "" "" + millionName
        i %= 1000000
        if i == 0: return output
 
    if i >= 1000:
        if len( output ) > 0:
            output += "", ""
        output += ParseTriplet( i / 1000 ) + "" "" + thousandName
        i %= 1000
        if i == 0: return output
 
    if len( output ) > 0:
        output += "", ""
    output += ParseTriplet( i )
    return output
 
def ParseTriplet( i ):
    output = """"
    if i >= 100:
        output += incrementsOfOne[i / 100] + "" "" + hundredName
        i %= 100
        if i == 0: return output
 
    if len( output ) > 0:
        output += "" "" + andName + "" ""
    if i >= 20:
        output += incrementsOfTen[i / 10]
        i %= 10
        if i == 0: return output
 
    if len( output ) > 0:
        output += "" ""
    output += incrementsOfOne[i]
    return output
 
# Test class
print( GetName( 1 ) )
print( GetName( 234 ) )
print( GetName( 31337 ) )
print( GetName( 987654321 ) )",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort,Sorting algorithms/Pancake sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of integers (of any convenient size) into ascending order using Pancake sorting.

In short, instead of individual elements being sorted, the only operation allowed is to ""flip"" one end of the list, like so:

          Before:   6 7 8 9 2 5 3 4 1
          After:    9 8 7 6 2 5 3 4 1

Only one end of the list can be flipped; this should be the low end, but the high end is okay if it's easier to code or works better, but it must be the same end for the entire solution. (The end flipped can't be arbitrarily changed.)

Show both the initial, unsorted list and the final sorted list.

(Intermediate steps during sorting are optional.)

Optimizations are optional (but recommended).



Related tasks

   Number reversal game
   Topswops


Also see

   Wikipedia article:   pancake sorting.

",Python,"tutor = False
 
def pancakesort(data):
    if len(data) <= 1:
        return data
    if tutor: print()
    for size in range(len(data), 1, -1):
        maxindex = max(range(size), key=data.__getitem__)
        if maxindex+1 != size:
            # This indexed max needs moving
            if maxindex != 0:
                # Flip the max item to the left
                if tutor: print('With: %r doflip  %i'
                                % ( ' '.join(str(x) for x in data), maxindex+1 ))
                data[:maxindex+1] = reversed(data[:maxindex+1])
            # Flip it into its final position
            if tutor: print('With: %r  doflip %i'
                                % ( ' '.join(str(x) for x in data), size ))
            data[:size] = reversed(data[:size])
    if tutor: print()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",Python,"def isLeap(year):
    return year%400 == 0 or year%4 == 0 and year%100!= 0",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Web_scraping,Web scraping,"Task

Create a program that downloads the time from this URL:   http://tycho.usno.navy.mil/cgi-bin/timer.pl   and then prints the current UTC time by extracting just the UTC time from the web page's HTML. Alternatively, if the above url is not working, grab the first date/time off this page's talk page.



If possible, only use libraries that come at no extra monetary cost with the programming language and that are widely available and popular such as CPAN for Perl or Boost for C++.



",Python,"import urllib
page = urllib.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl')
for line in page:
    if ' UTC' in line:
        print line.strip()[4:]
        break
page.close()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping,Sutherland-Hodgman polygon clipping,"The   Sutherland-Hodgman clipping algorithm   finds the polygon that is the intersection between an arbitrary polygon (the “subject polygon”) and a convex polygon (the “clip polygon”).

It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.



Task

Take the closed polygon defined by the points:

 



[
(
50
,
150
)
,
(
200
,
50
)
,
(
350
,
150
)
,
(
350
,
300
)
,
(
250
,
300
)
,
(
200
,
250
)
,
(
150
,
350
)
,
(
100
,
250
)
,
(
100
,
200
)
]


{\displaystyle [(50,150),(200,50),(350,150),(350,300),(250,300),(200,250),(150,350),(100,250),(100,200)]}


and clip it by the rectangle defined by the points:

 



[
(
100
,
100
)
,
(
300
,
100
)
,
(
300
,
300
)
,
(
100
,
300
)
]


{\displaystyle [(100,100),(300,100),(300,300),(100,300)]}


Print the sequence of points that define the resulting clipped polygon.



Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon.

(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)



",Python,"def clip(subjectPolygon, clipPolygon):
   def inside(p):
      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])
 
   def computeIntersection():
      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]
      dp = [ s[0] - e[0], s[1] - e[1] ]
      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]
      n2 = s[0] * e[1] - s[1] * e[0] 
      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]
 
   outputList = subjectPolygon
   cp1 = clipPolygon[-1]
 
   for clipVertex in clipPolygon:
      cp2 = clipVertex
      inputList = outputList
      outputList = []
      s = inputList[-1]
 
      for subjectVertex in inputList:
         e = subjectVertex
         if inside(e):
            if not inside(s):
               outputList.append(computeIntersection())
            outputList.append(e)
         elif inside(s):
            outputList.append(computeIntersection())
         s = e
      cp1 = cp2
   return(outputList)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort,Sorting algorithms/Merge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The   merge sort   is a recursive sort of order    n*log(n). 

It is notable for having a worst case and average complexity of    O(n*log(n)),    and a best case complexity of    O(n)    (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements   (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its   divide and conquer   description.



Task

Write a function to sort a collection of integers using the merge sort.



The merge sort algorithm comes in two parts:

   a sort function     and 
   a merge function 

The functions in pseudocode look like this:

function mergesort(m)
   var list left, right, result
   if length(m) ≤ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ≤ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ≤ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result



See also

   the Wikipedia entry:    merge sort


Note:   better performance can be expected if, rather than recursing until    length(m) ≤ 1,    an insertion sort is used for    length(m)    smaller than some threshold larger than   1.   However, this complicates the example code, so it is not shown here.



",Python,"def merge_sort(m):
    if len(m) <= 1:
        return m
    middle = len(m) // 2
    left = merge_sort(m[:middle])
    right = merge_sort(m[middle:])
    return merge(left, right)

def merge(left, right):
    result = []
    while left and right:
        if left[0] <= right[0]:
            result.append(left.pop(0))
        else:
            result.append(right.pop(0))
    return result + left + right

ary = [7,6,5,9,8,4,3,1,2,0]
print(merge_sort(ary))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",Python,"from itertools import permutations
from operator import mul
from math import fsum
from spermutations import spermutations
 
def prod(lst):
    return reduce(mul, lst, 1)
 
def perm(a):
    n = len(a)
    r = range(n)
    s = permutations(r)
    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)
 
def det(a):
    n = len(a)
    r = range(n)
    s = spermutations(n)
    return fsum(sign * prod(a[i][sigma[i]] for i in r)
                for sigma, sign in s)
 
if __name__ == '__main__':
    from pprint import pprint as pp
 
    for a in ( 
            [
             [1, 2], 
             [3, 4]], 
 
            [
             [1, 2, 3, 4],
             [4, 5, 6, 7],
             [7, 8, 9, 10],
             [10, 11, 12, 13]],        
 
            [
             [ 0,  1,  2,  3,  4],
             [ 5,  6,  7,  8,  9],
             [10, 11, 12, 13, 14],
             [15, 16, 17, 18, 19],
             [20, 21, 22, 23, 24]],
        ):
        print('')
        pp(a)
        print('Perm: %s Det: %s' % (perm(a), det(a)))",Human_written,Python_from_C++
http://rosettacode.org/wiki/File_size,File size,"Verify the size of a file called     input.txt     for a file in the current working directory, and another one in the file system root.



",Python,"f = open(""input.txt"", ""r"")
line = f.readline()
while line:
  print(line)
  line = f.readline()
f.close()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",Python,"class HelloWorld:
    def main(self):
        print(""Hello world!"")

HelloWorld().main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"from typing import List
 
def pascal_upper(n: int) -> List[List[int]]:
    matrix = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i > j:
                matrix[i][j] = 0
            elif i == j or i == 0:
                matrix[i][j] = 1
            else:
                matrix[i][j] = matrix[i - 1][j - 1] + matrix[i][j - 1]
    return matrix
 
def pascal_lower(n: int) -> List[List[int]]:
    matrix = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i < j:
                matrix[i][j] = 0
            elif i == j or j == 0:
                matrix[i][j] = 1
            else:
                matrix[i][j] = matrix[i - 1][j - 1] + matrix[i - 1][j]
    return matrix
 
def pascal_symmetric(n: int) -> List[List[int]]:
    matrix = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == 0 or j == 0:
                matrix[i][j] = 1
            else:
                matrix[i][j] = matrix[i][j - 1] + matrix[i - 1][j]
    return matrix
 
def print_matrix(matrix: List[List[int]]):
    for row in matrix:
        for i in row:
            print(f"" {i}"", end="""")
        print()
 
if __name__ == ""__main__"":
    print(""PASCAL UPPER MATRIX"")
    print_matrix(pascal_upper(5))
    print(""PASCAL LOWER MATRIX"")
    print_matrix(pascal_lower(5))
    print(""PASCAL SYMMETRIC MATRIX"")
    print_matrix(pascal_symmetric(5))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Bernoulli_numbers,Bernoulli numbers,"Bernoulli numbers are used in some series expansions of several functions   (trigonometric, hyperbolic, gamma, etc.),   and are extremely important in number theory and analysis.

Note that there are two definitions of Bernoulli numbers;   this task will be using the modern usage   (as per   The National Institute of Standards and Technology convention).

The   nth   Bernoulli number is expressed as   Bn.



Task
   show the Bernoulli numbers   B0   through   B60.
   suppress the output of values which are equal to zero.   (Other than   B1 , all   odd   Bernoulli numbers have a value of zero.)
   express the Bernoulli numbers as fractions  (most are improper fractions).
   the fractions should be reduced.
   index each number in some way so that it can be discerned which Bernoulli number is being displayed.
   align the solidi   (/)   if used  (extra credit).


An algorithm
The Akiyama–Tanigawa algorithm for the ""second Bernoulli numbers"" as taken from wikipedia is as follows:

 for m from 0 by 1 to n do
    A[m] ← 1/(m+1)
    for j from m by -1 to 1 do
      A[j-1] ← j×(A[j-1] - A[j])
  return A[0] (which is Bn)

See also
 Sequence A027641 Numerator of Bernoulli number B_n on The On-Line Encyclopedia of Integer Sequences.
 Sequence A027642 Denominator of Bernoulli number B_n on The On-Line Encyclopedia of Integer Sequences.
 Entry Bernoulli number on The Eric Weisstein's World of Mathematics (TM).
 Luschny's The Bernoulli Manifesto for a discussion on    B1   =   -½   versus   +½. 

",Python,"from fractions import Fraction as Fr
 
def bernoulli(n):
    A = [0] * (n+1)
    for m in range(n+1):
        A[m] = Fr(1, m+1)
        for j in range(m, 0, -1):
          A[j-1] = j*(A[j-1] - A[j])
    return A[0] # (which is Bn)
 
bn = [(i, bernoulli(i)) for i in range(61)]
bn = [(i, b) for i,b in bn if b]
width = max(len(str(b.numerator)) for i,b in bn)
for i,b in bn:
    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))",Human_written,Python_from_C
http://rosettacode.org/wiki/First_class_environments,First class environments,"According to Wikipedia, ""In computing, a first-class object ... is an entity that can be constructed at run-time, passed as a parameter, returned from a subroutine, or assigned into a variable"".

Often this term is used in the context of ""first class functions"". In an analogous way, a programming language may support ""first class environments"".

The environment is minimally, the set of variables accessible to a statement being executed. Change the environments and the same statement could produce different results when executed.

Often an environment is captured in a closure, which encapsulates a function together with an environment. That environment, however, is not first-class, as it cannot be created, passed etc. independently from the function's code.

Therefore, a first class environment is a set of variable bindings which can be constructed at run-time, passed as a parameter, returned from a subroutine, or assigned into a variable. It is like a closure without code. A statement must be able to be executed within a stored first class environment and act according to the environment variable values stored within.



Task

Build a dozen environments, and a single piece of code to be run repeatedly in each of these environments.

Each environment contains the bindings for two variables:

   a value in the Hailstone sequence, and 
   a count which is incremented until the value drops to 1. 


The initial hailstone values are 1 through 12, and the count in each environment is zero.

When the code runs, it calculates the next hailstone step in the current environment (unless the value is already 1) and counts the steps. Then it prints the current value in a tabular form.

When all hailstone values dropped to 1, processing stops, and the total number of hailstone steps for each environment is printed.



",Python,"from __future__ import print_function
 
jobs = 12
 
class environment(object):
    def __init__(self, seq, cnt):
        self.seq = seq
        self.cnt = cnt
 
env = [environment(i + 1, 0) for i in range(jobs)]
 
def hail():
    print(""{:4d}"".format(seq), end="""")
    if seq == 1:
        return
    cnt += 1
    if seq & 1:
        seq = 3 * seq + 1
    else:
        seq /= 2
 
def switchTo(id):
    global seq, cnt
    seq = env[id].seq
    cnt = env[id].cnt
 
for i in range(jobs):
    switchTo(i)
 
while True:
    for i in range(jobs):
        switchTo(i)
        hail()
    print()
 
    for j in range(jobs):
        switchTo(j)
        if seq!= 1:
            break
    else:
        break
 
print(""COUNTS:"")
for i in range(jobs):
    switchTo(i)
    print(""{:4d}"".format(cnt), end="""")
print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting algorithms/Quicksort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm.

The elements must have a   strict weak order   and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.



Quicksort, also known as   partition-exchange sort,   uses these steps.

   Choose any element of the array to be the pivot.
   Divide all other elements (except the pivot) into two partitions.
   All elements less than the pivot must be in the first partition.
   All elements greater than the pivot must be in the second partition.
   Use recursion to sort both partitions.
   Join the first sorted partition, the pivot, and the second sorted partition.


The best pivot creates partitions of equal length (or lengths differing by   1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.



This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

 ""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

 Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
 Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.


With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.



",Python,"def sort(array, less):
    def swap(i, j):
        t = array[i]
        array[i] = array[j]
        array[j] = t
    def quicksort(left, right):
        if left < right:
            pivot = array[left + int((right - left) / 2)]
            left_new = left
            right_new = right
            while left_new <= right_new:
                while less(array[left_new], pivot):
                    left_new += 1
                while less(pivot, array[right_new]):
                    right_new -= 1
                if left_new <= right_new:
                    swap(left_new, right_new)
                    left_new += 1
                    right_new -= 1
            quicksort(left, right_new)
            quicksort(left_new, right)
    quicksort(0, len(array) - 1)
    return array",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Averages/Root_mean_square,Averages/Root mean square,"Task[edit]
Compute the   Root mean square   of the numbers 1..10.



The   root mean square   is also known by its initials RMS (or rms), and as the quadratic mean.

The RMS is calculated as the mean of the squares of the numbers, square-rooted:



 




x


r
m
s



=







x

1




2


+



x

2




2


+
⋯
+



x

n




2



n



.


{\displaystyle x_{\mathrm {rms} }={\sqrt {{{x_{1}}^{2}+{x_{2}}^{2}+\cdots +{x_{n}}^{2}} \over n}}.}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,">>> from math import sqrt
>>> def qmean(num):
	return sqrt(sum(n*n for n in num)/len(num))
 
>>> qmean(range(1,11))
6.2048368229954285",Human_written,Python_from_C
http://rosettacode.org/wiki/Find_the_intersection_of_two_lines,Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",Python,"import sys
import math
 
class Point:
	def __init__(self,x,y):
		self.x = x
		self.y = y
 
def lineSlope(a,b):
	if a.x-b.x == 0.0:
		return float('nan')
	else:
		return (a.y-b.y)/(a.x-b.x)
 
def extractPoint(str):
	start = 0
	end = 0
	length = 0
	holder = """"
	c = Point(0,0)
 
	for i in range(0,len(str)):
		if str[i] == '(':
			start = i
		if str[i] == ',' or str[i] == ')':
			end = i
 
			length = end - start
 
			holder = str[start+1:end]
 
			if str[i] == ',':
				start = i
				c.x = float(holder)
			else:
				c.y = float(holder)
 
	return c
 
def intersectionPoint(a1,a2,b1,b2):
	c = Point(0,0)
 
	slopeA = lineSlope(a1,a2)
	slopeB = lineSlope(b1,b2)
 
	if slopeA == slopeB:
		c.x = float('nan')
		c.y = float('nan')
	elif math.isnan(slopeA) and not math.isnan(slopeB):
		c.x = a1.x
		c.y = (a1.x-b1.x)*slopeB + b1.y
	elif math.isnan(slopeB) and not math.isnan(slopeA):
		c.x = b1.x
		c.y = (b1.x-a1.x)*slopeA + a1.y
	else:
		c.x = (slopeA*a1.x - slopeB*b1.x + b1.y - a1.y)/(slopeA - slopeB)
		c.y = slopeB*(c.x - b1.x) + b1.y
 
	return c
 
if __name__ == ""__main__"":
	if len(sys.argv) < 5:
		print(""Usage : %s <four points specified as (x,y) separated by a space>"" % sys.argv[0])
	else:
		c = intersectionPoint(extractPoint(sys.argv[1]),extractPoint(sys.argv[2]),extractPoint(sys.argv[3]),extractPoint(sys.argv[4]))
 
		if math.isnan(c.x):
			print(""The lines do not intersect, they are either parallel or co-incident."")
		else:
			print(""Point of intersection : (%lf,%lf)"" % (c.x,c.y))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Pseudo-random_numbers/Xorshift_star,Pseudo-random numbers/Xorshift star,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
Xorshift_star Generator (pseudo-code)

   /* Let u64 denote an unsigned 64 bit integer type. */
   /* Let u32 denote an unsigned 32 bit integer type. */



   class Xorshift_star
       u64 state       /* Must be seeded to non-zero initial value */
       u64 const = HEX '2545F4914F6CDD1D'

       method seed(u64 num):
           state =  num
       end method
       
       method next_int():
           u64 x = state
           x = x ^ (x >> 12)
           x = x ^ (x << 25)
           x = x ^ (x >> 27)
           state = x
           u32 answer = ((x * const) >> 32)
           
           return answer
       end method
       
       method next_float():
           return float next_int() / (1 << 32)
       end method
       
   end class
       

Xorshift use

   random_gen = instance Xorshift_star
   random_gen.seed(1234567)
   print(random_gen.next_int())   /* 3540625527 */
   print(random_gen.next_int())   /* 2750739987 */
   print(random_gen.next_int())   /* 4037983143 */
   print(random_gen.next_int())   /* 1993361440 */
   print(random_gen.next_int())   /* 3809424708 */

Task

 Generate a class/set of functions that generates pseudo-random
numbers as shown above.

 Show that the first five integers genrated with the seed 1234567
are as shown above

 Show that for an initial seed of 987654321, the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20103, 1: 19922, 2: 19937, 3: 20031, 4: 20007

 Show your output here, on this page.

",Python,"class Xorshift_star:
    MASK64 = (1 << 64) - 1
    MASK32 = (1 << 32) - 1

    def __init__(self, seed = 0):
        self.state = seed & self.MASK64

    def next_int(self):
        x = self.state
        x =  x ^ (x >> 12) 
        x = (x ^ (x << 25)) & self.MASK64
        x =  x ^ (x >> 27) 
        self.state = x
        return (((x * 0x2545F4914F6CDD1D) & self.MASK64) >> 32) & self.MASK32

    def next_float(self):
        return self.next_int() / (1 << 32)

random_gen =  Xorshift_star(1234567)
for i in range(5):
    print(random_gen.next_int())

random_gen = Xorshift_star(987654321)
tally = {i:0 for i in range(5)}
for i in range(100000):
    tally[int(random_gen.next_float()*5)] += 1

for i in sorted(tally.keys()):
    print(f""{i}: {tally[i]}"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Magic_squares_of_odd_order,Magic squares of odd order,"A magic square is an   NxN   square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,   and   both long (main) diagonals are equal to the same sum (which is called the   magic number   or   magic constant).

The numbers are usually (but not always) the first   N2   positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.



 8 
 1 
 6


 3 
 5 
 7


 4 
 9 
 2



Task
For any odd   N,   generate a magic square with the integers    1 ──► N,   and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for   N = 5.



 Related tasks
 Magic squares of singly even order
 Magic squares of doubly even order



 See also

 MathWorld™ entry: Magic_square 
 Odd Magic Squares (1728.org)

",Python,"def magic(n):
    return rotation(transposed(rotation(table(n)))) if n % 2 else None
 
def rotation(lst):
    return [rotated(row, ((len(row) + 1) / 2) - (i + 1)) for i, row in enumerate(lst)]
 
def transposed(lst):
    return [[lst[j][i] for j in range(len(lst))] for i in range(len(lst[0]))]
 
def rotated(lst, n):
    lng = len(lst)
    m = n if n < 0 else n % lng if n > lng else n
 
    return lst[-m:] + lst[:lng - m] if m else lst
 
def table(n):
    rngTop = rng(1, n)
 
    return [[row * n + x for x in rngTop] for row in rng(0, n - 1)]
 
def rng(m, n):
    return [m + i for i in range(n - m + 1)]
 
def wikiTable(lstRows, blnHeaderRow, strStyle):
    css ='style=""' + strStyle + '""' if strStyle else ''
 
    return '{| class=""wikitable""'+ css + ''.join(
        '\n|-\n' + strDelim +'' +''.join(lstRow) + '\n'
        for lstRow in lstRows
        for strDelim in (('!' if blnHeaderRow and not iRow else '|'), '|')
    ) + '\n|}'
 
return '\n\n'.join(
   'magic(' + str(n) + ')\n\n' + wikiTable(
        magic(n), False, 'text-align:center;width:' + str(2.5 * n) + 'em;height:' + str(2.5 * n) + 'em;table-layout:fixed;'
    )
    for n in (3, 5, 11)
)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",Python,((\d*\.\d+|\d+\.)([eE][+-]?[0-9]+)?[flFL]?)|([0-9]+[eE][+-]?[0-9]+[flFL]?),Ai_generated,Python_from_C
http://rosettacode.org/wiki/Quine,Quine,"A quine is a self-referential program that can,
without any external access, output its own source.



A   quine   (named after Willard Van Orman Quine)   is also known as:

   self-reproducing automata   (1972)
   self-replicating program         or   self-replicating computer program
   self-reproducing program      or   self-reproducing computer program
   self-copying program             or   self-copying computer program


It is named after the philosopher and logician
who studied self-reference and quoting in natural language,
as for example in the paradox ""'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation.""

""Source"" has one of two meanings. It can refer to the text-based program source.
For languages in which program source is represented as a data structure, ""source"" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.



Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

 Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on.
 Some languages have a function for getting the ""source code representation"" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem.
 Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39.
 Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. ""\n""). This causes the same problem as above, where the escaping character needs to itself be escaped, etc.
 If the language has a way of getting the ""source code representation"", it usually handles the escaping of characters, so this is not a problem.
 Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping.
 Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.



Related task

   print itself.

",Python,"x = ""x = \""{}\"";\ny = \""{}\"";\nprint(x.format(x, y, y))\n""
y = ""print(x.format(x, y, y))\n""
print(x.format(x, y, y))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Averages/Pythagorean_means,Averages/Pythagorean means,"Task[edit]
Compute all three of the Pythagorean means of the set of integers 1 through 10 (inclusive).

Show that 



A
(

x

1


,
…
,

x

n


)
≥
G
(

x

1


,
…
,

x

n


)
≥
H
(

x

1


,
…
,

x

n


)


{\displaystyle A(x_{1},\ldots ,x_{n})\geq G(x_{1},\ldots ,x_{n})\geq H(x_{1},\ldots ,x_{n})}

 for this set of positive integers.

 The most common of the three means, the arithmetic mean, is the sum of the list divided by its length:
 



A
(

x

1


,
…
,

x

n


)
=




x

1


+
⋯
+

x

n



n




{\displaystyle A(x_{1},\ldots ,x_{n})={\frac {x_{1}+\cdots +x_{n}}{n}}}


 The geometric mean is the 



n


{\displaystyle n}

th root of the product of the list:
 



G
(

x

1


,
…
,

x

n


)
=




x

1


⋯

x

n




n





{\displaystyle G(x_{1},\ldots ,x_{n})={\sqrt[{n}]{x_{1}\cdots x_{n}}}}


 The harmonic mean is 



n


{\displaystyle n}

 divided by the sum of the reciprocal of each item in the list:
 



H
(

x

1


,
…
,

x

n


)
=


n



1

x

1




+
⋯
+


1

x

n









{\displaystyle H(x_{1},\ldots ,x_{n})={\frac {n}{{\frac {1}{x_{1}}}+\cdots +{\frac {1}{x_{n}}}}}}




See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,"from operator import mul
from functools import reduce
 
 
def amean(num):
    return sum(num) / len(num)
 
 
def gmean(num):
    return reduce(mul, num, 1)**(1 / len(num))
 
 
def hmean(num):
    return len(num) / sum(1 / n for n in num)
 
 
numbers = range(1, 11)  # 1..10
a, g, h = amean(numbers), gmean(numbers), hmean(numbers)
print(a, g, h)
assert a >= g >= h",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",Python,"# version 1.1.0 (run on Windows 10)

import os

def main():
    text = open(""narcissist.py"", ""r"").read()
    print(""Enter the number of lines to be input followed by those lines:\n"")
    n = int(input())
    lines = [input() for _ in range(n)]
    if ""\n"".join(lines) == text:
        print(""\naccept"")
    else:
        print(""\nreject"")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Textonyms,Textonyms,"When entering text on a phone's digital pad it is possible that a particular combination of digits corresponds to more than one word. Such are called textonyms.

Assuming the digit keys are mapped to letters as follows:

    2 -> ABC
    3 -> DEF
    4 -> GHI
    5 -> JKL
    6 -> MNO
    7 -> PQRS
    8 -> TUV
    9 -> WXYZ  



Task

Write a program that finds textonyms in a list of words such as  
Textonyms/wordlist   or  
unixdict.txt.

The task should produce a report:

There are #{0} words in #{1} which can be represented by the digit key mapping.
They require #{2} digit combinations to represent them.
#{3} digit combinations represent Textonyms.

Where:

#{0} is the number of words in the list which can be represented by the digit key mapping.
#{1} is the URL of the wordlist being used.
#{2} is the number of digit combinations required to represent the words in #{0}.
#{3} is the number of #{2} which represent more than one word.

At your discretion show a couple of examples of your solution displaying Textonyms.

E.G.:

 2748424767 -> ""Briticisms"", ""criticisms""



Extra credit

Use a word list and keypad mapping other than English.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
from collections import defaultdict
 
def text_char(ch):
    if ch in 'abc':
        return '2'
    elif ch in 'def':
        return '3'
    elif ch in 'ghi':
        return '4'
    elif ch in 'jkl':
        return '5'
    elif ch in'mno':
        return '6'
    elif ch in 'pqrs':
        return '7'
    elif ch in 'tuv':
        return '8'
    elif ch in 'wxyz':
        return '9'
    else:
        return None
 
def text_string(s):
    text = ''
    for c in s:
        t = text_char(c)
        if t is None:
            return None
        text += t
    return text
 
def print_top_words(textonyms, top):
    for text, words in textonyms[:top]:
        print(f'{text} = {"", "".join(words)}')
 
def find_textonyms(filename):
    table = defaultdict(list)
    count = 0
 
    with open(filename) as file:
        for line in file:
            word = line.strip().lower()
            text = text_string(word)
            if text is not None:
                table[text].append(word)
                count += 1
 
    textonyms = [(text, words) for text, words in table.items() if len(words) > 1]
 
    print(f'There are {count} words in ""{filename}"" which can be represented by the digit key mapping.')
    print(f'They require {len(table)} digit combinations to represent them.')
    print(f'{len(textonyms)} digit combinations represent Textonyms.')
 
    top = min(5, len(textonyms))
    textonyms.sort(key=lambda x: (-len(x[1]), x[0]))
    print(f'\nTop {top} by number of words:')
    print_top_words(textonyms, top)
 
    textonyms.sort(key=lambda x: (-len(x[0]), x[0]))
    print(f'\nTop {top} by length:')
    print_top_words(textonyms, top)
 
if __name__ == '__main__':
    if len(sys.argv)!= 2:
        print(f'usage: {sys.argv[0]} word-list', file=sys.stderr)
        sys.exit(1)
    try:
        find_textonyms(sys.argv[1])
    except OSError as error:
        print(f'{sys.argv[1]}: {error}', file=sys.stderr)
        sys.exit(1)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Special_variables,Special variables,"Special variables have a predefined meaning within a computer programming language.



Task

List the special variables used within the language.



",Python,"names = sorted((set(globals().keys()) | set(__builtins__.__dict__.keys())) - set('_ names i'.split()))
print( '\n'.join(' '.join(names[i:i+8]) for i in range(0, len(names), 8)) )",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pangram_checker,Pangram checker,"Pangram checker

You are encouraged to solve this task according to the task description, using any language you may know.
A pangram is a sentence that contains all the letters of the English alphabet at least once.

For example:   The quick brown fox jumps over the lazy dog.



Task

Write a function or method to check a sentence to see if it is a   pangram   (or not)   and show its use.



Related tasks

   determine if a string has all the same characters
   determine if a string has all unique characters

",Python,"import string
 
def is_pangram_via_bitmask(s):
 
    # Create a mask of set bits and convert to false as we find characters.
    mask = (1 << 26) - 1
 
    for chr in s:
        val = ord(chr) & !0x20 # 0x20 converts lowercase to upper
        if val <= ord('Z') and val >= ord('A'):
            mask = mask & !(1 << (val - ord('A')))
 
    return mask == 0
 
def is_pangram_via_hashset(s):
 
    # Insert lowercase letters into a HashSet, then check if we have at least 26.
    letters = set()
 
    for chr in s:
        if chr.isalpha():
            letters.add(chr.lower())
 
    return len(letters) == 26
 
def is_pangram_via_sort(s):
 
    # Copy chars into a vector, convert to lowercase, sort, and remove duplicates.
    chars = sorted(set(c for c in s if c.isalpha()))
 
    return len(chars) == 26
 
if __name__ == '__main__':
 
    examples = [""The quick brown fox jumps over the lazy dog"",
                ""The quick white cat jumps over the lazy dog""]
 
    for text in examples:
        is_pangram_sort = is_pangram_via_sort(text)
        print(""Is \""{}\"" a pangram via sort? - {}"".format(text, is_pangram_sort))
 
        is_pangram_bitmask = is_pangram_via_bitmask(text)
        print(""Is \""{}\"" a pangram via bitmask? - {}"".format(text, is_pangram_bitmask))
 
        is_pangram_hashset = is_pangram_via_hashset(text)
        print(""Is \""{}\"" a pangram via bitmask? - {}"".format(text, is_pangram_hashset))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/The_ISAAC_Cipher,The ISAAC Cipher,"ISAAC is a cryptographically secure pseudo-random number generator (CSPRNG) and stream cipher. It was developed by Bob Jenkins from 1993 (http://burtleburtle.net/bob/rand/isaac.html) and placed in the Public Domain. ISAAC is fast - especially when optimised - and portable to most architectures in nearly all programming and scripting languages.
It is also simple and succinct, using as it does just two 256-word arrays for its state.

ISAAC stands for ""Indirection, Shift, Accumulate, Add, and Count"" which are the principal bitwise operations employed.
To date - and that's after more than 20 years of existence - ISAAC has not been broken (unless GCHQ or NSA did it, but they wouldn't be telling).
ISAAC thus deserves a lot more attention than it has hitherto received and it would be salutary to see it more universally implemented.



Task

Translate ISAAC's reference C or Pascal code into your language of choice.

The RNG should then be seeded with the string ""this is my secret key"" and
finally the message ""a Top Secret secret"" should be encrypted on that key.
Your program's output cipher-text will be a string of hexadecimal digits.

Optional: Include a decryption check by re-initializing ISAAC and performing
the same encryption pass on the cipher-text.

Please use the C or Pascal as a reference guide to these operations.

Two encryption schemes are possible:
(1) XOR (Vernam) or
(2) Caesar-shift mod 95 (Vigenère).
XOR is the simplest; C-shifting offers greater security.

You may choose either scheme, or both, but please specify which you used.
Here are the alternative sample outputs for checking purposes:

Message: a Top Secret secret
Key    : this is my secret key
XOR    : 1C0636190B1260233B35125F1E1D0E2F4C5422
MOD    : 734270227D36772A783B4F2A5F206266236978
XOR dcr: a Top Secret secret
MOD dcr: a Top Secret secret

No official seeding method for ISAAC has been published, but for this task
we may as well just inject the bytes of our key into the randrsl array,
padding with zeroes before mixing, like so:

// zeroise mm array
FOR i:= 0 TO 255 DO mm[i]:=0;
// check seed's highest array element
m := High(seed);
// inject the seed
FOR i:= 0 TO 255 DO BEGIN
	// in case seed[] has less than 256 elements.
	IF i>m THEN randrsl[i]:=0  
		ELSE randrsl[i]:=seed[i];
END;
// initialize ISAAC with seed
RandInit(true);

ISAAC can of course also be initialized with a single 32-bit unsigned integer in the manner of traditional RNGs, and indeed used as such for research and gaming purposes.
But building a strong and simple ISAAC-based stream cipher - replacing the irreparably broken RC4 - is our goal here: ISAAC's intended purpose.



",Python,"import random
import collections
 
INT_MASK = 0xFFFFFFFF       # we use this to emulate 32-bit overflow semantics by masking off higher bits after operations
 
class IsaacRandom(random.Random):
    """"""
    Random number generator using the ISAAC algorithm.
    """"""
 
    def seed(self, seed=None):
        """"""
        Initialize internal state.
 
        The seed, if given, can be a string, an integer, or an iterable that contains
        integers only. If no seed is given, a fixed default state is set up; unlike
        our superclass, this class will not attempt to randomize the seed from outside sources.
        """"""
        def mix():
            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK
            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK
            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK
            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK
            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK
            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK
            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK
            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK
 
        super().seed(0) # give a chance for the superclass to reset its state - the actual seed given to it doesn't matter
        if seed is not None:
            if isinstance(seed, str):
                seed = [ord(x) for x in seed]
            elif isinstance(seed, collections.Iterable):
                seed = [x & INT_MASK for x in seed]
            elif isinstance(seed, int):
                val = abs(seed)
                seed = []
                while val:
                    seed.append(val & INT_MASK)
                    val >>= 32
            else:
                raise TypeError('Seed must be string, integer or iterable of integer')
 
            # make sure the seed list is exactly 256 elements long
            if len(seed)>256:
                del seed[256:]
            elif len(seed)<256:
                seed.extend([0]*(256-len(seed)))
 
        self.aa = self.bb = self.cc = 0
        self.mm = []
        init_state = [0x9e3779b9]*8
 
        for _ in range(4):
            mix()
 
        for i in range(0, 256, 8):
            if seed is not None:
                for j in range(8):
                    init_state[j] += seed[i+j]
                    init_state[j] &= INT_MASK
            mix()
            self.mm += init_state
 
        if seed is not None:
            for i in range(0, 256, 8):
                for j in range(8):
                    init_state[j] += self.mm[i+j]
                    init_state[j] &= INT_MASK
                mix()
                for j in range(8):
                    self.mm[i+j] = init_state[j]
 
        self.rand_count = 256
        self.rand_result = [0]*256
 
    def getstate(self):
        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result
 
    def setstate(self, state):
        super().setstate(state[0])
        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state 
 
    def _generate(self):
        # Generate 256 random 32-bit values and save them in an internal field.
        # The actual random functions will dish out these values to callers.
        self.cc = (self.cc + 1) & INT_MASK
        self.bb = (self.bb + self.cc) & INT_MASK
 
        for i in range(256):
            x = self.mm[i]
            mod = i & 3
            if mod==0:
                self.aa ^= ((self.aa << 13) & INT_MASK)
            elif mod==1:
                self.aa ^= (self.aa >> 6)
            elif mod==2:
                self.aa ^= ((self.aa << 2) & INT_MASK)
            else: # mod == 3
                self.aa ^= (self.aa >> 16)
            self.aa = (self.mm[i^128] + self.aa) & INT_MASK
            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK
            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK
 
        self.rand_count = 0
 
    def next_int(self):
        """"""Return a random integer between 0 (inclusive) and 2**32 (exclusive).""""""
        if self.rand_count == 256:
            self._generate()
        result = self.rand_result[self.rand_count]
        self.rand_count += 1
        return result
 
    def getrandbits(self, k):
        """"""Return a random integer between 0 (inclusive) and 2**k (exclusive).""""""
        result = 0
        ints_needed = (k+31)//32
        ints_used = 0
        while ints_used < ints_needed:
            if self.rand_count == 256:
                self._generate()
            ints_to_take = min(256-self.rand_count, ints_needed)
            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:
                result = (result << 32) | val
            self.rand_count += ints_to_take
            ints_used += ints_to_take
        result &= ((1<<k)-1)    # mask off extra bits, if any
        return result
 
    def random(self):
        """"""Return a random float between 0 (inclusive) and 1 (exclusive).""""""
        # A double stores 53 significant bits, so scale a 53-bit integer into the [0..1) range.
        return self.getrandbits(53) * (2**-53)
 
    def rand_char(self):
        """"""Return a random integer from the printable ASCII range [32..126].""""""
        return self.next_int() % 95 + 32
 
    def vernam(self, msg):
        """"""
        Encrypt/decrypt the given bytes object with the XOR algorithm, using the current generator state.
 
        To decrypt an encrypted string, restore the state of the generator to the state it had
        during encryption, then call this method with the encrypted string.
        """"""
        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)
 
    # Constants for selecting Caesar operation modes.
    ENCIPHER = 'encipher'
    DECIPHER = 'decipher'
 
    @staticmethod
    def _caesar(ciphermode, ch, shift, modulo, start):
        if ciphermode == IsaacRandom.DECIPHER:
            shift = -shift
        n = ((ch-start)+shift) % modulo
        if n<0:
            n += modulo
        return start+n
 
    def caesar(self, ciphermode, msg, modulo, start):
        """"""
        Encrypt/decrypt a string using the Caesar algorithm.
 
        For decryption to work, the generator must be in the same state it was during encryption,
        and the same modulo and start parameters must be used.
 
        ciphermode must be one of IsaacRandom.ENCIPHER or IsaacRandom.DECIPHER.
        """"""
        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)
 
if __name__=='__main__':
    import binascii
 
    def hexify(b):
        return binascii.hexlify(b).decode('ascii').upper()
 
    MOD = 95
    START = 32
 
    msg = 'a Top Secret secret'
    key = 'this is my secret key'
    isaac_random = IsaacRandom(key)
    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))
    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)
    isaac_random.seed(key)
    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')
    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')
 
    print('Message:', msg)
    print('Key    :', key)
    print('XOR    :', hexify(vernam_encoded))
    print('XOR dcr:', vernam_decoded)
    print('MOD    :', hexify(caesar_encoded))
    print('MOD dcr:', caesar_decoded)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Optional_parameters,Optional parameters,"Task

Define a function/method/subroutine which sorts a sequence (""table"") of sequences (""rows"") of strings (""cells""), by one of the strings. Besides the input to be sorted, it shall have the following optional parameters:





 ordering
 A function specifying the ordering of strings; lexicographic by default.
 column
 An integer specifying which string of each row to compare; the first by default.
 reverse
 Reverses the ordering.


This task should be considered to include both positional and named optional parameters, as well as overloading on argument count as in Java or selector name as in Smalltalk, or, in the extreme, using different function names. Provide these variations of sorting in whatever way is most natural to your language. If the language supports both methods naturally, you are encouraged to describe both.

Do not implement a sorting algorithm; this task is about the interface. If you can't use a built-in sort routine, just omit the implementation (with a comment).

See also:

 Named Arguments

",Python,">>> def printtable(data):
    for row in data:
        print ' '.join('%-5s' % ('""%s""' % cell) for cell in row)
 
 
>>> import operator
>>> def sorttable(table, ordering=None, column=0, reverse=False):
    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)
 
>>> data = [[""a"", ""b"", ""c""], ["""", ""q"", ""z""], [""zap"", ""zip"", ""Zot""]]
>>> printtable(data)
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
""zap"" ""zip"" ""Zot""
>>> printtable( sorttable(data) )
""""    ""q""   ""z""  
""a""   ""b""   ""c""  
""zap"" ""zip"" ""Zot""
>>> printtable( sorttable(data, column=2) )
""zap"" ""zip"" ""Zot""
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
>>> printtable( sorttable(data, column=1) )
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
""zap"" ""zip"" ""Zot""
>>> printtable( sorttable(data, column=1, reverse=True) )
""zap"" ""zip"" ""Zot""
""""    ""q""   ""z""  
""a""   ""b""   ""c""  
>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )
""zap"" ""zip"" ""Zot""
""a""   ""b""   ""c""  
""""    ""q""   ""z""  
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Draw_a_clock,Draw a clock,"Task

Draw a clock.



More specific:

 Draw a time keeping device. It can be a stopwatch, hourglass, sundial, a mouth counting ""one thousand and one"", anything. Only showing the seconds is required, e.g.: a watch with just a second hand will suffice. However, it must clearly change every second, and the change must cycle every so often (one minute, 30 seconds, etc.) It must be drawn; printing a string of numbers to your terminal doesn't qualify. Both text-based and graphical drawing are OK.
 The clock is unlikely to be used to control space flights, so it needs not be hyper-accurate, but it should be usable, meaning if one can read the seconds off the clock, it must agree with the system clock.
 A clock is rarely (never?) a major application: don't be a CPU hog and poll the system timer every microsecond, use a proper timer/signal/event from your system or language instead. For a bad example, many OpenGL programs update the frame-buffer in a busy loop even if no redraw is needed, which is very undesirable for this task.
 A clock is rarely (never?) a major application: try to keep your code simple and to the point. Don't write something too elaborate or convoluted, instead do whatever is natural, concise and clear in your language.


Key points
 animate simple object
 timed event 
 polling system resources 
 code clarity

",Python,"import time
 
def chunks(l, n=5):
    return [l[i:i+n] for i in range(0, len(l), n)]
 
def binary(n, digits=8):
    n=int(n)
    return '{0:0{1}b}'.format(n, digits)
 
def secs(n):
    n=int(n)
    h='x' * n
    return ""|"".join(chunks(h))
 
def bin_bit(h):
    h=h.replace(""1"",""x"")
    h=h.replace(""0"","" "")
    return ""|"".join(list(h))
 
 
x=str(time.ctime()).split()
y=x[3].split("":"")
 
s=y[-1]
y=map(binary,y[:-1])
 
print bin_bit(y[0])
print
print bin_bit(y[1])
print
print secs(s)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Word_frequency,Word frequency,"Task

Given a text file and an integer   n,   print/display the   n   most
common words in the file   (and the number of their occurrences)   in decreasing frequency.



For the purposes of this task:

   A word is a sequence of one or more contiguous letters.
   You are free to define what a   letter   is. 
   Underscores, accented letters, apostrophes, hyphens, and other special characters can be handled at your discretion.
   You may treat a compound word like   well-dressed   as either one word or two. 
   The word   it's   could also be one or two words as you see fit. 
   You may also choose not to support non US-ASCII characters. 
   Assume words will not span multiple lines.
   Don't worry about normalization of word spelling differences. 
   Treat   color   and   colour   as two distinct words.
   Uppercase letters are considered equivalent to their lowercase counterparts.
   Words of equal frequency can be listed in any order.
   Feel free to explicitly state the thoughts behind the program decisions.


Show example output using Les Misérables from Project Gutenberg as the text file input and display the top   10   most used words.



History

This task was originally taken from programming pearls from Communications of the ACM June 1986 Volume 29 Number 6
where this problem is solved by Donald Knuth using literate programming and then critiqued by Doug McIlroy,
demonstrating solving the problem in a 6 line Unix shell script (provided as an example below).



References

McIlroy's program



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import collections
import re
import string
import sys
 
def main():
  counter = collections.Counter(re.findall(r""\w+"",open(sys.argv[1]).read().lower()))
  print counter.most_common(int(sys.argv[2]))
 
if __name__ == ""__main__"":
  main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Merge_and_aggregate_datasets,Merge and aggregate datasets,"Merge and aggregate datasets



Task

Merge and aggregate two datasets as provided in   .csv   files into a new resulting dataset.

Use the appropriate methods and data structures depending on the programming language.

Use the most common libraries only when built-in functionality is not sufficient.



Note

Either load the data from the   .csv   files or create the required data structures hard-coded.


patients.csv   file contents:

PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz


visits.csv   file contents:

PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3



Create a resulting dataset in-memory or output it to screen or file, whichever is appropriate for the programming language at hand.

Merge and group per patient id and last name,   get the maximum visit date,   and get the sum and average of the scores per patient to get the resulting dataset.



Note that the visit date is purposefully provided as ISO format,   so that it could also be processed as text and sorted alphabetically to determine the maximum date.

| PATIENT_ID | LASTNAME | LAST_VISIT |  SCORE_SUM | SCORE_AVG |
| 1001       |  Hopper  | 2020-11-19 |  17.4      | 5.80      |
| 2002       |  Gosling | 2020-10-08 |   6.8      | 6.80      |
| 3003       |  Kemeny  | 2020-11-12 |            |           |
| 4004       |  Wirth   | 2020-11-05 |  15.4      | 7.70      |
| 5005       |  Kurtz   |            |            |           |



Note

This task is aimed in particular at programming languages that are used in data science and data processing, such as F#, Python, R, SPSS, MATLAB etc.



Related tasks

 CSV data manipulation
 CSV to HTML translation
 Read entire file
 Read a file line by line

",Python,"# to install pandas library go to cmd prompt and type:
# cd %USERPROFILE%\AppData\Local\Programs\Python\Python38-32\Scripts\
# pip install pandas
import pandas as pd
 
# load data from csv files
df_patients = pd.read_csv (r'patients.csv', sep = "","", decimal=""."")
df_visits = pd.read_csv (r'visits.csv', sep = "","", decimal=""."")
 
''' # load data hard coded, create data frames
import io
str_patients = """"""PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz
""""""
df_patients = pd.read_csv(io.StringIO(str_patients), sep = "","", decimal=""."")
str_visits = """"""PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3
""""""
df_visits = pd.read_csv(io.StringIO(str_visits), sep = "","", decimal=""."")
'''
 
# typecast from string to datetime so .agg can 'max' it
df_visits['VISIT_DATE'] = pd.to_datetime(df_visits['VISIT_DATE'])
 
# merge on PATIENT_ID
df_merge = df_patients.merge(df_visits, on='PATIENT_ID', how='left')
 
# groupby is an intermediate object
df_group = df_merge.groupby(['PATIENT_ID','LASTNAME'], as_index=False)
 
# note: you can use 'sum' instead of the lambda function but that returns NaN as 0 (zero)
df_result = df_group.agg({'VISIT_DATE': 'max', 'SCORE': [lambda x: x.sum(min_count=1),'mean']})
 
print(df_result)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Flipping_bits_game,Flipping bits game,"The game

Given an   N×N   square array of zeroes or ones in an initial configuration,   and a target configuration of zeroes and ones.



The game is to transform one to the other in as few moves as possible by inverting whole numbered rows or whole lettered
columns at once   (as one move).

In an inversion.   any  1  becomes  0,   and any  0  becomes  1  for that whole row or column.



Task

Create a program to score for the Flipping bits game.

 The game should create an original random target configuration and a starting configuration.
 Ensure that the starting position is never the target position.
 The target position must be guaranteed as reachable from the starting position.   (One possible way to do this is to generate the start position by legal flips from a random target position.   The flips will always be reversible back to the target from the given start position).
 The number of moves taken so far should be shown.


Show an example of a short game here, on this page, for a   3×3   array of bits.



",Python,"class FlipBoard:
    def __init__(self, size):
        if size < 2:
            raise ValueError(""Invalid board size: %s"" % size)
        self.size = size
        self.board = [0] * size**2
        self.randomize_board()
        while True:
            self.target = self.generate_target()
            if not self.solved():
                break
        self.columns = [chr(ord('a') + i) for i in range(self.size)]
        self.rows = [str(i) for i in range(1, self.size + 1)]

    def play(self):
        moves = 0
        print(""your target:"")
        print(self.target)
        while not self.solved():
            print("""")
            print(""move %s:"" % moves)
            print(self)
            print(""Row/column to flip: "", end="""")
            ans = input()
            if ans in self.columns:
                self.flip_column(self.columns.index(ans))
                moves += 1
            elif ans in self.rows:
                self.flip_row(self.rows.index(ans))
                moves += 1
            else:
                print(""invalid input: %s"" % ans)
        print("""")
        print(""you solved the game in %s moves"" % moves)
        print(self)

    def target(self):
        return self.format_array(self.target)

    def __str__(self):
        return self.format_array(self.board)

    def solved(self):
        return self.board == self.target

    def randomize_board(self):
        for i in range(self.size + random.randint(0, self.size)):
            self.flip_bit(random.randint(0, self.size - 1), random.randint(0, self.size - 1))

    def generate_target(self):
        orig_board = self.board[:]
        for i in range(self.size + random.randint(0, self.size)):
            if random.randint(0, 1) == 0:
                self.flip_row(random.randint(0, self.size - 1))
            else:
                self.flip_column(random.randint(0, self.size - 1))
        target, self.board = self.board, orig_board
        return target

    def flip_row(self, row):
        for col in range(self.size):
            self.flip_bit(row, col)

    def flip_column(self, col):
        for row in range(self.size):
            self.flip_bit(row, col)

    def flip_bit(self, row, col):
        self.board[self.size * row + col] ^= 1

    def format_array(self, ary):
        str = ""   "" + "" "".join(self.columns) + ""\n""
        for row in range(self.size):
            str += ""%2s "" % self.rows[row] + "" "".join(map(str, ary[self.size*row:self.size*row + self.size])) + ""\n""
        return str

if __name__ == ""__main__"":
    try:
        FlipBoard(int(sys.argv[1])).play()
    except ValueError as e:
        print(e)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Execute_Brain****,Execute Brain****,"Execute Brain**** is an implementation of Brainf***.
Other implementations of Brainf***.
RCBF is a set of Brainf*** compilers and interpreters written for Rosetta Code in a variety of languages.

Below are links to each of the versions of RCBF.

An implementation need only properly implement the following instructions:



Command

Description


 > 
 Move the pointer to the right


 < 
 Move the pointer to the left


 + 
 Increment the memory cell under the pointer


 - 
 Decrement the memory cell under the pointer


 . 
 Output the character signified by the cell at the pointer


 , 
 Input a character and store it in the cell at the pointer


 [ 
 Jump past the matching ] if the cell under the pointer is 0


 ] 
 Jump back to the matching [ if the cell under the pointer is nonzero

Any cell size is allowed,   EOF   (End-O-File)   support is optional, as is whether you have bounded or unbounded memory.



",Python,"#
# python bf interpreter
# by 
#
 
def execute(code):
    mem = [0] * 30000
    sp = 10000
    opcode = code
    oplen = len(opcode)
    ip = 0
    loopstack = []
    output = """"
 
    while ip < oplen:
        if opcode[ip] == '+':
            mem[sp] += 1
        elif opcode[ip] == '-':
            mem[sp] -= 1
        elif opcode[ip] == '>':
            sp += 1
        elif opcode[ip] == '<':
            sp -= 1
        elif opcode[ip] == '.':
            if mem[sp]!= 10 and mem[sp]!= 13:
                output += chr(mem[sp])
            else:
                print output
                output = """"
        elif opcode[ip] == ',':
            s = raw_input()
            if not s:
                exit(0)
 
            mem[sp] = ord(s[0])
        elif opcode[ip] == '[':
            if mem[sp]:
                loopstack.append(ip)
            else:
                for k in range(ip, oplen):
                    if opcode[k] == '[':
                        j += 1
                    elif opcode[k] == ']':
                        j -= 1
                    if j == 0:
                        break
                if j == 0:
                    ip = k
                else:
                    print ""Unmatched loop""
                    return False
        elif opcode[ip] == ']':
            ip = loopstack.pop() - 1
        ip += 1
    return True
 
if __name__ == '__main__':
    execute('
    ++++++++++[>+>+++>++++>+++++++ >++++++++>+++++++++>++++++++++>+++++++++
    ++>++++++++++++<<<<<<<<<-]>>>>+.>>>>+..<.<++++++++.>>>+.<<+.<<<<++++.<+
    +.>>>+++++++.>>>.+++.<+++++++.--------.<<<<<+.<+++.---.
')",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Luhn test of credit card numbers,"The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.

Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

 Reverse the order of the digits in the number.
 Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
 Taking the second, fourth ... and every other even digit in the reversed digits:
 Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
 Sum the partial sums of the even digits to form s2
 If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.


For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and

use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



Related tasks

   SEDOL
   ISIN

",Python,"def luhnTest(number):
    s1 = 0
    s2 = 0
    reverse = number[::-1]
    for i in range(len(reverse)):
        digit = int(reverse[i])
        if i % 2 == 0:
            s1 += digit
        else:
            s2 += 2 * digit
            if digit >= 5:
                s2 -= 9
    return (s1 + s2) % 10 == 0

print(luhnTest(""49927398716""))
print(luhnTest(""49927398717""))
print(luhnTest(""1234567812345678""))
print(luhnTest(""1234567812345670""))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Modular_arithmetic,Modular arithmetic,"Modular arithmetic is a form of arithmetic (a calculation technique involving the concepts of addition and multiplication) which is done on numbers with a defined equivalence relation called congruence.

For any positive integer 



p


{\displaystyle p}

 called the congruence modulus,
two numbers 



a


{\displaystyle a}

 and 



b


{\displaystyle b}

 are said to be congruent modulo p whenever there exists an integer 



k


{\displaystyle k}

 such that:





a
=
b
+
k

p


{\displaystyle a=b+k\,p}


The corresponding set of equivalence classes forms a ring denoted 






Z


p

Z






{\displaystyle {\frac {\mathbb {Z} }{p\mathbb {Z} }}}

.

Addition and multiplication on this ring have the same algebraic structure as in usual arithmetics, so that a function such as a polynomial expression could receive a ring element as argument and give a consistent result.

The purpose of this task is to show, if your programming language allows it,
how to redefine operators so that they can be used transparently on modular integers.
You can do it either by using a dedicated library, or by implementing your own class.

You will use the following function for demonstration:





f
(
x
)
=

x

100


+
x
+
1


{\displaystyle f(x)=x^{100}+x+1}


You will use 



13


{\displaystyle 13}

 as the congruence modulus and you will compute 



f
(
10
)


{\displaystyle f(10)}

.

It is important that the function 



f


{\displaystyle f}

 is agnostic about whether or not its argument is modular; it should behave the same way with normal and modular integers.
In other words, the function is an algebraic expression that could be used with any ring, not just integers.



",Python,"class ModularArithmetic:
    def __init__(self, value, modulus):
        self.value = value % modulus
        self.modulus = modulus
 
    def __str__(self):
        return ""ModularArithmetic(%d, %d)"" % (self.value, self.modulus)
 
def make(value, modulus):
    return ModularArithmetic(value, modulus)
 
def add(a, b):
    return make(a.value + b.value, a.modulus)
 
def addi(a, v):
    return make(a.value + v, a.modulus)
 
def mul(a, b):
    return make(a.value * b.value, a.modulus)
 
def pow(b, pow):
    r = make(1, b.modulus)
    while pow > 0:
        r = mul(r, b)
        pow -= 1
    return r
 
def f(x):
    return addi(add(pow(x, 100), x), 1)
 
input = make(10, 13)
output = f(input)
 
print(""f(%s) = %s"" % (input, output))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Least_common_multiple,Least common multiple,"Least common multiple

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Compute the   least common multiple   (LCM)   of two integers.

Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors.



Example

The least common multiple of   12   and   18   is   36,       because:

   12   is a factor     (12 × 3 = 36),     and 
   18   is a factor     (18 × 2 = 36),     and 
   there is no positive integer less than   36   that has both factors. 


As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.



One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.

If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.



 



lcm
⁡
(
m
,
n
)
=




|

m
×
n

|



gcd
⁡
(
m
,
n
)





{\displaystyle \operatorname {lcm} (m,n)={\frac {|m\times n|}{\operatorname {gcd} (m,n)}}}




One can also find   lcm   by merging the prime decompositions of both   m   and   n.



Related task
   greatest common divisor.


See also

   MathWorld entry:   Least Common Multiple.
   Wikipedia entry:   Least common multiple.

",Python,">>> import fractions
>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0
 
>>> lcm(12, 18)
36
>>> lcm(-6, 14)
42
>>> assert lcm(0, 2) == lcm(2, 0) == 0
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Zig-zag_matrix,Zig-zag matrix,"Task

Produce a zig-zag array.



A   zig-zag   array is a square arrangement of the first   N2   natural numbers,   where the

numbers increase sequentially as you zig-zag along the array's   anti-diagonals.

For a graphical representation, see   JPG zigzag   (JPG uses such arrays to encode images).



For example, given   5,   produce this array:

 0  1  5  6 14
 2  4  7 13 15
 3  8 12 16 21
 9 11 17 20 22
10 18 19 23 24



Related tasks

   Spiral matrix
   Identity matrix
   Ulam spiral (for primes)


See also

   Wiktionary entry:   anti-diagonals

",Python,"def zigzag(n):
    '''zigzag rows'''
    def compare(xy):
        x, y = xy
        return (x + y, -y if (x + y) % 2 else y)
    xs = range(n)
    return {index: n for n, index in enumerate(sorted(
        ((x, y) for x in xs for y in xs),
        key=compare
    ))}
 
 
def printzz(myarray):
    '''show zigzag rows as lines'''
    n = int(len(myarray) ** 0.5 + 0.5)
    xs = range(n)
    print('\n'.join(
        [''.join(""%3i"" % myarray[(x, y)] for x in xs) for y in xs]
    ))
 
 
printzz(zigzag(6))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Cholesky_decomposition,Cholesky decomposition,"Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:





A
=
L

L

T




{\displaystyle A=LL^{T}}






L


{\displaystyle L}

 is called the Cholesky factor of 



A


{\displaystyle A}

, and can be interpreted as a generalized square root of 



A


{\displaystyle A}

, as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:









A



=


(




a

11





a

21





a

31







a

21





a

22





a

32







a

31





a

32





a

33





)








=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




l

11





l

21





l

31






0



l

22





l

32






0


0



l

33





)


≡
L

L

T








=


(




l

11


2





l

21



l

11





l

31



l

11







l

21



l

11





l

21


2


+

l

22


2





l

31



l

21


+

l

32



l

22







l

31



l

11





l

31



l

21


+

l

32



l

22





l

31


2


+

l

32


2


+

l

33


2





)








{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a_{11}&a_{21}&a_{31}\\a_{21}&a_{22}&a_{32}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}\\&={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}l_{11}&l_{21}&l_{31}\\0&l_{22}&l_{32}\\0&0&l_{33}\end{pmatrix}}\equiv LL^{T}\\&={\begin{pmatrix}l_{11}^{2}&l_{21}l_{11}&l_{31}l_{11}\\l_{21}l_{11}&l_{21}^{2}+l_{22}^{2}&l_{31}l_{21}+l_{32}l_{22}\\l_{31}l_{11}&l_{31}l_{21}+l_{32}l_{22}&l_{31}^{2}+l_{32}^{2}+l_{33}^{2}\end{pmatrix}}\end{aligned}}}


We can see that for the diagonal elements (




l

k
k




{\displaystyle l_{kk}}

) of 



L


{\displaystyle L}

 there is a calculation pattern:






l

11


=



a

11






{\displaystyle l_{11}={\sqrt {a_{11}}}}







l

22


=



a

22


−

l

21


2






{\displaystyle l_{22}={\sqrt {a_{22}-l_{21}^{2}}}}







l

33


=



a

33


−
(

l

31


2


+

l

32


2


)




{\displaystyle l_{33}={\sqrt {a_{33}-(l_{31}^{2}+l_{32}^{2})}}}


or in general:






l

k
k


=



a

k
k


−

∑

j
=
1


k
−
1



l

k
j


2






{\displaystyle l_{kk}={\sqrt {a_{kk}-\sum _{j=1}^{k-1}l_{kj}^{2}}}}


For the elements below the diagonal (




l

i
k




{\displaystyle l_{ik}}

, where 



i
>
k


{\displaystyle i>k}

) there is also a calculation pattern:






l

21


=


1

l

11





a

21




{\displaystyle l_{21}={\frac {1}{l_{11}}}a_{21}}







l

31


=


1

l

11





a

31




{\displaystyle l_{31}={\frac {1}{l_{11}}}a_{31}}







l

32


=


1

l

22




(

a

32


−

l

31



l

21


)


{\displaystyle l_{32}={\frac {1}{l_{22}}}(a_{32}-l_{31}l_{21})}


which can also be expressed in a general formula:






l

i
k


=


1

l

k
k





(

a

i
k


−

∑

j
=
1


k
−
1



l

i
j



l

k
j


)



{\displaystyle l_{ik}={\frac {1}{l_{kk}}}\left(a_{ik}-\sum _{j=1}^{k-1}l_{ij}l_{kj}\right)}


Task description

The task is to implement a routine which will return a lower Cholesky factor 



L


{\displaystyle L}

 for every given symmetric, positive definite nxn matrix 



A


{\displaystyle A}

. You should then test it on the following two examples and include your output.

Example 1:

25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

Example 2:

18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262



Note

 The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. 
 The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.",Python,"import math
import numpy as np
 
def is_symmetric(A):
    return np.allclose(A, A.T)
 
def cholesky_factor(A):
    if not is_symmetric(A):
        raise ValueError(""must provide symmetric matrix"")
    L = np.zeros(A.shape)
    for k in range(A.shape[0]):
        for i in range(k+1):
            if i == k:
                sum = 0
                for j in range(i):
                    sum += L[i,j] ** 2
                L[i,i] = math.sqrt(A[i,i] - sum)
            elif i < k:
                sum = 0
                for j in range(i):
                    sum += L[k,j] * L[i,j]
                L[k,i] = (A[i,k] - sum) / L[i,i]
    return L
 
print(cholesky_factor(np.array([[25,15,-5],[15,18,0],[-5,0,11]])))
print(cholesky_factor(np.array([[18, 22,  54,  42],
                                [22, 70,  86,  62],
                                [54, 86, 174, 134],
                                [42, 62, 134, 106]])))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime,Create a two-dimensional array at runtime,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
Get two integers from the user, then create a two-dimensional array where the two dimensions have the sizes given by those numbers, and which can be accessed in the most natural way possible. Write some element of that array, and then output that element. Finally destroy the array if not done by the language itself.
",Python,"def main():
    # build
    dim = [10, 15]
    array = [[0 for j in range(dim[1])] for i in range(dim[0])]

    # fill
    for i in range(dim[0]):
        for j in range(dim[1]):
            array[i][j] = 1 + i + j

    # print
    for i in range(dim[0]):
        print(array[i])

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Python,"def genfizzbuzz(factorwords, numbers):
    # sort entries by factor
    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])
    lines = []
    for num in numbers:
        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)
        lines.append(words if words else str(num))
    return '\n'.join(lines)
 
if __name__ == '__main__':
    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Prime_conspiracy,Prime conspiracy,"A recent discovery, quoted from   Quantamagazine   (March 13, 2016):

     Two mathematicians have uncovered a simple, previously unnoticed property of 
     prime numbers — those numbers that are divisible only by 1 and themselves.     
     Prime numbers, it seems, have decided preferences about the final digits of    
     the primes that immediately follow them.  

and

     This conspiracy among prime numbers seems, at first glance, to violate a     
     longstanding assumption in number theory:  that prime numbers behave much    
     like random numbers. 

                            ─── (original authors from Stanford University):      
                            ─── Kannan Soundararajan  and  Robert Lemke Oliver    



The task is to check this assertion, modulo 10.

Lets call    i -> j    a transition if    i    is the last decimal digit of a prime, and    j    the last decimal digit of the following prime.



Task

Considering the first one million primes.   Count, for any pair of successive primes, the number of transitions    i -> j    and print them along with their relative frequency, sorted by    i .

You can see that, for a given    i ,   frequencies are not evenly distributed.



Observation

(Modulo 10),   primes whose last digit is   9   ""prefer""   the digit   1   to the digit   9,   as its following prime.



Extra credit

Do the same for one hundred million primes.



Example for 10,000 primes

10000 first primes. Transitions prime % 10 → next-prime % 10.
1 → 1 count:        365 frequency: 3.65 %
1 → 3 count:        833 frequency: 8.33 %
1 → 7 count:        889 frequency: 8.89 %
1 → 9 count:        397 frequency: 3.97 %
2 → 3 count:          1 frequency: 0.01 %
3 → 1 count:        529 frequency: 5.29 %
3 → 3 count:        324 frequency: 3.24 %
3 → 5 count:          1 frequency: 0.01 %
3 → 7 count:        754 frequency: 7.54 %
3 → 9 count:        907 frequency: 9.07 %
5 → 7 count:          1 frequency: 0.01 %
7 → 1 count:        655 frequency: 6.55 %
7 → 3 count:        722 frequency: 7.22 %
7 → 7 count:        323 frequency: 3.23 %
7 → 9 count:        808 frequency: 8.08 %
9 → 1 count:        935 frequency: 9.35 %
9 → 3 count:        635 frequency: 6.35 %
9 → 7 count:        541 frequency: 5.41 %
9 → 9 count:        379 frequency: 3.79 % 


",Python,"def main():
    limit = 1000_000
    sieve_limit = 15_500_000

    buckets = [[0 for i in range(10)] for j in range(10)]
    prev_digit = 2
    not_prime = sieve(sieve_limit)

    for n in range(3, limit):
        if not_prime[n]:
            continue

        digit = n % 10
        buckets[prev_digit][digit] += 1
        prev_digit = digit

    for i in range(10):
        for j in range(10):
            if buckets[i][j]!= 0:
                print(f""{i} -> {j} : {buckets[i][j] / (limit / 100.0)}"")


def sieve(limit):
    composite = [False for i in range(limit)]
    composite[0] = composite[1] = True

    max = int(math.sqrt(limit))
    for n in range(2, max):
        if not composite[n]:
            for k in range(n * n, limit, n):
                composite[k] = True

    return composite


if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Lah_numbers,Lah numbers,"Lah numbers, sometimes referred to as Stirling numbers of the third kind, are coefficients of polynomial expansions expressing rising factorials in terms of falling factorials.

Unsigned Lah numbers count the number of ways a set of n elements can be partitioned into k non-empty linearly ordered subsets.

Lah numbers are closely related to Stirling numbers of the first & second kinds, and may be derived from them.

Lah numbers obey the identities and relations:

  L(n, 0), L(0, k) = 0   # for n, k > 0
  L(n, n) = 1
  L(n, 1) = n!
  L(n, k) =           ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For unsigned Lah numbers
     or
  L(n, k) = (-1)**n * ( n! * (n - 1)! ) / ( k! * (k - 1)! ) / (n - k)!      # For   signed Lah numbers

Task

 Write a routine (function, procedure, whatever) to find unsigned Lah numbers. There are several methods to generate unsigned Lah numbers. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the unsigned Lah numbers, L(n, k), up to L(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where L(n, k) == 0 (when k > n).
 If your language supports large integers, find and show here, on this page, the maximum value of L(n, k) where n == 100.


See also

 Wikipedia - Lah number
 OEIS:A105278 - Unsigned Lah numbers
 OEIS:A008297 - Signed Lah numbers


Related Tasks

 Stirling numbers of the first kind
 Stirling numbers of the second kind
 Bell numbers

",Python,"def factorial(n):
    if n == 0:
        return 1
    res = 1
    while n > 0:
        res *= n
        n -= 1
    return res
 
def lah(n,k):
    if k == 1:
        return factorial(n)
    if k == n:
        return 1
    if k > n:
        return 0
    if k < 1 or n < 1:
        return 0
    return (factorial(n) * factorial(n - 1)) / (factorial(k) * factorial(k - 1)) / factorial(n - k)
 
def main():
    print ""Unsigned Lah numbers: L(n, k):""
    print ""n/k "",
    for i in xrange(13):
        print ""%11d"" % i,
    print
    for row in xrange(13):
        print ""%-4d"" % row,
        for i in xrange(row + 1):
            l = lah(row, i)
            print ""%11d"" % l,
        print
    print ""\nMaximum value from the L(100, *) row:""
    maxVal = max([lah(100, a) for a in xrange(100)])
    print maxVal
 
main()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Multiple_distinct_objects,Multiple distinct objects,"Create a sequence (array, list, whatever) consisting of n distinct, initialized items of the same type. n should be determined at runtime.

By distinct we mean that if they are mutable, changes to one do not affect all others; if there is an appropriate equality operator they are considered unequal; etc. The code need not specify a particular kind of distinction, but do not use e.g. a numeric-range generator which does not generalize.

By initialized we mean that each item must be in a well-defined state appropriate for its type, rather than e.g. arbitrary previous memory contents in an array allocation. Do not show only an initialization technique which initializes only to ""zero"" values (e.g. calloc() or int a[n] = {}; in C), unless user-defined types can provide definitions of ""zero"" for that type.

This task was inspired by the common error of intending to do this, but instead creating a sequence of n references to the same mutable object; it might be informative to show the way to do that as well, both as a negative example and as how to do it when that's all that's actually necessary.

This task is most relevant to languages operating in the pass-references-by-value style (most object-oriented, garbage-collected, and/or 'dynamic' languages).

See also: Closures/Value capture
",Python,[Foo()] * n # here Foo() can be any expression that returns a new object,Human_written,Python_from_Go
http://rosettacode.org/wiki/Closures/Value_capture,Closures/Value capture,"Task

Create a list of ten functions, in the simplest manner possible   (anonymous functions are encouraged),   such that the function at index    i     (you may choose to start     i     from either    0    or    1),    when run, should return the square of the index,   that is,     i  2.

Display the result of running any but the last function, to demonstrate that the function indeed remembers its value.



Goal

Demonstrate how to create a series of independent closures based on the same template but maintain separate copies of the variable closed over.

In imperative languages, one would generally use a loop with a mutable counter variable.

For each function to maintain the correct number, it has to capture the value of the variable at the time it was created, rather than just a reference to the variable, which would have a different value by the time the function was run.

See also: Multiple distinct objects
",Python,"def main():
    fs = [lambda i=i: i*i for i in range(10)]
    print(""7th val: {}"".format(fs[7]()))

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body,Loops/Increment loop index within loop body,"Sometimes, one may need   (or want)   a loop which
its   iterator   (the index
variable)   is modified within the

loop body    in addition to the normal incrementation by the   (do)   loop structure index.



Goal

Demonstrate the best way to accomplish this.



Task

Write a loop which:

   starts the index (variable) at   42
   (at iteration time)   increments the index by unity
   if the index is prime:
   displays the count of primes found (so far) and the prime   (to the terminal)
   increments the index such that the new index is now the (old) index plus that prime
   terminates the loop when   42   primes are shown


Extra credit:   because of the primes get rather large, use commas
within the displayed primes to ease comprehension.



Show all output here.



Note

Not all programming languages allow the modification of a
loop's index.   If that is the case, then use whatever method that
is appropriate or idiomatic for that language.   Please add a note
if the loop's index isn't modifiable.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"def isPrime(n):
    for x in 2, 3:
        if not n % x:
            return n == x
    d = 5
    while d * d <= n:
        for x in 2, 4:
            if not n % d:
                return False
            d += x
    return True
 
i = 42
n = 0
while n < 42:
    if isPrime(i):
        n += 1
        print('n = {:2} {:20,}'.format(n, i))
        i += i - 1
    i += 1",Human_written,Python_from_C++
http://rosettacode.org/wiki/Plasma_effect,Plasma effect,"The plasma effect is a visual effect created by applying various functions, notably sine and cosine, to the color values of screen pixels. When animated (not a task requirement) the effect may give the impression of a colorful flowing liquid.



Task
Create a plasma effect.




See also
 Computer Graphics Tutorial (lodev.org)
 Plasma (bidouille.org)

",Python,"import math
import colorsys
from PIL import Image
 
def plasma (w, h):
	out = Image.new(""RGB"", (w, h))
	pix = out.load()
	for x in range (w):
		for y in range(h):
			hue = 4.0 + math.sin(x / 19.0) + math.sin(y / 9.0) \
				+ math.sin((x + y) / 25.0) + math.sin(math.sqrt(x**2.0 + y**2.0) / 8.0)
			hsv = colorsys.hsv_to_rgb(hue/8.0, 1, 1)
			pix[x, y] = tuple([int(round(c * 255.0)) for c in hsv])
	return out
 
if __name__==""__main__"":
	im = plasma(400, 400)
	im.show()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Play_recorded_sounds,Play recorded sounds,"Load at least two prerecorded sounds, and demonstrate as many of these features as you can:

 playing them individually and simultaneously
 stopping before the end of the sound
 looping (preferably glitch-free)
 setting the volume of each sound
 stereo or 3D positional mixing
 performing other actions when marked times in the sound arrive
Describe:

 The supported audio formats, briefly.
 Whether it is suitable for game sound effects (low-latency start, resource efficiency, supports many simultaneous sounds, etc.)
 Whether it is suitable for playing music (long duration ).
[Note: If it seems to be a good idea, this task may be revised to specify a particular timeline rather than just 'demonstrate these features'.]

Where applicable, please categorize examples primarily by the audio facility used (library/API/program/platform) rather than the language if the language is incidental (e.g. ""Mac OS X CoreAudio"" or ""mplayer"" rather than ""C"" or ""bash"").
",Python,"import subprocess
import sys
 
args = [
    ""-m"", ""-v"", ""0.75"", ""a.wav"", ""-v"", ""0.25"", ""b.wav"",
    ""-d"",
    ""trim"", ""4"", ""6"",
    ""repeat"", ""5"",
]
subprocess.call([""sox""] + args)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Yellowstone_sequence,Yellowstone sequence,"The Yellowstone sequence, also called the Yellowstone permutation, is defined as:

For n <= 3,

   a(n) = n

For n >= 4,

   a(n) = the smallest number not already in sequence such that a(n) is relatively prime to a(n-1) and 
          is not relatively prime to a(n-2).



The sequence is a permutation of the natural numbers, and gets its name from what its authors felt was a spiking, geyser like appearance of a plot of the sequence.



Example

a(4) is 4 because 4 is the smallest number following 1, 2, 3 in the sequence that is relatively prime to the entry before it (3), and is not relatively prime to the number two entries before it (2).



Task
 Find and show as output the first  30  Yellowstone numbers.


Extra
 Demonstrate how to plot, with x = n and y coordinate a(n), the first 100 Yellowstone numbers.


Related tasks

   Greatest common divisor.
   Plot coordinate pairs.


See also

   The OEIS entry:   A098550 The Yellowstone permutation.
   Applegate et al, 2015: The Yellowstone Permutation [1].

",Python,"'''Yellowstone permutation OEIS A098550'''
 
from itertools import chain, count, islice
from operator import itemgetter
from math import gcd
 
from matplotlib import pyplot
 
 
# yellowstone :: [Int]
def yellowstone():
    '''A non-finite stream of terms from
       the Yellowstone permutation.
       OEIS A098550.
    '''
    # relativelyPrime :: Int -> Int -> Bool
    def relativelyPrime(a):
        return lambda b: 1 == gcd(a, b)
 
    # nextWindow :: (Int, Int, [Int]) -> (Int, Int, [Int])
    def nextWindow(triple):
        p2, p1, rest = triple
        [rp2, rp1] = map(relativelyPrime, [p2, p1])
 
        # match :: [Int] -> (Int, [Int])
        def match(xxs):
            x, xs = uncons(xxs)['Just']
            return (x, xs) if rp1(x) and not rp2(x) else (
                second(cons(x))(
                    match(xs)
                )
            )
        n, residue = match(rest)
        return (p1, n, residue)
 
    return chain(
        range(1, 3),
        map(
            itemgetter(1),
            iterate(nextWindow)(
                (2, 3, count(4))
            )
        )
    )
 
 
# TEST ----------------------------------------------------
# main :: IO ()
def main():
    '''Terms of the Yellowstone permutation.'''
 
    print(showList(
        take(30)(yellowstone())
    ))
    pyplot.plot(
        take(100)(yellowstone())
    )
    pyplot.xlabel(main.__doc__)
    pyplot.show()
 
 
# GENERIC -------------------------------------------------
 
# Just :: a -> Maybe a
def Just(x):
    '''Constructor for an inhabited Maybe (option type) value.
       Wrapper containing the result of a computation.
    '''
    return {'type': 'Maybe', 'Nothing': False, 'Just': x}
 
 
# Nothing :: Maybe a
def Nothing():
    '''Constructor for an empty Maybe (option type) value.
       Empty wrapper returned where a computation is not possible.
    '''
    return {'type': 'Maybe', 'Nothing': True}
 
 
# cons :: a -> [a] -> [a]
def cons(x):
    '''Construction of a list from x as head,
       and xs as tail.
    '''
    return lambda xs: [x] + xs if (
        isinstance(xs, list)
    ) else x + xs if (
        isinstance(xs, str)
    ) else chain([x], xs)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
# second :: (a -> b) -> ((c, a) -> (c, b))
def second(f):
    '''A simple function lifted to a function over a tuple,
       with f applied only to the second of two values.
    '''
    return lambda xy: (xy[0], f(xy[1]))
 
 
# showList :: [a] -> String
def showList(xs):
    '''Stringification of a list.'''
    return '[' + ','.join(repr(x) for x in xs) + ']'
 
 
# take :: Int -> [a] -> [a]
# take :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.
    '''
    return lambda xs: (
        xs[0:n]
        if isinstance(xs, (list, tuple))
        else list(islice(xs, n))
    )
 
 
# uncons :: [a] -> Maybe (a, [a])
def uncons(xs):
    '''The deconstruction of a non-empty list
       (or generator stream) into two parts:
       a head value, and the remaining values.
    '''
    if isinstance(xs, list):
        return Just((xs[0], xs[1:])) if xs else Nothing()
    else:
        nxt = take(1)(xs)
        return Just((nxt[0], xs)) if nxt else Nothing()
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Order_two_numerical_lists,Order two numerical lists,"sorting

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Write a function that orders two lists or arrays filled with numbers.
The function should accept two lists as arguments and return true if the first list should be ordered before the second, and false otherwise.

The order is determined by lexicographic order: Comparing the first element of each list.
If the first elements are equal, then the second elements should be compared, and so on, until one of the list has no more elements.
If the first list runs out of elements the result is true.
If the second list or both run out of elements the result is false.

Note: further clarification of lexicographical ordering is expounded on the talk page here and here.
",Python,"import numpy as np

a = np.array([1, 2, 1, 3, 2])
b = np.array([1, 2, 0, 4, 4, 0, 0, 0])

a < b",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Hello_world/Text,Hello world/Text,"Hello world/Text is part of Short Circuit's Console Program Basics selection.
Task

Display the string Hello world! on a text console.

Related tasks

   Hello world/Graphical
   Hello world/Line Printer
   Hello world/Newbie
   Hello world/Newline omission
   Hello world/Standard error
   Hello world/Web server

",Python,"print ""Hello world!""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",Python,"import sys
import clr
clr.AddReference(""System"")
from System import *
from System.Reflection import *
 
class Rosetta:
    @staticmethod
    def Main():
        #Let's get all methods, not just public ones.
        flags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly
 
        for method in TestForMethodReflection.GetMethods(flags):
            Console.WriteLine(method)
 
class TestForMethodReflection:
    def MyPublicMethod(self):
        pass
    def MyPrivateMethod(self):
        pass
 
    @staticmethod
    def MyPublicStaticMethod():
        pass
    @staticmethod
    def MyPrivateStaticMethod():
        pass
 
if __name__ == '__main__':
    import sys
    Rosetta.Main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Multi-dimensional_array,Multi-dimensional array,"For the purposes of this task, the actual memory layout or access method of this data structure is not mandated.

It is enough to:

 State the number and extent of each index to the array.
 Provide specific, ordered, integer indices for all dimensions of the array together with a new value to update the indexed value.
 Provide specific, ordered, numeric indices for all dimensions of the array to obtain the arrays value at that indexed position.


Task

 State if the language supports multi-dimensional arrays in its syntax and usual implementation.
 State whether the language uses row-major or column major order for multi-dimensional array storage, or any other relevant kind of storage.
 Show how to create a four dimensional array in your language and set, access, set to another value; and access the new value of an integer-indexed item of the array.
 The idiomatic method for the language is preferred.
 The array should allow a range of five, four, three and two (or two three four five if convenient), in each of the indices, in order. (For example, if indexing starts at zero for the first index then a range of 0..4 inclusive would suffice).
 State if memory allocation is optimised for the array - especially if contiguous memory is likely to be allocated.
 If the language has exceptional native multi-dimensional array support such as optional bounds checking, reshaping, or being able to state both the lower and upper bounds of index ranges, then this is the task to mention them.


Show all output here, (but you may judiciously use ellipses to shorten repetitive output text).



",Python,">>> from pprint import pprint as pp   # Pretty printer
>>> from itertools import product
>>> 
>>> def dict_as_mdarray(dimensions=(2, 3), init=0.0):
...     return {indices: init for indices in product(*(range(i) for i in dimensions))}
... 
>>> 
>>> mdarray = dict_as_mdarray((2, 3, 4, 5))
>>> pp(mdarray)
{(0, 0, 0, 0): 0.0,
 (0, 0, 0, 1): 0.0,
 (0, 0, 0, 2): 0.0,
 (0, 0, 0, 3): 0.0,
 (0, 0, 0, 4): 0.0,
 (0, 0, 1, 0): 0.0,
...
 (1, 2, 3, 0): 0.0,
 (1, 2, 3, 1): 0.0,
 (1, 2, 3, 2): 0.0,
 (1, 2, 3, 3): 0.0,
 (1, 2, 3, 4): 0.0}
>>> mdarray[(0, 1, 2, 3)]
0.0
>>> mdarray[(0, 1, 2, 3)] = 6.78
>>> mdarray[(0, 1, 2, 3)]
6.78
>>> mdarray[(0, 1, 2, 3)] = 5.4321
>>> mdarray[(0, 1, 2, 3)]
5.4321
>>> pp(mdarray)
{(0, 0, 0, 0): 0.0,
 (0, 0, 0, 1): 0.0,
 (0, 0, 0, 2): 0.0,
...
 (0, 1, 2, 2): 0.0,
 (0, 1, 2, 3): 5.4321,
 (0, 1, 2, 4): 0.0,
...
 (1, 2, 3, 3): 0.0,
 (1, 2, 3, 4): 0.0}
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Distributed_programming,Distributed programming,"Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.

The protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.

This task is intended to demonstrate high-level communication facilities beyond just creating sockets.
",Python,"import xmlrpclib
import sys
 
if len(sys.argv)!= 2:
    print ""Usage: %s <number>"" % sys.argv[0]
    sys.exit(1)
 
proxy = xmlrpclib.ServerProxy(""http://localhost:1234"")
try:
    print proxy.TaxComputer.Tax(float(sys.argv[1]))
except Exception, err:
    print ""ERROR:"", err",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Proper_divisors,Proper divisors,"The   proper divisors   of a positive integer N are those numbers, other than N itself, that divide N without remainder.

For N > 1 they will always include 1,   but for N == 1 there are no proper divisors.



Examples

The proper divisors of     6     are   1, 2, and 3.

The proper divisors of   100   are   1, 2, 4, 5, 10, 20, 25, and 50.



Task

 Create a routine to generate all the proper divisors of a number.
 use it to show the proper divisors of the numbers 1 to 10 inclusive.
 Find a number in the range 1 to 20,000 with the most proper divisors. Show the number and just the count of how many proper divisors it has.


Show all output here.



Related tasks

   Amicable pairs
   Abundant, deficient and perfect number classifications
   Aliquot sequence classifications
   Factors of an integer
   Prime decomposition

",Python,">>> def proper_divs2(n):
...     return {x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x}
... 
>>> [proper_divs2(n) for n in range(1, 11)]
[set(), {1}, {1}, {1, 2}, {1}, {1, 2, 3}, {1}, {1, 2, 4}, {1, 3}, {1, 2, 5}]
>>> 
>>> n, length = max(((n, len(proper_divs2(n))) for n in range(1, 20001)), key=lambda pd: pd[1])
>>> n
15120
>>> length
79
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Short-circuit_evaluation,Short-circuit evaluation,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops



Assume functions   a   and   b   return boolean values,   and further, the execution of function   b   takes considerable resources without side effects, and is to be minimized.

If we needed to compute the conjunction   (and):

  x = a() and b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   false,   as the value of   x   can then only ever be    false.

Similarly, if we needed to compute the disjunction (or):

  y = a() or b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   true,   as the value of   y   can then only ever be   true.

Some languages will stop further computation of boolean equations as soon as the result is known, so-called   short-circuit evaluation   of boolean expressions



Task

Create two functions named   a   and   b,   that take and return the same boolean value.

The functions should also print their name whenever they are called.

Calculate and assign the values of the following equations to a variable in such a way that function   b   is only called when necessary:

  x = a(i) and b(j) 
  y = a(i) or b(j) 

If the language does not have short-circuit evaluation, this might be achieved with nested     if     statements.



",Python,">>> def a(answer):
	print(""  # Called function a(%r) -> %r"" % (answer, answer))
	return answer
 
>>> def b(answer):
	print(""  # Called function b(%r) -> %r"" % (answer, answer))
	return answer
 
>>> for i in (False, True):
	for j in (False, True):
		print (""\nCalculating: x = a(i) and b(j)"")
		x = a(i) and b(j)
		print (""Calculating: y = a(i) or  b(j)"")
		y = a(i) or  b(j)
 
 
 
Calculating: x = a(i) and b(j)
  # Called function a(False) -> False
Calculating: y = a(i) or  b(j)
  # Called function a(False) -> False
  # Called function b(False) -> False
 
Calculating: x = a(i) and b(j)
  # Called function a(False) -> False
Calculating: y = a(i) or  b(j)
  # Called function a(False) -> False
  # Called function b(True) -> True
 
Calculating: x = a(i) and b(j)
  # Called function a(True) -> True
  # Called function b(False) -> False
Calculating: y = a(i) or  b(j)
  # Called function a(True) -> True
 
Calculating: x = a(i) and b(j)
  # Called function a(True) -> True
  # Called function b(True) -> True
Calculating: y = a(i) or  b(j)
  # Called function a(True) -> True",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",Python,"#include <stdio.h>
 
typedef unsigned uint;
int is_prime(uint n)
{
        if (!(n%2) ||!(n%3)) return 0;
        uint p = 1;
        while(p*p < n)
                if (n%(p += 4) == 0 || n%(p += 2) == 0)
                        return 0;
        return 1;
}
 
uint reverse(uint n)
{
        uint r;
        for (r = 0; n; n /= 10)
                r = r*10 + (n%10);
        return r;
}
 
int is_emirp(uint n)
{
        uint r = reverse(n);
        return r!= n && is_prime(n) && is_prime(r);
}
 
int main(int argc, char **argv)
{
        uint x, c = 0;
        switch(argc) { // advanced args parsing
        case 1: for (x = 11; c < 20; x += 2)
                        if (is_emirp(x))
                                printf("" %u"", x), ++c;
                break;
 
        case 2: for (x = 7701; x < 8000; x += 2)
                        if (is_emirp(x))
                                printf("" %u"", x);
                break;
 
        default:
                for (x = 11; ; x += 2)
                        if (is_emirp(x) && ++c == 10000) {
                                printf(""%u"", x);
                                break;
                        }
        }
 
        putchar('\n');
        return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/User_input/Text,User input/Text,"User input/Text is part of Short Circuit's Console Program Basics selection.
Task
 
Input a string and the integer   75000   from the text console.

See also: User input/Graphical
",Python,"string = raw_input(""Input a string: "")",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Percolation/Site_percolation,Percolation/Site percolation,"
Percolation Simulation

This is a simulation of aspects of mathematical percolation theory.

For other percolation simulations, see Category:Percolation Simulations, or:
1D finite grid simulation
Mean run density 
2D finite grid simulations
Site percolation | Bond percolation | Mean cluster density

Given an 



M
×
N


{\displaystyle M\times N}

 rectangular array of cells numbered 




c
e
l
l

[
0..
M
−
1
,
0..
N
−
1
]


{\displaystyle \mathrm {cell} [0..M-1,0..N-1]}

assume 



M


{\displaystyle M}

 is horizontal and 



N


{\displaystyle N}

 is downwards.

Assume that the probability of any cell being filled is a constant 



p


{\displaystyle p}

 where

 



0.0
≤
p
≤
1.0


{\displaystyle 0.0\leq p\leq 1.0}


The task

Simulate creating the array of cells with probability 



p


{\displaystyle p}

 and then
testing if there is a route through adjacent filled cells from any on row 



0


{\displaystyle 0}

 to any on row 



N


{\displaystyle N}

, i.e. testing for site percolation.

Given 



p


{\displaystyle p}

 repeat the percolation 



t


{\displaystyle t}

 times to estimate the proportion of times that the fluid can percolate to the bottom for any given 



p


{\displaystyle p}

.

Show how the probability of percolating through the random grid changes with 



p


{\displaystyle p}

 going from 



0.0


{\displaystyle 0.0}

 to 



1.0


{\displaystyle 1.0}

 in 



0.1


{\displaystyle 0.1}

 increments and with the number of repetitions to estimate the fraction at any given 



p


{\displaystyle p}

 as 



t
>=
100


{\displaystyle t>=100}

.

Use an 



M
=
15
,
N
=
15


{\displaystyle M=15,N=15}

 grid of cells for all cases.

Optionally depict a percolation through a cell grid graphically.

Show all output on this page.
",Python,"from random import random
import string
from pprint import pprint as pp
 
M, N, t = 15, 15, 100
 
cell2char = ' #' + string.ascii_letters
NOT_VISITED = 1     # filled cell not walked
 
class PercolatedException(Exception): pass
 
def newgrid(p):
    return [[int(random() < p) for m in range(M)] for n in range(N)] # cell
 
def pgrid(cell, percolated=None):
    for n in range(N):
        print( '%i)  ' % (n % 10) 
               + ' '.join(cell2char[cell[n][m]] for m in range(M)))
    if percolated: 
        where = percolated.args[0][0]
        print('!)  ' + '  ' * where + cell2char[cell[n][where]])
 
def check_from_top(cell):
    n, walk_index = 0, 1
    try:
        for m in range(M):
            if cell[n][m] == NOT_VISITED:
                walk_index += 1
                walk_maze(m, n, cell, walk_index)
    except PercolatedException as ex:
        return ex
    return None
 
 
def walk_maze(m, n, cell, indx):
    # fill cell 
    cell[n][m] = indx
    # down
    if n < N - 1 and cell[n+1][m] == NOT_VISITED:
        walk_maze(m, n+1, cell, indx)
    # THE bottom
    elif n == N - 1:
        raise PercolatedException((m, indx))
    # left
    if m and cell[n][m - 1] == NOT_VISITED:
        walk_maze(m-1, n, cell, indx)
    # right
    if m < M - 1 and cell[n][m + 1] == NOT_VISITED:
        walk_maze(m+1, n, cell, indx)
    # up
    if n and cell[n-1][m] == NOT_VISITED:
        walk_maze(m, n-1, cell, indx)
 
if __name__ == '__main__':
    sample_printed = False
    pcount = {}
    for p10 in range(11):
        p = p10 / 10.0
        pcount[p] = 0
        for tries in range(t):
            cell = newgrid(p)
            percolated = check_from_top(cell)
            if percolated:
                pcount[p] += 1
                if not sample_printed:
                    print('\nSample percolating %i x %i, p = %5.2f grid\n' % (M, N, p))
                    pgrid(cell, percolated)
                    sample_printed = True
    print('\n p: Fraction of %i tries that percolate through\n' % t )
 
    pp({p:c/float(t) for p, c in pcount.items()})",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Multisplit,Multisplit,"It is often necessary to split a string into pieces
based on several different (potentially multi-character) separator strings,
while still retaining the information about which separators were present in the input.

This is particularly useful when doing small parsing tasks. 

The task is to write code to demonstrate this.

The function (or procedure or method, as appropriate) should
take an input string and an ordered collection of separators.

The order of the separators is significant: 

The delimiter order represents priority in matching, with the first defined delimiter having the highest priority.
In cases where there would be an ambiguity as to
which separator to use at a particular point
(e.g., because one separator is a prefix of another)
the separator with the highest priority should be used.
Delimiters can be reused and the output from the function should be an ordered sequence of substrings.

Test your code using the input string “a!===b=!=c” and the separators “==”, “!=” and “=”.

For these inputs the string should be parsed as ""a"" (!=) """" (==) ""b"" (=) """" (!=) ""c"", where matched delimiters are shown in parentheses, and separated strings are quoted, so our resulting output is ""a"", empty string, ""b"", empty string, ""c"".
Note that the quotation marks are shown for clarity and do not form part of the output.

Extra Credit: provide information that indicates which separator was matched at each separation point and where in the input string that separator was matched.
",Python,">>> import re
>>> def ms2(txt=""a!===b=!=c"", sep=[""=="", ""!="", ""=""]):
	if not txt or not sep:
		return []
	ans = m = []
	for m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):
		ans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]
	if m and txt[m.end(m.lastindex):]:
		ans += [txt[m.end(m.lastindex):]]
	return ans
 
>>> ms2()
['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']
>>> ms2(txt=""a!===b=!=c"", sep=[""="", ""!="", ""==""])
['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']",Human_written,Python_from_C#
http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",Python,"from shoes import *

@number = edit_line
@number.change(update_controls)

@incr = button('Increment', update_controls(@number.text.to_i + 1))
@decr = button('Decrement', update_controls(@number.text.to_i - 1))

def update_controls(value = @number.text.to_i):
    @number.text = value
    @incr.state = value.to_i >= 10 ? ""disabled"" : nil
    @decr.state = value.to_i <=  0 ? ""disabled"" : nil

update_controls(0)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/String_length,String length,"Task

Find the character and byte length of a string.

This means encodings like UTF-8 need to be handled properly, as there is not necessarily a one-to-one relationship between bytes and characters.

By character, we mean an individual Unicode code point, not a user-visible grapheme containing combining characters.

For example, the character length of ""møøse"" is 5 but the byte length is 7 in UTF-8 and 10 in UTF-16.

Non-BMP code points (those between 0x10000 and 0x10FFFF) must also be handled correctly: answers should produce actual character counts in code points, not in code unit counts.

Therefore a string like ""𝔘𝔫𝔦𝔠𝔬𝔡𝔢"" (consisting of the 7 Unicode characters U+1D518 U+1D52B U+1D526 U+1D520 U+1D52C U+1D521 U+1D522) is 7 characters long, not 14 UTF-16 code units; and it is 28 bytes long whether encoded in UTF-8 or in UTF-16.

Please mark your examples with ===Character Length=== or ===Byte Length===.

If your language is capable of providing the string length in graphemes, mark those examples with ===Grapheme Length===.

For example, the string ""J̲o̲s̲é̲"" (""J\x{332}o\x{332}s\x{332}e\x{301}\x{332}"") has 4 user-visible graphemes, 9 characters (code points), and 14 bytes when encoded in UTF-8.





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.0.6
def main(args):
    s = ""José""
    print(""The char length is {0}"".format(len(s)))
    print(""The byte length is {0}"".format(len(s) * 4))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Caesar_cipher,Caesar cipher,"

Task

Implement a Caesar cipher, both encoding and decoding. 

The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).

So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"".

This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigenère cipher with a key of length 1. 

Also, Rot-13 is identical to Caesar cipher with key 13.



Related tasks

 Rot-13
 Substitution Cipher
 Vigenère Cipher/Cryptanalysis

",Python,"from typing import Callable
 
class Caesar:
    def __init__(self, key: int) -> None:
        if key < 1 or key > 25:
            raise ValueError(""Key must be between 1 and 25"")
        self.key = key
        self.enc = self.encipher
        self.dec = self.decipher
 
    def encipher(self, plaintext: str) -> str:
        return """".join(self._encipher(c) for c in plaintext)
 
    def decipher(self, ciphertext: str) -> str:
        return """".join(self._decipher(c) for c in ciphertext)
 
    def _encipher(self, c: str) -> str:
        if c.isalpha():
            return self._shift(c, self.key)
        return c
 
    def _decipher(self, c: str) -> str:
        if c.isalpha():
            return self._shift(c, -self.key)
        return c
 
    def _shift(self, c: str, key: int) -> str:
        if c.islower():
            return self._shift_lower(c, key)
        return self._shift_upper(c, key)
 
    def _shift_lower(self, c: str, key: int) -> str:
        return chr((ord(c) - ord(""a"") + key) % 26 + ord(""a""))
 
    def _shift_upper(self, c: str, key: int) -> str:
        return chr((ord(c) - ord(""A"") + key) % 26 + ord(""A""))
 
if __name__ == ""__main__"":
    pt = ""The five boxing wizards jump quickly""
    print(""Plaintext:"", pt)
    for key in [0, 1, 7, 25, 26]:
        try:
            ck = Caesar(key)
        except ValueError:
            print(""Key"", key, ""invalid"")
            continue
        ct = ck.encipher(pt)
        print(""Key"", key)
        print(""  Enciphered:"", ct)
        print(""  Deciphered:"", ck.decipher(ct))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Benford%27s_law,Benford's law,"

 This page uses content from Wikipedia. The original article was at Benford's_law. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


Benford's law, also called the first-digit law, refers to the frequency distribution of digits in many (but not all) real-life sources of data.

In this distribution, the number 1 occurs as the first digit about 30% of the time, while larger numbers occur in that position less frequently: 9 as the first digit less than 5% of the time. This distribution of first digits is the same as the widths of gridlines on a logarithmic scale.

Benford's law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution.

This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, physical and mathematical constants, and processes described by power laws (which are very common in nature). It tends to be most accurate when values are distributed across multiple orders of magnitude.

A set of numbers is said to satisfy Benford's law if the leading digit 



d


{\displaystyle d}

  (



d
∈
{
1
,
…
,
9
}


{\displaystyle d\in \{1,\ldots ,9\}}

) occurs with probability

 



P
(
d
)
=

log

10


⁡
(
d
+
1
)
−

log

10


⁡
(
d
)
=

log

10


⁡

(
1
+


1
d


)



{\displaystyle P(d)=\log _{10}(d+1)-\log _{10}(d)=\log _{10}\left(1+{\frac {1}{d}}\right)}


For this task, write (a) routine(s) to calculate the distribution of first significant (non-zero) digits in a collection of numbers, then display the actual vs. expected distribution in the way most convenient for your language (table / graph / histogram / whatever).

Use the first 1000 numbers from the Fibonacci sequence as your data set. No need to show how the Fibonacci numbers are obtained.

You can generate them or load them from a file; whichever is easiest.

Display your actual vs expected distribution.


For extra credit: Show the distribution for one other set of numbers from a page on Wikipedia. State which Wikipedia page it can be obtained from and what the set enumerates. Again, no need to display the actual list of numbers or the code to load them.



See also:
 numberphile.com.
 A starting page on Wolfram Mathworld is Benfords Law .

",Python,"from __future__ import division
from itertools import islice, count
from collections import Counter
from math import log10
from random import randint
 
expected = [log10(1+1/d) for d in range(1,10)]
 
def fib():
    a,b = 1,1
    while True:
        yield a
        a,b = b,a+b
 
# powers of 3 as a test sequence
def power_of_threes():
    return (3**k for k in count(0))
 
def heads(s):
    for a in s: yield int(str(a)[0])
 
def show_dist(title, s):
    c = Counter(s)
    size = sum(c.values())
    res = [c[d]/size for d in range(1,10)]
 
    print(""\n%s Benfords deviation"" % title)
    for r, e in zip(res, expected):
        print(""%5.1f%% %5.1f%%  %5.1f%%"" % (r*100., e*100., abs(r - e)*100.))
 
def rand1000():
    while True: yield randint(1,9999)
 
if __name__ == '__main__':
    show_dist(""fibbed"", islice(heads(fib()), 1000))
    show_dist(""threes"", islice(heads(power_of_threes()), 1000))
 
    # just to show that not all kind-of-random sets behave like that
    show_dist(""random"", islice(heads(rand1000()), 10000))",Human_written,Python_from_JavaScript
"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def shortest_abbreviation_length(line, list_size):
    words = line.split()
    word_count = len(words)
    # Can't give true answer with unexpected number of entries
    if word_count != list_size:
        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')
 
    # Find the small slice length that gives list_size unique values
    abbreviation_length = 1
    abbreviations = set()
    while(True):
        abbreviations = {word[:abbreviation_length] for word in words}
        if len(abbreviations) == list_size:
            return abbreviation_length
        abbreviation_length += 1
        abbreviations.clear()
 
def automatic_abbreviations(filename, words_per_line):
    with open(filename) as file:
        for line in file:
            line = line.rstrip()
            if len(line) > 0:
                length = shortest_abbreviation_length(line, words_per_line)
                print(f'{length:2} {line}')
            else:
                print()
 
automatic_abbreviations('daysOfWeek.txt', 7)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Word_ladder,Word ladder,"Yet another shortest path problem. Given two words of equal length the task is to transpose the first into the second.

Only one letter may be changed at a time and the change must result in a word in unixdict, the minimum number of intermediate words should be used.

Demonstrate the following:

A boy can be made into a man: boy -> bay -> ban -> man

With a little more difficulty a girl can be made into a lady: girl -> gill -> gall -> gale -> gaze -> laze -> lazy -> lady

A john can be made into a jane: john -> cohn -> conn -> cone -> cane -> jane

A child can not be turned into an adult.

Optional transpositions of your choice.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import os,sys,zlib,urllib.request
 
def h ( str,x=9 ):
    for c in str :
        x = ( x*33 + ord( c )) & 0xffffffffff
    return x  
 
def cache ( func,*param ):
    n = 'cache_%x.bin'%abs( h( repr( param )))
    try    : return eval( zlib.decompress( open( n,'rb' ).read()))
    except : pass
    s = func( *param )
    open( n,'wb' ).write( zlib.compress( bytes( repr( s ),'ascii' )))
    return s
 
dico_url  = 'https://raw.githubusercontent.com/quinnj/Rosetta-Julia/master/unixdict.txt'
read_url  = lambda url   : urllib.request.urlopen( url ).read()
load_dico = lambda url   : tuple( cache( read_url,url ).split( b'\n'))
isnext    = lambda w1,w2 : len( w1 ) == len( w2 ) and len( list( filter( lambda l : l[0]!=l[1] , zip( w1,w2 )))) == 1
 
def build_map ( words ):
    map = [(w.decode('ascii'),[]) for w in words]
    for i1,(w1,n1) in enumerate( map ):
        for i2,(w2,n2) in enumerate( map[i1+1:],i1+1 ):
            if isnext( w1,w2 ):
                n1.append( i2 )
                n2.append( i1 )
    return map
 
def find_path ( words,w1,w2 ):
    i = [w[0] for w in words].index( w1 )
    front,done,res  = [i],{i:-1},[]
    while front :
        i = front.pop(0)
        word,next = words[i]
        for n in next :
            if n in done : continue
            done[n] = i
            if words[n][0] == w2 :
                while n >= 0 :
                    res = [words[n][0]] + res
                    n = done[n]
                return ' '.join( res )
            front.append( n )
    return '%s can not be turned into %s'%( w1,w2 )
 
for w in ('boy man','girl lady','john jane','alien drool','child adult'):
    print( find_path( cache( build_map,load_dico( dico_url )),*w.split()))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Longest_common_subsequence,Longest common subsequence,"Introduction

Define a subsequence to be any output string obtained by deleting zero or more symbols from an input string.

The Longest Common Subsequence (LCS) is a subsequence of maximum length common to two or more strings.

Let A ≡ A[0]… A[m - 1] and B ≡ B[0]… B[n - 1], m < n be strings drawn from an alphabet Σ of size s, containing every distinct symbol in A + B.

An ordered pair (i, j) will be referred to as a match if A[i] = B[j], where 0 < i ≤ m and 0 < j ≤ n.

Define a non-strict product-order (≤) over ordered pairs, such that (i1, j1) ≤ (i2, j2) ⇔ i1 ≤ i2 and j1 ≤ j2. We define (≥) similarly.

We say m1, m2 are comparable if either m1 ≤ m2 or m1 ≥ m2 holds. If i1 < i2 and j2 < j1 (or i2 < i1 and j1 < j2) then neither m1 ≤ m2 nor m1 ≥ m2 are possible; and we say m1, m2 are incomparable.

We also define the strict product-order (<) over ordered pairs, such that (i1, j1) < (i2, j2) ⇔ i1 < i2 and j1 < j2. We define (>) similarly.

Given a set of matches M, a chain C is a subset of M consisting of at least one element m; and where either m1 < m2 or m1 > m2 for every pair of distinct elements m1 and m2. An antichain D is any subset of M in which every pair of distinct elements m1 and m2 are incomparable.

The set M represents a relation over match pairs: M[i, j] ⇔ (i, j) ∈ M. A chain C can be visualized as a curve which strictly increases as it passes through each match pair in the m*n coordinate space.

Finding an LCS can be restated as the problem of finding a chain of maximum cardinality p over the set of matches M.

According to [Dilworth 1950], this cardinality p equals the minimum number of disjoint antichains into which M can be decomposed. Note that such a decomposition into the minimal number p of disjoint antichains may not be unique.

Contours

Forward Contours FC[k] of class k are defined inductively, as follows:

FC[0] consists of those elements m1 for which there exists no element m2 such that m2 < m1.

FC[k] consists of those elements m1 for which there exists no element m2 such that m2 < m1; and where neither m1 nor m2 are contained in FC[l] for any class l < k.

Reverse Contours RC[k] of class k are defined similarly.

Members of the Meet (∧), or Infimum of a Forward Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 < m1.

Members of the Join (∨), or Supremum of a Reverse Contour are referred to as its Dominant Matches: those m1 for which there exists no m2 such that m2 > m1.

Where multiple Dominant Matches exist within a Meet (or within a Join, respectively) the Dominant Matches will be incomparable to each other.

Background

Where the number of symbols appearing in matches is small relative to the length of the input strings, reuse of the symbols increases; and the number of matches will tend towards quadratic, O(m*n) growth. This occurs, for example, in the Bioinformatics application of nucleotide and protein sequencing.

The divide-and-conquer approach of [Hirschberg 1975] limits the space required to O(n). However, this approach requires O(m*n) time even in the best case.

This quadratic time dependency may become prohibitive, given very long input strings. Thus, heuristics are often favored over optimal Dynamic Programming solutions.

In the application of comparing file revisions, records from the input files form a large symbol space; and the number of symbols approaches the length of the LCS. In this case the number of matches reduces to linear, O(n) growth.

A binary search optimization due to [Hunt and Szymanski 1977] can be applied to the basic Dynamic Programming approach, resulting in an expected performance of O(n log m). Performance can degrade to O(m*n log m) time in the worst case, as the number of matches grows to O(m*n).

Note

[Rick 2000] describes a linear-space algorithm with a time bound of O(n*s + p*min(m, n - p)).

Legend

A, B are input strings of lengths m, n respectively
p is the length of the LCS
M is the set of match pairs (i, j) such that A[i] = B[j]
r is the magnitude of M
s is the magnitude of the alphabet Σ of distinct symbols in A + B

References

[Dilworth 1950] ""A decomposition theorem for partially ordered sets""
by Robert P. Dilworth, published January 1950,
Annals of Mathematics [Volume 51, Number 1, pp. 161-166]

[Goeman and Clausen 2002] ""A New Practical Linear Space Algorithm for the Longest Common
Subsequence Problem"" by Heiko Goeman and Michael Clausen,
published 2002, Kybernetika [Volume 38, Issue 1, pp. 45-66]

[Hirschberg 1975] ""A linear space algorithm for computing maximal common subsequences""
by Daniel S. Hirschberg, published June 1975
Communications of the ACM [Volume 18, Number 6, pp. 341-343]

[Hunt and McIlroy 1976] ""An Algorithm for Differential File Comparison""
by James W. Hunt and M. Douglas McIlroy, June 1976
Computing Science Technical Report, Bell Laboratories 41

[Hunt and Szymanski 1977] ""A Fast Algorithm for Computing Longest Common Subsequences""
by James W. Hunt and Thomas G. Szymanski, published May 1977
Communications of the ACM [Volume 20, Number 5, pp. 350-353]

[Rick 2000] ""Simple and fast linear space computation of longest common subsequences""
by Claus Rick, received 17 March 2000, Information Processing Letters,
Elsevier Science [Volume 75, pp. 275–281]



Examples

The sequences ""1234"" and ""1224533324"" have an LCS of ""1234"":

1234
1224533324

For a string example, consider the sequences ""thisisatest"" and ""testing123testing"". An LCS would be ""tsitest"":

thisisatest
testing123testing

In this puzzle, your code only needs to deal with strings. Write a function which returns an LCS of two strings (case-sensitive). You don't need to show multiple LCS's.

For more information on this problem please see Wikipedia.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.1.2
 
def lcs(x, y):
    if len(x) == 0 or len(y) == 0:
        return """"
    x1 = x[:-1]
    y1 = y[:-1]
    if x[-1] == y[-1]:
        return lcs(x1, y1) + x[-1]
    x2 = lcs(x, y1)
    y2 = lcs(x1, y)
    return x2 if len(x2) > len(y2) else y2
 
x = ""thisisatest""
y = ""testing123testing""
print(lcs(x, y))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",Python,">>> # Bin(leading 0b or 0B), Oct(leading 0o or 0O), Dec, Hex(leading 0x or 0X), in order:
>>> 0b1011010111 == 0o1327 == 727 == 0x2d7
True
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Mandelbrot_set,Mandelbrot set,"Mandelbrot set

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Generate and draw the Mandelbrot set.



Note that there are many algorithms to draw Mandelbrot set and there are many functions which generate it .



",Python,"# Python 3.0+ and 2.5+
try:
    from functools import reduce
except:
    pass
 
 
def mandelbrot(a):
    return reduce(lambda z, _: z * z + a, range(50), 0)
 
def step(start, step, iterations):
    return (start + (i * step) for i in range(iterations))
 
rows = ((""*"" if abs(mandelbrot(complex(x, y))) < 2 else "" ""
        for x in step(-2.0, .0315, 80))
        for y in step(1, -.05, 41))
 
print(""\n"".join("""".join(row) for row in rows))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Horner%27s_rule_for_polynomial_evaluation,Horner's rule for polynomial evaluation,"A fast scheme for evaluating a polynomial such as:

 



−
19
+
7
x
−
4

x

2


+
6

x

3





{\displaystyle -19+7x-4x^{2}+6x^{3}\,}


when

 



x
=
3



{\displaystyle x=3\;}

.
is to arrange the computation as follows:

 



(
(
(
(
0
)
x
+
6
)
x
+
(
−
4
)
)
x
+
7
)
x
+
(
−
19
)



{\displaystyle ((((0)x+6)x+(-4))x+7)x+(-19)\;}


And compute the result from the innermost brackets outwards as in this pseudocode:

coefficients := [-19, 7, -4, 6] # list coefficients of all x^0..x^n in order
x := 3
accumulator := 0
for i in length(coefficients) downto 1 do
    # Assumes 1-based indexing for arrays
    accumulator := ( accumulator * x ) + coefficients[i]
done
# accumulator now has the answer

Task Description

Create a routine that takes a list of coefficients of a polynomial in order of increasing powers of x; together with a value of x to compute its value at, and return the value of the polynomial at that value using Horner's rule.
Cf. Formal power series
",Python,">>> def horner(coeffs, x):
	acc = 0
	for c in reversed(coeffs):
		acc = acc * x + c
	return acc
 
>>> horner( (-19, 7, -4, 6), 3)
128",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Nth_root,Nth root,"Task

Implement the algorithm to compute the principal   nth   root   





A

n





{\displaystyle {\sqrt[{n}]{A}}}

   of a positive real number   A,   as explained at the   Wikipedia page.


",Python,"def root(a, n):
    n1 = n - 1
    n1f, rn = float(n1), 1/float(n)
    x, x0 = 1., 0.
    while True:
        potx, t2 = 1/x, a
        for b in range(n1, 0, -1):
            if b&1 == 1:
                t2 *= potx
            potx *= potx
        x0, x = x, rn*(n1f*x+t2)
        if abs(x-x0)*1e15 < x:
            break
    return x",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Zebra_puzzle,Zebra puzzle,"Zebra puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
The Zebra puzzle, a.k.a. Einstein's Riddle,
is a logic puzzle which is to be solved programmatically.



It has several variants, one of them this:

   There are five houses.
   The English man lives in the red house.
   The Swede has a dog.
   The Dane drinks tea.
   The green house is immediately to the left of the white house.
   They drink coffee in the green house.
   The man who smokes Pall Mall has birds.
   In the yellow house they smoke Dunhill.
   In the middle house they drink milk.
   The Norwegian lives in the first house.
   The man who smokes Blend lives in the house next to the house with cats.
   In a house next to the house where they have a horse, they smoke Dunhill.
   The man who smokes Blue Master drinks beer.
   The German smokes Prince.
   The Norwegian lives next to the blue house.
   They drink water in a house next to the house where they smoke Blend. 

The question is, who owns the zebra?

Additionally, list the solution for all the houses.

Optionally, show the solution is unique.



Related tasks

   Dinesman's multiple-dwelling problem
   Twelve statements

",Python,"from logpy import *
from logpy.core import lall
import time
 
def lefto(q, p, list):
	# give me q such that q is left of p in list
	# zip(list, list[1:]) gives a list of 2-tuples of neighboring combinations
	# which can then be pattern-matched against the query
	return membero((q,p), zip(list, list[1:]))
 
def nexto(q, p, list):
	# give me q such that q is next to p in list
	# match lefto(q, p) OR lefto(p, q)
	# requirement of vector args instead of tuples doesn't seem to be documented
	return conde([lefto(q, p, list)], [lefto(p, q, list)])
 
houses = var()
 
zebraRules = lall(
	# there are 5 houses
	(eq, 		(var(), var(), var(), var(), var()), houses),
	# the Englishman's house is red
	(membero,	('Englishman', var(), var(), var(), 'red'), houses),
	# the Swede has a dog
	(membero,	('Swede', var(), var(), 'dog', var()), houses),
	# the Dane drinks tea
	(membero,	('Dane', var(), 'tea', var(), var()), houses),
	# the Green house is left of the White house
	(lefto,		(var(), var(), var(), var(), 'green'),
				(var(), var(), var(), var(), 'white'), houses),
	# coffee is the drink of the green house
	(membero,	(var(), var(), 'coffee', var(), 'green'), houses),
	# the Pall Mall smoker has birds
	(membero,	(var(), 'Pall Mall', var(), 'birds', var()), houses),
	# the yellow house smokes Dunhills
	(membero,	(var(), 'Dunhill', var(), var(), 'yellow'), houses),
	# the middle house drinks milk
	(eq,		(var(), var(), (var(), var(), 'milk', var(), var()), var(), var()), houses),
	# the Norwegian is the first house
	(eq,		(('Norwegian', var(), var(), var(), var()), var(), var(), var(), var()), houses),
	# the Blend smoker is in the house next to the house with cats
	(nexto,		(var(), 'Blend', var(), var(), var()),
				(var(), var(), var(), 'cats', var()), houses),
	# the Dunhill smoker is next to the house where they have a horse
	(nexto,		(var(), 'Dunhill', var(), var(), var()),
				(var(), var(), var(), 'horse', var()), houses),
	# the Blue Master smoker drinks beer
	(membero,	(var(), 'Blue Master', 'beer', var(), var()), houses),
	# the German smokes Prince
	(membero,	('German', 'Prince', var(), var(), var()), houses),
	# the Norwegian is next to the blue house
	(nexto,		('Norwegian', var(), var(), var(), var()),
				(var(), var(), var(), var(), 'blue'), houses),
	# the house next to the Blend smoker drinks water
	(nexto,		(var(), 'Blend', var(), var(), var()),
				(var(), var(), 'water', var(), var()), houses),
	# one of the houses has a zebra--but whose?
	(membero,	(var(), var(), var(), 'zebra', var()), houses)
)
 
t0 = time.time()
solutions = run(0, houses, zebraRules)
t1 = time.time()
dur = t1-t0
 
count = len(solutions)
zebraOwner = [house for house in solutions[0] if 'zebra' in house][0][0]
 
print ""%i solutions in %.2f seconds"" % (count, dur)
print ""The %s is the owner of the zebra"" % zebraOwner
print ""Here are all the houses:""
for line in solutions[0]:
	print str(line)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Write_to_Windows_event_log,Write to Windows event log,"Task

Write script status to the Windows Event Log



",Python,"import win32api
import win32con
import win32evtlog
import win32security
import win32evtlogutil
 
ph = win32api.GetCurrentProcess()
th = win32security.OpenProcessToken(ph, win32con.TOKEN_READ)
my_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]
 
applicationName = ""My Application""
eventID = 1
category = 5	# Shell
myType = win32evtlog.EVENTLOG_WARNING_TYPE
descr = [""A warning"", ""An even more dire warning""]
data = ""Application\0Data"".encode(""ascii"")
 
win32evtlogutil.ReportEvent(applicationName, eventID, eventCategory=category, 
	eventType=myType, strings=descr, data=data, sid=my_sid)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Euler%27s_sum_of_powers_conjecture,Euler's sum of powers conjecture,"There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.



Euler's (disproved) sum of powers   conjecture

  At least  k  positive  kth  powers are required to sum to a  kth  power,  
  except for the trivial case of one  kth power:  yk = yk 



In 1966,   Leon J. Lander   and   Thomas R. Parkin   used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.



Task

Write a program to search for an integer solution for:


  x05 + x15 + x25 + x35 == y5 

Where all     xi's   and    y    are distinct integers between   0   and   250   (exclusive).

Show an answer here.



Related tasks

   Pythagorean quadruples. 
   Pythagorean triples.

",Python,"import math
 
def eulerSum():
	pow5 = [i**5 for i in range(250)]
	for x0 in range(4, len(pow5)):
		for x1 in range(3, x0):
			for x2 in range(2, x1):
				for x3 in range(1, x2):
					sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3]
					for y in range(x0 + 1, len(pow5)):
						if sum == pow5[y]:
							return x0, x1, x2, x3, y
 
if __name__ == ""__main__"":
	print(eulerSum())",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"class Numeric:
    def pow(self, m):
        if not isinstance(m, int):
            raise TypeError(""exponent must be an integer: {}"".format(m))
        print(""pow!!"")
        return reduce(lambda x, y: x * y, [self] * m)
 
print(Numeric().pow(5, 3))
print(Numeric().pow(5.5, 3))
print(Numeric().pow(5, 3.1))",Ai_generated,Python_from_Ruby
"http://rosettacode.org/wiki/Abbreviations,_simple","Abbreviations, simple","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



For this task, the following   command table   will be used:

   add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   a command is followed by an optional number, which indicates the minimum abbreviation
   A valid abbreviation is a word that has:
   at least the minimum length of the word's minimum number in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTER 3
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTER 3
   The   3   indicates that any abbreviation for   ALTER   must be at least three characters
   Any word longer than five characters can't be an abbreviation for   ALTER
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   overlay 1
   if there isn't a number after the command,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"command_table_text = """"""add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3
   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate
   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2
   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load
   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2
   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3
   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left
   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1""""""
 
user_words = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
 
 
def find_abbreviations_length(command_table_text):
    """""" find the minimal abbreviation length for each word.
        a word that does not have minimum abbreviation length specified
        gets it's full lengths as the minimum.
    """"""
    command_table = dict()
    input_iter = iter(command_table_text.split())
 
    word = None
    try:
        while True:
            if word is None:
                word = next(input_iter)
            abbr_len = next(input_iter, len(word))
            try:
                command_table[word] = int(abbr_len)
                word = None
            except ValueError:
                command_table[word] = len(word)
                word = abbr_len
    except StopIteration:
        pass
    return command_table
 
 
def find_abbreviations(command_table):
    """""" for each command insert all possible abbreviations""""""
    abbreviations = dict()
    for command, min_abbr_len in command_table.items():
        for l in range(min_abbr_len, len(command)+1):
            abbr = command[:l].lower()
            abbreviations[abbr] = command.upper()
    return abbreviations
 
 
def parse_user_string(user_string, abbreviations):
    user_words = [word.lower() for word in user_string.split()]
    commands = [abbreviations.get(user_word, ""*error*"") for user_word in user_words]
    return "" "".join(commands)
 
 
command_table = find_abbreviations_length(command_table_text)
abbreviations_table = find_abbreviations(command_table)
 
full_words = parse_user_string(user_words, abbreviations_table)
 
print(""user words:"", user_words)
print(""full words:"", full_words)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Prime_decomposition,Prime decomposition,"The prime decomposition of a number is defined as a list of prime numbers
which when all multiplied together, are equal to that number.



Example

 12 = 2 × 2 × 3,  so its prime decomposition is  {2, 2, 3}



Task

Write a function which returns an array or collection which contains the prime decomposition of a given number   



n


{\displaystyle n}

   greater than   1.

If your language does not have an isPrime-like function available,
you may assume that you have a function which determines
whether a number is prime (note its name before your code).

If you would like to test code from this task, you may use code from trial division or the Sieve of Eratosthenes.

Note: The program must not be limited by the word size of your computer or some other artificial limit; it should work for any number regardless of size (ignoring the physical limits of RAM etc).



Related tasks

   count in factors
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"from jsbn import BigInteger

def run_factorize(input, output):
    n = BigInteger(input.value, 10)
    TWO = BigInteger(""2"", 10)
    divisor = BigInteger(""3"", 10)
    prod = False

    if n.compareTo(TWO) < 0:
        return

    output.value = """"

    while True:
        qr = n.divideAndRemainder(TWO)
        if qr[1].equals(BigInteger.ZERO):
            if prod:
                output.value += ""*""
            else:
                prod = True
            output.value += ""2""
            n = qr[0]
        else:
            break

    while not n.equals(BigInteger.ONE):
        qr = n.divideAndRemainder(divisor)
        if qr[1].equals(BigInteger.ZERO):
            if prod:
                output.value += ""*""
            else:
                prod = True
            output.value += divisor
            n = qr[0]
        else:
            divisor = divisor.add(TWO)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/XML/Input,XML/Input,"Given the following XML fragment, extract the list of student names using whatever means desired. If the only viable method is to use XPath, refer the reader to the task XML and XPath.

<Students>
  <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
  <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
  <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
  <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
    <Pet Type=""dog"" Name=""Rover"" />
  </Student>
  <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>
Expected Output

April
Bob
Chad
Dave
Émily
",Python,"import xml.dom.minidom
 
doc = """"""<Students>
  <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
  <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
  <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
  <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
    <Pet Type=""dog"" Name=""Rover"" />
  </Student>
  <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>""""""
 
doc = xml.dom.minidom.parseString(doc)
 
for i in doc.getElementsByTagName(""Student""):
    print i.getAttribute(""Name"")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Display_a_linear_combination,Display a linear combination,"Task

Display a finite linear combination in an infinite vector basis 



(

e

1


,

e

2


,
…
)


{\displaystyle (e_{1},e_{2},\ldots )}

.

Write a function that, when given a finite list of scalars 



(

α

1


,

α

2


,
…
)


{\displaystyle (\alpha ^{1},\alpha ^{2},\ldots )}

, 
creates a string representing the linear combination 




∑

i



α

i



e

i




{\displaystyle \sum _{i}\alpha ^{i}e_{i}}

 in an explicit format often used in mathematics, that is:






α


i

1





e


i

1




±

|


α


i

2





|


e


i

2




±

|


α


i

3





|


e


i

3




±
…


{\displaystyle \alpha ^{i_{1}}e_{i_{1}}\pm |\alpha ^{i_{2}}|e_{i_{2}}\pm |\alpha ^{i_{3}}|e_{i_{3}}\pm \ldots }


where 




α


i

k




≠
0


{\displaystyle \alpha ^{i_{k}}\neq 0}







The output must comply to the following rules:

   don't show null terms, unless the whole combination is null. 
 e(1)     is fine,     e(1) + 0*e(3)     or     e(1) + 0     is wrong.
   don't show scalars when they are equal to one or minus one. 
 e(3)     is fine,     1*e(3)     is wrong.
   don't prefix by a minus sign if it follows a preceding term.   Instead you use subtraction. 
 e(4) - e(5)     is fine,     e(4) + -e(5)     is wrong.


Show here output for the following lists of scalars:

 1)    1,  2,  3
 2)    0,  1,  2,  3
 3)    1,  0,  3,  4
 4)    1,  2,  0
 5)    0,  0,  0
 6)    0
 7)    1,  1,  1
 8)   -1, -1, -1
 9)   -1, -2,  0, -3
10)   -1


",Python,"def linear(x):
    return ' + '.join(['{}e({})'.format('-' if v == -1 else '' if v == 1 else str(v) + '*', i + 1)
        for i, v in enumerate(x) if v] or ['0']).replace(' + -', ' - ')
 
list(map(lambda x: print(linear(x)), [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0],
        [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]]))",Human_written,Python_from_C
http://rosettacode.org/wiki/Doubly-linked_list/Definition,Doubly-linked list/Definition,"Define the data structure for a complete Doubly Linked List.

 The structure should support adding elements to the head, tail and middle of the list. 
 The structure should not allow circular loops


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"from collections import deque
 
some_list = deque([""a"", ""b"", ""c""])
print(some_list)
 
some_list.appendleft(""Z"")
print(some_list)
 
for value in reversed(some_list):
    print(value)",Human_written,Python_from_C
http://rosettacode.org/wiki/Variadic_function,Variadic function,"Task

Create a function which takes in a variable number of arguments and prints each one on its own line.

Also show, if possible in your language, how to call the function on a list of arguments constructed at runtime.



Functions of this type are also known as Variadic Functions.



Related task

   Call a function

",Python,"# 20220106 Python programming solution
 
def print_all(*args):
   for arg in args:
      print(arg)
 
print_all(""Rosetta"", ""Code"", ""Is"", ""Awesome!"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds,Sorting algorithms/Cocktail sort with shifting bounds,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The   cocktail sort   is an improvement on the   Bubble Sort.



A cocktail sort is also known as:

   cocktail shaker sort
   happy hour sort
   bidirectional bubble sort
   a bubble sort variation
   a selection sort variation
   ripple sort
   shuffle sort
   shuttle sort


The improvement is basically that values ""bubble""   (migrate)   both directions through the
array,   because on each iteration the cocktail sort   bubble sorts   once
forwards and once backwards.

After   ii   passes,   the first   ii   and the
last   ii   elements in the array are in their correct
positions,   and don't have to be checked (again).

By shortening the part of the array that is sorted each time,   the number of
comparisons can be halved.



Pseudocode for the    2nd    algorithm   (from
Wikipedia)   with an added comment and changed indentations:

function A = cocktailShakerSort(A)
% `beginIdx` and `endIdx` marks the first and last index to check.
beginIdx = 1;
endIdx = length(A) - 1;
 
    while beginIdx <= endIdx
    newBeginIdx = endIdx;
    newEndIdx = beginIdx;
        for ii = beginIdx:endIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newEndIdx = ii;
            end
        end
 
    % decreases `endIdx` because the elements after `newEndIdx` are in correct order
    endIdx = newEndIdx - 1;
 
    % (FOR  (below)  decrements the  II  index by -1.
 
        for ii = endIdx:-1:beginIdx
            if A(ii) > A(ii + 1)
                [A(ii+1), A(ii)] = deal(A(ii), A(ii+1));
                newBeginIdx = ii;
            end
        end
 
    % increases `beginIdx` because the elements before `newBeginIdx` are in correct order.
    beginIdx = newBeginIdx + 1;
    end
end
%   indicates a comment,   and   deal   indicates a   swap.



Task

Implement a   cocktail sort   and optionally show the sorted output here on this page.

See the   discussion   page for some timing comparisons.



Related task

   cocktail sort

",Python,"""""""
 
Python example of
 
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort_with_shifting_bounds
 
based on 
 
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort#Python
 
""""""
 
def cocktailshiftingbounds(A):
    beginIdx = 0
    endIdx = len(A) - 1
 
    while beginIdx <= endIdx:
        newBeginIdx = endIdx
        newEndIdx = beginIdx
        for ii in range(beginIdx,endIdx):
            if A[ii] > A[ii + 1]:
                A[ii+1], A[ii] = A[ii], A[ii+1]
                newEndIdx = ii
 
        endIdx = newEndIdx
 
        for ii in range(endIdx,beginIdx-1,-1):
            if A[ii] > A[ii + 1]:
                A[ii+1], A[ii] = A[ii], A[ii+1]
                newBeginIdx = ii
 
        beginIdx = newBeginIdx + 1
 
test1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]
cocktailshiftingbounds(test1)
print(test1)
 
test2=list('big fjords vex quick waltz nymph')
cocktailshiftingbounds(test2)
print(''.join(test2))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"import numpy as np
 
def print_matrix(matrix):
    width = max(len(str(x)) for x in matrix.flatten())
    for row in matrix:
        print(""|"", end="""")
        for x in row:
            print(str(x).rjust(width), end="" "")
        print(""|"")
 
def generate_upper(size):
    m = np.zeros((size, size), dtype=int)
    for c in range(size):
        m[0, c] = 1
    for r in range(1, size):
        for c in range(r, size):
            m[r, c] = m[r-1, c-1] + m[r, c-1]
    return m
 
def generate_lower(size):
    m = np.zeros((size, size), dtype=int)
    for r in range(size):
        m[r, 0] = 1
    for c in range(1, size):
        for r in range(c, size):
            m[r, c] = m[r-1, c-1] + m[r-1, c]
    return m
 
def generate_symmetric(size):
    m = np.zeros((size, size), dtype=int)
    for i in range(size):
        m[0, i] = m[i, 0] = 1
    for r in range(1, size):
        for c in range(1, size):
            m[r, c] = m[r-1, c] + m[r, c-1]
    return m
 
print_matrix(generate_upper(5))
print()
print_matrix(generate_lower(5))
print()
print_matrix(generate_symmetric(5))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Probabilistic_choice,Probabilistic choice,"Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
Related task

 Random number generator (device)

",Python,"import random, bisect
 
def probchoice(items, probs):
  '''\
  Splits the interval 0.0-1.0 in proportion to probs
  then finds where each random.random() choice lies
  '''
 
  prob_accumulator = 0
  accumulator = []
  for p in probs:
    prob_accumulator += p
    accumulator.append(prob_accumulator)
 
  while True:
    r = random.random()
    yield items[bisect.bisect(accumulator, r)]
 
def probchoice2(items, probs, bincount=10000):
  '''\
  Puts items in bins in proportion to probs
  then uses random.choice() to select items.
 
  Larger bincount for more memory use but
  higher accuracy (on avarage).
  '''
 
  bins = []
  for item,prob in zip(items, probs):
    bins += [item]*int(bincount*prob)
  while True:
    yield random.choice(bins)
 
 
def tester(func=probchoice, items='good bad ugly'.split(),
                    probs=[0.5, 0.3, 0.2],
                    trials = 100000
                    ):
  def problist2string(probs):
    '''\
    Turns a list of probabilities into a string
    Also rounds FP values
    '''
    return "","".join('%8.6f' % (p,) for p in probs)
 
  from collections import defaultdict
 
  counter = defaultdict(int)
  it = func(items, probs)
  for dummy in xrange(trials):
    counter[it.next()] += 1
  print ""\n##\n## %s\n##"" % func.func_name.upper()  
  print ""Trials:              "", trials
  print ""Items:               "", ' '.join(items)
  print ""Target probability:  "", problist2string(probs)
  print ""Attained probability:"", problist2string(
    counter[x]/float(trials) for x in items)
 
if __name__ == '__main__':
  items = 'aleph beth gimel daleth he waw zayin heth'.split()
  probs = [1/(float(n)+5) for n in range(len(items))]
  probs[-1] = 1-sum(probs[:-1])
  tester(probchoice, items, probs, 1000000)
  tester(probchoice2, items, probs, 1000000)",Human_written,Python_from_C
http://rosettacode.org/wiki/Magic_squares_of_odd_order,Magic squares of odd order,"A magic square is an   NxN   square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,   and   both long (main) diagonals are equal to the same sum (which is called the   magic number   or   magic constant).

The numbers are usually (but not always) the first   N2   positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.



 8 
 1 
 6


 3 
 5 
 7


 4 
 9 
 2



Task
For any odd   N,   generate a magic square with the integers    1 ──► N,   and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for   N = 5.



 Related tasks
 Magic squares of singly even order
 Magic squares of doubly even order



 See also

 MathWorld™ entry: Magic_square 
 Odd Magic Squares (1728.org)

",Python,"n = 9
square = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    for j in range(n):
        square[i][j] = n * (((i + 1) + (j + 1) - 1 + (n >> 1)) % n) + (((i + 1) + (2 * (j + 1)) - 2) % n) + 1
        print(f""{square[i][j]:3} "", end="""")
    print()
sum = n * (((n * n) + 1) / 2)
print(f""The sum of the square is {sum}."")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Self_numbers,Self numbers,"A number n is a self number if there is no number g such that g + the sum of g's digits = n. So 18 is not a self number because 9+9=18, 43 is not a self number because 35+5+3=43.


The task is:

 Display the first 50 self numbers;
 I believe that the 100000000th self number is 1022727208. You should either confirm or dispute my conjecture.

224036583-1 is a Mersenne prime, claimed to also be a self number. Extra credit to anyone proving it.


See also
 
OEIS: A003052 - Self numbers or Colombian numbers
Wikipedia: Self numbers",Python,"from array import array
from math import log10
from sys import stdout
 
MC = 103 * 1000 * 10000 + 11 * 9 + 1
SV = array('B', [0] * (MC + 1))
 
def sieve():
    dS = [0] * 10000
    for a in range(9, -1, -1):
        for b in range(9, -1, -1):
            for c in range(9, -1, -1):
                for d in range(9, -1, -1):
                    dS[a * 1000 + b * 100 + c * 10 + d] = a + b + c + d
    for a in range(103):
        for b in range(1000):
            for c in range(10000):
                SV[dS[a * 1000 + b] + dS[b * 10000 + c] + a * 100000000 + b * 10000 + c] = 1
 
def main():
    sieve()
    print(""The first 50 self numbers are:"")
    count = 0
    for i in range(MC):
        if SV[i] == 0:
            count += 1
            if count <= 50:
                stdout.write(str(i) +'')
            else:
                print(""\n\n       Index     Self number"")
    for i in range(MC):
        if SV[i] == 0:
            count += 1
            if count % (10 ** int(log10(count))) == 0:
                print(""{:12,d}   {:13,d}"".format(count, i))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Range_expansion,Range expansion,"A format for expressing an ordered list of integers is to use a comma separated list of either

 individual integers
 Or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. (The range includes all integers in the interval including both endpoints)
 The range syntax is to be used only for, and for every range that expands to more than two values.
Example

The list of integers:

 -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20
Is accurately expressed by the range expression:

 -6,-3-1,3-5,7-11,14,15,17-20
(And vice-versa).



Task

Expand the range description:

  -6,-3--1,3-5,7-11,14,15,17-20 

Note that the second element above,
is the range from minus 3 to minus 1. 



Related task

   Range extraction

",Python,"def rangeexpand(txt):
    lst = []
    for r in txt.split(','):
        if '-' in r[1:]:
            r0, r1 = r[1:].split('-', 1)
            lst += range(int(r[0] + r0), int(r1) + 1)
        else:
            lst.append(int(r))
    return lst
 
print(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Memory_allocation,Memory allocation,"Task

Show how to explicitly allocate and deallocate blocks of memory in your language.

Show access to different types of memory (i.e., heap, stack, shared, foreign) if applicable.



",Python,">>> from array import array
>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \u2641'),
	('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]
>>> for typecode, initializer in argslist:
	a = array(typecode, initializer)
	print a
	del a
 
 
array('l')
array('c', 'hello world')
array('u', u'hello \u2641')
array('l', [1, 2, 3, 4, 5])
array('d', [1.0, 2.0, 3.1400000000000001])
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Respond_to_an_unknown_method_call,Respond to an unknown method call,"Task

Demonstrate how to make the object respond (sensibly/usefully) to an invocation of a method on it that it does not support through its class definitions.

Note that this is not the same as just invoking a defined method whose name is given dynamically; the method named at the point of invocation must not be defined.

This task is intended only for object systems that use a dynamic dispatch mechanism without static checking.



Related task

   Send an unknown method call.

",Python,"# Python version 3.5.2
# Generated by Kotlin 1.2.0

class C:
    def __noSuchMethod__(self, id, args):
        print('Class C does not have a method called'+ id)
        if len(args) > 0:
            print('which takes arguments:'+ str(args))

def main(args):
    c = C()
    c.foo()

if __name__ == '__main__':
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Order_two_numerical_lists,Order two numerical lists,"sorting

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Write a function that orders two lists or arrays filled with numbers.
The function should accept two lists as arguments and return true if the first list should be ordered before the second, and false otherwise.

The order is determined by lexicographic order: Comparing the first element of each list.
If the first elements are equal, then the second elements should be compared, and so on, until one of the list has no more elements.
If the first list runs out of elements the result is true.
If the second list or both run out of elements the result is false.

Note: further clarification of lexicographical ordering is expounded on the talk page here and here.
",Python,">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]
False",Human_written,Python_from_Go
http://rosettacode.org/wiki/Compare_sorting_algorithms%27_performance,Compare sorting algorithms' performance,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Measure a relative performance of sorting algorithms implementations.

Plot execution time vs. input sequence length dependencies for various implementation of sorting algorithm and different input sequence types (example figures).

Consider three type of input sequences:

   ones: sequence of all 1's.   Example: {1, 1, 1, 1, 1}
   range: ascending sequence, i.e. already sorted.   Example: {1, 2, 3, 10, 15}
   shuffled range: sequence with elements randomly distributed.   Example: {5, 3, 9, 6, 8}


Consider at least two different sorting functions (different algorithms or/and different implementation of the same algorithm).

For example, consider Bubble Sort, Insertion sort, Quicksort or/and implementations of Quicksort with different pivot selection mechanisms.   Where possible, use existing implementations.

Preliminary subtask:

   Bubble Sort, Insertion sort, Quicksort, Radix sort, Shell sort
   Query Performance
   Write float arrays to a text file
   Plot x, y arrays
   Polynomial Fitting


General steps:

   Define sorting routines to be considered.
   Define appropriate sequence generators and write timings.
   Plot timings.
   What conclusions about relative performance of the sorting routines could be made based on the plots?

",Python,"import time
import random
import math
 
class Array(list):
    def radix_sort(self, base=10):
        ary = self[:]
        rounds = int(math.log(max(ary), base)) + 1
        for i in range(rounds):
            buckets = [[] for _ in range(base)]
            base_i = base**i
            for n in ary:
                digit = (n/base_i) % base
                buckets[digit].append(n)
            ary = [n for bucket in buckets for n in bucket]
        return ary
 
    def quick_sort(self):
        if len(self) <= 1:
            return self
        pivot = random.choice(self)
        g = {}
        for x in self:
            g.setdefault(x<pivot, []).append(x)
        return g.get(True, []).quick_sort() + g.get(False, []) + g.get(True, []).quick_sort()
 
    def shell_sort(self):
        inc = len(self) / 2
        while inc > 0:
            for i in range(inc, len(self)):
                value = self[i]
                j = i - inc
                while j >= 0 and self[j] > value:
                    self[j+inc] = self[j]
                    j -= inc
                self[j+inc] = value
            inc = 1 if inc == 2 else int(inc * 5.0 / 11)
        return self
 
    def insertion_sort(self):
        for i in range(1, len(self)):
            value = self[i]
            j = i - 1
            while j >= 0 and self[j] > value:
                self[j+1] = self[j]
                j -= 1
            self[j+1] = value
        return self
 
    def bubble_sort(self):
        for i in range(1, len(self)):
            for j in range(len(self)-i):
                if self[j] > self[j+1]:
                    self[j], self[j+1] = self[j+1], self[j]
        return self
 
data_size = [1000, 10000, 100000, 1000000]
data = []
for size in data_size:
    ary = range(1, size+1)
    data.append([ [1]*size, ary, random.sample(ary, size), ary[::-1] ])
data = zip(*data)
 
data_type = [""set to all ones"", ""ascending sequence"", ""randomly shuffled"", ""descending sequence""]
print ""Array size:          "",
print "" "".join(""%9d"" % size for size in data_size)
 
for arys in data:
    print ""\nData %s:"" % data_type.pop(0)
    for m in [list.sort, Array.radix_sort, Array.quick_sort, Array.shell_sort, Array.insertion_sort, Array.bubble_sort]:
        print ""%20s "" % m.__name__,
        flag = True
        for ary in arys:
            if flag:
                t0 = time.time()
                m(ary[:])
                print ""%7.3f"" % (t1 = time.time() - t0),
                flag = False if t1 > 2 else True
            else:
                print ""   --.---"",
        print",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Memory_layout_of_a_data_structure,Memory layout of a data structure,"It is often useful to control the memory layout of fields in a data structure to match an interface control definition, or to interface with hardware. Define a data structure matching the RS-232 Plug Definition. Use the 9-pin definition for brevity.

Pin Settings for Plug
(Reverse order for socket.)
__________________________________________
1  2  3  4  5  6  7  8  9  10 11 12 13
 14 15 16 17 18 19 20 21 22 23 24 25
_________________
1  2  3  4  5
6  7  8  9
25 pin                        9 pin
1 - PG   Protective ground
2 - TD   Transmitted data     3
3 - RD   Received data        2
4 - RTS  Request to send      7
5 - CTS  Clear to send        8
6 - DSR  Data set ready       6
7 - SG   Signal ground        5
8 - CD   Carrier detect       1
9 - + voltage (testing)
10 - - voltage (testing)
11 -
12 - SCD  Secondary CD
13 - SCS  Secondary CTS
14 - STD  Secondary TD
15 - TC   Transmit clock
16 - SRD  Secondary RD
17 - RC   Receiver clock
18 -
19 - SRS  Secondary RTS            
20 - DTR  Data terminal ready      4
21 - SQD  Signal quality detector
22 - RI   Ring indicator           9
23 - DRS  Data rate select
24 - XTC  External clock
25 -
",Python,"# version 1.0.6
 
OFF = False
ON  = True
 
def toOnOff(b):
    return ""ON"" if b else ""OFF""
 
class Rs232Pins9:
    def __init__(self, carrierDetect = OFF, receivedData = OFF, transmittedData = OFF, dataTerminalReady = OFF, signalGround = OFF, dataSetReady = OFF, requestToSend = OFF, clearToSend = OFF, ringIndicator = OFF):
        self.carrierDetect     = carrierDetect
        self.receivedData      = receivedData
        self.transmittedData   = transmittedData
        self.dataTerminalReady = dataTerminalReady
        self.signalGround      = signalGround
        self.dataSetReady      = dataSetReady
        self.requestToSend     = requestToSend
        self.clearToSend       = clearToSend
        self.ringIndicator     = ringIndicator
    def setPin(self, n, v):
        if n == 1:
            self.carrierDetect = v
        elif n == 2:
            self.receivedData = v
        elif n == 3:
            self.transmittedData = v
        elif n == 4:
            self.dataTerminalReady = v
        elif n == 5:
            self.signalGround = v
        elif n == 6:
            self.dataSetReady = v
        elif n == 7:
            self.requestToSend = v
        elif n == 8:
            self.clearToSend = v
        elif n == 9:
            self.ringIndicator = v
    def __getitem__(self, n):
        if n == 1:
            return self.carrierDetect
        elif n == 2:
            return self.receivedData
        elif n == 3:
            return self.transmittedData
        elif n == 4:
            return self.dataTerminalReady
        elif n == 5:
            return self.signalGround
        elif n == 6:
            return self.dataSetReady
        elif n == 7:
            return self.requestToSend
        elif n == 8:
            return self.clearToSend
        elif n == 9:
            return self.ringIndicator
 
plug = Rs232Pins9(carrierDetect = ON, receivedData = ON) # set first two pins, say
print(toOnOff(plug[2]))                                  # print value of pin 2 by number
plug.transmittedData = ON                                # set pin 3 by name
plug.setPin(4, ON)                                       # set pin 4 by number
print(toOnOff(plug[3]))                                  # print value of pin 3 by number
print(toOnOff(plug.dataTerminalReady))                   # print value of pin 4 by name 
print(toOnOff(plug.ringIndicator))                       # print value of pin 9 by name",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed),Apply a digital filter (direct form II transposed),"Digital filters are used to apply a mathematical operation to a sampled signal. One of the common formulations is the ""direct form II transposed"" which can represent both infinite impulse response (IIR) and finite impulse response (FIR) filters, as well as being more numerically stable than other forms. [1]

Task

Filter a signal using an order 3 low-pass Butterworth filter. The coefficients for the filter are a=[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17] and b = [0.16666667, 0.5, 0.5, 0.16666667]

The signal that needs filtering is the following vector: [-0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412, -0.662370894973, -1.00700480494, -0.404707073677 ,0.800482325044, 0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195, 0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293, 0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589]
",Python,"import numpy as np
 
def Filter(b, a, in_sig):
 
	out_sig = np.zeros(len(in_sig))
 
	for i in range(len(in_sig)):
		tmp = 0.
		j=0
		out_sig[i] = 0.
		for j in range(len(b)):
			if i - j < 0: continue
			tmp += b[j] * in_sig[i-j]
 
		for j in range(1, len(a)):
			if i - j < 0: continue
			tmp -= a[j]*out_sig[i-j]
 
		tmp /= a[0]
		out_sig[i] = tmp
 
	return out_sig
 
if __name__ == ""__main__"":
	sig = np.array([-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,\
		-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,\
		0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,\
		0.0259303398477,0.490105989562,0.549391221511,0.9047198589])
 
	#Constants for a Butterworth filter (order 3, low pass)
	a = np.array([1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17])
	b = np.array([0.16666667, 0.5, 0.5, 0.16666667])
 
	result = Filter(b, a, sig)
 
	print(result)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Operator_precedence,Operator precedence,"

 This page uses content from Wikipedia. The original article was at Operators in C and C++. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a list of   precedence   and   associativity   of all the operators and constructs that the language utilizes in descending order of precedence such that an operator which is listed on some row will be evaluated prior to any operator that is listed on a row further below it.

Operators that are in the same cell (there may be several rows of operators listed in a cell) are evaluated with the same level of precedence, in the given direction.

State whether arguments are passed by value or by reference.



",Python,"def write(x):
    print(x)

def read():
    return int(input())

def main():
    write(18 / 2 * 3 + 7)
    write(18 / (2 * 3) + 7)

main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"for i in range(0, 16):
    for j in range(32+i, 128, 16):
        k = chr(j)
        print(f""{j:3} : {k:<3}   "", end="""")
    print()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Chinese_remainder_theorem,Chinese remainder theorem,"Suppose   




n

1




{\displaystyle n_{1}}

,   




n

2




{\displaystyle n_{2}}

,   



…


{\displaystyle \ldots }

,   




n

k




{\displaystyle n_{k}}

   are positive integers that are pairwise co-prime.  

Then, for any given sequence of integers   




a

1




{\displaystyle a_{1}}

,   




a

2




{\displaystyle a_{2}}

,   



…


{\displaystyle \dots }

,   




a

k




{\displaystyle a_{k}}

,   there exists an integer   



x


{\displaystyle x}

   solving the following system of simultaneous congruences:

 







x



≡

a

1




(
mod


n

1


)





x



≡

a

2




(
mod


n

2


)








 
 
⋮




x



≡

a

k




(
mod


n

k


)







{\displaystyle {\begin{aligned}x&\equiv a_{1}{\pmod {n_{1}}}\\x&\equiv a_{2}{\pmod {n_{2}}}\\&{}\ \ \vdots \\x&\equiv a_{k}{\pmod {n_{k}}}\end{aligned}}}


Furthermore, all solutions   



x


{\displaystyle x}

   of this system are congruent modulo the product,   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

.



Task

Write a program to solve a system of linear congruences by applying the   Chinese Remainder Theorem.

If the system of equations cannot be solved, your program must somehow indicate this.

(It may throw an exception or return a special false value.)

Since there are infinitely many solutions, the program should return the unique solution   



s


{\displaystyle s}

   where   



0
≤
s
≤

n

1



n

2


…

n

k




{\displaystyle 0\leq s\leq n_{1}n_{2}\ldots n_{k}}

.


Show the functionality of this program by printing the result such that the   



n


{\displaystyle n}

's   are   



[
3
,
5
,
7
]


{\displaystyle [3,5,7]}

   and the   



a


{\displaystyle a}

's   are   



[
2
,
3
,
2
]


{\displaystyle [2,3,2]}

.


Algorithm:   The following algorithm only applies if the   




n

i




{\displaystyle n_{i}}

's   are pairwise co-prime.

Suppose, as above, that a solution is required for the system of congruences:

 



x
≡

a

i




(
mod


n

i


)



f
o
r


i
=
1
,
…
,
k


{\displaystyle x\equiv a_{i}{\pmod {n_{i}}}\quad \mathrm {for} \;i=1,\ldots ,k}


Again, to begin, the product   



N
=

n

1



n

2


…

n

k




{\displaystyle N=n_{1}n_{2}\ldots n_{k}}

   is defined.

Then a solution   



x


{\displaystyle x}

   can be found as follows:

For each   



i


{\displaystyle i}

,   the integers   




n

i




{\displaystyle n_{i}}

   and   



N

/


n

i




{\displaystyle N/n_{i}}

   are co-prime.

Using the   Extended Euclidean algorithm,   we can find integers   




r

i




{\displaystyle r_{i}}

   and   




s

i




{\displaystyle s_{i}}

   such that   




r

i



n

i


+

s

i


N

/


n

i


=
1


{\displaystyle r_{i}n_{i}+s_{i}N/n_{i}=1}

.

Then, one solution to the system of simultaneous congruences is:

 



x
=

∑

i
=
1


k



a

i



s

i


N

/


n

i




{\displaystyle x=\sum _{i=1}^{k}a_{i}s_{i}N/n_{i}}


and the minimal solution,

 



x


(
mod

N
)



{\displaystyle x{\pmod {N}}}

.

",Python,"# Python 2.7
def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda a, b: a*b, n)
 
    for n_i, a_i in zip(n, a):
        p = prod / n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod
 
 
def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1
    while a > 1:
        q = a / b
        a, b = b, a%b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0: x1 += b0
    return x1
 
if __name__ == '__main__':
    n = [3, 5, 7]
    a = [2, 3, 2]
    print chinese_remainder(n, a)",Human_written,Python_from_Go
http://rosettacode.org/wiki/First-class_functions,First-class functions,"A language has first-class functions if it can do each of the following without recursively invoking a compiler or interpreter or otherwise metaprogramming:

 Create new functions from preexisting functions at run-time
 Store functions in collections
 Use functions as arguments to other functions
 Use functions as return values of other functions


Task

Write a program to create an ordered collection A of functions of a real number. At least one function should be built-in and at least one should be user-defined; try using the sine, cosine, and cubing functions. Fill another collection B with the inverse of each function in A. Implement function composition as in Functional Composition. Finally, demonstrate that the result of applying the composition of each function in A and its inverse in B to a value, is the original value. (Within the limits of computational accuracy).

(A solution need not actually call the collections ""A"" and ""B"". These names are only used in the preceding paragraph for clarity.)



Related task
 
First-class Numbers
",Python,">>> # Some built in functions and their inverses
>>> from math import sin, cos, acos, asin
>>> # Add a user defined function and its inverse
>>> cube = lambda x: x * x * x
>>> croot = lambda x: x ** (1/3.0)
>>> # First class functions allow run-time creation of functions from functions
>>> # return function compose(f,g)(x) == f(g(x))
>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )
>>> # first class functions should be able to be members of collection types
>>> funclist = [sin, cos, cube]
>>> funclisti = [asin, acos, croot]
>>> # Apply functions from lists as easily as integers
>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]
[0.5, 0.4999999999999999, 0.5]
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Padovan_n-step_number_sequences,Padovan n-step number sequences,"As the Fibonacci sequence expands to the Fibonacci n-step number sequences; We similarly expand the Padovan sequence to form these Padovan n-step number sequences.

The Fibonacci-like sequences can be defined like this:

   For n == 2:
       start:      1, 1
       Recurrence: R(n, x) = R(n, x-1) + R(n, x-2); for n == 2
   For n == N:
       start:      First N terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-1) + R(N, x-2) + ... R(N, x-N))

For this task we similarly define terms of the first 2..n-step Padovan sequences as:

   For n == 2:
       start:      1, 1, 1
       Recurrence: R(n, x) = R(n, x-2) + R(n, x-3); for n == 2
   For n == N:
       start:      First N + 1 terms of R(N-1, x)
       Recurrence: R(N, x) = sum(R(N, x-2) + R(N, x-3) + ... R(N, x-N-1))

The initial values of the sequences are:


 Padovan 



n


{\displaystyle n}

-step sequences


 



n


{\displaystyle n}

 
 Values 
 OEIS Entry


 2 
 1,1,1,2,2,3,4,5,7,9,12,16,21,28,37, ... 
 A134816: 'Padovan's spiral numbers'


 3 
 1,1,1,2,3,4,6,9,13,19,28,41,60,88,129, ... 
 A000930: 'Narayana's cows sequence'


 4 
 1,1,1,2,3,5,7,11,17,26,40,61,94,144,221, ... 
 A072465: 'A Fibonacci-like model in which each pair of rabbits dies after the birth of their 4th litter'


 5 
 1,1,1,2,3,5,8,12,19,30,47,74,116,182,286, ... 
 A060961: 'Number of compositions (ordered partitions) of n into 1's, 3's and 5's'


 6 
 1,1,1,2,3,5,8,13,20,32,51,81,129,205,326, ... 
 <not found>


 7 
 1,1,1,2,3,5,8,13,21,33,53,85,136,218,349, ... 
 A117760: 'Expansion of 1/(1 - x - x^3 - x^5 - x^7)'


 8 
 1,1,1,2,3,5,8,13,21,34,54,87,140,225,362, ... 
 <not found>




Task

 Write a function to generate the first 



t


{\displaystyle t}

 terms, of the first 2..max_n Padovan 



n


{\displaystyle n}

-step number sequences as defined above.
 Use this to print and show here at least the first t=15 values of the first 2..8 



n


{\displaystyle n}

-step sequences.
 (The OEIS column in the table above should be omitted).

",Python,"def padovanN(n, t):
    if n < 2 or t < 3:
        ones = [1] * t
        return ones
    p = padovanN(n-1, t)
    for i in range(n, t):
        p[i] = 0
        for j in range(i-2, i-n-1, -1):
            p[i] += p[j]
    return p
 
t = 15
print(""First"", t, ""terms of the Padovan n-step number sequences:"")
for n in range(2, 9):
    print(n, "":"", padovanN(n, t))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Long_primes,Long primes,"

A   long prime   (as defined here)   is a prime number whose reciprocal   (in decimal)   has
a   period length   of one less than the prime number.


Long primes   are also known as:

   base ten cyclic numbers
   full reptend primes
   golden primes
   long period primes
   maximal period primes
   proper primes


Another definition:   primes   p   such that the decimal expansion of   1/p   has period   p-1,   which is the greatest period possible for any integer.



Example

7   is the first long prime,   the reciprocal of seven
is   1/7,   which
is equal to the repeating decimal fraction   0.142857142857···

The length of the   repeating   part of the decimal fraction
is six,   (the underlined part)   which is one less
than the (decimal) prime number   7.

Thus   7   is a long prime.



There are other (more) general definitions of a   long prime   which
include wording/verbiage for bases other than ten.



Task

   Show all long primes up to   500   (preferably on one line).
   Show the   number   of long primes up to         500
   Show the   number   of long primes up to      1,000
   Show the   number   of long primes up to      2,000
   Show the   number   of long primes up to      4,000
   Show the   number   of long primes up to      8,000
   Show the   number   of long primes up to   16,000
   Show the   number   of long primes up to   32,000
   Show the   number   of long primes up to   64,000   (optional)
   Show all output here.


Also see

   Wikipedia: full reptend prime
   MathWorld: full reptend prime
   OEIS: A001913

",Python,"#
# References:
# https://en.wikipedia.org/wiki/Full_reptend_prime
# https://en.wikipedia.org/wiki/Primitive_root_modulo_n#Finding_primitive_roots
#
 
def modpow(base, exp, n):
    if n == 1:
        return 0
    result = 1
    base %= n
    while exp > 0:
        if (exp & 1) == 1:
            result = (result * base) % n
        base = (base * base) % n
        exp >>= 1
    return result
 
def is_long_prime(sieve, prime):
    if not sieve[prime]:
        return False
    if 10 % prime == 0:
        return False
    n = prime - 1
    m = n
    p = 2
    while p * p <= n:
        if sieve[p] and m % p == 0:
            if modpow(10, n / p, prime) == 1:
                return False
            while m % p == 0:
                m /= p
        p += 1
    if m == 1:
        return True
    return modpow(10, n / m, prime) != 1
 
def long_primes(limit1, limit2):
    sieve = [True] * (limit2 + 1)
    sieve[0] = sieve[1] = False
    for prime in range(2, limit2 + 1):
        if sieve[prime]:
            for i in range(prime * prime, limit2 + 1, prime):
                sieve[i] = False
    limit = limit1
    count = 0
    for prime in range(3, limit2 + 1, 2):
        if is_long_prime(sieve, prime):
            if prime < limit1:
                print(prime, end=' ')
            if prime > limit:
                print(""\nNumber of long primes up to {}: {}"".format(limit, count))
                limit *= 2
            count += 1
    print(""\nNumber of long primes up to {}: {}"".format(limit, count))
 
if __name__ == '__main__':
    long_primes(500, 8192000)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Two_bullet_roulette,Two bullet roulette,"The following is supposedly a question given to mathematics graduates seeking jobs on Wall Street:


 A revolver handgun has a revolving cylinder with six chambers for bullets.
 It is loaded with the following procedure:
 1. Check the first chamber to the right of the trigger for a bullet. If a bullet
is seen, the cylinder is rotated one chamber clockwise and the next chamber
checked until an empty chamber is found.
 2. A cartridge containing a bullet is placed in the empty chamber.
 3. The cylinder is then rotated one chamber clockwise.
 To randomize the cylinder's position, the cylinder is spun, which causes the cylinder to take
a random position from 1 to 6 chamber rotations clockwise from its starting position.
 When the trigger is pulled the gun will fire if there is a bullet in position 0, which is just
counterclockwise from the loading position.
 The gun is unloaded by removing all cartridges from the cylinder.
 According to the legend, a suicidal Russian imperial military officer plays a game of Russian
roulette by putting two bullets in a six-chamber cylinder and pulls the trigger twice.
If the gun fires with a trigger pull, this is considered a successful suicide.
 The cylinder is always spun before the first shot, but it may or may not be spun after putting
in the first bullet and may or may not be spun after taking the first shot.
 Which of the following situations produces the highest probability of suicide?
 A. Spinning the cylinder after loading the first bullet, and spinning again after the first shot.
 B. Spinning the cylinder after loading the first bullet only.
 C. Spinning the cylinder after firing the first shot only.
 D. Not spinning the cylinder either after loading the first bullet or after the first shot.
 E. The probability is the same for all cases.


Task

 Run a repeated simulation of each of the above scenario, calculating the percentage of suicide with a randomization of the four spinning, loading and firing order scenarios.
 Show the results as a percentage of deaths for each type of scenario.
 The hand calculated probabilities are 5/9, 7/12, 5/9, and 1/2. A correct program should produce results close enough to those to allow a correct response to the interview question. 


Reference

Youtube video on the Russian 1895 Nagant revolver [[1]]



",Python,"import random
 
class Pistol:
    def __init__(self, method):
        self.fired = False
        self.cylinder = [False] * 6
        self.trigger = 0
        self.method = method.upper()
        self.rshift = lambda: self.trigger - 1 if self.trigger else 5
        self.load = lambda: self.cylinder[self.trigger] if self.cylinder[self.trigger] else self.rshift()
        self.unload = lambda: self.cylinder.fill(False)
        self.spin = lambda: random.randint(0, 5)
        self.fire = lambda: self.cylinder[self.trigger] if self.cylinder[self.trigger] else self.rshift()
        self.exec = lambda: self.method if not self.method else self.method.upper()
        for x in range(len(self.method)):
            if self.method[x] == 'F':
                self.fire()
            elif self.method[x] == 'L':
                self.load()
            elif self.method[x] == 'S':
                self.spin()
            elif self.method[x] == 'U':
                self.unload()
            else:
                print('Unknown character in method: {}'.format(self.method[x]))
 
# simulating
ITERATIONS = 250000
methods = 'lslsfsf lslsff llsfsf llsff'.split(' ')
bodyCount = 0
print('@ {} iterations:'.format(ITERATIONS))
print()
for x in range(len(methods)):
    bodyCount = 0
    for y in range(1, ITERATIONS):
        if Pistol(methods[x]).exec():
            bodyCount += 1
    print('{}:'.format(methods[x]))
    print('deaths: {} ({:.3f} %)'.format(bodyCount, bodyCount / ITERATIONS * 100))
    print()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Binary_strings,Binary strings,"Many languages have powerful and useful (binary safe) string manipulation functions, while others don't, making it harder for these languages to accomplish some tasks.

This task is about creating functions to handle binary strings (strings made of arbitrary bytes, i.e. byte strings according to Wikipedia) for those languages that don't have built-in support for them.

If your language of choice does have this built-in support, show a possible alternative implementation for the functions or abilities already provided by the language.

In particular the functions you need to create are:

 String creation and destruction (when needed and if there's no garbage collection or similar mechanism)
 String assignment
 String comparison
 String cloning and copying
 Check if a string is empty
 Append a byte to a string
 Extract a substring from a string
 Replace every occurrence of a byte (or a string) in a string with another string
 Join strings


Possible contexts of use: compression algorithms (like LZW compression), L-systems (manipulation of symbols), many more.



",Python,"#String creation
str=''
#or 
str2=str()
 
#String assignment
str=""Hello""
#or
str2=', Hey there' #can use "" or '
str=str+str2#concantenates
#string deletion
del str2#this will return true or false, true when it has been successfully deleted, it shouldn't/won't work when the variable has been declared with the keyword 'var', you don't have to initialize variables with the var keyword in Python, but when you do, you cannot 'delete' them. However Python garbage collects, so when the function returns, the variable declared on the function is erased.
 
#String comparison
str!=""Hello"" #!== not equal-> returns true there's also !==
str==""Hello, Hey there"" #returns true
#compares 'byte' by 'byte'
""Character Z"">""Character A"" #returns true, when using > or < operators it converts the string to an array and evalues the first index that is higher than another. (using unicode values) in this case 'Z' char code is 90 (decimal) and 'A' char code is 65, therefore making one string ""larger"" than the other.
 
#String cloning and copying
string=str#Strings are immutable therefore when you assign a string to a variable another one is created. So for two variables to have the'same' string you have to add that string to an object, and get/set the string from that object
 
#Check if a string is empty
bool('') #returns false
''[0] #returns undefined
''==0 #returns true 
''===0 #returns false
''==false #returns true
 
#Append byte to String
str+=""\x40""#using + operator before the equal sign on a string makes it equal to str=str+""\x40""
 
#Extract a substring from a string
#str is ""Hello, Hey there@""
str[3:] #returns ""lo, Hey there@""
str[-5:] #returns ""here@"" negative values just go to the end
str[7:9] #returns ""Hey there"" index of 7 + 9 characters after the 7
str[7:9] #same as substr
str[-5:] #negative values don't work on substring same as substr(0)
str[7:9] #returns ""He"" that is, whatever is between index 7 and index 9, same as substring(9,7)
 
#Replace every occurence of x byte with another string
str3=""url,url,url,url,url""
str3.replace(',','\n') #returns the same string with the, replaced by \n 
str4=str3.replace('.',lambda index:index==',' and '\n' or index)#it also supports callback functions, the function will be called when a match has been found..
#returns replacement
 
#Join Strings
' '.join([str,"" "",str3])#we can join an array of strings
str3+str4; 
str.join('\n',[str4]) #concantenate them",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test,Miller–Rabin primality test,"

 This page uses content from Wikipedia. The original article was at Miller–Rabin primality test. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The Miller–Rabin primality test or Rabin–Miller primality test is a primality test: an algorithm which determines whether a given number is prime or not.

The algorithm, as modified by Michael O. Rabin to avoid the generalized Riemann hypothesis, is a probabilistic algorithm.

The pseudocode, from Wikipedia is:

Input: n > 2, an odd integer to be tested for primality;
       k, a parameter that determines the accuracy of the test
Output: composite if n is composite, otherwise probably prime
write n − 1 as 2s·d with d odd by factoring powers of 2 from n − 1
LOOP: repeat k times:
   pick a randomly in the range [2, n − 1]
   x ← ad mod n
   if x = 1 or x = n − 1 then do next LOOP
   repeat s − 1 times:
      x ← x2 mod n
      if x = 1 then return composite
      if x = n − 1 then do next LOOP
   return composite
return probably prime

 The nature of the test involves big numbers, so the use of ""big numbers"" libraries (or similar features of the language of your choice) are suggested, but not mandatory.
 Deterministic variants of the test exist and can be implemented as extra (not mandatory to complete the task)

",Python,"import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True  
 
    for i in range(8):#number of trials 
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Date_manipulation,Date manipulation,"Task

Given the date string ""March 7 2009 7:30pm EST"", 

output the time 12 hours later in any human-readable format.

As extra credit, display the resulting time in a time zone different from your own.



",Python,"import datetime
 
def mt():
	datime1=""March 7 2009 7:30pm EST""
	formatting = ""%B %d %Y %I:%M%p ""
	datime2 = datime1[:-3]  # format can't handle ""EST"" for some reason
	tdelta = datetime.timedelta(hours=12)		# twelve hours..
	s3 = datetime.datetime.strptime(datime2, formatting)
	datime2 = s3+tdelta
	print datime2.strftime(""%B %d %Y %I:%M%p %Z"") + datime1[-3:]
 
mt()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Narcissistic_decimal_number,Narcissistic decimal number,"A   Narcissistic decimal number   is a non-negative integer,   



n


{\displaystyle n}

,   that is equal to the sum of the   



m


{\displaystyle m}

-th   powers of each of the digits in the decimal representation of   



n


{\displaystyle n}

,   where   



m


{\displaystyle m}

   is the number of digits in the decimal representation of   



n


{\displaystyle n}

.



Narcissistic (decimal) numbers are sometimes called   Armstrong   numbers, named after Michael F. Armstrong.

They are also known as   Plus Perfect   numbers.



An example

   if   



n


{\displaystyle n}

   is   153 
   then   



m


{\displaystyle m}

,   (the number of decimal digits)   is   3 
   we have    13 + 53 + 33   =   1 + 125 + 27   =   153  
   and so   153   is a narcissistic decimal number


Task

Generate and show here the first   25   narcissistic decimal numbers.



Note:   




0

1


=
0


{\displaystyle 0^{1}=0}

,   the first in the series.



See also

   the  OEIS entry:     Armstrong (or Plus Perfect, or narcissistic) numbers.
   MathWorld entry:   Narcissistic Number.
   Wikipedia entry:     Narcissistic number.

",Python,"def isNarc(x):
	if x < 0:
		return False
	xStr = str(x)
	m = len(xStr)
	sum = 0
	for c in xStr:
		sum += pow(int(c), m)
	return sum == x

def main():
	x = 0
	count = 0
	while count < 25:
		if isNarc(x):
			print(x, end = "" "")
			count += 1
		x += 1

main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Roots_of_a_quadratic_function,Roots of a quadratic function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
Write a program to find the roots of a quadratic equation, i.e., solve the equation 



a

x

2


+
b
x
+
c
=
0


{\displaystyle ax^{2}+bx+c=0}

.
Your program must correctly handle non-real roots, but it need not check that 



a
≠
0


{\displaystyle a\neq 0}

.

The problem of solving a quadratic equation is a good example of how dangerous it can be to ignore the peculiarities of floating-point arithmetic.
The obvious way to implement the quadratic formula suffers catastrophic loss of accuracy when one of the roots to be found is much closer to 0 than the other.
In their classic textbook on numeric methods Computer Methods for Mathematical Computations, George Forsythe, Michael Malcolm, and Cleve Moler suggest trying the naive algorithm with 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

5




{\displaystyle b=-10^{5}}

, and 



c
=
1


{\displaystyle c=1}

.
(For double-precision floats, set 



b
=
−

10

9




{\displaystyle b=-10^{9}}

.)
Consider the following implementation in Ada:

with Ada.Text_IO;                        use Ada.Text_IO;
with Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;
 
procedure Quadratic_Equation is
   type Roots is array (1..2) of Float;
   function Solve (A, B, C : Float) return Roots is
      SD : constant Float := sqrt (B**2 - 4.0 * A * C);
      AA : constant Float := 2.0 * A;
   begin
      return ((- B + SD) / AA, (- B - SD) / AA);
   end Solve;
 
   R : constant Roots := Solve (1.0, -10.0E5, 1.0);
begin
   Put_Line (""X1 ="" & Float'Image (R (1)) & "" X2 ="" & Float'Image (R (2)));
end Quadratic_Equation;

Output:
X1 = 1.00000E+06 X2 = 0.00000E+00
As we can see, the second root has lost all significant figures. The right answer is that X2 is about 




10

−
6




{\displaystyle 10^{-6}}

. The naive method is numerically unstable.

Suggested by Middlebrook (D-OA), a better numerical method: to define two parameters 



q
=


a
c



/

b


{\displaystyle q={\sqrt {ac}}/b}

 and 



f
=
1

/

2
+


1
−
4

q

2





/

2


{\displaystyle f=1/2+{\sqrt {1-4q^{2}}}/2}



and the two roots of the quardratic are: 






−
b

a


f


{\displaystyle {\frac {-b}{a}}f}

 and 






−
c


b
f





{\displaystyle {\frac {-c}{bf}}}




Task: do it better. This means that given 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

9




{\displaystyle b=-10^{9}}

, and 



c
=
1


{\displaystyle c=1}

, both of the roots your program returns should be greater than 




10

−
11




{\displaystyle 10^{-11}}

. Or, if your language can't do floating-point arithmetic any more precisely than single precision, your program should be able to handle 



b
=
−

10

6




{\displaystyle b=-10^{6}}

. Either way, show what your program gives as the roots of the quadratic in question. See page 9 of
""What Every Scientist Should Know About Floating-Point Arithmetic"" for a possible algorithm.
",Python,"import cmath
 
def quadratic(a, b, c):
    sqrt_discriminant = cmath.sqrt(b**2 - 4*a*c)
    return [(-b + sqrt_discriminant) / (2.0*a), (-b - sqrt_discriminant) / (2.0*a)]
 
print(quadratic(3, 4, 4/3.0))  # [-2/3]
print(quadratic(3, 2, -1))     # [1/3, -1]
print(quadratic(3, 2,  1))     # [(-1/3 + sqrt(2/9)i), (-1/3 - sqrt(2/9)i)]
print(quadratic(1, 0,  1))     # [(0+i), (0-i)]
print(quadratic(1, -1e6, 1))   # [1e6, 1e-6]
print(quadratic(-2,  7, 15))   # [-3/2, 5]
print(quadratic(1, -2,  1))    # [1]
print(quadratic(1,  3,  3))    # [(-3 + sqrt(3)i)/2), (-3 - sqrt(3)i)/2)]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Window_creation,Window creation,"Display a GUI window. The window need not have any contents, but should respond to requests to be closed.
",Python,"import sys
from PyQt4.QtGui import QApplication, QMainWindow
 
app = QApplication(sys.argv)
window = QMainWindow()
window.show()
sys.exit(app.exec_())",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"#include <stdio.h>
#include <stdlib.h>
 
/* to read expanded code, run through cpp | indent -st */
#define DECL_STACK_TYPE(type, name)					\
typedef struct stk_##name##_t{type *buf; size_t alloc,len;}*stk_##name;	\
stk_##name stk_##name##_create(size_t init_size) {			\
	stk_##name s; if (!init_size) init_size = 4;			\
	s = malloc(sizeof(struct stk_##name##_t));			\
	if (!s) return 0;						\
	s->buf = malloc(sizeof(type) * init_size);			\
	if (!s->buf) { free(s); return 0; }				\
	s->len = 0, s->alloc = init_size;				\
	return s; }							\
int stk_##name##_push(stk_##name s, type item) {			\
	type *tmp;							\
	if (s->len >= s->alloc) {					\
		tmp = realloc(s->buf, s->alloc*2*sizeof(type));		\
		if (!tmp) return -1; s->buf = tmp;			\
		s->alloc *= 2; }					\
	s->buf[s->len++] = item;					\
	return s->len; }						\
type stk_##name##_pop(stk_##name s) {					\
	type tmp;							\
	if (!s->len) abort();						\
	tmp = s->buf[--s->len];						\
	if (s->len * 2 <= s->alloc && s->alloc >= 8) {			\
		s->alloc /= 2;						\
		s->buf = realloc(s->buf, s->alloc * sizeof(type));}	\
	return tmp; }							\
void stk_##name##_delete(stk_##name s) {				\
	free(s->buf); free(s); }
 
#define stk_empty(s) (!(s)->len)
#define stk_size(s) ((s)->len)
 
DECL_STACK_TYPE(int, int)
 
int main(void)
{
	int i;
	stk_int stk = stk_int_create(0);
 
	printf(""pushing: "");
	for (i = 'a'; i <= 'z'; i++) {
		printf("" %c"", i);
		stk_int_push(stk, i);
	}
 
	printf(""\nsize now: %d"", stk_size(stk));
	printf(""\nstack is%s empty\n"", stk_empty(stk)? """" : "" not"");
 
	printf(""\npoppoing:"");
	while (stk_size(stk))
		printf("" %c"", stk_int_pop(stk));
	printf(""\nsize now: %d"", stk_size(stk));
	printf(""\nstack is%s empty\n"", stk_empty(stk)? """" : "" not"");
 
	/* stk_int_pop(stk); <-- will abort() */
	stk_int_delete(stk);
	return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Padovan_sequence,Padovan sequence,"

The Padovan sequence is similar to the Fibonacci sequence in several ways.
Some are given in the table below, and the referenced video shows some of the geometric
similarities.



 Comment 
 Padovan 
 Fibonacci


 
 



 Named after. 
 Richard Padovan 
 Leonardo of Pisa: Fibonacci


 
 



 Recurrence initial values. 
 P(0)=P(1)=P(2)=1 
 F(0)=0, F(1)=1


 Recurrence relation. 
 P(n)=P(n-2)+P(n-3) 
 F(n)=F(n-1)+F(n-2)


 
 



 First 10 terms. 
 1,1,1,2,2,3,4,5,7,9 
 0,1,1,2,3,5,8,13,21,34


 
 



 Ratio of successive terms... 
 Plastic ratio, p 
 Golden ratio, g


 
 1.324717957244746025960908854… 
 1.6180339887498948482...


 Exact formula of ratios p and q. 
 ((9+69**.5)/18)**(1/3) + ((9-69**.5)/18)**(1/3) 
 (1+5**0.5)/2


 Ratio is real root of polynomial. 
 p: x**3-x-1 
 g: x**2-x-1


 
 



 Spirally tiling the plane using. 
 Equilateral triangles 
 Squares


 
 



 Constants for ... 
 s= 1.0453567932525329623 
 a=5**0.5


 ... Computing by truncation. 
 P(n)=floor(p**(n-1) / s + .5) 
 F(n)=floor(g**n / a + .5)


 
 



 L-System Variables. 
 A,B,C 
 A,B


 L-System Start/Axiom. 
 A 
 A


 L-System Rules. 
 A->B,B->C,C->AB 
 A->B,B->AB

Task

 Write a function/method/subroutine to compute successive members of the Padovan series using the recurrence relation.
 Write a function/method/subroutine to compute successive members of the Padovan series using the floor function.
 Show the first twenty terms of the sequence.
 Confirm that the recurrence and floor based functions give the same results for 64 terms,
 Write a function/method/... using the L-system to generate successive strings.
 Show the first 10 strings produced from the L-system
 Confirm that the length of the first 32 strings produced is the Padovan sequence.
Show output here, on this page.

Ref

 The Plastic Ratio - Numberphile video.

",Python,"from math import floor
from collections import deque
from typing import Dict, Generator
 
 
def padovan_r() -> Generator[int, None, None]:
    last = deque([1, 1, 1], 4)
    while True:
        last.append(last[-2] + last[-3])
        yield last.popleft()
 
_p, _s = 1.324717957244746025960908854, 1.0453567932525329623
 
def padovan_f(n: int) -> int:
    return floor(_p**(n-1) / _s + .5)
 
def padovan_l(start: str='A',
             rules: Dict[str, str]=dict(A='B', B='C', C='AB')
             ) -> Generator[str, None, None]:
    axiom = start
    while True:
        yield axiom
        axiom = ''.join(rules[ch] for ch in axiom)
 
 
if __name__ == ""__main__"":
    from itertools import islice
 
    print(""The first twenty terms of the sequence."")
    print(str([padovan_f(n) for n in range(20)])[1:-1])
 
    r_generator = padovan_r()
    if all(next(r_generator) == padovan_f(n) for n in range(64)):
        print(""\nThe recurrence and floor based algorithms match to n=63 ."")
    else:
        print(""\nThe recurrence and floor based algorithms DIFFER!"")
 
    print(""\nThe first 10 L-system string-lengths and strings"")
    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))
    print('\n'.join(f""  {len(string):3} {repr(string)}""
                    for string in islice(l_generator, 10)))
 
    r_generator = padovan_r()
    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))
    if all(len(next(l_generator)) == padovan_f(n) == next(r_generator)
           for n in range(32)):
        print(""\nThe L-system, recurrence and floor based algorithms match to n=31 ."")
    else:
        print(""\nThe L-system, recurrence and floor based algorithms DIFFER!"")",Human_written,Python_from_Rust
"http://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion","Angles (geometric), normalization and conversion","This task is about the normalization and/or conversion of (geometric) angles using
some common scales.



The angular scales that will be used in this task are:

   degree
   gradian
   mil
   radian


Definitions

The angular scales used or referenced here:

   turn   is a full turn or 360 degrees, also shown as 360º
   degree   is   1/360   of a turn
   gradian   is   1/400   of a turn
   mil   is   1/6400   of a turn
   radian   is   1/2



π


{\displaystyle \pi }

   of a turn   (or   0.5/



π


{\displaystyle \pi }

   of a turn)


Or, to put it another way,   for a full circle:

   there are   360   degrees
   there are   400   gradians
   there are   6,400   mils
   there are   2



π


{\displaystyle \pi }

   radians   (roughly equal to 6.283+)


A   mil   is approximately equal to a   milliradian   (which is   1/1000   of a radian).

There is another definition of a   mil   which
is   1/1000   of a radian   ─── this
definition won't be used in this Rosetta Code task.


Turns   are sometimes known or shown as:

   turn(s)
   360 degrees
   unit circle
   a (full) circle

Degrees   are sometimes known or shown as:

   degree(s)
   deg
   º       (a symbol)
   °       (another symbol)

Gradians   are sometimes known or shown as:

   gradian(s)
   grad(s)
   grade(s)
   gon(s)
   metric degree(s)
   (Note that   centigrade   was used for 1/100th of a grade, see the note below.)

Mils   are sometimes known or shown as:

   mil(s)
   NATO mil(s)

Radians   are sometimes known or shown as:

   radian(s)
   rad(s)


Notes

In continental Europe, the French term   centigrade   was used
for   1/100   of a grad (grade);   this was
one reason for the adoption of the term   Celsius   to
replace   centigrade   as the name of a temperature scale.

Gradians were commonly used in civil engineering.

Mils were normally used for artillery   (elevations of the gun barrel for ranging).



Positive and negative angles

Although the definition of the measurement of an angle doesn't support the
concept of a negative angle,   it's frequently useful to impose a convention that
allows positive and negative angular values to represent orientations and/or rotations
in opposite directions relative to some reference.   It is this reason that
negative angles will keep their sign and not be normalized to positive angles.



Normalization

Normalization   (for this Rosetta Code task)   will keep the same
sign,   but it will reduce the magnitude to less than a full circle;   in
other words, less than 360º.

Normalization   shouldn't   change   -45º   to   315º,

An angle of   0º,   +0º,   0.000000,   or   -0º   should be
shown as   0º.



Task

   write a function (or equivalent) to do the normalization for each scale
 Suggested names:
 d2d,   g2g,   m2m,   and  r2r
   write a function (or equivalent) to convert one scale to another
 Suggested names for comparison of different computer language function names:
 d2g,   d2m,   and   d2r   for degrees
 g2d,   g2m,   and   g2r   for gradians
 m2d,   m2g,   and   m2r   for mils
 r2d,   r2g,   and   r2m   for radians
   normalize all angles used   (except for the ""original"" or ""base"" angle)
   show the angles in every scale and convert them to all other scales
   show all output here on this page


For the (above) conversions,   use these dozen numbers   (in the order shown):

   -2   -1   0   1   2   6.2831853   16   57.2957795   359   399   6399   1000000

",Python,"PI = 3.141592653589793
TWO_PI = 6.283185307179586
 
def normalize2deg(a):
  while a < 0: a += 360
  while a >= 360: a -= 360
  return a
def normalize2grad(a):
  while a < 0: a += 400
  while a >= 400: a -= 400
  return a
def normalize2mil(a):
  while a < 0: a += 6400
  while a >= 6400: a -= 6400
  return a
def normalize2rad(a):
  while a < 0: a += TWO_PI
  while a >= TWO_PI: a -= TWO_PI
  return a
 
def deg2grad(a): return a * 10.0 / 9.0
def deg2mil(a): return a * 160.0 / 9.0
def deg2rad(a): return a * PI / 180.0
 
def grad2deg(a): return a * 9.0 / 10.0
def grad2mil(a): return a * 16.0
def grad2rad(a): return a * PI / 200.0
 
def mil2deg(a): return a * 9.0 / 160.0
def mil2grad(a): return a / 16.0
def mil2rad(a): return a * PI / 3200.0
 
def rad2deg(a): return a * 180.0 / PI
def rad2grad(a): return a * 200.0 / PI
def rad2mil(a): return a * 3200.0 / PI",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Verify_distribution_uniformity/Naive,Verify distribution uniformity/Naive,"This task is an adjunct to Seven-sided dice from five-sided dice.



Task

Create a function to check that the random integers returned from a small-integer generator function have uniform distribution.



The function should take as arguments:

 The function (or object) producing random integers.
 The number of times to call the integer generator.
 A 'delta' value of some sort that indicates how close to a flat distribution is close enough.


The function should produce:

 Some indication of the distribution achieved.
 An 'error' if the distribution is not flat enough.


Show the distribution checker working when the produced distribution is flat enough and when it is not. (Use a generator from Seven-sided dice from five-sided dice).



See also:

Verify distribution uniformity/Chi-squared test

",Python,"from collections import defaultdict
import math

def test_distribution(f, calls, delta):
    dist = defaultdict(int)
    for i in range(calls):
        dist[f()] += 1
    mean = 1.0/len(dist)
    good = True
    for i in dist:
        if math.fabs((1.0 * dist[i])/calls - mean) > delta:
            print ""Relative frequency"", dist[i]/(1.0*calls), ""of result"", i, ""deviates by more than"", delta, ""from the expected value"", mean
            good = False
    return good",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Floyd%27s_triangle,Floyd's triangle,"Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where

 the first row is   1     (unity)
 successive rows start towards the left with the next number followed by successive naturals listing one more number than the line above.


The first few lines of a Floyd triangle looks like this:

 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15



Task

 Write a program to generate and display here the first   n   lines of a Floyd triangle. 
(Use   n=5   and   n=14   rows).
 Ensure that when displayed in a mono-space font, the numbers line up in vertical columns as shown and that only one space separates numbers of the last row.

",Python,">>> def floyd(rowcount=5):
	rows = [[1]]
	while len(rows) < rowcount:
		n = rows[-1][-1] + 1
		rows.append(list(range(n, n + len(rows[-1]) + 1)))
	return rows
 
>>> floyd()
[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]
>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):
	colspace = [len(str(n)) for n in rows[-1]]
	for row in rows:
		print( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))
 
 
>>> pfloyd()
1
2 3
4 5 6
7 8 9 10
>>> pfloyd(floyd(5))
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
>>> pfloyd(floyd(14))
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31 32 33 34 35 36
37 38 39 40 41 42 43 44  45
46 47 48 49 50 51 52 53  54  55
56 57 58 59 60 61 62 63  64  65  66
67 68 69 70 71 72 73 74  75  76  77  78
79 80 81 82 83 84 85 86  87  88  89  90  91
92 93 94 95 96 97 98 99 100 101 102 103 104 105
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Count_occurrences_of_a_substring,Count occurrences of a substring,"Task

Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.

The function should take two arguments:

   the first argument being the string to search,   and 
   the second a substring to be searched for. 


It should return an integer count.

print countSubstring(""the three truths"",""th"")
3
 
// do not count substrings that overlap with previously-counted substrings:
print countSubstring(""ababababab"",""abab"")
2
The matching should yield the highest number of non-overlapping matches.

In general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> ""the three truths"".count(""th"")
3
>>> ""ababababab"".count(""abab"")
2",Human_written,Python_from_Go
http://rosettacode.org/wiki/Circular_primes,Circular primes,"Definitions
A circular prime is a prime number with the property that the number generated at each intermediate step when cyclically permuting its (base 10) digits will also be prime.

For example:
1193 is a circular prime, since 1931, 9311 and 3119 are all also prime.

Note that a number which is a cyclic permutation of a smaller circular prime is not considered to be itself a circular prime. So 13 is a circular prime, but 31 is not.



A repunit (denoted by R) is a number whose base 10 representation contains only the digit 1.

For example:
R(2) = 11 and R(5) = 11111 are repunits.



Task
 Find the first 19 circular primes.


 If your language has access to arbitrary precision integer arithmetic, given that they are all repunits, find the next 4 circular primes.


 (Stretch) Determine which of the following repunits are probably circular primes: R(5003), R(9887), R(15073), R(25031), R(35317) and R(49081). The larger ones may take a long time to process so just do as many as you reasonably can.


See also
 Wikipedia article - Circular primes.
 Wikipedia article - Repunit.
 OEIS sequence A016114 - Circular primes.

",Python,"import random
 
def is_Prime(n):
    """"""
    Miller-Rabin primality test.
 
    A return value of False means n is certainly not prime. A return value of
    True means n is very likely a prime.
    """"""
    if n!=int(n):
        return False
    n=int(n)
    #Miller-Rabin test for prime
    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:
        return False
 
    if n==2 or n==3 or n==5 or n==7:
        return True
    s = 0
    d = n-1
    while d%2==0:
        d>>=1
        s+=1
    assert(2**s * d == n-1)
 
    def trial_composite(a):
        if pow(a, d, n) == 1:
            return False
        for i in range(s):
            if pow(a, 2**i * d, n) == n-1:
                return False
        return True
 
    for i in range(8):#number of trials
        a = random.randrange(2, n)
        if trial_composite(a):
            return False
 
    return True
 
def isPrime(n: int) -> bool:
    '''
        https://www.geeksforgeeks.org/python-program-to-check-whether-a-number-is-prime-or-not/
    '''
    # Corner cases
    if (n <= 1) :
        return False
    if (n <= 3) :
        return True
    # This is checked so that we can skip
    # middle five numbers in below loop
    if (n % 2 == 0 or n % 3 == 0) :
        return False
    i = 5
    while(i * i <= n) :
        if (n % i == 0 or n % (i + 2) == 0) :
            return False
        i = i + 6
    return True
 
def rotations(n: int)-> set((int,)):
    '''
        >>> {123, 231, 312} == rotations(123)
        True
    '''
    a = str(n)
    return set(int(a[i:] + a[:i]) for i in range(len(a)))
 
def isCircular(n: int) -> bool:
    '''
        >>> [isCircular(n) for n in (11, 31, 47,)]
	[True, True, False]
    '''
    return all(isPrime(int(o)) for o in rotations(n))
 
from itertools import product
 
def main():
    result = [2, 3, 5, 7]
    first = '137'
    latter = '1379'
    for i in range(1, 6):
        s = set(int(''.join(a)) for a in product(first, *((latter,) * i)))
        while s:
            a = s.pop()
            b = rotations(a)
            if isCircular(a):
                result.append(min(b))
            s -= b
    result.sort()
    return result
 
assert [2, 3, 5, 7, 11, 13, 17, 37, 79, 113, 197, 199, 337, 1193, 3779, 11939, 19937, 193939, 199933] == main()
 
 
repunit = lambda n: int('1' * n)
 
def repmain(n: int) -> list:
    '''
        returns the first n repunit primes, probably.
    '''
    result = []
    i = 2
    while len(result) < n:
        if is_Prime(repunit(i)):
            result.append(i)
        i += 1
    return result
 
assert [2, 19, 23, 317, 1031] == repmain(5)
 
# because this Miller-Rabin test is already on rosettacode there's no good reason to test the longer repunits.",Human_written,Python_from_C
http://rosettacode.org/wiki/Knight%27s_tour,Knight's tour,"
Task
Problem: you have a standard 8x8 chessboard, empty but for a single knight on some square. Your task is to emit a series of legal knight moves that result in the knight visiting every square on the chessboard exactly once. Note that it is not a requirement that the tour be ""closed""; that is, the knight need not end within a single move of its start position.

Input and output may be textual or graphical, according to the conventions of the programming environment. If textual, squares should be indicated in algebraic notation. The output should indicate the order in which the knight visits the squares, starting with the initial position. The form of the output may be a diagram of the board with the squares numbered according to visitation sequence, or a textual list of algebraic coordinates in order, or even an actual animation of the knight moving around the chessboard.

Input: starting square

Output: move sequence



Related tasks
 A* search algorithm
 N-queens problem
 Solve a Hidato puzzle
 Solve a Holy Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle

",Python,"import copy
 
boardsize=6
_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) 
 
 
def chess2index(chess, boardsize=boardsize):
    'Convert Algebraic chess notation to internal index format'
    chess = chess.strip().lower()
    x = ord(chess[0]) - ord('a')
    y = boardsize - int(chess[1:])
    return (x, y)
 
def boardstring(board, boardsize=boardsize):
    r = range(boardsize)
    lines = ''
    for y in r:
        lines += '\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '
                                 for x in r)
    return lines
 
def knightmoves(board, P, boardsize=boardsize):
    Px, Py = P
    kmoves = set((Px+x, Py+y) for x,y in _kmoves)
    kmoves = set( (x,y)
                  for x,y in kmoves
                  if 0 <= x < boardsize
                     and 0 <= y < boardsize
                     and not board[(x,y)] )
    return kmoves
 
def accessibility(board, P, boardsize=boardsize):
    access = []
    brd = copy.deepcopy(board)
    for pos in knightmoves(board, P, boardsize=boardsize):
        brd[pos] = -1
        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )
        brd[pos] = 0
    return access
 
def knights_tour(start, boardsize=boardsize, _debug=False):
    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}
    move = 1
    P = chess2index(start, boardsize)
    board[P] = move
    move += 1
    if _debug:
        print(boardstring(board, boardsize=boardsize))
    while move <= len(board):
        P = min(accessibility(board, P, boardsize))[1]
        board[P] = move
        move += 1
        if _debug:
            print(boardstring(board, boardsize=boardsize))
            input('\n%2i next: ' % move)
    return board
 
if __name__ == '__main__':
    while 1:
        boardsize = int(input('\nboardsize: '))
        if boardsize < 5:
            continue
        start = input('Start position: ')
        board = knights_tour(start, boardsize)
        print(boardstring(board, boardsize=boardsize))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Check_output_device_is_a_terminal,Check output device is a terminal,"Task

Demonstrate how to check whether the output device is a terminal or not.



Related task

   Check input device is a terminal

",Python,"print(""Hello, world!"")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Permutations/Derangements,Permutations/Derangements,"A derangement is a permutation of the order of distinct items in which no item appears in its original place.

For example, the only two derangements of the three items (0, 1, 2) are (1, 2, 0), and (2, 0, 1).

The number of derangements of n distinct items is known as the subfactorial of n, sometimes written as !n.
There are various ways to calculate !n.



Task

 Create a named function/method/subroutine/... to generate derangements of the integers 0..n-1, (or 1..n if you prefer). 
 Generate and show all the derangements of 4 integers using the above routine.
 Create a function that calculates the subfactorial of n, !n.
 Print and show a table of the counted number of derangements of n vs. the calculated !n for n from 0..9 inclusive.


Optional stretch goal

   Calculate    !20 


Related tasks

   Anagrams/Deranged anagrams
   Best shuffle
   Left_factorials



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.2.2
 
def permute(input):
    if len(input) == 1:
        return [input]
    perms = []
    to_insert = input[0]
    for perm in permute(input[1:]):
        for i in range(len(perm) + 1):
            new_perm = perm[:i] + [to_insert] + perm[i:]
            perms.append(new_perm)
    return perms
 
def derange(input):
    if not input:
        return [input]
    return [perm for perm in permute(input) if all(i!= perm[i] for i in range(len(perm)))]
 
def sub_factorial(n):
    if n == 0:
        return 1
    if n == 1:
        return 0
    return (n - 1) * (sub_factorial(n - 1) + sub_factorial(n - 2))
 
if __name__ == '__main__':
    input = ['a', 'b', 'c', 'd']
 
    derangements = derange(input)
    print(""There are {} derangements of {}, namely:\n"".format(len(derangements), input))
    for derangement in derangements:
        print(derangement)
 
    print(""\nN  Counted   Calculated"")
    print(""-  -------   ----------"")
    for n in range(10):
        counted = len(derange(list(range(n))))
        print(""{:d}  {:9d} {:9d}"".format(n, counted, sub_factorial(n)))
    print(""\n!20 = {}"".format(sub_factorial(20)))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Handle_a_signal,Handle a signal,"Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.
Unhandled signals generally terminate a program in a disorderly manner.
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second.
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.



",Python,"import time
 
t1 = time.time()
 
def signal_handler(signal, frame):
    print('You pressed Ctrl+C!')
    sys.exit(0)
 
signal.signal(signal.SIGINT, signal_handler)
 
n = 0
while True:
    time.sleep(0.5)
    n += 1
    print(n)
 
tdelt = time.time() - t1
print('Program has run for %5.3f seconds.' % tdelt)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Kronecker_product_based_fractals,Kronecker product based fractals,"This task is based on    Kronecker product   of two matrices.

If your language has no a built-in function for such product then you need to implement it first.

The essence of fractals is self-replication (at least, self-similar replications).

So, using   n   times self-product of the matrix   (filled with 0/1)   we will have a fractal of the   nth   order.

Actually, ""self-product"" is a Kronecker power of the matrix.

In other words: for a matrix   M   and a power   n   create a function like   matkronpow(M, n),

which returns   MxMxMx...   (n   times product).

A formal recurrent algorithm of creating Kronecker power of a matrix is the following:



Algorithm


Let M is an initial matrix, and Rn is a resultant block matrix of the Kronecker power, where n is the power (a.k.a. order).
Self-product of M, i.e., M x M producing R2 (resultant matrix with order/power 2).
To receive the next order/power matrix use this recurrent formula: Rn = R(n-1) x M.
Plot this Rn matrix to produce the nth order fractal.



Even just looking at the resultant matrix you can see what will be plotted.

There are virtually infinitely many fractals of this type. You are limited only by your creativity and
the power of your computer.



Task

Using  Kronecker product implement and show two popular and well-known fractals, i.e.:

  Vicsek fractal;
  Sierpinski carpet fractal.


The last one ( Sierpinski carpet) is already here on RC, but built using different approaches.




Test cases

These 2 fractals (each order/power 4 at least) should be built using the following 2 simple matrices:

          │ 0 1 0 │    and    │ 1 1 1 │
          │ 1 1 1 │           │ 1 0 1 │
          │ 0 1 0 │           │ 1 1 1 │

Note

 Output could be a graphical or ASCII-art representation, but if an order is set > 4 then printing is not suitable.
 The orientation and distortion of the fractal could be your language/tool specific.
 It would be nice to see one additional fractal of your choice, e.g., based on using a single (double) letter(s) of an alphabet, any sign(s) or already made a resultant matrix of the Kronecker product.


See implementations and results below in JavaScript, PARI/GP and R languages. They have additional samples of ""H"", ""+"" and checkerboard fractals.



",Python,"import os
from PIL import Image
 
 
def imgsave(path, arr):
    w, h = len(arr), len(arr[0])
    img = Image.new('1', (w, h))
    for x in range(w):
        for y in range(h):
            img.putpixel((x, y), arr[x][y])
    img.save(path)
 
 
def get_shape(mat):
    return len(mat), len(mat[0])
 
 
def kron(matrix1, matrix2):
    """"""
    Calculate the kronecker product of two matrices
    """"""
    final_list = []
 
    count = len(matrix2)
 
    for elem1 in matrix1:
        for i in range(count):
            sub_list = []
            for num1 in elem1:
                for num2 in matrix2[i]:
                    sub_list.append(num1 * num2)
            final_list.append(sub_list)
 
    return final_list
 
 
def kronpow(mat):
    """"""
    Generate an arbitrary number of kronecker powers
    """"""
    matrix = mat
    while True:
        yield matrix
        matrix = kron(mat, matrix)
 
 
def fractal(name, mat, order=6):
    """"""
    Save fractal as jpg to 'fractals/name'
    """"""
    path = os.path.join('fractals', name)
    os.makedirs(path, exist_ok=True)
 
    fgen = kronpow(mat)
    print(name)
    for i in range(order):
        p = os.path.join(path, f'{i}.jpg')
        print('Calculating n =', i, end='\t', flush=True)
 
        mat = next(fgen)
        imgsave(p, mat)
 
        x, y = get_shape(mat)
        print('Saved as', x, 'x', y, 'image', p)
 
 
test1 = [
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
]
 
test2 = [
    [1, 1, 1],
    [1, 0, 1],
    [1, 1, 1]
]
 
test3 = [
    [1, 0, 1],
    [0, 1, 0],
    [1, 0, 1]
]
 
fractal('test1', test1)
fractal('test2', test2)
fractal('test3', test3)",Human_written,Python_from_C
http://rosettacode.org/wiki/Address_of_a_variable,Address of a variable,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Demonstrate how to get the address of a variable and how to set the address of a variable.



",Python,"foo = object()  # Create (instantiate) an empty object
address = id(foo)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"def eca(cells, rule):
    lencells = len(cells)
    c = ""0"" + cells + ""0""    # Zero pad the ends
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    yield c[1:-1]
    while True:
        c = ''.join(['0',
                     ''.join(neighbours2next[c[i-1:i+2]]
                             for i in range(1,lencells+1)),
                     '0'])
        yield c[1:-1]
 
if __name__ == '__main__':
    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)
    zipped = [range(lines)] + [eca(start, rule) for rule in rules]
    print('\n   Rules: %r' % (rules,))
    for data in zip(*zipped):
        i = data[0]
        cells = data[1:]
        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Singly-linked_list/Element_insertion,Singly-linked list/Element insertion,"Singly-Linked List (element)
singly-linked list
Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"def chain_insert(lst, at, item):
    while lst is not None:
        if lst[0] == at:
            lst[1] = [item, lst[1]]
            return
        else:
            lst = lst[1]
    raise ValueError(str(at) + "" not found"")
 
chain = ['A', ['B', None]]
chain_insert(chain, 'A', 'C')
print chain",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",Python,"compose = lambda f, g: lambda x: f( g(x) )",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sequence_of_primorial_primes,Sequence of primorial primes,"The sequence of primorial primes is given as the increasing values of n where primorial(n) ± 1 is prime.

Noting that the n'th primorial is defined as the multiplication of the smallest n primes, the sequence is of the number of primes, in order that when multiplied together is one-off being a prime number itself.



Task

Generate and show here the first ten values of the sequence.



Optional extended task

Show the first twenty members of the series.



Notes
 
 This task asks for the primorial indices that create the final primorial prime numbers, so there should be no ten-or-more digit numbers in the program output (although extended precision integers will be needed for intermediate results).
 There is some confusion in the references, but for the purposes of this task the sequence begins with n = 1.
 Probabilistic primality tests are allowed, as long as they are good enough such that the output shown is correct.


Related tasks

 Primorial numbers
 Factorial


See also

 Primorial prime Wikipedia.
 Primorial prime from The Prime Glossary.
 Sequence A088411 from The On-Line Encyclopedia of Integer Sequences

",Python,"# version 1.0.6
 
import math
 
LIMIT = 20  # expect a run time of about 2 minutes on a typical laptop
 
def isPrime(n):
    if n < 2: return False 
    if n % 2 == 0: return n == 2
    if n % 3 == 0: return n == 3
    d = 5
    while d * d <= n:
        if n % d == 0: return False
        d += 2
        if n % d == 0: return False
        d += 4
    return True
 
def main():
    print(""The first"", LIMIT, ""primorial indices in the sequence are:"")
    print(""1 "", end="""")
    primorial = 1
    count = 1
    p = 3
    prod = 2
    while True:
        if isPrime(p):
            prod *= p
            primorial += 1
            if math.factorial(prod + 1) % prod == 0 or math.factorial(prod - 1) % prod == 0:
                print(primorial, end="" "")
                count += 1
                if count == LIMIT:
                    print()
                    break
        p += 2         
main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort,Sorting algorithms/Cocktail sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Cocktail sort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The cocktail shaker sort is an improvement on the Bubble Sort.

The improvement is basically that values ""bubble"" both directions through the array, because on each iteration the cocktail shaker sort bubble sorts once forwards and once backwards. Pseudocode for the algorithm (from wikipedia):

function cocktailSort( A : list of sortable items )
 do
   swapped := false
   for each i in 0 to length( A ) - 2 do
     if A[ i ] > A[ i+1 ] then // test whether the two 
                               // elements are in the wrong 
                               // order
       swap( A[ i ], A[ i+1 ] ) // let the two elements
                                // change places
       swapped := true;
   if swapped = false then
     // we can exit the outer loop here if no swaps occurred.
     break do-while loop;
   swapped := false
   for each i in length( A ) - 2 down to 0 do
     if A[ i ] > A[ i+1 ] then
       swap( A[ i ], A[ i+1 ] )
       swapped := true;
 while swapped; // if no elements have been swapped, 
                // then the list is sorted

Related task

   cocktail sort with shifting bounds

",Python,"import random
import time
 
EL_COUNT = 77
LLEN = 11
 
class cocktailSort:
    def sort(self, arr, len):
        notSorted = True
        while notSorted:
            notSorted = False
            for a in range(0, len - 1):
                if arr[a] > arr[a + 1]:
                    self.sSwap(arr[a], arr[a + 1])
                    notSorted = True
 
            if not notSorted:
                break
            notSorted = False
 
            for a in range(len - 1, 0, -1):
                if arr[a - 1] > arr[a]:
                    self.sSwap(arr[a], arr[a - 1])
                    notSorted = True
 
    def sSwap(self, a, b):
        t = a
        a = b
        b = t
 
if __name__ == ""__main__"":
    cs = cocktailSort()
    arr = []
 
    for x in range(0, EL_COUNT):
        arr.append(random.randint(1, EL_COUNT))
 
    print(""Original: "")
    print(""=========="")
    for x in range(0, EL_COUNT, LLEN):
        for s in range(x, x + LLEN):
            print(arr[s], end = "", "")
 
        print()
 
    now = time.time()
    cs.sort(arr, EL_COUNT)
    now = time.time() - now
 
    print()
    print()
    print(""Sorted: "")
    print(""========"")
    for x in range(0, EL_COUNT, LLEN):
        for s in range(x, x + LLEN):
            print(arr[s], end = "", "")
 
        print()
 
    print()
    print()
    print()
    print()
    print(now)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Vigenère cipher,"Task

Implement a   Vigenère cypher,   both encryption and decryption.

The program should handle keys and text of unequal length,
and should capitalize everything and discard non-alphabetic characters. 

(If your program handles non-alphabetic characters in another way,
make a note of it.)



Related tasks

   Caesar cipher
   Rot-13
   Substitution Cipher

",Python,"'''Vigenere encryption and decryption'''
 
from itertools import starmap, cycle
 
 
def encrypt(message, key):
    '''Vigenere encryption of message using key.'''
 
    # Converted to uppercase.
    # Non-alpha characters stripped out.
    message = filter(str.isalpha, message.upper())
 
    def enc(c, k):
        '''Single letter encryption.'''
 
        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))
 
    return ''.join(starmap(enc, zip(message, cycle(key))))
 
 
def decrypt(message, key):
    '''Vigenere decryption of message using key.'''
 
    def dec(c, k):
        '''Single letter decryption.'''
 
        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))
 
    return ''.join(starmap(dec, zip(message, cycle(key))))
 
 
def main():
    '''Demonstration'''
 
    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (
           'the claws that catch!'
    )
    key = 'VIGENERECIPHER'
 
    encr = encrypt(text, key)
    decr = decrypt(encr, key)
 
    print(text)
    print(encr)
    print(decr)
 
 
if __name__ == '__main__':
    main()",Human_written,Python_from_C
http://rosettacode.org/wiki/Fast_Fourier_transform,Fast Fourier transform,"Task

Calculate the   FFT   (Fast Fourier Transform)   of an input sequence.

The most general case allows for complex numbers at the input
and results in a sequence of equal length, again of complex numbers.
If you need to restrict yourself to real numbers, the output should
be the magnitude   (i.e.:   sqrt(re2 + im2))   of the complex result.

The classic version is the recursive Cooley–Tukey FFT. Wikipedia has pseudo-code for that.
Further optimizations are possible but not required.



",Python,"import math
import cmath
 
def ditfft2(x, y, n, s):
    if n == 1:
        y[0] = complex(x[0], 0)
        return
    ditfft2(x, y, n/2, 2*s)
    ditfft2(x[s:], y[n/2:], n/2, 2*s)
    for k in range(n/2):
        tf = cmath.rect(1, -2*math.pi*k/n) * y[k+n/2]
        y[k], y[k+n/2] = y[k]+tf, y[k]-tf
 
x = [1, 1, 1, 1, 0, 0, 0, 0]
y = [0] * len(x)
ditfft2(x, y, len(x), 1)
for c in y:
    print ""%8.4f"" % c",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Reflection/List_methods,Reflection/List methods,"Task

The goal is to get the methods of an object, as names, values or both.

Some languages offer dynamic methods, which in general can only be inspected if a class' public API includes a way of listing them.
",Python,"# Sample classes for reflection
class Super:
    CLASSNAME ='super'

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return ""Super({0})"".format(self.name)

    def doSup(self):
        return 'did super stuff'

    @classmethod
    def superClassStuff(cls):
        return 'did super class stuff'

    def protSup(self):
        return ""Super's protected""

    def privSup(self):
        return ""Super's private""

class Other:
    def otherStuff(self):
        return 'did other stuff'

class Sub(Super):
    CLASSNAME ='sub'

    def __init__(self, name, *args):
        super().__init__(name)
        self.rest = args
        self.dynamic = {}

    def __str__(self):
        return ""Sub({0})"".format(self.name)

    def doSub(self):
        return 'did sub stuff'

    @classmethod
    def subClassStuff(cls):
        return 'did sub class stuff'

    def protSub(self):
        return ""Sub's protected""

    def privSub(self):
        return ""Sub's private""

sup = Super('sup')
sub = Sub('sub', 0, 'I', 'two')
sub.dynamic['incr'] = lambda i: i+1

print(sub.__dir__())
#=> ['__module__', '__doc__', '__init__', '__str__', '__repr__', '__hash__', '__weakref__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__setattr__', '__sizeof__', '__subclasshook__', '__init_subclass__', '__dir__', '__class__', 'doSup','superClassStuff', 'protSup', 'privSup', 'CLASSNAME', 'name', 'doSub','subClassStuff', 'protSub', 'privSub','rest', 'dynamic', 'otherStuff']

print(dir(sub) - dir(object))
#=> ['__module__', '__doc__', '__init__', '__str__', '__repr__', '__hash__', '__weakref__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__setattr__', '__sizeof__', '__subclasshook__', '__init_subclass__', '__dir__', '__class__', 'doSup','superClassStuff', 'protSup', 'privSup', 'CLASSNAME', 'name', 'doSub','subClassStuff', 'protSub', 'privSub','rest', 'dynamic', 'otherStuff']

print(dir(sub) - dir(sup))
#=> ['__module__', '__doc__', '__init__', '__str__', '__repr__', '__hash__', '__weakref__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__setattr__', '__sizeof__', '__subclasshook__', '__init_subclass__', '__dir__', '__class__', 'doSub','subClassStuff', 'protSub', 'privSub','rest', 'dynamic', 'otherStuff']

# singleton/eigenclass methods
print(dir(sub))
#=> ['__module__', '__doc__', '__init__', '__str__', '__repr__', '__hash__', '__weakref__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__setattr__', '__sizeof__', '__subclasshook__', '__init_subclass__', '__dir__', '__class__', 'doSup','superClassStuff', 'protSup', 'privSup', 'CLASSNAME', 'name', 'doSub','subClassStuff', 'protSub', 'privSub','rest', 'dynamic', 'otherStuff']
print(dir(type(sub)))
#=> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'doSup','superClassStuff', 'protSup', 'privSup', 'CLASSNAME', 'name', 'doSub','subClassStuff', 'protSub', 'privSub','rest', 'dynamic', 'otherStuff']",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def prime(a):
    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Monte_Carlo_methods,Monte Carlo methods,"A Monte Carlo Simulation is a way of approximating the value of a function
where calculating the actual value is difficult or impossible. 

It uses random sampling to define constraints on the value
and then makes a sort of ""best guess.""

A simple Monte Carlo Simulation can be used to calculate the value for 



π


{\displaystyle \pi }

.

If you had a circle and a square where the length of a side of the square
was the same as the diameter of the circle, the ratio of the area of the circle
to the area of the square would be 



π

/

4


{\displaystyle \pi /4}

.

So, if you put this circle inside the square and select many random points
inside the square, the number of points inside the circle
divided by the number of points inside the square and the circle
would be approximately 



π

/

4


{\displaystyle \pi /4}

.



Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number 



π


{\displaystyle \pi }

 is not built-in,
we give 



π


{\displaystyle \pi }

 as a number of digits:

            3.141592653589793238462643383280


",Python,"import random
import math

def approx_pi(throws):
    times_inside = 0
    for i in range(throws):
        x = random.random()
        y = random.random()
        if math.hypot(x, y) <= 1.0:
            times_inside += 1
    return 4.0 * times_inside / throws

for n in [1000, 10_000, 100_000, 1_000_000, 10_000_000]:
    print(""%8d samples: PI = %s"" % (n, approx_pi(n)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Terminal_control/Inverse_video,Terminal control/Inverse video,"Task

Display a word in inverse video   (or reverse video)   followed by a word in normal video.



",Python,"#!/usr/bin/env python
 
print ""\033[7mReversed\033[m Normal""",Human_written,Python_from_C
http://rosettacode.org/wiki/Penney%27s_game,Penney's game,"Penney's game is a game where two players bet on being the first to see a particular sequence of heads or tails in consecutive tosses of a fair coin.

It is common to agree on a sequence length of three then one player will openly choose a sequence, for example:

 Heads,  Tails,  Heads, or HTH for short.

The other player on seeing the first players choice will choose his sequence. The coin is tossed and the first player to see his sequence in the sequence of coin tosses wins.



Example

One player might choose the sequence HHT and the other THT.

Successive coin tosses of HTTHT gives the win to the second player as the last three coin tosses are his sequence.



Task
Create a program that tosses the coin, keeps score and plays Penney's game against a human opponent.

 Who chooses and shows their sequence of three should be chosen randomly.
 If going first, the computer should randomly choose its sequence of three.
 If going second, the computer should automatically play the optimum sequence.
 Successive coin tosses should be shown.


Show output of a game where the computer chooses first and a game where the user goes first here on this page.



See also
 The Penney Ante Part 1 (Video).
 The Penney Ante Part 2 (Video).

",Python,"import random

Toss = [0, 1]

def yourChoice():
    choice = []
    for i in range(3):
        c = input(""Enter your choice (H/T): "")
        if c == ""H"":
            choice.append(Toss[0])
        else:
            choice.append(Toss[1])
    print(""You chose"", choice)
    return choice

while True:
    coin = random.choice(Toss)
    print(""\n%s I start, %s you start..... %s"" % (Toss, Toss, coin))
    if coin == Toss[0]:
        myC = random.sample(Toss, 3)
        myC.append(random.choice(Toss))
        print(""I chose"", myC)
        yC = yourChoice()
    else:
        yC = yourChoice()
        myC = [yC[1]] + yC[:2]
        myC.append(random.choice(Toss))
        print(""I chose"", myC)

    seq = [random.choice(Toss) for i in range(3)]
    print(seq)
    while True:
        if seq == myC:
            print(""I win!"")
            break
        elif seq == yC:
            print(""You win!"")
            break
        else:
            seq.append(random.choice(Toss))
            seq.pop(0)
            print(seq)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Count_in_octal,Count in octal,"Task

Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number.

Each number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.



Related task

   Integer sequence   is a similar task without the use of octal numbers.

",Python,"import sys
for n in xrange(sys.maxint):
    print oct(n)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Nested_function,Nested function,"In many languages, functions can be nested, resulting in outer functions and inner functions. The inner function can access variables from the outer function. In most languages, the inner function can also modify variables in the outer function.



Task
 
Write a program consisting of two nested functions that prints the following text.

1. first
2. second
3. third

The outer function (called MakeList or equivalent) is responsible for creating the list as a whole and is given the separator "". "" as argument. It also defines a counter variable to keep track of the item number. This demonstrates how the inner function can influence the variables in the outer function.

The inner function (called MakeItem or equivalent) is responsible for creating a list item. It accesses the separator from the outer function and modifies the counter.



References

 Nested function

",Python,"def makeList(separator):
    counter = 1
 
    def makeItem(item):
        nonlocal counter
        result = str(counter) + separator + item + ""\n""
        counter += 1
        return result
 
    return makeItem(""first"") + makeItem(""second"") + makeItem(""third"")
 
print(makeList("". ""))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Greatest_element_of_a_list,Greatest element of a list,"Task

Create a function that returns the maximum value in a provided set of values,

where the number of values may not be known until run-time.



",Python,"def max(count, values):
     assert(count > 0)
     themax = values[0]
     idx = 1
     while idx < count:
          if values[idx] > themax:
               themax = values[idx]
          idx += 1
     return themax",Ai_generated,Python_from_C
"http://rosettacode.org/wiki/Abbreviations,_easy","Abbreviations, easy","This task is an easier (to code) variant of the Rosetta Code task:    Abbreviations, simple.



For this task, the following   command table   will be used:

   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   A valid abbreviation is a word that has:
   at least the minimum length of the number of capital letters of the word in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTer
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTer
   The number of capital letters in   ALTer   indicates that any abbreviation for   ALTer   must be at least three letters
   Any word longer than five characters can't be an abbreviation for   ALTer
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   Overlay
   if there isn't any lowercase letters in the word in the command table,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.1.4-3
 
import re
 
r = re.compile(r""[ ]+"")
 
table = (
    ""Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy "" +
    ""COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find "" +
    ""NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput "" +
    ""Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO "" + 
    ""MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT "" +
    ""READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT "" +
    ""RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up ""
)
 
def validate(commands, minLens, words):
    if not words: return []
    results = []
    for word in words:
        matchFound = False
        for i, command in enumerate(commands):
            if minLens[i] == 0 or len(word) not in range(minLens[i], len(command) + 1): continue
            if command.startswith(word, True):
                results.append(command.upper())
                matchFound = True
                break
        if not matchFound: results.append(""*error*"")
    return results
 
commands = r.split(table.strip())
minLens = [len(command) - len(command.lower()) for command in commands]
sentence = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
words = r.split(sentence.strip())
results = validate(commands, minLens, words)  
print(""user words:  "", end = """")
for j in range(len(words)): print(words[j].ljust(len(results[j])), end = "" "")
print(""\nfull words:  "", end = """")
for j in range(len(results)): print(results[j], end = "" "")
print()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort,Sorting algorithms/Selection sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array (or list) of elements using the Selection sort algorithm.



It works as follows:

First find the smallest element in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.



Its asymptotic complexity is    O(n2)    making it inefficient on large arrays.

Its primary purpose is for when writing data is very expensive (slow) when compared to reading, eg. writing to flash memory or EEPROM.

No other sorting algorithm has less data movement.



References

   Rosetta Code:   O     (complexity).
   Wikipedia:   Selection sort.
   Wikipedia:   [Big O notation].

",Python,"a = [170, 45, 75, -90, -802, 24, 2, 66]
 
def main():
    print(""before:"", a)
    selectionSort(a)
    print(""after: "", a)
 
def selectionSort(a):
    last = len(a) - 1
    for i in range(0, last):
        aMin = a[i]
        iMin = i
        for j in range(i + 1, len(a)):
            if a[j] < aMin:
                aMin = a[j]
                iMin = j
        a[i], a[iMin] = aMin, a[i]
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Call_a_function,Call a function,"Task

Demonstrate the different syntax and semantics provided for calling a function.



This may include:

   Calling a function that requires no arguments
   Calling a function with a fixed number of arguments
   Calling a function with optional arguments
   Calling a function with a variable number of arguments
   Calling a function with named arguments
   Using a function in statement context
   Using a function in first-class context within an expression
   Obtaining the return value of a function
   Distinguishing built-in functions and user-defined functions
   Distinguishing subroutines and functions
   Stating whether arguments are passed by value or by reference
   Is partial application possible and how


This task is not about defining functions.



",Python,"def no_args():
    pass
# call
no_args()
 
def fixed_args(x, y):
    print('x=%r, y=%r' % (x, y))
# call
fixed_args(1, 2)        # x=1, y=2
 
## Can also called them using the parameter names, in either order:
fixed_args(y=2, x=1)
 
## Can also ""apply"" fixed_args() to a sequence:
myargs=(1,2) # tuple
fixed_args(*myargs)
 
def opt_args(x=1):
    print(x)
# calls
opt_args()              # 1
opt_args(3.141)         # 3.141
 
def var_args(*v):
    print(v)
# calls	
var_args(1, 2, 3)       # (1, 2, 3)
var_args(1, (2,3))      # (1, (2, 3))
var_args()              # ()
 
## Named arguments
fixed_args(y=2, x=1)    # x=1, y=2
 
## As a statement
if 1:
    no_args()
 
## First-class within an expression
assert no_args() is None
 
def return_something():
    return 1
x = return_something()
 
def is_builtin(x):
	print(x.__name__ in dir(__builtins__))
# calls
is_builtin(pow)         # True
is_builtin(is_builtin)  # False
 
# Very liberal function definition
 
def takes_anything(*args, **kwargs):
    for each in args:
        print(each)
    for key, value in sorted(kwargs.items()):
        print(""%s:%s"" % (key, value))
    # Passing those to another, wrapped, function:
    wrapped_fn(*args, **kwargs)
    # (Function being wrapped can have any parameter list
    # ... that doesn't have to match this prototype)
 
## A subroutine is merely a function that has no explicit
## return statement and will return None.
 
## Python uses ""Call by Object Reference"".
## See, for example, http://www.python-course.eu/passing_arguments.php
 
## For partial function application see:
##   http://rosettacode.org/wiki/Partial_function_application#Python",Human_written,Python_from_Go
http://rosettacode.org/wiki/Wieferich_primes,Wieferich primes,"

 This page uses content from Wikipedia. The original article was at Wieferich prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In number theory, a Wieferich prime is a prime number  p  such that  p2  evenly divides  2(p − 1) − 1 .



It is conjectured that there are infinitely many Wieferich primes, but as of March 2021,only two have been identified.



Task 
 Write a routine (function procedure, whatever) to find Wieferich primes.
 Use that routine to identify and display all of the Wieferich primes less than 5000.


See also
 OEIS A001220 - Wieferich primes

",Python,"from typing import List
 
def prime_sieve(limit: int) -> List[bool]:
    sieve = [True] * limit
    if limit > 0:
        sieve[0] = False
    if limit > 1:
        sieve[1] = False
    for i in range(4, limit, 2):
        sieve[i] = False
    for p in range(3, limit, 2):
        q = p * p
        if q >= limit:
            break
        if sieve[p]:
            inc = 2 * p
            for _ in range(q, limit, inc):
                sieve[q] = False
    return sieve
 
def modpow(base: int, exp: int, mod: int) -> int:
    if mod == 1:
        return 0
    result = 1
    base %= mod
    for _ in range(exp):
        if (exp & 1) == 1:
            result = (result * base) % mod
        base = (base * base) % mod
    return result
 
def wieferich_primes(limit: int) -> List[int]:
    result = []
    sieve = prime_sieve(limit)
    for p in range(2, limit):
        if sieve[p] and modpow(2, p - 1, p * p) == 1:
            result.append(p)
    return result
 
if __name__ == ""__main__"":
    limit = 5000
    print(f""Wieferich primes less than {limit}:"")
    for p in wieferich_primes(limit):
        print(p)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sierpinski_carpet,Sierpinski carpet,"Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N.



For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art.

The important requirement is the placement of whitespace and non-whitespace characters.



Related task

   Sierpinski triangle

",Python,"import sys

def main():
    i = 0
    j = 0
    dim = 0
    d = 0
    depth = 3
    for i in range(0, depth):
        dim *= 3
    for i in range(0, dim):
        for j in range(0, dim):
            for d in range(dim / 3, 0, -1):
                if ((i % (d * 3)) / d == 1) and ((j % (d * 3)) / d == 1):
                    break
            if d:
                print ""  "",
            else:
                print ""##"",
        print ""\n"",
    return 0

if __name__ == ""__main__"":
    sys.exit(main())",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Empty_string,Empty string,"Languages may have features for dealing specifically with empty strings
(those containing no characters).



Task

   Demonstrate how to assign an empty string to a variable.
   Demonstrate how to check that a string is empty.
   Demonstrate how to check that a string is not empty.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = """"
s = str()
s = ""any string""; s = """"",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Pisano_period,Pisano period,"The Fibonacci sequence taken modulo 2 is a periodic sequence of period 3 : 0, 1, 1, 0, 1, 1, ...

For any integer n, the Fibonacci sequence taken modulo n is periodic and the length of the periodic cycle is referred to as the Pisano period.

Prime numbers are straightforward; the Pisano period of a prime number p is simply: pisano(p). The Pisano period of a composite number c may be found in different ways. It may be calculated directly: pisano(c), which works, but may be time consuming to find, especially for larger integers, or, it may be calculated by finding the least common multiple of the Pisano periods of each composite component.



E.G.

Given a Pisano period function: pisano(x), and a least common multiple function lcm(x, y):

   pisano(m × n) is equivalent to lcm(pisano(m), pisano(n)) where  m  and  n  are coprime

A formulae to calculate the pisano period for integer powers   k   of prime numbers   p   is:

   pisano(pk) == p(k-1)pisano(p) 

The equation is conjectured, no exceptions have been seen.

If a positive integer   i   is split into its prime factors,   then the second and first equations above can be applied to generate the pisano period.



Task
Write 2 functions: pisanoPrime(p,k) and pisano(m).

pisanoPrime(p,k) should return the Pisano period of pk where p is prime and k is a positive integer.

pisano(m) should use pisanoPrime to return the Pisano period of m where m is a positive integer.

Print pisanoPrime(p,2) for every prime lower than 15.

Print pisanoPrime(p,1) for every prime lower than 180.

Print pisano(m) for every integer from 1 to 180.



Related tasks
  Fibonacci sequence
  Prime decomposition
  Least common multiple

",Python,"from sympy import isprime, lcm, factorint, primerange
from functools import reduce
 
 
def pisano1(m):
    ""Simple definition""
    if m < 2:
        return 1
    lastn, n = 0, 1
    for i in range(m ** 2):
        lastn, n = n, (lastn + n) % m
        if lastn == 0 and n == 1:
            return i + 1
    return 1
 
def pisanoprime(p, k):
    ""Use conjecture π(p ** k) == p ** (k − 1) * π(p) for prime p and int k > 1""
    assert isprime(p) and k > 0
    return p ** (k - 1) * pisano1(p)
 
def pisano_mult(m, n):
    ""pisano(m*n) where m and n assumed coprime integers""
    return lcm(pisano1(m), pisano1(n))
 
def pisano2(m):
    ""Uses prime factorization of m""
    return reduce(lcm, (pisanoprime(prime, mult)
                        for prime, mult in factorint(m).items()), 1)
 
 
if __name__ == '__main__':
    for n in range(1, 181):
        assert pisano1(n) == pisano2(n), ""Wall-Sun-Sun prime exists??!!""
    print(""\nPisano period (p, 2) for primes less than 50\n "",
          [pisanoprime(prime, 2) for prime in primerange(1, 50)])
    print(""\nPisano period (p, 1) for primes less than 180\n "",
          [pisanoprime(prime, 1) for prime in primerange(1, 180)])
    print(""\nPisano period (p) for integers 1 to 180"")
    for i in range(1, 181):
        print("" %3d"" % pisano2(i), end="""" if i % 10 else ""\n"")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",Python,">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
0.9999999999999999
>>> from math import fsum
>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
1.0",Human_written,Python_from_C#
http://rosettacode.org/wiki/Handle_a_signal,Handle a signal,"Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space.
Unhandled signals generally terminate a program in a disorderly manner.
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second.
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ )) the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit.



",Python,"import time
import signal
import sys
 
def main():
    start = time.time()
    k = time.time()
    n = 1
    while True:
        if time.time() - k > 0.5:
            print(n)
            n += 1
            k = time.time()
        if signal.getsignal(signal.SIGINT) == signal.default_int_handler:
            print(""Ran for %f seconds."" % (time.time() - start))
            sys.exit(0)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Fixed_length_records,Fixed length records,"Fixed length read/write

Before terminals, computers commonly used punch card readers or paper tape input.

A common format before these devices were superseded by terminal technology was based on the Hollerith code, Hollerith code.

These input devices handled 80 columns per card and had a limited character set, encoded by punching holes in one or more rows of the card for each column.

These devices assumed/demanded a fixed line width of 80 characters, newlines were not required (and could not even be encoded in some systems).

Task

Write a program to read 80 column fixed length records (no newline terminators (but newline characters allowed in the data)) and then write out the reverse of each line as fixed length 80 column records.

Samples here use printable characters, but that is not a given with fixed length data. Filenames used are sample.txt, infile.dat, outfile.dat.

Note: There are no newlines, inputs and outputs are fixed at 80 columns, no more, no less, space padded. Fixed length data is 8 bit complete. NUL bytes of zero are allowed.

These fixed length formats are still in wide use on mainframes, with JCL and with COBOL (which commonly use EBCDIC encoding and not ASCII). Most of the large players in day to day financial transactions know all about fixed length records and the expression logical record length.

Sample data

To create the sample input file, use an editor that supports fixed length records or use a conversion utility. For instance, most GNU/Linux versions of dd support blocking and unblocking records with a conversion byte size.

Line 1...1.........2.........3.........4.........5.........6.........7.........8
Line 2
Line 3
Line 4

Line 6
Line 7
     Indented line 8............................................................
Line 9                                                                 RT MARGIN


prompt$ dd if=sample.txt of=infile.dat cbs=80 conv=block
prompt$ dd if=infile.dat cbs=80 conv=unblock


Bonus round

Forth systems often include BLOCK words. A block is 1024 bytes. Source code is stored as 16 lines of 64 characters each (again, no newline character or sequence to mark the end of a line).

Write a program to convert a block file to text (using newlines). Trailing spaces should be excluded from the output.

Also demonstrate how to convert from a normal text file to block form. All lines either truncated or padded to 64 characters with no newline terminators. The last block filled to be exactly 1024 characters by adding blanks if needed. Assume a full range of 8 bit byte values for each character.

The COBOL example uses forth.txt and forth.blk filenames.



",Python,"import os
import subprocess
 
def reverse_bytes(bytes):
    for i in range(len(bytes) // 2):
        bytes[i], bytes[-i - 1] = bytes[-i - 1], bytes[i]
 
def check(err):
    if err:
        raise err
 
def main():
    with open(""infile.dat"", ""rb"") as in_file:
        with open(""outfile.dat"", ""wb"") as out_file:
            record = bytearray(80)
            empty = bytearray(80)
            while True:
                n = in_file.readinto(record)
                if n == 0:
                    break
                reverse_bytes(record)
                out_file.write(record)
                record[:] = empty
 
    # Run dd from within program to write output.dat
    # to standard output as normal text with newlines.
    cmd = subprocess.Popen([""dd"", ""if=outfile.dat"", ""cbs=80"", ""conv=unblock""], stdout=subprocess.PIPE)
    bytes, err = cmd.communicate()
    check(err)
    print(bytes.decode(""utf-8""))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion,Doubly-linked list/Element insertion,"Doubly-Linked List (element)
This is much like inserting into a Singly-Linked List, but with added assignments so that the backwards-pointing links remain correct.

See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Python,"def insert(anchor, new):
    new.next = anchor.next
    new.prev = anchor
    anchor.next.prev = new
    anchor.next = new",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Totient_function,Totient function,"The   totient   function is also known as:

   Euler's totient function
   Euler's phi totient function
   phi totient function
    Φ    function   (uppercase Greek phi)
    φ     function   (lowercase Greek phi)


Definitions   (as per number theory)

The totient function:

   counts the integers up to a given positive integer   n   that are relatively prime to   n
   counts the integers   k   in the range   1 ≤ k ≤ n   for which the greatest common divisor   gcd(n,k)   is equal to   1
   counts numbers   ≤ n   and   prime to   n


If the totient number   (for N)   is one less than   N,   then   N   is prime.



Task

Create a   totient   function and:

   Find and display   (1 per line)   for the 1st   25   integers:
   the integer   (the index)
   the totient number for that integer
   indicate if that integer is prime
   Find and display the   count   of the primes up to          100
   Find and display the   count   of the primes up to       1,000
   Find and display the   count   of the primes up to     10,000
   Find and display the   count   of the primes up to   100,000     (optional)
Show all output here.



Related task

   Perfect totient numbers


Also see

   Wikipedia: Euler's totient function.
   MathWorld: totient function.
   OEIS: Euler totient function phi(n).

",Python,"def gcd(n, k):
    if n < k or k < 1:
        raise ValueError(""Need n >= k and k >= 1"")
 
    s = 1
    while n & 1 == 0 and k & 1 == 0:
        n >>= 1
        k >>= 1
        s <<= 1
 
    t = n
    if n & 1!= 0:
        t = -k
    while t!= 0:
        while t & 1 == 0:
            t >>= 1
        if t > 0:
            n = t
        else:
            k = -t
        t = n - k
    return n * s
 
def totient(n):
    tot = 0
    for k in range(1, n + 1):
        if gcd(n, k) == 1:
            tot += 1
    return tot
 
print("" n  phi   prime"")
print(""---------------"")
count = 0
for n in range(1, 26):
    tot = totient(n)
    isPrime = n - 1 == tot
    if isPrime:
        count += 1
    print(""%2d   %2d   %s"" % (n, tot, isPrime))
print(""\nNumber of primes up to 25     ="", count)
for n in range(26, 100001):
    tot = totient(n)
    if tot == n - 1:
        count += 1
    if n == 100 or n == 1000 or n % 10000 == 0:
        print(""\nNumber of primes up to %-6d = %d"" % (n, count))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Literals/Floating_point,Literals/Floating point,"Programming languages have different ways of expressing floating-point literals.



Task

Show how floating-point literals can be expressed in your language: decimal or other bases, exponential notation, and any other special features.

You may want to include a regular expression or BNF/ABNF/EBNF defining allowable formats for your language.



Related tasks

   Literals/Integer
   Extreme floating point values

",Python,"2.3         # Normal floating point literal
3.          # Equivalent to 3.0 (3 would be interpreted as an integer)
2f64        # The type (in this case f64, a 64-bit floating point number) may be appended to the value
1_000.2_f32 # Underscores may appear anywhere in the number for clarity.",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Anagrams,Anagrams,"When two or more words are composed of the same characters, but in a different order, they are called anagrams.

Task[edit]
Using the word list at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

find the sets of words that share the same characters that contain the most words in them.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> import urllib.request
>>> from collections import defaultdict
>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()
>>> anagram = defaultdict(list) # map sorted chars to anagrams
>>> for word in words:
	anagram[tuple(sorted(word))].append( word )
 
 
>>> count = max(len(ana) for ana in anagram.values())
>>> for ana in anagram.values():
	if len(ana) >= count:
		print ([x.decode() for x in ana])",Human_written,Python_from_Go
http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences,Hofstadter Figure-Figure sequences,"These two sequences of positive integers are defined as:

 







R
(
1
)



=
1
 
;
 
S
(
1
)
=
2




R
(
n
)



=
R
(
n
−
1
)
+
S
(
n
−
1
)
,

n
>
1.






{\displaystyle {\begin{aligned}R(1)&=1\ ;\ S(1)=2\\R(n)&=R(n-1)+S(n-1),\quad n>1.\end{aligned}}}




The sequence 



S
(
n
)


{\displaystyle S(n)}

 is further defined as the sequence of positive integers not present in 



R
(
n
)


{\displaystyle R(n)}

.

Sequence 



R


{\displaystyle R}

 starts:

   1, 3, 7, 12, 18, ...

Sequence 



S


{\displaystyle S}

 starts:

   2, 4, 5, 6, 8, ...



Task

 Create two functions named ffr and ffs that when given n return R(n) or S(n) respectively.
(Note that R(1) = 1 and S(1) = 2 to avoid off-by-one errors).
 No maximum value for n should be assumed.
 Calculate and show that the first ten values of R are:
 1, 3, 7, 12, 18, 26, 35, 45, 56, and 69
 Calculate and show that the first 40 values of ffr plus the first 960 values of ffs include all the integers from 1 to 1000 exactly once.


References

 Sloane's A005228 and A030124.
 Wolfram MathWorld
 Wikipedia: Hofstadter Figure-Figure sequences.

",Python,"from collections import defaultdict
 
class Hffs:
    def __init__(self):
        self.sequence_r = defaultdict(int)
        self.sequence_s = defaultdict(int)
 
    def ffr(self, n):
        if n in self.sequence_r:
            return self.sequence_r[n]
        elif n == 0:
            return 1
        else:
            new_r = self.ffr(n - 1) + self.ffs(n - 1)
            self.sequence_r[n] = new_r
            return new_r
 
    def ffs(self, n):
        if n in self.sequence_s:
            return self.sequence_s[n]
        elif n == 0:
            return 2
        else:
            lower = self.ffs(n - 1) + 1
            upper = self.ffr(n) + 1
            min_s = 0
            for i in range(lower, upper + 1):
                if i not in self.sequence_r.values():
                    min_s = i
                    break
            self.sequence_s[n] = min_s
            return min_s
 
if __name__ == ""__main__"":
    hof = Hffs()
 
    for i in range(10):
        print(f""H:{i} -> R: {hof.ffr(i)}, S: {hof.ffs(i)}"")
 
    r40 = [hof.ffr(i) for i in range(40)]
    s960 = [hof.ffs(i) for i in range(960)]
 
    s960.extend(r40)
    s960.sort()
    f1000 = list(range(1, 1001))
 
    assert f1000 == s960, ""Does NOT match""",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division,Sequence of primes by trial division,"Sequence of primes by trial division

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Generate a sequence of primes by means of trial division.



Trial division is an algorithm where a candidate number is tested for being a prime by trying to divide it by other numbers.

You may use primes, or any numbers of your choosing, as long as the result is indeed a sequence of primes.

The sequence may be bounded (i.e. up to some limit), unbounded, starting from the start (i.e. 2) or above some given value.

Organize your function as you wish, in particular, it might resemble a filtering operation, or a sieving operation.

If you want to use a ready-made is_prime function, use one from the Primality by trial division page (i.e., add yours there if it isn't there already).



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Python,"import math
 
def get_primes(start, end):
    return [n for n in range(start, end + 1) if is_prime(n)]
 
def is_prime(x):
    if x < 3 or x % 2 == 0:
        return x == 2
 
    max = math.sqrt(x)
    for n in range(3, max + 1, 2):
        if x % n == 0:
            return False
 
    return True
 
if __name__ == '__main__':
    print(get_primes(0, 100))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Ranking_methods,Ranking methods,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The numerical rank of competitors in a competition shows if one is better than, equal to, or worse than another based on their results in a competition.

The numerical rank of a competitor can be assigned in several different ways.



Task

The following scores are accrued for all competitors of a competition (in best-first order):

44 Solomon
42 Jason
42 Errol
41 Garry
41 Bernard
41 Barry
39 Stephen
For each of the following ranking methods, create a function/method/procedure/subroutine... that applies the ranking method to an ordered list of scores with scorers:

 Standard. (Ties share what would have been their first ordinal number).
 Modified. (Ties share what would have been their last ordinal number).
 Dense. (Ties share the next available integer). 
 Ordinal. ((Competitors take the next available integer. Ties are not treated otherwise).
 Fractional. (Ties share the mean of what would have been their ordinal numbers).


See the wikipedia article for a fuller description.

Show here, on this page, the ranking of the test scores under each of the numbered ranking methods.



",Python,"def mc_rank(iterable, start=1):
    """"""Modified competition ranking""""""
    lastresult, fifo = None, []
    for n, item in enumerate(iterable, start-1):
        if item[0] == lastresult:
            fifo += [item]
        else:
            while fifo:
                yield n, fifo.pop(0)
            lastresult, fifo = item[0], fifo + [item]
    while fifo:
        yield n+1, fifo.pop(0)
 
 
def sc_rank(iterable, start=1):
    """"""Standard competition ranking""""""
    lastresult, lastrank = None, None
    for n, item in enumerate(iterable, start):
        if item[0] == lastresult:
            yield lastrank, item
        else:
            yield n, item
            lastresult, lastrank = item[0], n
 
 
def d_rank(iterable, start=1):
    """"""Dense ranking""""""
    lastresult, lastrank = None, start - 1,
    for item in iterable:
        if item[0] == lastresult:
            yield lastrank, item
        else:
            lastresult, lastrank = item[0], lastrank + 1
            yield lastrank, item
 
 
def o_rank(iterable, start=1):
    """"""Ordinal  ranking""""""
    yield from enumerate(iterable, start)
 
 
def f_rank(iterable, start=1):
    """"""Fractional ranking""""""
    last, fifo = None, []
    for n, item in enumerate(iterable, start):
        if item[0] != last:
            if fifo:
                mean = sum(f[0] for f in fifo) / len(fifo)
                while fifo:
                    yield mean, fifo.pop(0)[1]
        last = item[0]
        fifo.append((n, item))
    if fifo:
        mean = sum(f[0] for f in fifo) / len(fifo)
        while fifo:
            yield mean, fifo.pop(0)[1]
 
 
if __name__ == '__main__':
    scores = [(44, 'Solomon'),
              (42, 'Jason'),
              (42, 'Errol'),
              (41, 'Garry'),
              (41, 'Bernard'),
              (41, 'Barry'),
              (39, 'Stephen')]
 
    print('\nScores to be ranked (best first):')
    for s in scores:
        print('        %2i %s' % (s ))
    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:
        print('\n%s:' % ranker.__doc__)
        for rank, score in ranker(scores):
            print('  %3g, %r' % (rank, score))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Search_a_list,Search a list,"Task[edit]
Find the index of a string (needle) in an indexable, ordered collection of strings (haystack).

Raise an exception if the needle is missing.

If there is more than one occurrence then return the smallest index to the needle.

Extra credit
Return the largest index to a needle that has multiple occurrences in the haystack.

See also
 Search a list of records
",Python,"haystack = [""Zig"", ""Zag"", ""Wally"", ""Ronald"", ""Bush"", ""Krusty"", ""Charlie"", ""Bush"", ""Boz"", ""Zag""]
 
print(""First occurence of 'Bush' at"", haystack.index(""Bush""))
print(""Last occurence of 'Bush' at"", haystack[::-1].index(""Bush""))
print(""First occurence of 'Rob' at"", haystack.index(""Rob""))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Order_by_pair_comparisons,Order by pair comparisons,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Assume we have a set of items that can be sorted into an order by the user.

The user is presented with pairs of items from the set in no order,
the user states which item
is less than, equal to, or greater than the other (with respect to their
relative positions if fully ordered).

Write a function that given items that the user can order, asks the user to
give the result of comparing two items at a time and uses the comparison results
to eventually return the items in order.

Try and minimise the comparisons the user is asked for.

Show on this page, the function ordering the colours of the rainbow:

   violet red green indigo blue yellow orange

The correct ordering being:

   red orange yellow green blue indigo violet

Note:

 Asking for/receiving user comparisons is a part of the task.
 Code inputs should not assume an ordering.
 The seven colours can form twenty-one different pairs.
 A routine that does not ask the user ""too many"" comparison questions should be used.

",Python,"items = [""violet"", ""red"", ""green"", ""indigo"", ""blue"", ""yellow"", ""orange""]
count = 0
sortedItems = []
for item in items:
    print(""Inserting '%s' into %s"" % (item, sortedItems))
    spotToInsert = bisect.bisect_left(sortedItems, item, key=lambda x: x)
    sortedItems.insert(spotToInsert, item)
print(sortedItems)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",Python,">>> import os
>>> print('\n'.join(sorted(os.listdir('.'))))
DLLs
Doc
LICENSE.txt
Lib
NEWS.txt
README.txt
Scripts
Tools
include
libs
python.exe
pythonw.exe
tcl
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Ordered_words,Ordered words,"An   ordered word   is a word in which the letters appear in alphabetic order.

Examples include   abbey   and   dirt.

Task[edit]
Find and display all the ordered words in the dictionary   unixdict.txt   that have the longest word length.

(Examples that access the dictionary file locally assume that you have downloaded this file yourself.)

The display needs to be shown on this page.

Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import urllib2
ordered_words = urllib2.urlopen('http://www.puzzlers.org/pub/wordlists/unixdict.txt').read().split()
ordered_words = [word.strip() for word in ordered_words]
ordered_words = [word for word in ordered_words if sorted(word) == list(word)]

grouped = {}
for word in ordered_words:
    if len(word) in grouped:
        grouped[len(word)].append(word)
    else:
        grouped[len(word)] = [word]

print grouped[max(grouped.keys())]",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Damm_algorithm,Damm algorithm,"The Damm algorithm is a checksum algorithm which detects all single digit errors and adjacent transposition errors.



The algorithm is named after H. Michael Damm.



Task

Verify the checksum, stored as last digit of an input.


",Python,"# version 1.1.2
 
table = [
    [0, 3, 1, 7, 5, 9, 8, 6, 4, 2],
    [7, 0, 9, 2, 1, 5, 4, 8, 6, 3],
    [4, 2, 0, 6, 8, 7, 1, 3, 5, 9],
    [1, 7, 5, 0, 9, 8, 3, 4, 2, 6],
    [6, 1, 2, 3, 0, 4, 5, 9, 7, 8],
    [3, 6, 7, 4, 2, 0, 9, 5, 8, 1],
    [5, 8, 6, 9, 7, 2, 0, 1, 3, 4],
    [8, 9, 4, 5, 3, 6, 2, 0, 1, 7],
    [9, 4, 3, 8, 6, 1, 7, 2, 0, 5],
    [2, 5, 8, 1, 4, 3, 6, 7, 9, 0]
]
 
def damm(s):
    interim = 0
    for c in s:
        interim = table[interim][int(c)]
    return interim == 0
 
numbers = [5724, 5727, 112946, 112949]
for number in numbers:
    isValid = damm(str(number))
    print(f""{number:6d} is {'valid' if isValid else 'invalid'}"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Runge-Kutta_method,Runge-Kutta method,"Given the example Differential equation:






y
′

(
t
)
=
t
×


y
(
t
)




{\displaystyle y'(t)=t\times {\sqrt {y(t)}}}


With initial condition:






t

0


=
0


{\displaystyle t_{0}=0}

 and 




y

0


=
y
(

t

0


)
=
y
(
0
)
=
1


{\displaystyle y_{0}=y(t_{0})=y(0)=1}


This equation has an exact solution:





y
(
t
)
=



1
16



(

t

2


+
4

)

2




{\displaystyle y(t)={\tfrac {1}{16}}(t^{2}+4)^{2}}




Task
Demonstrate the commonly used explicit   fourth-order Runge–Kutta method   to solve the above differential equation.

 Solve the given differential equation over the range 



t
=
0
…
10


{\displaystyle t=0\ldots 10}

 with a step value of 



δ
t
=
0.1


{\displaystyle \delta t=0.1}

 (101 total points, the first being given)
 Print the calculated values of 



y


{\displaystyle y}

 at whole numbered 



t


{\displaystyle t}

's (



0.0
,
1.0
,
…
10.0


{\displaystyle 0.0,1.0,\ldots 10.0}

) along with error as compared to the exact solution.


Method summary
Starting with a given 




y

n




{\displaystyle y_{n}}

 and 




t

n




{\displaystyle t_{n}}

 calculate:





δ

y

1


=
δ
t
×

y
′

(

t

n


,

y

n


)



{\displaystyle \delta y_{1}=\delta t\times y'(t_{n},y_{n})\quad }






δ

y

2


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

1


)


{\displaystyle \delta y_{2}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{1})}






δ

y

3


=
δ
t
×

y
′

(

t

n


+



1
2



δ
t
,

y

n


+



1
2



δ

y

2


)


{\displaystyle \delta y_{3}=\delta t\times y'(t_{n}+{\tfrac {1}{2}}\delta t,y_{n}+{\tfrac {1}{2}}\delta y_{2})}






δ

y

4


=
δ
t
×

y
′

(

t

n


+
δ
t
,

y

n


+
δ

y

3


)



{\displaystyle \delta y_{4}=\delta t\times y'(t_{n}+\delta t,y_{n}+\delta y_{3})\quad }


then:






y

n
+
1


=

y

n


+



1
6



(
δ

y

1


+
2
δ

y

2


+
2
δ

y

3


+
δ

y

4


)


{\displaystyle y_{n+1}=y_{n}+{\tfrac {1}{6}}(\delta y_{1}+2\delta y_{2}+2\delta y_{3}+\delta y_{4})}







t

n
+
1


=

t

n


+
δ
t



{\displaystyle t_{n+1}=t_{n}+\delta t\quad }



",Python,"from math import sqrt
 
def rk4(f, x0, y0, x1, n):
    vx = [0] * (n + 1)
    vy = [0] * (n + 1)
    h = (x1 - x0) / float(n)
    vx[0] = x = x0
    vy[0] = y = y0
    for i in range(1, n + 1):
        k1 = h * f(x, y)
        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)
        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)
        k4 = h * f(x + h, y + k3)
        vx[i] = x = x0 + i * h
        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6
    return vx, vy
 
def f(x, y):
    return x * sqrt(y)
 
vx, vy = rk4(f, 0, 1, 10, 100)
for x, y in list(zip(vx, vy))[::10]:
    print(""%4.1f %10.5f %+12.4e"" % (x, y, y - (4 + x * x)**2 / 16))
 
 0.0    1.00000  +0.0000e+00
 1.0    1.56250  -1.4572e-07
 2.0    4.00000  -9.1948e-07
 3.0   10.56250  -2.9096e-06
 4.0   24.99999  -6.2349e-06
 5.0   52.56249  -1.0820e-05
 6.0   99.99998  -1.6595e-05
 7.0  175.56248  -2.3518e-05
 8.0  288.99997  -3.1565e-05
 9.0  451.56246  -4.0723e-05
10.0  675.99995  -5.0983e-05",Human_written,Python_from_C#
http://rosettacode.org/wiki/Draw_a_cuboid,Draw a cuboid,"Task

Draw a   cuboid   with relative dimensions of    2 × 3 × 4. 



The cuboid can be represented graphically, or in   ASCII art,   depending on the language capabilities.

To fulfill the criteria of being a cuboid, three faces must be visible.

Either static or rotational projection is acceptable for this task.



Related tasks
 draw a sphere
 draw a rotating cube
 write language name in 3D ASCII
 draw a Deathstar

",Python,"def _pr(t, x, y, z):
    txt = '\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()
                    for m in reversed(range(3+y+z)))
    return txt
 
def cuboid(x,y,z):
    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}
    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']
    for i,ch in enumerate(xrow):
        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch
    if _debug: print(_pr(t, x, y, z))
    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']
    for j,ch in enumerate(ycol):
        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch
    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']
    if _debug: print(_pr(t, x, y, z))
    for k,ch in enumerate(zdepth):
        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch
 
    return _pr(t, x, y, z)
 
 
_debug = False
if __name__ == '__main__':
    for dim in ((2,3,4), (3,4,2), (4,2,3)):
        print(""CUBOID%r"" % (dim,), cuboid(*dim), sep='\n')",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Horizontal_sundial_calculations,Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",Python,"from __future__ import print_function
import math
try: raw_input
except: raw_input = input
 
lat = float(raw_input(""Enter latitude       => ""))
lng = float(raw_input(""Enter longitude      => ""))
ref = float(raw_input(""Enter legal meridian => ""))
print()
 
slat = math.sin(math.radians(lat))
print(""    sine of latitude:   %.3f"" % slat)
print(""    diff longitude:     %.3f"" % (lng-ref))
print()
print(""Hour, sun hour angle, dial hour line angle from 6am to 6pm"")
 
for h in range(-6, 7):
  hra = 15 * h
  hra -= lng - ref
  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))
  print(""HR=%3d; HRA=%7.3f; HLA=%7.3f"" % (h, hra, hla))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Generator/Exponential,Generator/Exponential,"A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.

Generators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.

Generators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.



Task

 Create a function that returns a generation of the m'th powers of the positive integers starting from zero, in order, and without obvious or simple upper limit. (Any upper limit to the generator should not be stated in the source but should be down to factors such as the languages natural integer size limit or computational time/size).
 Use it to create a generator of:
   Squares.
   Cubes. 
 Create a new generator that filters all cubes from the generator of squares.
 Drop the first 20 values from this last generator of filtered results, and then show the next 10 values.


Note that this task requires the use of generators in the calculation of the result.



Also see

 Generator

",Python,"from itertools import islice, count
 
def powers(m):
    for n in count():
        yield n ** m
 
def filtered(s1, s2):
    v, f = next(s1), next(s2)
    while True:
        if v > f:
            f = next(s2)
            continue
        elif v < f:
            yield v
        v = next(s1)
 
squares, cubes = powers(2), powers(3)
f = filtered(squares, cubes)
print(list(islice(f, 20, 30)))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Department_numbers,Department numbers,"There is a highly organized city that has decided to assign a number to each of their departments:

   police department
   sanitation department
   fire department 


Each department can have a number between   1   and   7   (inclusive).

The three department numbers are to be unique (different from each other) and must add up to   12.

The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.



Task

Write a computer program which outputs all valid combinations.



Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1


",Python,"from itertools import permutations
 
def solve():
    c, p, f, s = ""\\,Police,Fire,Sanitation"".split(',')
    print(f""{c:>3}  {p:^6} {f:^4} {s:^10}"")
    c = 1
    for p, f, s in permutations(range(1, 8), r=3):
        if p + s + f == 12 and p % 2 == 0:
            print(f""{c:>3}: {p:^6} {f:^4} {s:^10}"")
            c += 1
 
if __name__ == '__main__':
    solve()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",Python,"import random
import string
import itertools
import operator
 
def next_character(self):
    allowed_chars = "" ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    return allowed_chars[self.next() % len(allowed_chars)]
 
def next_string(self, length):
    return """".join(itertools.repeat("" "", length)
       .select(lambda c: self.next_character()))
 
def fitness(target, current):
    return sum(map(operator.eq, target, current))
 
def mutate(current, rate):
    return """".join(map(lambda c: self.next_character() if random.random() <= rate else c, current))
 
def main():
    target = ""METHINKS IT IS LIKE A WEASEL""
    c = 100
    p = 0.05
 
    # Start with a random string the same length as the target.
    parent = next_string(random.random(), len(target))
 
    print ""START:       {0,20} fitness: {1}"".format(parent, fitness(target, parent))
    i = 0
 
    while parent!= target:
        # Create C mutated strings + the current parent.
        candidates = itertools.repeat(parent, c + 1)
           .select(lambda n: mutate(parent, p) if n > 0 else parent)
 
        # select the fittest
        parent = sorted(candidates, key=lambda c: fitness(target, c), reverse=True)[0]
 
        i += 1
        print ""     #{0,6} {1,20} fitness: {2}"".format(i, parent, fitness(target, parent))
 
    print ""END: #{0,6} {1,20}"".format(i, parent)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Holidays_related_to_Easter,Holidays related to Easter,"Task

Calculate the dates of:

   Easter
   Ascension Thursday
   Pentecost
   Trinity Sunday
   Corpus Christi feast (for Catholic)
   All Saints' Sunday (for Orthodox)


As an example, calculate for the first year of each century from;

   years     400   to   2100 CE   and for 
   years   2010   to   2020 CE.
Note

From the year 325 CE on,   Easter Sunday   has been defined as the first Sunday after the first full moon on or after the day of the March equinox. However, the actual astronomical values for the moments of the full moon and equinox are not used. Instead, approximations are used, the first one being that the equinox is assumed to fall on March 21st every year. The tracking of the moon phases is similarly done with relatively straightforward arithmetic (compared to the sort required for astronomical accuracy) which amounts to maintaining a lunisolar calendar in parallel to our standard purely-solar one.

When Pope Gregory reformed the Catholic calendar in 1582 CE, the drifting of Easter with respect to the seasons was the driving motivation, and the rules for determining it (called the computus) were altered to correct that drift. Catholic nations adopted both the new calendar and the new computus right away, while Western Protestant nations adopted them more gradually over the next 350 years or so. Eventually, even nations dominated by the Eastern Orthodox church adopted a similar calendar reform (the Revised Julian calendar), so pretty much the whole world agrees on what day it is for civil purposes. But the Eastern churches never adopted the corresponding Easter rule changes; they still use the original Julian calendar and computus to determine the date of what is known in the West as ""Orthodox Easter"". Therefore, your output should indicate which computus was used to calculate the dates and, at least for historical dates where the calendar can't be assumed or is location-dependent, which calendar those dates are given in.

You may find algorithms on the Computus Wikipedia page. Some of the results:

In the year 400 CE, Easter Sunday was April 1st (in the contemporary Julian calendar), making Ascension Thursday May 10th and Pentecost May 20th. It is ahistorical to give a date so far back for either Trinity Sunday or Corpus Christi, neither of which were observed until centuries later, but they would have been May 27th and 31st. If you extend the modern civil calendar back that far, those days are instead assigned the subsequent dates: Easter on April 2nd, Ascension on May 11th, Pentecost on May 21st.

Skipping forward to the year 2100 CE, assuming the rules don't change between now and then, the Western churches will observe Easter on March 28, Ascension Thursday May 6th, Pentecost May 16th, Trinity Sunday May 23rd and Corpus Christi May 27th. Heading East, the Orthodox rules place Easter on April 18 in the original Julian calendar; the corresponding civil date is May 2nd. That puts the Ascension on June 10th and Pentecost June 20th. Orthodox Trinity Sunday is the same day as Pentecost, but they observe All Saints' Sunday the following week, June 27th. Corpus Christi is a purely Catholic date that has no Orthodox version.

Test values of Easter dates



 Year

 Orthodox

 Catholic

 Calendar


400

01 Apr

 —

Jul.


800

19 Apr

 —

Jul.


1200

09 Apr

 —

Jul.


2000

30 Apr

23 Apr

Gr.


2020

19 Apr

12 Apr

Gr.


",Python,"# version 1.1.2
 
import calendar
import datetime
 
holidayOffsets = [
    (""Easter"", 0),
    (""Ascension"", 39),
    (""Pentecost"", 49),
    (""Trinity"", 56),   
    (""C/Christi"", 60)
]
 
def padCenter(s, n):
    len_s = len(s)
    if n <= len_s: return s
    return s.rjust((n + len_s) // 2).ljust(n)
 
def calculateEaster(year):
    a = year % 19
    b = year // 100
    c = year % 100
    d = b // 4
    e = b % 4
    f = (b + 8) // 25
    g = (b - f + 1) // 3
    h = (19 * a + b - d - g + 15) % 30
    i = c // 4
    k = c % 4
    l = (32 + 2 * e + 2 * i - h - k) % 7
    m = (a + 11 * h + 22 * l) // 451
    n = h + l - 7 * m + 114
    month = n // 31 - 1  # months indexed from 0 
    day = (n % 31) + 1
    return datetime.date(year, month + 1, day)
 
def outputHolidays(year):
    date = calculateEaster(year)
    print(""%4d  "" % year, end="""")
    po = 0
    for h, o in holidayOffsets:
        date += datetime.timedelta(days=o - po)
        po = o
        print(padCenter(date.strftime(""%d %b""), len(h)), end=""  "")
    print()
 
print(""Year  Easter  Ascension  Pentecost  Trinity  C/Christi"")
print("" CE   Sunday  Thursday    Sunday    Sunday   Thursday "") 
print(""----  ------  ---------  ---------  -------  ---------"")  
for year in range(400, 2100, 100): outputHolidays(year)
print()
for year in range(2010, 2021): outputHolidays(year)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"Python 3.2.3 (default, May  3 2012, 15:54:42) 
[GCC 4.6.3] on linux2
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> help('pprint.pprint')
Help on function pprint in pprint:
 
pprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)
    Pretty-print a Python object to a stream [default is sys.stdout].
 
>>> from pprint import pprint
>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),
	          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),
	          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:
	print(""\nTree %r can be pprint'd as:"" % (tree, ))
	pprint(tree, indent=1, width=1)
 
 
 
Tree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:
(1,
 2,
 3,
 4,
 5,
 6,
 7,
 8)
 
Tree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:
(1,
 ((2,
   3),
  (4,
   (5,
    ((6,
      7),
     8)))))
 
Tree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:
((((1,
    2),
   3),
  4),
 5,
 6,
 7,
 8)
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Priority_queue,Priority queue,"A priority queue is somewhat similar to a queue, with an important distinction: each item is added to a priority queue with a priority level, and will be later removed from the queue with the highest priority element first. That is, the items are (conceptually) stored in the queue in priority order instead of in insertion order.



Task

Create a priority queue.   The queue must support at least two operations:

   Insertion.   An element is added to the queue with a priority (a numeric value).
   Top item removal.   Deletes the element or one of the elements with the current top priority and return it.


Optionally, other operations may be defined, such as peeking (find what current top priority/top element is), merging (combining two priority queues into one), etc.



To test your implementation, insert a number of elements into the queue, each with some random priority.

Then dequeue them sequentially; now the elements should be sorted by priority.

You can use the following task/priority items as input data:

        Priority         Task
       ══════════   ════════════════
           3         Clear drains
           4         Feed cat
           5         Make tea
           1         Solve RC tasks
           2         Tax return



The implementation should try to be efficient.   A typical implementation has   O(log n)   insertion and extraction time,   where   n   is the number of items in the queue.

You may choose to impose certain limits such as small range of allowed priority levels, limited capacity, etc.   If so, discuss the reasons behind it.



",Python,">>> import queue
>>> pq = queue.PriorityQueue()
>>> for item in ((3, ""Clear drains""), (4, ""Feed cat""), (5, ""Make tea""), (1, ""Solve RC tasks""), (2, ""Tax return"")):
  pq.put(item)
 
 
>>> while not pq.empty():
  print(pq.get_nowait())
 
 
(1, 'Solve RC tasks')
(2, 'Tax return')
(3, 'Clear drains')
(4, 'Feed cat')
(5, 'Make tea')
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Inheritance/Single,Inheritance/Single," This task is about derived types;   for implementation inheritance, see Polymorphism.


Inheritance is an operation of type algebra that creates a new type from one or several parent types.

The obtained type is called derived type.

It inherits some of the properties of its parent types.

Usually inherited properties are:

   methods
   components
   parts of the representation


The  class of the new type is a   subclass   of the classes rooted in the parent types.

When all (in certain sense) properties of the parents are preserved by the derived type,   it is said to be a Liskov subtype.

When properties are preserved then the derived type is substitutable for its parents in all contexts.   Usually full substitutability is achievable only in some contexts.



Inheritance is

   single, when only one parent is allowed
    multiple, otherwise


Some single inheritance languages usually allow multiple inheritance for certain abstract types, interfaces in particular.

Inheritance can be considered as a relation parent-child.

Parent types are sometimes called supertype, the derived ones are subtype.   This relation is transitive and reflexive.

Types bound by the relation form a wp:Directed_acyclic_graph directed acyclic graph (ignoring reflexivity).

With single inheritance it becomes a tree.



Task

Show a tree of types which inherit from each other.

   At the top of the tree should be a class called   Animal. 
   The second level should have Dog and Cat. 
   Under   Dog   should be   Lab   and   Collie. 
   None of the classes need to have any functions,   the only thing they need to do is inherit from the specified superclasses 
   (overriding functions should be shown in Polymorphism). 


The tree should look like this:

                        Animal
                          /\
                         /  \
                        /    \
                      Dog    Cat
                      /\
                     /  \
                    /    \
                  Lab  Collie


",Python,"class Animal:
    def __init__(self):
        #...",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Rep-string,Rep-string,"Given a series of ones and zeroes in a string, define a repeated string or rep-string as a string which is created by repeating a substring of the first N characters of the string truncated on the right to the length of the input string, and in which the substring appears repeated at least twice in the original.

For example, the string 10011001100 is a rep-string as the leftmost four characters of 1001 are repeated three times and truncated on the right to give the original string.

Note that the requirement for having the repeat occur two or more times means that the repeating unit is never longer than half the length of the input string.



Task

 Write a function/subroutine/method/... that takes a string and returns an indication of if it is a rep-string and the repeated string.   (Either the string that is repeated, or the number of repeated characters would suffice). 
 There may be multiple sub-strings that make a string a rep-string - in that case an indication of all, or the longest, or the shortest would suffice.
 Use the function to indicate the repeating substring if any, in the following:

1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1


 Show your output on this page.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_repeated(text):
    'check if the first part of the string is repeated throughout the string'
    for x in range(len(text)//2, 0, -1):
        if text.startswith(text[x:]): return x
    return 0
 
matchstr = """"""\
1001110011
1110111011
0010010010
1010101010
1111111111
0100101101
0100100
101
11
00
1
""""""
for line in matchstr.split():
    ln = is_repeated(line)
    print('%r has a repetition length of %i i.e. %s' 
           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Metronome,Metronome,"
The task is to implement a   metronome.

The metronome should be capable of producing high and low audio beats, accompanied by a visual beat indicator, and the beat pattern and tempo should be configurable.

For the purpose of this task, it is acceptable to play sound files for production of the beat notes, and an external player may be used.

However, the playing of the sounds should not interfere with the timing of the metronome.

The visual indicator can simply be a blinking red or green area of the screen (depending on whether a high or low beat is being produced), and the metronome can be implemented using a terminal display, or optionally, a graphical display, depending on the language capabilities.

If the language has no facility to output sound, then it is permissible for this to implemented using just the visual indicator.



",Python,"#lang Python
import time
 
def main(bpm = 72, bpb = 4):
    sleep = 60.0 / bpm
    counter = 0
    while True:
        counter += 1
        if counter % bpb:
            print 'tick'
        else:
            print 'TICK'
        time.sleep(sleep)
 
 
 
main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Vogel%27s_approximation_method,Vogel's approximation method,"Vogel's Approximation Method (VAM) is a technique for finding a good initial feasible solution to an allocation problem.

The powers that be have identified 5 tasks that need to be solved urgently. Being imaginative chaps, they have called them “A”, “B”, “C”, “D”, and “E”. They estimate that:

 A will require 30 hours of work,
 B will require 20 hours of work,
 C will require 70 hours of work,
 D will require 30 hours of work, and
 E will require 60 hours of work.
They have identified 4 contractors willing to do the work, called “W”, “X”, “Y”, and “Z”.

 W has 50 hours available to commit to working,
 X has 60 hours available,
 Y has 50 hours available, and
 Z has 50 hours available.
The cost per hour for each contractor for each task is summarized by the following table:

   A  B  C  D  E
W 16 16 13 22 17
X 14 14 13 19 15
Y 19 19 20 23 50
Z 50 12 50 15 11

The task is to use VAM to allocate contractors to tasks. It scales to large problems, so ideally keep sorts out of the iterative cycle. It works as follows:

Step 1: Balance the given transportation problem if either (total supply>total demand) or (total supply<total demand)
Step 2: Determine the penalty cost for each row and column by subtracting the lowest cell cost in the row or column from the next lowest cell cost in the same row or column.
Step 3: Select the row or column with the highest penalty cost (breaking ties arbitrarily or choosing the lowest-cost cell).
Step 4: Allocate as much as possible to the feasible cell with the lowest transportation cost in the row or column with the highest penalty cost.
Step 5: Repeat steps 2, 3 and 4 until all requirements have been meet.
Step 6: Compute total transportation cost for the feasible allocations.
For this task assume that the model is balanced.

For each task and contractor (row and column above) calculating the difference between the smallest two values produces:

        A       B       C       D       E       W       X       Y       Z
1       2       2       0       4       4       3       1       0       1   E-Z(50)

Determine the largest difference (D or E above). In the case of ties I shall choose the one with the lowest price (in this case E because the lowest price for D is Z=15, whereas for E it is Z=11). For your choice determine the minimum cost (chosen E above so Z=11 is chosen now). Allocate as much as possible from Z to E (50 in this case limited by Z's supply).
Adjust the supply and demand accordingly. If demand or supply becomes 0 for a given task or contractor it plays no further part. In this case Z is out of it. If you choose arbitrarily, and chose D see here for the working.

Repeat until all supply and demand is met:

2       2       2       0       3       2       3       1       0       -   C-W(50)
3       5       5       7       4      35       -       1       0       -   E-X(10)
4       5       5       7       4       -       -       1       0       -   C-X(20)
5       5       5       -       4       -       -       0       0       -   A-X(30)
6       -      19       -      23       -       -       -       4       -   D-Y(30)
        -       -       -       -       -       -       -       -       -   B-Y(20)

Finally calculate the cost of your solution. In the example given it is £3100:

   A  B  C  D  E
W       50
X 30    20    10
Y    20    30
Z             50

The optimal solution determined by GLPK is £3100:

   A  B  C  D  E
W       50
X 10 20 20    10
Y 20       30
Z             50

Cf.
 Transportation problem",Python,"from collections import defaultdict
 
costs  = {'W': {'A': 16, 'B': 16, 'C': 13, 'D': 22, 'E': 17},
          'X': {'A': 14, 'B': 14, 'C': 13, 'D': 19, 'E': 15},
          'Y': {'A': 19, 'B': 19, 'C': 20, 'D': 23, 'E': 50},
          'Z': {'A': 50, 'B': 12, 'C': 50, 'D': 15, 'E': 11}}
demand = {'A': 30, 'B': 20, 'C': 70, 'D': 30, 'E': 60}
cols = sorted(demand.iterkeys())
supply = {'W': 50, 'X': 60, 'Y': 50, 'Z': 50}
res = dict((k, defaultdict(int)) for k in costs)
g = {}
for x in supply:
    g[x] = sorted(costs[x].iterkeys(), key=lambda g: costs[x][g])
for x in demand:
    g[x] = sorted(costs.iterkeys(), key=lambda g: costs[g][x])
 
while g:
    d = {}
    for x in demand:
        d[x] = (costs[g[x][1]][x] - costs[g[x][0]][x]) if len(g[x]) > 1 else costs[g[x][0]][x]
    s = {}
    for x in supply:
        s[x] = (costs[x][g[x][1]] - costs[x][g[x][0]]) if len(g[x]) > 1 else costs[x][g[x][0]]
    f = max(d, key=lambda n: d[n])
    t = max(s, key=lambda n: s[n])
    t, f = (f, g[f][0]) if d[f] > s[t] else (g[t][0], t)
    v = min(supply[f], demand[t])
    res[f][t] += v
    demand[t] -= v
    if demand[t] == 0:
        for k, n in supply.iteritems():
            if n != 0:
                g[k].remove(t)
        del g[t]
        del demand[t]
    supply[f] -= v
    if supply[f] == 0:
        for k, n in demand.iteritems():
            if n != 0:
                g[k].remove(f)
        del g[f]
        del supply[f]
 
for n in cols:
    print ""\t"", n,
print
cost = 0
for g in sorted(costs):
    print g, ""\t"",
    for n in cols:
        y = res[g][n]
        if y != 0:
            print y,
        cost += y * costs[g][n]
        print ""\t"",
    print
print ""\n\nTotal Cost = "", cost",Human_written,Python_from_Java
http://rosettacode.org/wiki/Cullen_and_Woodall_numbers,Cullen and Woodall numbers,"A Cullen number is a number of the form n × 2n + 1 where n is a natural number.

A Woodall number is very similar. It is a number of the form n × 2n - 1 where n is a natural number.

So for each n the associated Cullen number and Woodall number differ by 2.

Woodall numbers are sometimes referred to as Riesel numbers or Cullen numbers of the second kind.


Cullen primes are Cullen numbers that are prime. Similarly, Woodall primes are Woodall numbers that are prime.

It is common to list the Cullen and Woodall primes by the value of n rather than the full evaluated expression. They tend to get very large very quickly. For example, the third Cullen prime, n == 4713, has 1423 digits when evaluated.



Task
 Write procedures to find Cullen numbers and Woodall numbers. 
 Use those procedures to find and show here, on this page the first 20 of each.


Stretch
 Find and show the first 5 Cullen primes in terms of n.
 Find and show the first 12 Woodall primes in terms of n.


See also
 OEIS:A002064 - Cullen numbers: a(n) = n*2^n + 1
 OEIS:A003261 - Woodall (or Riesel) numbers: n*2^n - 1
 OEIS:A005849 - Indices of prime Cullen numbers: numbers k such that k*2^k + 1 is prime
 OEIS:A002234 - Numbers k such that the Woodall number k*2^k - 1 is prime

",Python,"print(""working..."")
print(""First 20 Cullen numbers:"")
 
for n in range(1,20):
    num = n*pow(2,n)+1
    print(str(num),end= "" "")
 
print()
print(""First 20 Woodall numbers:"")
 
for n in range(1,20):
    num = n*pow(2,n)-1
    print(str(num),end="" "")
 
print()
print(""done..."")",Human_written,Python_from_Go
http://rosettacode.org/wiki/Roots_of_a_quadratic_function,Roots of a quadratic function,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.
Write a program to find the roots of a quadratic equation, i.e., solve the equation 



a

x

2


+
b
x
+
c
=
0


{\displaystyle ax^{2}+bx+c=0}

.
Your program must correctly handle non-real roots, but it need not check that 



a
≠
0


{\displaystyle a\neq 0}

.

The problem of solving a quadratic equation is a good example of how dangerous it can be to ignore the peculiarities of floating-point arithmetic.
The obvious way to implement the quadratic formula suffers catastrophic loss of accuracy when one of the roots to be found is much closer to 0 than the other.
In their classic textbook on numeric methods Computer Methods for Mathematical Computations, George Forsythe, Michael Malcolm, and Cleve Moler suggest trying the naive algorithm with 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

5




{\displaystyle b=-10^{5}}

, and 



c
=
1


{\displaystyle c=1}

.
(For double-precision floats, set 



b
=
−

10

9




{\displaystyle b=-10^{9}}

.)
Consider the following implementation in Ada:

with Ada.Text_IO;                        use Ada.Text_IO;
with Ada.Numerics.Elementary_Functions;  use Ada.Numerics.Elementary_Functions;
 
procedure Quadratic_Equation is
   type Roots is array (1..2) of Float;
   function Solve (A, B, C : Float) return Roots is
      SD : constant Float := sqrt (B**2 - 4.0 * A * C);
      AA : constant Float := 2.0 * A;
   begin
      return ((- B + SD) / AA, (- B - SD) / AA);
   end Solve;
 
   R : constant Roots := Solve (1.0, -10.0E5, 1.0);
begin
   Put_Line (""X1 ="" & Float'Image (R (1)) & "" X2 ="" & Float'Image (R (2)));
end Quadratic_Equation;

Output:
X1 = 1.00000E+06 X2 = 0.00000E+00
As we can see, the second root has lost all significant figures. The right answer is that X2 is about 




10

−
6




{\displaystyle 10^{-6}}

. The naive method is numerically unstable.

Suggested by Middlebrook (D-OA), a better numerical method: to define two parameters 



q
=


a
c



/

b


{\displaystyle q={\sqrt {ac}}/b}

 and 



f
=
1

/

2
+


1
−
4

q

2





/

2


{\displaystyle f=1/2+{\sqrt {1-4q^{2}}}/2}



and the two roots of the quardratic are: 






−
b

a


f


{\displaystyle {\frac {-b}{a}}f}

 and 






−
c


b
f





{\displaystyle {\frac {-c}{bf}}}




Task: do it better. This means that given 



a
=
1


{\displaystyle a=1}

, 



b
=
−

10

9




{\displaystyle b=-10^{9}}

, and 



c
=
1


{\displaystyle c=1}

, both of the roots your program returns should be greater than 




10

−
11




{\displaystyle 10^{-11}}

. Or, if your language can't do floating-point arithmetic any more precisely than single precision, your program should be able to handle 



b
=
−

10

6




{\displaystyle b=-10^{6}}

. Either way, show what your program gives as the roots of the quadratic in question. See page 9 of
""What Every Scientist Should Know About Floating-Point Arithmetic"" for a possible algorithm.
",Python,"from __future__ import division
from cmath import sqrt
from collections import namedtuple
 
Complex = namedtuple('Complex','real imag')
 
def solve_quadratic_equation(a, b, c):
    b /= a
    c /= a
    discriminant = b*b-4*c
    if discriminant < 0:
        return (Complex(-b/2, sqrt(-discriminant)/2),
                Complex(-b/2, -sqrt(-discriminant)/2))
 
    root = sqrt(discriminant)
    solution1 = (-b - root)/2 if b > 0 else (-b + root)/2
 
    return (solution1, c/solution1)
 
if __name__ == '__main__':
    result = solve_quadratic_equation(1, -1e20, 1)
    print(result[0], result[1])",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Queue/Definition,Queue/Definition,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Implement a FIFO queue.

Elements are added at one side and popped from the other in the order of insertion.



Operations:

   push   (aka enqueue)    - add element
   pop     (aka dequeue)    - pop first element
   empty                             - return truth value when empty


Errors:

   handle the error of trying to pop from an empty queue (behavior depends on the language and platform)


See

   Queue/Usage   for the built-in FIFO or queue of your language or standard library.


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"class FIFO(object):
       def __init__(self, *args):
           self.contents = list(args)
       def __call__(self):
           return self.pop()
       def __len__(self):
           return len(self.contents)
       def pop(self):
           return self.contents.pop(0)
       def push(self, item):
           self.contents.append(item)
       def extend(self,*itemlist):
           self.contents += itemlist
       def empty(self):
           return bool(self.contents)
       def __iter__(self):
           return self
       def next(self):
           if self.empty():
               raise StopIteration
           return self.pop()
 
if __name__ == ""__main__"":
    # Sample usage:
    f = FIFO()
    f.push(3)
    f.push(2)
    f.push(1)
    while not f.empty():
        print f.pop(),
    # >>> 3 2 1
    # Another simple example gives the same results:
    f = FIFO(3,2,1)
    while not f.empty():
        print f(),
    # Another using the default ""truth"" value of the object
    # (implicitly calls on the length() of the object after
    # checking for a __nonzero__ method
    f = FIFO(3,2,1)
    while f:
        print f(),
    # Yet another, using more Pythonic iteration:
    f = FIFO(3,2,1)
    for i in f:
        print i,",Human_written,Python_from_C
http://rosettacode.org/wiki/Take_notes_on_the_command_line,Take notes on the command line,"Take notes on the command line is part of Short Circuit's Console Program Basics selection.
Invoking NOTES without commandline arguments displays the current contents of the local NOTES.TXT if it exists.
If NOTES has arguments, the current date and time are appended to the local NOTES.TXT followed by a newline.
Then all the arguments, joined with spaces, prepended with a tab, and appended with a trailing newline, are written to NOTES.TXT.
If NOTES.TXT doesn't already exist in the current directory then a new NOTES.TXT file should be created.
",Python,"import sys, datetime, shutil
 
if len(sys.argv) == 1:
    try:
        with open('notes.txt', 'r') as f:
            shutil.copyfileobj(f, sys.stdout)
    except IOError:
        pass
else:
    with open('notes.txt', 'a') as f:
        f.write(datetime.datetime.now().isoformat() + '\n')
        f.write(""\t%s\n"" % ' '.join(sys.argv[1:]))",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",Python,"import sys
for i in xrange(5):
    for j in xrange(i+1):
        sys.stdout.write(""*"")
    print",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Reverse_a_string,Reverse a string,"Task

Take a string and reverse it.

For example, ""asdf"" becomes ""fdsa"".



Extra credit

Preserve Unicode combining characters.

For example, ""as⃝df̅"" becomes ""f̅ds⃝a"", not ""̅fd⃝sa"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def reverse_string(input):
    input_chars = list(input)
    input_chars.reverse()
    return ''.join(input_chars)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort,Sorting algorithms/Merge sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


The   merge sort   is a recursive sort of order    n*log(n). 

It is notable for having a worst case and average complexity of    O(n*log(n)),    and a best case complexity of    O(n)    (for pre-sorted input).

The basic idea is to split the collection into smaller groups by halving it until the groups only have one element or no elements   (which are both entirely sorted groups).

Then merge the groups back together so that their elements are in order.

This is how the algorithm gets its   divide and conquer   description.



Task

Write a function to sort a collection of integers using the merge sort.



The merge sort algorithm comes in two parts:

   a sort function     and 
   a merge function 

The functions in pseudocode look like this:

function mergesort(m)
   var list left, right, result
   if length(m) ≤ 1
       return m
   else
       var middle = length(m) / 2
       for each x in m up to middle - 1
           add x to left
       for each x in m at and after middle
           add x to right
       left = mergesort(left)
       right = mergesort(right)
       if last(left) ≤ first(right) 
          append right to left
          return left
       result = merge(left, right)
       return result

function merge(left,right)
   var list result
   while length(left) > 0 and length(right) > 0
       if first(left) ≤ first(right)
           append first(left) to result
           left = rest(left)
       else
           append first(right) to result
           right = rest(right)
   if length(left) > 0 
       append rest(left) to result
   if length(right) > 0 
       append rest(right) to result
   return result



See also

   the Wikipedia entry:    merge sort


Note:   better performance can be expected if, rather than recursing until    length(m) ≤ 1,    an insertion sort is used for    length(m)    smaller than some threshold larger than   1.   However, this complicates the example code, so it is not shown here.



",Python,"from heapq import merge
 
def merge_sort(m):
    if len(m) <= 1:
        return m
 
    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]
 
    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sorting_algorithms/Bogosort,Sorting algorithms/Bogosort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Bogosort a list of numbers.



Bogosort simply shuffles a collection randomly until it is sorted.

""Bogosort"" is a perversely inefficient algorithm only used as an in-joke.

Its average run-time is   O(n!)   because the chance that any given shuffle of a set will end up in sorted order is about one in   n   factorial,   and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.

Its best case is   O(n)   since a single pass through the elements may suffice to order them.



Pseudocode:

while not InOrder(list) do
   Shuffle(list)
done



The Knuth shuffle may be used to implement the shuffle part of this algorithm.



",Python,"import random
 
def bogosort(l):
    while not in_order(l):
        random.shuffle(l)
    return l
 
def in_order(l):
    if not l:
        return True
    last = l[0]
    for x in l[1:]:
        if x < last:
            return False
        last = x
    return True",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Palindrome_detection,Palindrome detection,"A palindrome is a phrase which reads the same backward and forward.

Task[edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes)
is a palindrome.

For extra credit:

 Support Unicode characters.
 Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
 It might be useful for this task to know how to reverse a string.
 This task's entries might also form the subjects of the task Test a function.
Related tasks
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def isPalindrome(str):
  return str == str[::-1]

print(isPalindrome(""ingirumimusnocteetconsumimurigni""))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas,The Twelve Days of Christmas,"Task

Write a program that outputs the lyrics of the Christmas carol The Twelve Days of Christmas.
The lyrics can be found here.

(You must reproduce the words in the correct order, but case, format, and punctuation are left to your discretion.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"days = [
    'first','second', 'third', 'fourth', 'fifth','sixth','seventh', 'eighth', 'ninth',
    'tenth', 'eleventh', 'twelfth',
]

gifts = [
    ""A partridge in a pear tree"",
    ""Two turtle doves"",
    ""Three french hens"",
    ""Four calling birds"",
    ""Five golden rings"",
    ""Six geese a-laying"",
    ""Seven swans a-swimming"",
    ""Eight maids a-milking"",
    ""Nine ladies dancing"",
    ""Ten lords a-leaping"",
    ""Eleven pipers piping"",
    ""Twelve drummers drumming""
]

lines, verses = [], []

for i in range(12):
    lines = []
    lines.append(""On the "" + days[i] + "" day of Christmas, my true love gave to me"")

    j = i + 1
    k = 0
    while j > 0:
        lines.append(gifts[j-1])
        j -= 1

    verses.append('\n'.join(lines))

    if i == 0:
        gifts[0] = ""And a partridge in a pear tree""

song = '\n\n'.join(verses)
print(song)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Constrained_random_points_on_a_circle,Constrained random points on a circle,"Task

Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that 




10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

. 
Then display/plot them. The outcome should be a ""fuzzy"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.

There are several possible approaches to accomplish this. Here are two possible algorithms.

1) Generate random pairs of integers and filter out those that don't satisfy this condition:





10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

.
2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.



",Python,"import random

field = [[''for i in range(31)] for j in range(31)]
pointsInDisc = 0
while pointsInDisc < 100:
    x = random.randint(0, 30) - 15
    y = random.randint(0, 30) - 15
    dist = (x ** 2 + y ** 2) ** 0.5
    if dist >= 10 and dist <= 15 and field[x + 15][y + 15] =='':
        field[x + 15][y + 15] = 'X'
        pointsInDisc += 1

for row in field:
    for space in row:
        print(space, end='')
    print()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Non-decimal_radices/Convert,Non-decimal radices/Convert,"Number base conversion is when you express a stored integer in an integer base, such as in octal (base 8) or binary (base 2). It also is involved when you take a string representing a number in a given base and convert it to the stored integer form. Normally, a stored integer is in binary, but that's typically invisible to the user, who normally enters or sees stored integers as decimal.



Task

Write a function (or identify the built-in function) which is passed a non-negative integer to convert, and another integer representing the base.

It should return a string containing the digits of the resulting number, without leading zeros except for the number   0   itself.

For the digits beyond 9, one should use the lowercase English alphabet, where the digit   a = 9+1,   b = a+1,   etc.

For example:   the decimal number   26   expressed in base   16   would be   1a.

Write a second function which is passed a string and an integer base, and it returns an integer representing that string interpreted in that base.

The programs may be limited by the word size or other such constraint of a given language. There is no need to do error checking for negatives, bases less than 2, or inappropriate digits.



",Python,"k = 26
s = hex(k) #gives '0x1a'
i = int(s,16) #gives 26
#optional special case for hex:
i = int('0x'+s,16) #gives 26",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",Python,"'''Hilbert curve'''
 
from itertools import (chain, islice)
 
 
# hilbertCurve :: Int -> SVG String
def hilbertCurve(n):
    '''An SVG string representing a
       Hilbert curve of degree n.
    '''
    w = 1024
    return svgFromPoints(w)(
        hilbertPoints(w)(
            hilbertTree(n)
        )
    )
 
 
# hilbertTree :: Int -> Tree Char
def hilbertTree(n):
    '''Nth application of a rule to a seedling tree.'''
 
    # rule :: Dict Char [Char]
    rule = {
        'a': ['d', 'a', 'a', 'b'],
        'b': ['c', 'b', 'b', 'a'],
        'c': ['b', 'c', 'c', 'd'],
        'd': ['a', 'd', 'd', 'c']
    }
 
    # go :: Tree Char -> Tree Char
    def go(tree):
        c = tree['root']
        xs = tree['nest']
        return Node(c)(
            map(go, xs) if xs else map(
                flip(Node)([]),
                rule[c]
            )
        )
    seed = Node('a')([])
    return list(islice(
        iterate(go)(seed), n
    ))[-1] if 0 < n else seed
 
 
# hilbertPoints :: Int -> Tree Char -> [(Int, Int)]
def hilbertPoints(w):
    '''Serialization of a tree to a list of points
       bounded by a square of side w.
    '''
 
    # vectors :: Dict Char [(Int, Int)]
    vectors = {
        'a': [(-1, 1), (-1, -1), (1, -1), (1, 1)],
        'b': [(1, -1), (-1, -1), (-1, 1), (1, 1)],
        'c': [(1, -1), (1, 1), (-1, 1), (-1, -1)],
        'd': [(-1, 1), (1, 1), (1, -1), (-1, -1)]
    }
 
    # points :: Int -> ((Int, Int), Tree Char) -> [(Int, Int)]
    def points(d):
        '''Size -> Centre of a Hilbert subtree -> All subtree points
        '''
        def go(xy, tree):
            r = d // 2
 
            def deltas(v):
                return (
                    xy[0] + (r * v[0]),
                    xy[1] + (r * v[1])
                )
            centres = map(deltas, vectors[tree['root']])
            return chain.from_iterable(
                map(points(r), centres, tree['nest'])
            ) if tree['nest'] else centres
        return go
 
    d = w // 2
    return lambda tree: list(points(d)((d, d), tree))
 
 
# svgFromPoints :: Int -> [(Int, Int)] -> SVG String
def svgFromPoints(w):
    '''Width of square canvas -> Point list -> SVG string'''
 
    def go(xys):
        def points(xy):
            return str(xy[0]) + ' ' + str(xy[1])
        xs = ' '.join(map(points, xys))
        return '\n'.join(
            ['<svg xmlns=""http://www.w3.org/2000/svg""',
             f'width=""512"" height=""512"" viewBox=""5 5 {w} {w}"">',
             f'<path d=""M{xs}"" ',
             'stroke-width=""2"" stroke=""red"" fill=""transparent""/>',
             '</svg>'
             ]
        )
    return go
 
 
# ------------------------- TEST --------------------------
def main():
    '''Testing generation of the SVG for a Hilbert curve'''
    print(
        hilbertCurve(6)
    )
 
 
# ------------------- GENERIC FUNCTIONS -------------------
 
# Node :: a -> [Tree a] -> Tree a
def Node(v):
    '''Contructor for a Tree node which connects a
       value of some kind to a list of zero or
       more child trees.'''
    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}
 
 
# flip :: (a -> b -> c) -> b -> a -> c
def flip(f):
    '''The (curried or uncurried) function f with its
       arguments reversed.
    '''
    return lambda a: lambda b: f(b)(a)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
#  TEST ---------------------------------------------------
if __name__ == '__main__':
    main()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Conditional_structures,Conditional structures,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

Task

List the conditional structures offered by a programming language. See Wikipedia: conditionals for descriptions.

Common conditional structures include if-then-else and switch.

Less common are arithmetic if, ternary operator and Hash-based conditionals.

Arithmetic if allows tight control over computed gotos, which optimizers have a hard time to figure out.


",Python,"if x == 0:
    foo()
elif x == 1:
    bar()
elif x == 2:
    baz()
else:
    boz()",Human_written,Python_from_C
http://rosettacode.org/wiki/Straddling_checkerboard,Straddling checkerboard,"Task

Implement functions to encrypt and decrypt a message using the straddling checkerboard method. The checkerboard should take a 28 character alphabet (A-Z plus a full stop and an escape character) and two different numbers representing the blanks in the first row. The output will be a series of decimal digits.

Numbers should be encrypted by inserting the escape character before each digit, then including the digit unencrypted. This should be reversed for decryption.



",Python,"class StraddlingCheckerboard:
    def __init__(self, alphabet, u, v):
        self.table = {}
        self.first = [0] * 10
        self.second = [0] * 10
        self.third = [0] * 10
        self.rowU = min(u, v)
        self.rowV = max(u, v)
 
        for i in range(10):
            if i!= u and i!= v:
                self.first[i] = alphabet[i]
                self.table[alphabet[i]] = str(i)
 
            self.second[i] = alphabet[i+8]
            self.table[alphabet[i+8]] = str(self.rowU) + str(i)
 
            self.third[i] = alphabet[i+18]
            self.table[alphabet[i+18]] = str(self.rowV) + str(i)
 
    def encode(self, plain):
        out = """"
        for c in plain:
            if c >= 'a' and c <= 'z':
                c += 'A' - 'a'
 
            if c >= 'A' and c <= 'Z':
                out += self.table[c]
            elif c >= '0' and c <= '9':
                out += self.table['/']
                out += c
        return out
 
    def decode(self, cipher):
        out = """"
        state = 0
        for c in cipher:
            n = ord(c) - ord('0')
            next = 0
 
            if state == 1:
                next = self.second[n]
            elif state == 2:
                next = self.third[n]
            elif state == 3:
                next = c
            elif n == self.rowU:
                state = 1
            elif n == self.rowV:
                state = 2
            else:
                next = self.first[n]
 
            if next == '/':
                state = 3
            elif next!= 0:
                state = 0
                out += next
        return out",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Inheritance/Multiple,Inheritance/Multiple,"Multiple inheritance allows to specify that one  class is a subclass of several other classes.

Some languages allow multiple inheritance for arbitrary classes,   others restrict it to interfaces,   some don't allow it at all.



Task

Write two classes (or interfaces) Camera and MobilePhone,   then write a class CameraPhone which is both a Camera and a MobilePhone.

There is no need to implement any functions for those classes.



",Python,"class Camera:
  pass #functions go here...",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort,Sorting algorithms/Comb sort,"Sorting algorithms/Comb sort

You are encouraged to solve this task according to the task description, using any language you may know.

Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a   comb sort.



The Comb Sort is a variant of the Bubble Sort.

Like the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.

Dividing the gap by   



(
1
−

e

−
φ



)

−
1


≈
1.247330950103979


{\displaystyle (1-e^{-\varphi })^{-1}\approx 1.247330950103979}

    works best, but    1.3   may be more practical.



Some implementations use the insertion sort once the gap is less than a certain amount.



Also see

   the Wikipedia article:   Comb sort.


Variants:

 Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.
 Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small).   Comb sort with a low gap isn't much better than the Bubble Sort.


Pseudocode:

function combsort(array input)
    gap := input.size //initialize gap size
    loop until gap = 1 and swaps = 0
        //update the gap value for a next comb. Below is an example
        gap := int(gap / 1.25)
        if gap < 1
          //minimum gap is 1
          gap := 1
        end if
        i := 0
        swaps := 0 //see Bubble Sort for an explanation
        //a single ""comb"" over the input list
        loop until i + gap >= input.size //see Shell sort for similar idea
            if input[i] > input[i+gap]
                swap(input[i], input[i+gap])
                swaps := 1 // Flag a swap has occurred, so the
                           // list is not guaranteed sorted
            end if
            i := i + 1
        end loop
    end loop
end function


",Python,">>> def combsort(input):
    gap = len(input)
    swaps = True
    while gap > 1 or swaps:
        gap = max(1, int(gap / 1.25))  # minimum gap is 1
        swaps = False
        for i in range(len(input) - gap):
            j = i+gap
            if input[i] > input[j]:
                input[i], input[j] = input[j], input[i]
                swaps = True
 
 
>>> y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]
>>> combsort(y)
>>> assert y == sorted(y)
>>> y
[0, 4, 5, 8, 14, 18, 20, 31, 33, 44, 62, 70, 73, 75, 76, 78, 81, 82, 84, 88]
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Babbage_problem,Babbage problem,"

Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:

 What is the smallest positive integer whose square ends in the digits 269,696?

— Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, Electronic Computers, second edition, 1970, p. 125.

He thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.



Task[edit]
The task is to find out if Babbage had the right answer — and to do so, as far as your language allows it, in code that Babbage himself would have been able to read and understand.
As Babbage evidently solved the task with pencil and paper, a similar efficient solution is preferred.

For these purposes, Charles Babbage may be taken to be an intelligent person, familiar with mathematics and with the idea of a computer; he has written the first drafts of simple computer programmes in tabular form. [Babbage Archive Series L].



Motivation
The aim of the task is to write a program that is sufficiently clear and well-documented for such a person to be able to read it and be confident that it does indeed solve the specified problem.



",Python,"# Lines that start by # are a comments:
# they will be ignored by the machine
 
n=0 # n is a variable and its value is 0
 
# we will increase its value by one until
# its square ends in 269,696
 
while n**2 % 1000000 != 269696:
 
    # n**2 -> n squared
    # %    -> 'modulo' or remainer after division
    # !=   -> not equal to
 
    n += 1 # += -> increase by a certain number
 
print(n) # prints n
 
# short version
>>> [x for x in range(30000) if (x*x) % 1000000 == 269696] [0]
25264",Human_written,Python_from_Java
http://rosettacode.org/wiki/Loops/Continue,Loops/Continue,"Task

Show the following output using one loop.

1, 2, 3, 4, 5
6, 7, 8, 9, 10



Try to achieve the result by forcing the next iteration within the loop
upon a specific condition, if your language allows it.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"for i in xrange(1,11):
    if i % 5 == 0:
        print i
        continue
    print i, "","",",Human_written,Python_from_C#
http://rosettacode.org/wiki/Hello_world/Web_server,Hello world/Web server,"The browser is the new GUI !



Task

Serve our standard text   Goodbye, World!   to   http://localhost:8080/   so that it can be viewed with a web browser.

The provided solution must start or implement a server that accepts multiple client connections and serves text as requested.

Note that starting a web browser or opening a new window with this URL
is not part of the task.

Additionally, it is permissible to serve the provided page as a plain text file (there is no requirement to serve properly formatted HTML here).

The browser will generally do the right thing with simple text like this.



",Python,"import socket
import sys
 
msg = ""<html>\n<body>\nGoodbye, world!\n</body>\n</html>\n""
port = 8080
serverRunning = True
 
tcpListener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcpListener.bind(('', port))
tcpListener.listen(1)
 
while serverRunning:
    socketConnection, addr = tcpListener.accept()
    socketConnection.send(msg)
    socketConnection.close()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/URL_decoding,URL decoding,"This task   (the reverse of   URL encoding   and distinct from   URL parser)   is to provide a function
or mechanism to convert an URL-encoded string into its original unencoded form.



Test cases

   The encoded string   ""http%3A%2F%2Ffoo%20bar%2F""   should be reverted to the unencoded form   ""http://foo bar/"".
   The encoded string   ""google.com/search?q=%60Abdu%27l-Bah%C3%A1""   should revert to the unencoded form   ""google.com/search?q=`Abdu'l-Bahá"".

",Python,"#Python 2.X
import urllib
print urllib.unquote(""http%3A%2F%2Ffoo%20bar%2F"")
#Python 3.5+
from urllib.parse import unquote
print(unquote('http%3A%2F%2Ffoo%20bar%2F'))",Human_written,Python_from_Rust
"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import sys
 
def main():
    with open(""days_of_week.txt"") as f:
        lines = f.readlines()
    i = 0
    for line in lines:
        i += 1
        if len(line) > 0:
            days = line.split()
            if len(days)!= 7:
                raise Exception(""There aren't 7 days in line "" + str(i))
 
            temp = {}
            for day in days:
                if day in temp:
                    print("" ∞  {0}"".format(line))
                    continue
                temp[day] = 1
 
            len = 1
            while True:
                temp.clear()
                for day in days:
                    key = day[:len]
                    if key in temp:
                        break
                    temp[key] = 1
                if len(temp) == 7:
                    print(""{0,2:D}  {1}"".format(len, line))
                    break
                len += 1
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Power_set,Power set,"A   set   is a collection (container) of certain values,
without any particular order, and no repeated values.

It corresponds with a finite set in mathematics.

A set can be implemented as an associative array (partial mapping)
in which the value of each key-value pair is ignored.

Given a set S, the power set (or powerset) of S, written P(S), or 2S, is the set of all subsets of S.



Task

By using a library or built-in set type, or by defining a set type with necessary operations, write a function with a set S as input that yields the power set 2S of S.



For example, the power set of     {1,2,3,4}     is

 {{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}, {4}, {1,4}, {2,4}, {1,2,4}, {3,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}.
For a set which contains n elements, the corresponding power set has 2n elements, including the edge cases of empty set.


The power set of the empty set is the set which contains itself (20 = 1):


 





P




{\displaystyle {\mathcal {P}}}

(



∅


{\displaystyle \varnothing }

) = { 



∅


{\displaystyle \varnothing }

 }

And the power set of the set which contains only the empty set, has two subsets, the empty set and the set which contains the empty set (21 = 2):


 





P




{\displaystyle {\mathcal {P}}}

({



∅


{\displaystyle \varnothing }

}) = { 



∅


{\displaystyle \varnothing }

, { 



∅


{\displaystyle \varnothing }

 } }


Extra credit:  Demonstrate that your language supports these last two powersets.



",Python,"def list_powerset(lst):
    # the power set of the empty set has one element, the empty set
    result = [[]]
    for x in lst:
        # for every additional element in our set
        # the power set consists of the subsets that don't
        # contain this element (just take the previous power set)
        # plus the subsets that do contain the element (use list
        # comprehension to add [x] onto everything in the
        # previous power set)
        result.extend([subset + [x] for subset in result])
    return result
 
# the above function in one statement
def list_powerset2(lst):
    return reduce(lambda result, x: result + [subset + [x] for subset in result],
                  lst, [[]])
 
def powerset(s):
    return frozenset(map(frozenset, list_powerset(list(s))))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Entropy,Entropy,"Task

Calculate the Shannon entropy   H   of a given input string.

Given the discrete random variable 



X


{\displaystyle X}

 that is a string of 



N


{\displaystyle N}

 ""symbols"" (total characters) consisting of 



n


{\displaystyle n}

 different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is :






H

2


(
X
)
=
−

∑

i
=
1


n





c
o
u
n

t

i



N



log

2


⁡

(



c
o
u
n

t

i



N


)



{\displaystyle H_{2}(X)=-\sum _{i=1}^{n}{\frac {count_{i}}{N}}\log _{2}\left({\frac {count_{i}}{N}}\right)}


where 



c
o
u
n

t

i




{\displaystyle count_{i}}

 is the count of character 




n

i




{\displaystyle n_{i}}

.

For this task, use X=""1223334444"" as an example. The result should be 1.84644... bits/symbol. This assumes X was a random variable, which may not be the case, or it may depend on the observer.

This coding problem calculates the ""specific"" or ""intensive"" entropy that finds its parallel in physics with ""specific entropy"" S0 which is entropy per kg or per mole, not like physical entropy S and therefore not the ""information"" content of a file. It comes from Boltzmann's H-theorem where 



S
=

k

B


N
H


{\displaystyle S=k_{B}NH}

 where N=number of molecules. Boltzmann's H is the same equation as Shannon's H, and it gives the specific entropy H on a ""per molecule"" basis.

The ""total"", ""absolute"", or ""extensive"" information entropy is





S
=

H

2


N


{\displaystyle S=H_{2}N}

 bits
This is not the entropy being coded here, but it is the closest to physical entropy and a measure of the information content of a string. But it does not look for any patterns that might be available for compression, so it is a very restricted, basic, and certain measure of ""information"". Every binary file with an equal number of 1's and 0's will have S=N bits. All hex files with equal symbol frequencies will have 



S
=
N

log

2


⁡
(
16
)


{\displaystyle S=N\log _{2}(16)}

 bits of entropy. The total entropy in bits of the example above is S= 10*18.4644 = 18.4644 bits.

The H function does not look for any patterns in data or check if X was a random variable. For example, X=000000111111 gives the same calculated entropy in all senses as Y=010011100101. For most purposes it is usually more relevant to divide the gzip length by the length of the original data to get an informal measure of how much ""order"" was in the data.

Two other ""entropies"" are useful:

Normalized specific entropy:






H

n


=




H

2


∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle H_{n}={\frac {H_{2}*\log(2)}{\log(n)}}}

 
which varies from 0 to 1 and it has units of ""entropy/symbol"" or just 1/symbol. For this example, Hn<\sub>= 0.923.

Normalized total (extensive) entropy:






S

n


=




H

2


N
∗
log
⁡
(
2
)


log
⁡
(
n
)





{\displaystyle S_{n}={\frac {H_{2}N*\log(2)}{\log(n)}}}


which varies from 0 to N and does not have units. It is simply the ""entropy"", but it needs to be called ""total normalized extensive entropy"" so that it is not confused with Shannon's (specific) entropy or physical entropy. For this example, Sn<\sub>= 9.23.

Shannon himself is the reason his ""entropy/symbol"" H function is very confusingly called ""entropy"". That's like calling a function that returns a speed a ""meter"". See section 1.7 of his classic A Mathematical Theory of Communication and search on ""per symbol"" and ""units"" to see he always stated his entropy H has units of ""bits/symbol"" or ""entropy/symbol"" or ""information/symbol"". So it is legitimate to say entropy NH is ""information"".

In keeping with Landauer's limit, the physics entropy generated from erasing N bits is 



S
=

H

2


N

k

B


ln
⁡
(
2
)


{\displaystyle S=H_{2}Nk_{B}\ln(2)}

 if the bit storage device is perfectly efficient. This can be solved for H2*N to (arguably) get the number of bits of information that a physical entropy represents.

Related tasks

 Fibonacci_word
 Entropy/Narcissist

",Python,"import math
 
MAXLEN = 100
 
def makehist(S, hist, len):
	wherechar = [-1] * 256
	histlen = 0
	for i in range(len):
		if wherechar[ord(S[i])] == -1:
			wherechar[ord(S[i])] = histlen
			histlen += 1
		hist[wherechar[ord(S[i])]] += 1
	return histlen
 
def entropy(hist, histlen, len):
	H = 0
	for i in range(histlen):
		H -= hist[i] / len * math.log(hist[i] / len, 2)
	return H
 
S = input()
len = len(S)
hist = [0] * len
histlen = makehist(S, hist, len)
H = entropy(hist, histlen, len)
print(H)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Chaocipher,Chaocipher,"Description

The Chaocipher was invented by J.F.Byrne in 1918 and, although simple by modern cryptographic standards, does not appear to have been broken until the algorithm was finally disclosed by his family in 2010.

The algorithm is described in this paper by M.Rubin in 2010 and there is a C# implementation here.



Task

Code the algorithm in your language and to test that it works with the plaintext 'WELLDONEISBETTERTHANWELLSAID' used in the paper itself.



",Python,"# Python3 implementation of Chaocipher 
# left wheel = ciphertext wheel
# right wheel = plaintext wheel
 
def main():
    # letters only! makealpha(key) helps generate lalpha/ralpha. 
    lalpha = ""HXUCZVAMDSLKPEFJRIGTWOBNYQ""
    ralpha = ""PTLNBQDEOYSFAVZKGJRIHWXUMC""
    msg = ""WELLDONEISBETTERTHANWELLSAID""
 
    print(""L:"", lalpha)
    print(""R:"", ralpha)
    print(""I:"", msg)
    print(""O:"", do_chao(msg, lalpha, ralpha, 1, 0), ""\n"")
 
    do_chao(msg, lalpha, ralpha, 1, 1)
 
def do_chao(msg, lalpha, ralpha, en=1, show=0):
    msg = correct_case(msg)
    out = """"    
    if show:
        print(""=""*54)        
        print(10*"" "" + ""left:"" + 21*"" "" + ""right: "")
        print(""=""*54)        
        print(lalpha, ralpha, ""\n"")
    for L in msg:
        if en:
            lalpha, ralpha = rotate_wheels(lalpha, ralpha, L)
            out += lalpha[0]
        else:
            ralpha, lalpha = rotate_wheels(ralpha, lalpha, L)
            out += ralpha[0]
        lalpha, ralpha = scramble_wheels(lalpha, ralpha)
        if show:
            print(lalpha, ralpha)            
    return out
 
def makealpha(key=""""):
    alpha = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
    z = set()
    key = [x.upper() for x in (key + alpha[::-1])
           if not (x.upper() in z or z.add(x.upper()))]
    return """".join(key)
 
def correct_case(string):
    return """".join([s.upper() for s in string if s.isalpha()])
 
def permu(alp, num):
    alp = alp[:num], alp[num:]
    return """".join(alp[::-1])
 
def rotate_wheels(lalph, ralph, key):
    newin = ralph.index(key)
    return permu(lalph, newin), permu(ralph, newin)    
 
def scramble_wheels(lalph, ralph):
    # LEFT = cipher wheel 
    # Cycle second[1] through nadir[14] forward
    lalph = list(lalph)
    lalph = """".join([*lalph[0],
                    *lalph[2:14],
                    lalph[1],
                    *lalph[14:]])
 
    # RIGHT = plain wheel                    
    # Send the zenith[0] character to the end[25],
    # cycle third[2] through nadir[14] characters forward
    ralph = list(ralph)
    ralph = """".join([*ralph[1:3],
                     *ralph[4:15],
                     ralph[3],
                     *ralph[15:],
                     ralph[0]])
    return lalph, ralph
 
main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Enforced_immutability,Enforced immutability,"Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.



",Python,">>> s = ""Hello""
>>> s[0] = ""h""
 
Traceback (most recent call last):
  File ""<pyshell#1>"", line 1, in <module>
    s[0] = ""h""
TypeError: 'str' object does not support item assignment",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Rock-paper-scissors,Rock-paper-scissors,"Task

Implement the classic children's game Rock-paper-scissors, as well as a simple predictive   AI   (artificial intelligence)   player.

Rock Paper Scissors is a two player game.

Each player chooses one of rock, paper or scissors, without knowing the other player's choice.

The winner is decided by a set of rules:

   Rock beats scissors
   Scissors beat paper
   Paper beats rock


If both players choose the same thing, there is no winner for that round.

For this task, the computer will be one of the players.

The operator will select Rock, Paper or Scissors and the computer will keep a record of the choice frequency, and use that information to make a weighted random choice in an attempt to defeat its opponent.



Extra credit

Support additional choices   additional weapons.



",Python,"import random
from enum import Enum
 
class Choice(Enum):
    Rock = 0
    Paper = 1
    Scissors = 2
 
def beats(c1, c2):
    return (c1 == Choice.Rock and c2 == Choice.Scissors) or (c1 == Choice.Scissors and c2 == Choice.Paper) or (c1 == Choice.Paper and c2 == Choice.Rock)
 
def ai_move(v):
    # weighted random choice, a dynamic version of `rand::distributions::WeightedChoice`
    rand = random.randint(0, v[0] + v[1] + v[2])
    if rand < v[0]:
        return Choice.Paper
    elif rand < v[0] + v[1]:
        return Choice.Scissors
    else:
        return Choice.Rock
 
print(""Rock, paper, scissors!"")
ai_choice = random.choice(list(Choice))
ucf = [0, 0, 0] # user choice frequency
score = [0, 0]
 
while True:
    print(""Please input your move: 'r', 'p' or's'. Type 'q' to quit"")
    input = input()
    u_choice = {
        'r': Choice.Rock,
        'p': Choice.Paper,
       's': Choice.Scissors,
        'q': None
    }.get(input.lower()[0], None)
    if u_choice is None:
        print(""Please enter a correct choice!"")
        continue
    print(""You chose {}, I chose {}."".format(u_choice, ai_choice))
    if beats(u_choice, ai_choice):
        score[0] += 1
        print(""You win!"")
    elif u_choice == ai_choice:
        print(""It's a tie!"")
    else:
        score[1] += 1
        print(""I win!"")
    print(""-Score: You {}, Me {}"".format(score[0], score[1]))
 
    # only after the 1st iteration the AI knows the stats and can make
    # its weighted random move
    ai_choice = ai_move(ucf)
 
print(""Thank you for the game!"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Unix/ls,Unix/ls,"Task

Write a program that will list everything in the current folder,   similar to:

   the Unix utility   “ls”   [1]       or 
   the Windows terminal command   “DIR” 


The output must be sorted, but printing extended details and producing multi-column output is not required.



Example output
For the list of paths:

/foo/bar
/foo/bar/1
/foo/bar/2
/foo/bar/a
/foo/bar/b



When the program is executed in   `/foo`,   it should print:

bar

and when the program is executed in   `/foo/bar`,   it should print:

1
2
a
b


",Python,">>> import os
>>> print('\n'.join(sorted(os.listdir('.'))))
DLLs
Doc
LICENSE.txt
Lib
NEWS.txt
README.txt
Scripts
Tools
include
libs
python.exe
pythonw.exe
tcl
>>>",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Magic_constant,Magic constant,"A magic square is a square grid containing consecutive integers from 1 to N², arranged so that every row, column and diagonal adds up to the same number. That number is a constant. There is no way to create a valid N x N magic square that does not sum to the associated constant.

EG
A 3 x 3 magic square always sums to 15.

    ┌───┬───┬───┐
    │ 2 │ 7 │ 6 │
    ├───┼───┼───┤
    │ 9 │ 5 │ 1 │
    ├───┼───┼───┤
    │ 4 │ 3 │ 8 │
    └───┴───┴───┘
A 4 x 4 magic square always sums to 34.

Traditionally, the sequence leaves off terms for n = 0 and n = 1 as the magic squares of order 0 and 1 are trivial; and a term for n = 2 because it is impossible to form a magic square of order 2.



Task
 Starting at order 3, show the first 20 magic constants.
 Show the 1000th magic constant. (Order 1003)
 Find and show the order of the smallest N x N magic square whose constant is greater than 10¹ through 10¹⁰.


Stretch
 Find and show the order of the smallest N x N magic square whose constant is greater than 10¹¹ through 10²⁰.


See also
 Wikipedia: Magic constant
 OEIS: A006003 (Similar sequence, though it includes terms for 0, 1 & 2.)

",Python,"import math
import rcu
 
def magicConstant(n):
    return (n*n + 1) * n / 2
 
ss = [
    ""\u2070"", ""\u00b9"", ""\u00b2"", ""\u00b3"", ""\u2074"",
    ""\u2075"", ""\u2076"", ""\u2077"", ""\u2078"", ""\u2079"",
]
 
def superscript(n):
    if n < 10:
        return ss[n]
    if n < 20:
        return ss[1] + ss[n-10]
    return ss[2] + ss[0]
 
def main():
    print(""First 20 magic constants:"")
    for n in range(3, 23):
        print(""%5d "" % magicConstant(n), end="""")
        if (n-2)%10 == 0:
            print()
 
    print(""\n1,000th magic constant:"", rcu.Commatize(magicConstant(1002)))
 
    print(""\nSmallest order magic square with a constant greater than:"")
    for i in range(1, 21):
        goal = math.pow(10, i)
        order = int(math.pow(goal*2, 1/3)) + 1
        print(""10%-2s : %9s"" % (superscript(i), rcu.Commatize(order)))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Dice_game_probabilities,Dice game probabilities,"Two players have a set of dice each. The first player has nine dice with four faces each, with numbers one to four. The second player has six normal dice with six faces each, each face has the usual numbers from one to six.

They roll their dice and sum the totals of the faces. The player with the highest total wins (it's a draw if the totals are the same). What's the probability of the first player beating the second player?

Later the two players use a different set of dice each. Now the first player has five dice with ten faces each, and the second player has six dice with seven faces each. Now what's the probability of the first player beating the second player?

This task was adapted from the Project Euler Problem n.205:
https://projecteuler.net/problem=205
",Python,"import math
from collections import defaultdict
 
# Returns map from sum of faces to number of ways it can happen
def get_totals(dice, faces):
    result = defaultdict(int)
    for i in range(1, faces+1):
        result[i] = 1
    for d in range(2, dice+1):
        tmp = defaultdict(int)
        for p in result:
            for i in range(1, faces+1):
                tmp[p + i] += result[p]
        result = tmp
    return result
 
def probability(dice1, faces1, dice2, faces2):
    totals1 = get_totals(dice1, faces1)
    totals2 = get_totals(dice2, faces2)
    wins = 0
    for p1 in totals1:
        for p2 in totals2:
            if p2 >= p1:
                break
            wins += totals1[p1] * totals2[p2]
    total = math.pow(faces1, dice1) * math.pow(faces2, dice2)
    return wins/total
 
print(probability(9, 4, 6, 6))
print(probability(5, 10, 6, 7))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Character_codes,Character codes,"

Task

Given a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).



Example

The character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.



",Python,"print ord('a') # prints ""97""
print chr(97)  # prints ""a""",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Temperature_conversion,Temperature conversion,"There are quite a number of temperature scales. For this task we will concentrate on four of the perhaps best-known ones:
Kelvin, Celsius, Fahrenheit, and Rankine.

The Celsius and Kelvin scales have the same magnitude, but different null points.

 0 degrees Celsius corresponds to 273.15 kelvin.
 0 kelvin is absolute zero.
The Fahrenheit and Rankine scales also have the same magnitude, but different null points.

 0 degrees Fahrenheit corresponds to 459.67 degrees Rankine.
 0 degrees Rankine is absolute zero.
The Celsius/Kelvin and Fahrenheit/Rankine scales have a ratio of 5 : 9.



Task
Write code that accepts a value of kelvin, converts it to values of the three other scales, and prints the result.



Example

K  21.00

C  -252.15

F  -421.87

R  37.80


",Python,"from __future__ import division
 
class TempConvert(object):
 
    FROM_TEMP_SCALE_TO_K = {
        'kelvin': lambda t: t,
        'celsius': lambda t: t + 273.15,
        'fahrenheit': lambda t: (t + 459.67) * 5/9.0,
        'rankine': lambda t: t * 5/9.0,
        'delisle': lambda t: 373.15 - t * 2/3.0,
        'newton': lambda t: t * 100/33.0 + 273.15,
       'reaumur': lambda t: t * 5/4.0 + 273.15,
        'roemer': lambda t: (t - 7.5) * 40/21.0 + 273.15}
 
    TO_TEMP_SCALE_FROM_K = {
        'kelvin': lambda t: t,
        'celsius': lambda t: t - 273.15,
        'fahrenheit': lambda t: t * 9/5.0 - 459.67,
        'rankine': lambda t: t * 9/5.0,
        'delisle': lambda t: (373.15 - t) * 3/2.0,
        'newton': lambda t: (t - 273.15) * 33/100.0,
       'reaumur': lambda t: (t - 273.15) * 4/5.0,
        'roemer': lambda t: (t - 273.15) * 21/40.0 + 7.5}
 
    SUPPORTED_SCALES = '|'.join(FROM_TEMP_SCALE_TO_K.keys())
 
    def __getattr__(self, meth):
        if self.valid_temperature_conversion(meth):
            return self.convert_temperature(meth)
        else:
            raise AttributeError
 
    def __dir__(self):
        return dir(type(self)) + self.SUPPORTED_SCALES.split('|')
 
    def valid_temperature_conversion(self, meth):
        return bool(meth.match(r'(%s)_to_(%s)' % (self.SUPPORTED_SCALES, self.SUPPORTED_SCALES)))
 
    def convert_temperature(self, meth):
        from_scale, to_scale = meth.split(""_to_"")
        if from_scale == to_scale:
            return self.temp
        else:
            return round(self.TO_TEMP_SCALE_FROM_K[to_scale](self.FROM_TEMP_SCALE_TO_K[from_scale](self.temp)), 2)
 
if __name__ == '__main__':
    tc = TempConvert()
    tc.temp = 100
    print tc.celsius_to_kelvin
    print tc.celsius_to_fahrenheit
    print tc.celsius_to_celsius
    print tc.celsius_to_rankine
    print tc.celsius_to_delisle
    print tc.celsius_to_newton
    print tc.celsius_to_reaumur
    print tc.celsius_to_roemer",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Singleton,Singleton,"A Global Singleton is a class of which only one instance exists within a program.

Any attempt to use non-static members of the class involves performing operations on this one instance.



",Python,"import singleton
class MySingleton(singleton.Singleton):
   # constructor and/or methods go here
 
a = MySingleton() # instance is only created the first time it is requested
b = MySingleton()
print(a is b) # outputs ""true""",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Quine,Quine,"A quine is a self-referential program that can,
without any external access, output its own source.



A   quine   (named after Willard Van Orman Quine)   is also known as:

   self-reproducing automata   (1972)
   self-replicating program         or   self-replicating computer program
   self-reproducing program      or   self-reproducing computer program
   self-copying program             or   self-copying computer program


It is named after the philosopher and logician
who studied self-reference and quoting in natural language,
as for example in the paradox ""'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation.""

""Source"" has one of two meanings. It can refer to the text-based program source.
For languages in which program source is represented as a data structure, ""source"" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.



Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

 Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on.
 Some languages have a function for getting the ""source code representation"" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem.
 Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39.
 Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. ""\n""). This causes the same problem as above, where the escaping character needs to itself be escaped, etc.
 If the language has a way of getting the ""source code representation"", it usually handles the escaping of characters, so this is not a problem.
 Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping.
 Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.



Related task

   print itself.

",Python,"w = ""print('w = ' + chr(34) + w + chr(34) + chr(10) + w)""
print('w = ' + chr(34) + w + chr(34) + chr(10) + w)",Human_written,Python_from_C
http://rosettacode.org/wiki/Colour_bars/Display,Colour bars/Display,"Task

Display a series of vertical color bars across the width of the display.

The color bars should either use:

   the system palette,   or 
   the sequence of colors: 
   black
   red
   green
   blue
   magenta
   cyan
   yellow
   white

",Python,"from PySide import QtCore, QtGui
 
class MyWidget(QtGui.QWidget):
    def __init__(self):
        super(MyWidget, self).__init__()
        self.width = 0
        self.height = 0
        self.colornumber = 0
 
    def paintEvent(self, QPaintEvent):
        pass",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Letter_frequency,Letter frequency,"Task

Open a text file and count the occurrences of each letter.

Some of these programs count all characters (including punctuation),
but some only count letters A to Z.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import collections, sys
 
def filecharcount(openfile):
    return sorted(collections.Counter(c for l in openfile for c in l).items())
 
f = open(sys.argv[1])
print(filecharcount(f))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",Python,"subject = ""Hello world!""
 
# Two different ways to create the RegExp object
# Both examples use the exact same pattern... matching ""hello ""
re_PatternToMatch = re.compile(""Hello (World)"", re.IGNORECASE) # creates a RegExp literal with case-insensitivity
re_PatternToMatch2 = re.compile(""Hello (World)"", re.IGNORECASE)
 
# Test for a match - return a bool
isMatch = re_PatternToMatch.search(subject)
 
# Get the match details
#    Returns an array with the match's details
#    matches[0] == ""Hello world""
#    matches[1] == ""world""
matches = re_PatternToMatch2.search(subject)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sierpinski_arrowhead_curve,Sierpinski arrowhead curve,"Task
Produce a graphical or ASCII-art representation of a  Sierpinski arrowhead curve  of at least order  3.



",Python,"import math
import numpy as np
from PIL import Image, ImageDraw
 
width = 770
height = 770
iy = 1
theta = 0
cx = width / 2
cy = height
h = cx / 2
 
def arrowhead(order, length):
    if order & 1 == 0:
        curve(order, length, 60)
    else:
        turn(60)
        curve(order, length, -60)
    drawLine(length)
 
def drawLine(length):
    global cx, cy, theta
    rads = math.radians(theta)
    cx += length * math.cos(rads)
    cy += length * math.sin(rads)
 
def turn(angle):
    global theta
    theta = (theta + angle) % 360
 
def curve(order, length, angle):
    if order == 0:
        drawLine(length)
    else:
        curve(order - 1, length / 2, -angle)
        turn(angle)
        curve(order - 1, length / 2, angle)
        turn(angle)
        curve(order - 1, length / 2, -angle)
 
order = 6
if order & 1 == 0:
    iy = -1
cx = width / 2
cy = height
h = cx / 2
arrowhead(order, cx)
 
img = Image.new('RGB', (width, height), (0, 0, 0))
draw = ImageDraw.Draw(img)
draw.line((cx - width / 2 + h, (height - cy) * iy + 2 * h, cx, cy), fill=(255, 0, 255), width=2)
img.save('sierpinski_arrowhead_curve.png')",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Delete_a_file,Delete a file,"Task

Delete a file called ""input.txt"" and delete a directory called ""docs"".

This should be done twice: once ""here"", i.e. in the current working directory and once in the filesystem root.



",Python,"import os
# current directory
os.remove(""output.txt"")
os.rmdir(""docs"")
# root directory
os.remove(""/output.txt"")
os.rmdir(""/docs"")",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",Python,"print('Enter x and y')
x = int(input())
y = int(input())

print('Sum: ', x+y)
print('Difference: ', x-y)
print('Product: ', x*y)
print('Quotient: ', x//y)
print('Quotient: ', x/y)
print('Remainder: ', x%y)
print('Exponentiation: ', x**y)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",Python,"import java.util.HashMap;
import java.util.Map;

def Q(n):
    if n in q:
        return q[n]
    ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2))
    q[n] = ans
    return ans

q = {1: 1, 2: 1}
nUses = [0] * 100001

for i in range(1, 11):
    print(""Q("" + str(i) + "") = "" + str(Q(i)))

last = 6
count = 0
for i in range(11, 100001):
    curr = Q(i)
    if curr < last:
        count += 1
    last = curr
    if i == 1000:
        print(""Q(1000) = "" + str(curr))

print(""Q(i) is less than Q(i-1) for i <= 100000 "" + str(count) + "" times"")

maxUses = 0
maxN = 0
for i in range(1, len(nUses)):
    if nUses[i] > maxUses:
        maxUses = nUses[i]
        maxN = i

print(""Q("" + str(maxN) + "") was called the most with "" + str(maxUses) + "" calls"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Monte_Carlo_methods,Monte Carlo methods,"A Monte Carlo Simulation is a way of approximating the value of a function
where calculating the actual value is difficult or impossible. 

It uses random sampling to define constraints on the value
and then makes a sort of ""best guess.""

A simple Monte Carlo Simulation can be used to calculate the value for 



π


{\displaystyle \pi }

.

If you had a circle and a square where the length of a side of the square
was the same as the diameter of the circle, the ratio of the area of the circle
to the area of the square would be 



π

/

4


{\displaystyle \pi /4}

.

So, if you put this circle inside the square and select many random points
inside the square, the number of points inside the circle
divided by the number of points inside the square and the circle
would be approximately 



π

/

4


{\displaystyle \pi /4}

.



Task

Write a function to run a simulation like this, with a variable number of random points to select.

Also, show the results of a few different sample sizes.

For software where the number 



π


{\displaystyle \pi }

 is not built-in,
we give 



π


{\displaystyle \pi }

 as a number of digits:

            3.141592653589793238462643383280


",Python,"import random
import math

def MonteCarloPi(n):
    inside = 0
    r = random.Random()

    for i in range(n):
        if math.pow(r.random(), 2) + math.pow(r.random(), 2) <= 1:
            inside += 1

    return 4.0 * inside / n

value = 1000
for n in range(5):
    value *= 10
    print(""{0}:{1}"".format(str(value).rjust(11,''), MonteCarloPi(value)))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Keyboard_input/Keypress_check,Keyboard input/Keypress check,"

Determine if a key has been pressed and store this in a variable.

If no key has been pressed, the program should continue without waiting.



",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, unicode_literals, print_function
 
import tty, termios
import sys
if sys.version_info.major < 3:
    import thread as _thread
else:
    import _thread
import time
 
 
try:
    from msvcrt import getch  # try to import Windows version
except ImportError:
    def getch():   # define non-Windows version
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
 
def keypress():
    global char
    char = getch()
 
def main():
    global char
    char = None
    _thread.start_new_thread(keypress, ())
 
    while True:
        if char is not None:
            try:
                print(""Key pressed is "" + char.decode('utf-8'))
            except UnicodeDecodeError:
                print(""character can not be decoded, sorry!"")
                char = None
            _thread.start_new_thread(keypress, ())
            if char == 'q' or char == '\x1b':  # x1b is ESC
                exit()
            char = None
        print(""Program is running"")
        time.sleep(1)
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Java
http://rosettacode.org/wiki/File_extension_is_in_extensions_list,File extension is in extensions list,"File extension is in extensions list

You are encouraged to solve this task according to the task description, using any language you may know.
Filename extensions are a rudimentary but commonly used way of identifying files types.



Task

Given an arbitrary filename and a list of extensions, tell whether the filename has one of those extensions.



Notes:

 The check should be case insensitive.
 The extension must occur at the very end of the filename, and be immediately preceded by a dot (.).
 You may assume that none of the given extensions are the empty string, and none of them contain a dot. Other than that they may be arbitrary strings.


Extra credit:
 Allow extensions to contain dots. This way, users of your function/program have full control over what they consider as the extension in cases like:
  archive.tar.gz

 Please state clearly whether or not your solution does this.
Test cases
The following test cases all assume this list of extensions:   zip, rar, 7z, gz, archive, A##



 Filename

 Result


 MyData.a## 
 true


 MyData.tar.Gz 
 true


 MyData.gzip 
 false


 MyData.7z.backup 
 false


 MyData... 
 false


 MyData 
 false

If your solution does the extra credit requirement, add tar.bz2 to the list of extensions, and check the following additional test cases:



 Filename

 Result


 MyData_v1.0.tar.bz2 
 true


 MyData_v1.0.bz2 
 false

Motivation
Checking if a file is in a certain category of file formats with known extensions (e.g. archive files, or image files) is a common problem in practice, and may be approached differently from extracting and outputting an arbitrary extension (see e.g. FileNameExtensionFilter in Java).

It also requires less assumptions about the format of an extension, because the calling code can decide what extensions are valid.

For these reasons, this task exists in addition to the Extract file extension task.



Related tasks
 
 Extract file extension
 String matching

",Python,"def isExt(fileName, extensions):
  return True in map(fileName.lower().endswith, (""."" + e.lower() for e in extensions))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Sieve_of_Eratosthenes,Sieve of Eratosthenes,"This task has been clarified. Its programming examples are in need of review to ensure that they still fit the requirements of the task.


The Sieve of Eratosthenes is a simple algorithm that finds the prime numbers up to a given integer.



Task

Implement the   Sieve of Eratosthenes   algorithm, with the only allowed optimization that the outer loop can stop at the square root of the limit, and the inner loop may start at the square of the prime just found.

That means especially that you shouldn't optimize by using pre-computed wheels, i.e. don't assume you need only to cross out odd numbers (wheel based on 2), numbers equal to 1 or 5 modulo 6 (wheel based on 2 and 3), or similar wheels based on low primes.

If there's an easy way to add such a wheel based optimization, implement it as an alternative version.



Note

 It is important that the sieve algorithm be the actual algorithm used to find prime numbers for the task.


Related tasks

   Emirp primes
   count in factors
   prime decomposition
   factors of an integer
   extensible prime generator
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def eratosthenes2(n):
    multiples = set()
    for i in range(2, n+1):
        if i not in multiples:
            yield i
            multiples.update(range(i*i, n+1, i))
 
print(list(eratosthenes2(100)))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Aliquot_sequence_classifications,Aliquot sequence classifications,"An aliquot sequence of a positive integer K is defined recursively as the first member
being K and subsequent members being the sum of the Proper divisors of the previous term.

 If the terms eventually reach 0 then the series for K is said to terminate.

There are several classifications for non termination:
 If the second term is K then all future terms are also K and so the sequence repeats from the first term with period 1 and K is called perfect.
 If the third term would be repeating K then the sequence repeats with period 2 and K is called amicable.
 If the Nth term would be repeating K for the first time, with N > 3 then the sequence repeats with period N - 1 and K is called sociable.

Perfect, amicable and sociable numbers eventually repeat the original number K; there are other repetitions...
 Some K have a sequence that eventually forms a periodic repetition of period 1 but of a number other than K, for example 95 which forms the sequence 95, 25, 6, 6, 6, ... such K are called aspiring.
 K that have a sequence that eventually forms a periodic repetition of period >= 2 but of a number other than K, for example 562 which forms the sequence 562, 284, 220, 284, 220, ... such K are called cyclic.

And finally:
 Some K form aliquot sequences that are not known to be either terminating or periodic; these K are to be called non-terminating. 
For the purposes of this task, K is to be classed as non-terminating if it has not been otherwise classed after generating 16 terms or if any term of the sequence is greater than 2**47 = 140,737,488,355,328. 


Task

 Create routine(s) to generate the aliquot sequence of a positive integer enough to classify it according to the classifications given above.
 Use it to display the classification and sequences of the numbers one to ten inclusive.
 Use it to show the classification and sequences of the following integers, in order:
 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488, and optionally 15355717786080.
Show all output on this page.



Related tasks

   Abundant, deficient and perfect number classifications. (Classifications from only the first two members of the whole sequence).
   Proper divisors
   Amicable pairs

",Python,"def aliquot(n, maxlen=16, maxterm=2**47):
    if n == 0:
        return ""terminating"", [0]
    s = []
    while len(s) <= maxlen and n < maxterm:
        s.append(n)
        n = sum(proper_divisors(n))
        if n in s:
            if n == s[0]:
                if len(s) == 1:
                    return ""perfect"", s
                elif len(s) == 2:
                    return ""amicable"", s
                else:
                    return ""sociable of length %d"" % len(s), s
            elif n == s[-1]:
                return ""aspiring"", s
            else:
                return ""cyclic back to %d"" % n, s
        elif n == 0:
            return ""terminating"", s + [0]
    return ""non-terminating"", s
 
for n in range(1, 11):
    print(""%20s: %s"" % aliquot(n))
print
for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]:
    print(""%20s: %s"" % aliquot(n))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Speech_synthesis,Speech synthesis,"Render the text       This is an example of speech synthesis      as speech.



Related task

   using a speech engine to highlight words



",Python,"import pyttsx
 
engine = pyttsx.init()
engine.say(""It was all a dream."")
engine.runAndWait()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers,Sort a list of object identifiers,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Object identifiers (OID)


Task

Show how to sort a list of OIDs, in their natural sort order.

Details
 An OID consists of one or more non-negative integers in base 10, separated by dots. It starts and ends with a number.
 Their natural sort order is lexicographical with regard to the dot-separated fields, using numeric comparison between fields.
Test case


 Input (list of strings)

 Output (list of strings)



1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11150.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11150.3.4.0



1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11150.3.4.0
1.3.6.1.4.1.11150.3.4.0.1


Related tasks
 Natural sorting
 Sort using a custom comparator
",Python,"data = [
    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',
    '1.3.6.1.4.1.11.2.17.5.2.0.79',
    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',
    '1.3.6.1.4.1.11150.3.4.0.1',
    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',
    '1.3.6.1.4.1.11150.3.4.0'
]
 
for s in sorted(data, key=lambda x: list(map(int, x.split('.')))):
    print(s)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Discordian_date,Discordian date,"

Task

Convert a given date from the   Gregorian calendar   to the   Discordian calendar.



",Python,"import datetime, calendar
 
DISCORDIAN_SEASONS = [""Chaos"", ""Discord"", ""Confusion"", ""Bureaucracy"", ""The Aftermath""]
 
def ddate(year, month, day):
    today = datetime.date(year, month, day)
    is_leap_year = calendar.isleap(year)
    if is_leap_year and month == 2 and day == 29:
        return ""St. Tib's Day, YOLD "" + (year + 1166)
 
    day_of_year = today.timetuple().tm_yday - 1
 
    if is_leap_year and day_of_year >= 60:
        day_of_year -= 1 # Compensate for St. Tib's Day
 
    season, dday = divmod(day_of_year, 73)
    return ""%s %d, YOLD %d"" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)",Human_written,Python_from_C
http://rosettacode.org/wiki/Huffman_coding,Huffman coding,"Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:


 Create a leaf node for each symbol and add it to the priority queue.
 While there is more than one node in the queue:
 Remove the node of highest priority (lowest probability) twice to get two nodes.
 Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
 Add the new node to the queue.
 The remaining node is the root node and the tree is complete.


Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:



Task

Using the characters and their frequency from the string:

     this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.



",Python,"import heapq
import collections
import itertools
 
class Node(object):
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right
 
class LeafNode(Node):
    def __init__(self, char, weight):
        super(LeafNode, self).__init__()
        self.char = char
        self.weight = weight
 
class InternalNode(Node):
    def __init__(self, left, right):
        super(InternalNode, self).__init__(left, right)
        self.weight = left.weight + right.weight
 
def huffman_encode(s):
    # count character frequency
    freq = collections.Counter(s).items()
    freq = [(weight, LeafNode(char, weight)) for char, weight in freq]
 
    # build Huffman tree
    heapq.heapify(freq)
    while len(freq) > 1:
        lo = heapq.heappop(freq)
        hi = heapq.heappop(freq)
        node = InternalNode(lo[1], hi[1])
        heapq.heappush(freq, (node.weight, node))
 
    # walk the tree and assign codes
    root = freq[0][1]
    codes = {}
    stack = [(root, """")]
    while stack:
        node, code = stack.pop()
        if isinstance(node, LeafNode):
            codes[node.char] = code
        else:
            stack.append((node.left, code + ""0""))
            stack.append((node.right, code + ""1""))
 
    return codes
 
def huffman_decode(encoded, codes):
    # build the reverse code table
    rcodes = {v:k for k, v in codes.items()}
 
    # decode
    it = iter(encoded)
    return """".join(rcodes["""".join(itertools.takewhile(lambda x: x in ""01"", it))]
                   for _ in encoded)
 
if __name__ == ""__main__"":
    s = ""this is an example for huffman encoding""
    codes = huffman_encode(s)
    encoded = """".join(codes[c] for c in s)
    print(encoded)
    print(huffman_decode(encoded, codes))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sum_and_product_of_an_array,Sum and product of an array,"Task

Compute the sum and product of an array of integers.



",Python,"numbers = [1, 2, 3]
total = sum(numbers)
 
product = 1
for i in numbers:
    product *= i",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Problem_of_Apollonius,Problem of Apollonius,"
Task

Implement a solution to the Problem of Apollonius   (description on Wikipedia)   which is the problem of finding the circle that is tangent to three specified circles   (colored black in the diagram below to the right).

There is an   algebraic solution   which is pretty straightforward.



The solutions to the example in the code are shown in the diagram   (below and to the right).

The red circle is ""internally tangent"" to all three black circles,   and the green circle is ""externally tangent"" to all three black circles.



",Python,"from collections import namedtuple
import math
 
Circle = namedtuple('Circle', 'x, y, r')
 
def solveApollonius(c1, c2, c3, s1, s2, s3):
    '''
    >>> solveApollonius((0, 0, 1), (4, 0, 1), (2, 4, 2), 1,1,1)
    Circle(x=2.0, y=2.1, r=3.9)
    >>> solveApollonius((0, 0, 1), (4, 0, 1), (2, 4, 2), -1,-1,-1)
    Circle(x=2.0, y=0.8333333333333333, r=1.1666666666666667) 
    '''
    x1, y1, r1 = c1
    x2, y2, r2 = c2
    x3, y3, r3 = c3
 
    v11 = 2*x2 - 2*x1
    v12 = 2*y2 - 2*y1
    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2
    v14 = 2*s2*r2 - 2*s1*r1
 
    v21 = 2*x3 - 2*x2
    v22 = 2*y3 - 2*y2
    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3
    v24 = 2*s3*r3 - 2*s2*r2
 
    w12 = v12/v11
    w13 = v13/v11
    w14 = v14/v11
 
    w22 = v22/v21-w12
    w23 = v23/v21-w13
    w24 = v24/v21-w14
 
    P = -w23/w22
    Q = w24/w22
    M = -w12*P-w13
    N = w14 - w12*Q
 
    a = N*N + Q*Q - 1
    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1
    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1
 
    # Find a root of a quadratic equation. This requires the circle centers not to be e.g. colinear
    D = b*b-4*a*c
    rs = (-b-math.sqrt(D))/(2*a)
 
    xs = M+N*rs
    ys = P+Q*rs
 
    return Circle(xs, ys, rs)
 
if __name__ == '__main__':
    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)
    print(solveApollonius(c1, c2, c3, 1, 1, 1))    #Expects ""Circle[x=2.00,y=2.10,r=3.90]"" (green circle in image)
    print(solveApollonius(c1, c2, c3, -1, -1, -1)) #Expects ""Circle[x=2.00,y=0.83,r=1.17]"" (red circle in image)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Partial_function_application,Partial function application,"Partial function application   is the ability to take a function of many
parameters and apply arguments to some of the parameters to create a new
function that needs only the application of the remaining arguments to
produce the equivalent of applying all arguments to the original function.

E.g:

 Given values v1, v2
 Given f(param1, param2)
 Then partial(f, param1=v1) returns f'(param2)
 And f(param1=v1, param2=v2) == f'(param2=v2) (for any value v2)


Note that in the partial application of a parameter, (in the above case param1), other parameters are not explicitly mentioned. This is a recurring feature of partial function application.



Task 
 Create a function fs( f, s ) that takes a function, f( n ), of one value and a sequence of values s.
 Function fs should return an ordered sequence of the result of applying function f to every value of s in turn.
 Create function f1 that takes a value and returns it multiplied by 2.
 Create function f2 that takes a value and returns it squared.
 Partially apply f1 to fs to form function fsf1( s )
 Partially apply f2 to fs to form function fsf2( s )
 Test fsf1 and fsf2 by evaluating them with s being the sequence of integers from 0 to 3 inclusive and then the sequence of even integers from 2 to 8 inclusive.


Notes
 In partially applying the functions f1 or f2 to fs, there should be no explicit mention of any other parameters to fs, although introspection of fs within the partial applicator to find its parameters is allowed.
 This task is more about how results are generated rather than just getting results.

",Python,"from typing import Callable, Iterable, List, Tuple
 
def PartiallyApply(function: Callable[[T1, T2], TResult], argument2: T2) -> Callable[[T1], TResult]:
    return lambda argument1: function(argument1, argument2)
 
def Main():
    fs = (Callable[[Iterable[int], Callable[[int], int]], Iterable[int]])(list.map)
    f1 = (Callable[[int], int])(lambda n: n * 2)
    f2 = (Callable[[int], int])(lambda n: n * n)
    fsf1 = PartiallyApply(fs, f1)
    fsf2 = PartiallyApply(fs, f2)
 
    s = [0, 1, 2, 3]
    print("", "".join(map(str, fsf1(s))))
    print("", "".join(map(str, fsf2(s))))
 
    s = [2, 4, 6, 8]
    print("", "".join(map(str, fsf1(s))))
    print("", "".join(map(str, fsf2(s))))
 
if __name__ == ""__main__"":
    Main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Middle_three_digits,Middle three digits,"Task

Write a function/procedure/subroutine that is called with an integer value and returns the middle three digits of the integer if possible or a clear indication of an error if this is not possible.

Note: The order of the middle digits should be preserved.

Your function should be tested with the following values; the first line should return valid answers, those of the second line should return clear indications of an error:

123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345
1, 2, -1, -10, 2002, -2002, 0

Show your output on this page.



",Python,"def middle_three(x):
    s = str(abs(x))
    if len(s) < 3:
        return None
    if len(s) % 2 == 0:
        return None
    return int(s[(len(s) // 2) - 1: (len(s) // 2) + 2])

print(middle_three(12345)) # 234
print(middle_three(1234)) # None
print(middle_three(1234567)) # 345
print(middle_three(123))# 123
print(middle_three(123555)) # None",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Strip_block_comments,Strip block comments,"A block comment begins with a   beginning delimiter   and ends with a   ending delimiter,   including the delimiters.   These delimiters are often multi-character sequences.



Task

Strip block comments from program text (of a programming language much like classic C).

Your demos should at least handle simple, non-nested and multi-line block comment delimiters.

The block comment delimiters are the two-character sequences:

      /*      (beginning delimiter)
      */      (ending delimiter)


Sample text for stripping:

  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */

   /**
    * Another comment.
    */
    function something() {
    }

Extra credit

Ensure that the stripping code is not hard-coded to the particular delimiters described above, but instead allows the caller to specify them.   (If your language supports them,   optional parameters   may be useful for this.)




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def remove_comments(str, comment_start='/*', comment_end='*/'):
    str = str.replace(comment_start, '')
    str = str.replace(comment_end, '')
    return str
 
example = """"""
  /**
   * Some comments
   * longer comments here that we can parse.
   *
   * Rahoo 
   */
   function subroutine() {
    a = /* inline comment */ b + c ;
   }
   /*/ <-- tricky comments */
 
   /**
    * Another comment.
    */
    function something() {
    }
""""""
 
print remove_comments(example)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Julia_set,Julia set,"
Task
Generate and draw a Julia set.




Related tasks
   Mandelbrot Set

",Python,"from PIL import Image
import colorsys
 
w = 800
h = 600
zoom = 1
maxiter = 255
moveX = 0
moveY = 0
cX = -0.7
cY = 0.27015
 
colors = [colorsys.hsv_to_rgb(i / 255.0, 1.0, 1.0) for i in range(256)]
 
bitmap = Image.new(""RGB"", (w, h))
for x in range(w):
    for y in range(h):
        zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX
        zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY
        i = maxiter
        while zx * zx + zy * zy < 4 and i > 1:
            tmp = zx * zx - zy * zy + cX
            zy = 2.0 * zx * zy + cY
            zx = tmp
            i -= 1
        bitmap.putpixel((x, y), (int(colors[i][0] * 255), int(colors[i][1] * 255), int(colors[i][2] * 255)))
bitmap.save(""julia-set.png"")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/String_concatenation,String concatenation,"String concatenation

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a string variable equal to any text value.

Create another string variable whose value is the original variable concatenated with another string literal.

To illustrate the operation, show the content of the variables.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s1 = ""hello""
print s1 + "" world""
 
s2 = s1 + "" world""
print s2",Human_written,Python_from_Go
http://rosettacode.org/wiki/Queue/Usage,Queue/Usage,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
 Illustration of FIFO behavior
Task

Create a queue data structure and demonstrate its operations.

(For implementations of queues, see the FIFO task.)



Operations:

   push       (aka enqueue) - add element
   pop         (aka dequeue) - pop first element
   empty     - return truth value when empty


See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"import Queue
my_queue = Queue.Queue()
my_queue.put(""foo"")
my_queue.put(""bar"")
my_queue.put(""baz"")
print my_queue.get()  # foo
print my_queue.get()  # bar
print my_queue.get()  # baz",Human_written,Python_from_C++
http://rosettacode.org/wiki/Web_scraping,Web scraping,"Task

Create a program that downloads the time from this URL:   http://tycho.usno.navy.mil/cgi-bin/timer.pl   and then prints the current UTC time by extracting just the UTC time from the web page's HTML. Alternatively, if the above url is not working, grab the first date/time off this page's talk page.



If possible, only use libraries that come at no extra monetary cost with the programming language and that are widely available and popular such as CPAN for Perl or Boost for C++.



",Python,"import urllib.request
 
def main():
    resp = urllib.request.urlopen(""http://www.google.com/robots.txt"")
    print(resp.read().decode())
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",Python,"from sys import stdout
 
 
def factors(n):
    rt = []
    f = 2
    if n == 1:
        rt.append(1);
    else:
        while 1:
            if 0 == ( n % f ):
                rt.append(f);
                n //= f
                if n == 1:
                    return rt
            else:
                f += 1
    return rt
 
 
def sum_digits(n):
    sum = 0
    while n > 0:
        m = n % 10
        sum += m
        n -= m
        n //= 10
 
    return sum
 
 
def add_all_digits(lst):
    sum = 0
    for i in range (len(lst)):
        sum += sum_digits(lst[i])
 
    return sum
 
 
def list_smith_numbers(cnt):
    for i in range(4, cnt):
        fac = factors(i)
        if len(fac) > 1:
            if sum_digits(i) == add_all_digits(fac):
                stdout.write(""{0} "".format(i) )
 
# entry point
list_smith_numbers(10_000)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",Python,">>> # Bin(leading 0b or 0B), Oct(leading 0o or 0O), Dec, Hex(leading 0x or 0X), in order:
>>> 0b1011010111 == 0o1327 == 727 == 0x2d7
True
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Parallel_calculations,Parallel calculations,"Many programming languages allow you to specify computations to be run in parallel.
While Concurrent computing is focused on concurrency,
the purpose of this task is to distribute time-consuming calculations
on as many CPUs as possible.

Assume we have a collection of numbers, and want to find the one
with the largest minimal prime factor
(that is, the one that contains relatively large factors).
To speed up the search, the factorization should be done
in parallel using separate threads or processes,
to take advantage of multi-core CPUs.

Show how this can be formulated in your language.
Parallelize the factorization of those numbers,
then search the returned list of numbers and factors
for the largest minimal factor,
and return that number and its prime factors.

For the prime number decomposition
you may use the solution of the Prime decomposition task.
",Python,"import numpy as np
from multiprocessing import Pool
import time

def largest_factor(n):
    for p in range(3, int(np.sqrt(n)) + 1, 2):
        if n % p == 0:
            return p
    return n

def main():
    data = [12757923, 12878611, 12878893, 12757923, 15808973, 15780709, 197622519]
    largest_factor = 0
    largest = 0
    pool = Pool(4)
    for p, n in zip(pool.map(largest_factor, data), data):
        if p > largest_factor:
            largest_factor = p
            largest = n
            print(""found larger: {} of {}"".format(p, n))
        else:
            print(""not larger: {} of {}"".format(p, n))
    print(""Largest factor: {} of {}"".format(largest_factor, largest))

if __name__ == ""__main__"":
    start = time.time()
    main()
    print(""Time taken: {}"".format(time.time() - start))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/A%2BB,A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",Python,"# version 1.0.5-2

import re

r = re.compile(r""-?\d+[ ]+-?\d+"")
while True:
    print(""Enter two integers separated by space(s) or q to quit: "", end="""")
    input = input().strip()
    if input == ""q"" or input == ""Q"":
        break
    if not r.match(input):
        print(""Invalid input, try again"")
        continue
    index = input.rfind(' ')
    a = int(input[:index].strip())
    b = int(input[index + 1:])
    if abs(a) > 1000 or abs(b) > 1000:
        print(""Both numbers must be in the interval [-1000, 1000] - try again"")
    else:
        print(""Their sum is"", a + b)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Set_of_real_numbers,Set of real numbers,"All real numbers form the uncountable set ℝ. Among its subsets, relatively simple are the convex sets, each expressed as a range between two real numbers a and b where a ≤ b. There are actually four cases for the meaning of ""between"", depending on open or closed boundary:

 [a, b]: {x | a ≤ x and x ≤ b }
 (a, b): {x | a < x and x < b }
 [a, b): {x | a ≤ x and x < b }
 (a, b]: {x | a < x and x ≤ b }
Note that if a = b, of the four only [a, a] would be non-empty.

Task

 Devise a way to represent any set of real numbers, for the definition of 'any' in the implementation notes below.
 Provide methods for these common set operations (x is a real number; A and B are sets):
 x ∈ A: determine if x is an element of A
 example: 1 is in [1, 2), while 2, 3, ... are not.
 A ∪ B: union of A and B, i.e. {x | x ∈ A or x ∈ B}
 example: [0, 2) ∪ (1, 3) = [0, 3); [0, 1) ∪ (2, 3] = well, [0, 1) ∪ (2, 3]
 A ∩ B: intersection of A and B, i.e. {x | x ∈ A and x ∈ B}
 example: [0, 2) ∩ (1, 3) = (1, 2); [0, 1) ∩ (2, 3] = empty set
 A - B: difference between A and B, also written as A \ B, i.e. {x | x ∈ A and x ∉ B}
 example: [0, 2) − (1, 3) = [0, 1]
 Test your implementation by checking if numbers 0, 1, and 2 are in any of the following sets:
 (0, 1] ∪ [0, 2)
 [0, 2) ∩ (1, 2]
 [0, 3) − (0, 1)
 [0, 3) − [0, 1]
Implementation notes

 'Any' real set means 'sets that can be expressed as the union of a finite number of convex real sets'. Cantor's set needs not apply.
 Infinities should be handled gracefully; indeterminate numbers (NaN) can be ignored.
 You can use your machine's native real number representation, which is probably IEEE floating point, and assume it's good enough (it usually is).
Optional work

 Create a function to determine if a given set is empty (contains no element).
 Define A = {x | 0 < x < 10 and |sin(π x²)| > 1/2 }, B = {x | 0 < x < 10 and |sin(π x)| > 1/2}, calculate the length of the real axis covered by the set A − B. Note that 
|sin(π x)| > 1/2 is the same as n + 1/6 < x < n + 5/6 for all integers n; your program does not need to derive this by itself.
",Python,"from __future__ import print_function
 
def Union(a, b): return lambda x: a(x) or b(x)
def Inter(a, b): return lambda x: a(x) and b(x)
def Diff(a, b): return lambda x: a(x) and not b(x)
def open(a, b): return lambda x: a < x and x < b
def closed(a, b): return lambda x: a <= x and x <= b
def opCl(a, b): return lambda x: a < x and x <= b
def clOp(a, b): return lambda x: a <= x and x < b
 
s = [None] * 4
s[0] = Union(opCl(0, 1), clOp(0, 2))  # (0,1] ∪ [0,2)
s[1] = Inter(clOp(0, 2), opCl(1, 2))  # [0,2) ∩ (1,2]
s[2] = Diff(clOp(0, 3), open(0, 1))   # [0,3) − (0,1)
s[3] = Diff(clOp(0, 3), closed(0, 1)) # [0,3) − [0,1]
 
for i in range(len(s)):
	for x in range(3):
		print(""%d ∈ s%d: %s"" % (x, i, s[i](x)))
	print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Approximate_equality,Approximate equality,"Sometimes, when testing whether the solution to a task (for example, here on Rosetta Code) is correct, the
difference in floating point calculations between different language implementations becomes significant.

For example, a difference between 32 bit and 64 bit floating point calculations may appear by
about the 8th significant digit in base 10 arithmetic.



Task

Create a function which returns true if two floating point numbers are approximately equal.



The function should allow for differences in the magnitude of numbers, so that, for example,

100000000000000.01   may be approximately equal to   100000000000000.011,

even though   100.01   is not approximately equal to   100.011.

If the language has such a feature in its standard library, this may be used instead of a custom function.

Show the function results with comparisons on the following pairs of values:

     100000000000000.01,   100000000000000.011     (note: should return true)
     100.01,   100.011                                                     (note: should return false)
     10000000000000.001 / 10000.0,   1000000000.0000001000
     0.001,   0.0010000001
     0.000000000000000000000101,   0.0
      sqrt(2) * sqrt(2),    2.0
     -sqrt(2) * sqrt(2),   -2.0
     3.14159265358979323846,   3.14159265358979324


Answers should be true for the first example and false in the second, so that just rounding the numbers to a fixed number of decimals should not be enough. Otherwise answers may vary and still be correct. See the Python code for one type of solution.



",Python,"math.isclose -> bool
    a: double
    b: double
    *
    rel_tol: double = 1e-09
        maximum difference for being considered ""close"", relative to the
        magnitude of the input values
    abs_tol: double = 0.0
        maximum difference for being considered ""close"", regardless of the
        magnitude of the input values
Determine whether two floating point numbers are close in value.
Return True if a is close in value to b, and False otherwise.
For the values to be considered close, the difference between them
must be smaller than at least one of the tolerances.
-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
is, NaN is not close to anything, even itself.  inf and -inf are
only close to themselves.",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Towers_of_Hanoi,Towers of Hanoi,"Task

Solve the   Towers of Hanoi   problem with recursion.



",Python,"def hanoi(ndisks, startPeg=1, endPeg=3):
    if ndisks:
        hanoi(ndisks-1, startPeg, 6-startPeg-endPeg)
        print ""Move disk %d from peg %d to peg %d"" % (ndisks, startPeg, endPeg)
        hanoi(ndisks-1, 6-startPeg-endPeg, endPeg)
 
hanoi(ndisks=4)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Continued_fraction,Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",Python,"from math import pow
 
def calc(f, n):
    temp = 0.0
    for ni in range(n, 0, -1):
        p = f(ni)
        temp = p[1] / (p[0] + temp)
    return f(0)[0] + temp
 
def f1(n):
    return [n > 0 and 2 or 1, 1]
 
def f2(n):
    return [n > 0 and n or 2, n > 1 and n - 1 or 1]
 
def f3(n):
    return [n > 0 and 6 or 3, int(pow(2 * n - 1, 2))]
 
fList = [f1, f2, f3]
 
for f in fList:
    print(calc(f, 200))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Substitution_cipher,Substitution cipher,"Substitution Cipher Implementation - File Encryption/Decryption



Task

Encrypt a input/source file by replacing every upper/lower case alphabets of the source file with another predetermined upper/lower case alphabets or symbols and save it into another output/encrypted file and then again convert that output/encrypted file into original/decrypted file.

This type of Encryption/Decryption scheme is often called a Substitution Cipher.



Related tasks

 Caesar cipher
 Rot-13
 Vigenère Cipher/Cryptanalysis


See also

 Wikipedia: Substitution cipher

",Python,"from string import printable
import random
 
EXAMPLE_KEY = ''.join(sorted(printable, key=lambda _:random.random()))
 
def encode(plaintext, key):
    return ''.join(key[printable.index(char)] for char in plaintext)
 
def decode(plaintext, key):
    return ''.join(printable[key.index(char)] for char in plaintext)
 
original = ""A simple example.""
encoded = encode(original, EXAMPLE_KEY)
decoded = decode(encoded, EXAMPLE_KEY)
print(""""""The original is: {}
Encoding it with the key: {}
Gives: {}
Decoding it by the same key gives: {}"""""".format(
    original, EXAMPLE_KEY, encoded, decoded))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Cholesky_decomposition,Cholesky decomposition,"Every symmetric, positive definite matrix A can be decomposed into a product of a unique lower triangular matrix L and its transpose:





A
=
L

L

T




{\displaystyle A=LL^{T}}






L


{\displaystyle L}

 is called the Cholesky factor of 



A


{\displaystyle A}

, and can be interpreted as a generalized square root of 



A


{\displaystyle A}

, as described in Cholesky decomposition.

In a 3x3 example, we have to solve the following system of equations:









A



=


(




a

11





a

21





a

31







a

21





a

22





a

32







a

31





a

32





a

33





)








=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




l

11





l

21





l

31






0



l

22





l

32






0


0



l

33





)


≡
L

L

T








=


(




l

11


2





l

21



l

11





l

31



l

11







l

21



l

11





l

21


2


+

l

22


2





l

31



l

21


+

l

32



l

22







l

31



l

11





l

31



l

21


+

l

32



l

22





l

31


2


+

l

32


2


+

l

33


2





)








{\displaystyle {\begin{aligned}A&={\begin{pmatrix}a_{11}&a_{21}&a_{31}\\a_{21}&a_{22}&a_{32}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}\\&={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}l_{11}&l_{21}&l_{31}\\0&l_{22}&l_{32}\\0&0&l_{33}\end{pmatrix}}\equiv LL^{T}\\&={\begin{pmatrix}l_{11}^{2}&l_{21}l_{11}&l_{31}l_{11}\\l_{21}l_{11}&l_{21}^{2}+l_{22}^{2}&l_{31}l_{21}+l_{32}l_{22}\\l_{31}l_{11}&l_{31}l_{21}+l_{32}l_{22}&l_{31}^{2}+l_{32}^{2}+l_{33}^{2}\end{pmatrix}}\end{aligned}}}


We can see that for the diagonal elements (




l

k
k




{\displaystyle l_{kk}}

) of 



L


{\displaystyle L}

 there is a calculation pattern:






l

11


=



a

11






{\displaystyle l_{11}={\sqrt {a_{11}}}}







l

22


=



a

22


−

l

21


2






{\displaystyle l_{22}={\sqrt {a_{22}-l_{21}^{2}}}}







l

33


=



a

33


−
(

l

31


2


+

l

32


2


)




{\displaystyle l_{33}={\sqrt {a_{33}-(l_{31}^{2}+l_{32}^{2})}}}


or in general:






l

k
k


=



a

k
k


−

∑

j
=
1


k
−
1



l

k
j


2






{\displaystyle l_{kk}={\sqrt {a_{kk}-\sum _{j=1}^{k-1}l_{kj}^{2}}}}


For the elements below the diagonal (




l

i
k




{\displaystyle l_{ik}}

, where 



i
>
k


{\displaystyle i>k}

) there is also a calculation pattern:






l

21


=


1

l

11





a

21




{\displaystyle l_{21}={\frac {1}{l_{11}}}a_{21}}







l

31


=


1

l

11





a

31




{\displaystyle l_{31}={\frac {1}{l_{11}}}a_{31}}







l

32


=


1

l

22




(

a

32


−

l

31



l

21


)


{\displaystyle l_{32}={\frac {1}{l_{22}}}(a_{32}-l_{31}l_{21})}


which can also be expressed in a general formula:






l

i
k


=


1

l

k
k





(

a

i
k


−

∑

j
=
1


k
−
1



l

i
j



l

k
j


)



{\displaystyle l_{ik}={\frac {1}{l_{kk}}}\left(a_{ik}-\sum _{j=1}^{k-1}l_{ij}l_{kj}\right)}


Task description

The task is to implement a routine which will return a lower Cholesky factor 



L


{\displaystyle L}

 for every given symmetric, positive definite nxn matrix 



A


{\displaystyle A}

. You should then test it on the following two examples and include your output.

Example 1:

25  15  -5                 5   0   0
15  18   0         -->     3   3   0
-5   0  11                -1   1   3

Example 2:

18  22   54   42           4.24264    0.00000    0.00000    0.00000
22  70   86   62   -->     5.18545    6.56591    0.00000    0.00000
54  86  174  134          12.72792    3.04604    1.64974    0.00000
42  62  134  106           9.89949    1.62455    1.84971    1.39262



Note

 The Cholesky decomposition of a Pascal upper-triangle matrix is the Identity matrix of the same size. 
 The Cholesky decomposition of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.",Python,"from __future__ import print_function
 
from pprint import pprint
from math import sqrt
 
 
def cholesky(A):
    L = [[0.0] * len(A) for _ in xrange(len(A))]
    for i in xrange(len(A)):
        for j in xrange(i+1):
            s = sum(L[i][k] * L[j][k] for k in xrange(j))
            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \
                      (1.0 / L[j][j] * (A[i][j] - s))
    return L
 
if __name__ == ""__main__"":
    m1 = [[25, 15, -5],
          [15, 18,  0],
          [-5,  0, 11]]
    pprint(cholesky(m1))
    print()
 
    m2 = [[18, 22,  54,  42],
          [22, 70,  86,  62],
          [54, 86, 174, 134],
          [42, 62, 134, 106]]
    pprint(cholesky(m2), width=120)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Loops/While,Loops/While,"Task

Start an integer value at   1024.

Loop while it is greater than zero.

Print the value (with a newline) and divide it by two each time through the loop.



Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreachbas
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"n = 1024
while n > 0:
    print(n)
    n /= 2",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Vigenère cipher,"Task

Implement a   Vigenère cypher,   both encryption and decryption.

The program should handle keys and text of unequal length,
and should capitalize everything and discard non-alphabetic characters. 

(If your program handles non-alphabetic characters in another way,
make a note of it.)



Related tasks

   Caesar cipher
   Rot-13
   Substitution Cipher

",Python,"# version 1.1.3
 
def vigenere(text, key, encrypt=True):
    t = text.upper() if encrypt else text
    sb = []
    ki = 0
    for c in t:
        if c not in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
            continue
        ci = (c.upper().ord() + key[ki].ord() - 130) % 26 if encrypt else (c.upper().ord() - key[ki].ord() + 26) % 26
        sb.append((ci + 65).chr())
        ki = (ki + 1) % key.length
    return ''.join(sb)
 
key = ""VIGENERECIPHER""
text = ""Beware the Jabberwock, my son! The jaws that bite, the claws that catch!""
encoded = vigenere(text, key)
print(encoded)
decoded = vigenere(encoded, key, False)
print(decoded)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Partition_an_integer_x_into_n_primes,Partition an integer x into n primes,"Task

Partition a positive integer   X   into   N   distinct primes.



Or, to put it in another way:

Find   N   unique primes such that they add up to   X.



Show in the output section the sum   X   and the   N   primes in ascending order separated by plus (+) signs:

     •    partition  99809  with   1 prime.
     •    partition    18   with   2 primes.
     •    partition    19   with   3 primes.
     •    partition    20   with   4 primes.
     •    partition   2017  with  24 primes.
     •    partition  22699  with   1,  2,  3,  and  4  primes.
     •    partition  40355  with   3 primes.

The output could/should be shown in a format such as:

    Partitioned  19  with  3  primes:  3+5+11

   Use any spacing that may be appropriate for the display.
   You need not validate the input(s).
   Use the lowest primes possible;   use  18 = 5+13,   not   18 = 7+11.
   You only need to show one solution.
This task is similar to factoring an integer.



Related tasks

   Count in factors
   Prime decomposition
   Factors of an integer
   Sieve of Eratosthenes
   Primality by trial division
   Factors of a Mersenne number
   Factors of a Mersenne number
   Sequence of primes by trial division

",Python,"from itertools import combinations as cmb
 
 
def isP(n):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    return all(n % x > 0 for x in range(3, int(n ** 0.5) + 1, 2))
 
 
def genP(n):
    p = [2]
    p.extend([x for x in range(3, n + 1, 2) if isP(x)])
    return p
 
 
data = [
    (99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),
    (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]
 
 
for n, cnt in data:
    ci = iter(cmb(genP(n), cnt))
    while True:
        try:
            c = next(ci)
            if sum(c) == n:
                print(' '.join(
                    [repr((n, cnt)), ""->"", '+'.join(str(s) for s in c)]
                ))
                break
        except StopIteration:
            print(repr((n, cnt)) + "" -> Not possible"")
            break",Human_written,Python_from_Go
http://rosettacode.org/wiki/Copy_stdin_to_stdout,Copy stdin to stdout,"Create an executable file that copies stdin to stdout, or else a script that does so through the invocation of an interpreter at the command line.
",Python,-c 'import sys; sys.stdout.write(sys.stdin.read())',Human_written,Python_from_C++
http://rosettacode.org/wiki/Lucky_and_even_lucky_numbers,Lucky and even lucky numbers,"Note that in the following explanation list indices are assumed to start at one.

Definition of lucky numbers
Lucky numbers are positive integers that are formed by:

 Form a list of all the positive odd integers > 0




1
,
3
,
5
,
7
,
9
,
11
,
13
,
15
,
17
,
19
,
21
,
23
,
25
,
27
,
29
,
31
,
33
,
35
,
37
,
39...


{\displaystyle 1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39...}


 Return the first number from the list (which is 1).
 (Loop begins here)
 Note then return the second number from the list (which is 3).
 Discard every third, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
19
,
21
,
25
,
27
,
31
,
33
,
37
,
39
,
43
,
45
,
49
,
51
,
55
,
57...


{\displaystyle 1,3,7,9,13,15,19,21,25,27,31,33,37,39,43,45,49,51,55,57...}


 (Expanding the loop a few more times...)
 Note then return the third number from the list (which is 7).
 Discard every 7th, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
21
,
25
,
27
,
31
,
33
,
37
,
43
,
45
,
49
,
51
,
55
,
57
,
63
,
67...


{\displaystyle 1,3,7,9,13,15,21,25,27,31,33,37,43,45,49,51,55,57,63,67...}


 Note then return the 4th number from the list (which is 9).
 Discard every 9th, (as noted), number from the list to form the new list




1
,
3
,
7
,
9
,
13
,
15
,
21
,
25
,
31
,
33
,
37
,
43
,
45
,
49
,
51
,
55
,
63
,
67
,
69
,
73...


{\displaystyle 1,3,7,9,13,15,21,25,31,33,37,43,45,49,51,55,63,67,69,73...}


 Take the 5th, i.e. 13. Remove every 13th.
 Take the 6th, i.e. 15. Remove every 15th.
 Take the 7th, i.e. 21. Remove every 21th.
 Take the 8th, i.e. 25. Remove every 25th.
 (Rule for the loop)
 Note the 



n


{\displaystyle n}

th, which is 



m


{\displaystyle m}

.
 Remove every 



m


{\displaystyle m}

th.
 Increment 



n


{\displaystyle n}

.
Definition of even lucky numbers
This follows the same rules as the definition of lucky numbers above except for the very first step:

 Form a list of all the positive even integers > 0




2
,
4
,
6
,
8
,
10
,
12
,
14
,
16
,
18
,
20
,
22
,
24
,
26
,
28
,
30
,
32
,
34
,
36
,
38
,
40...


{\displaystyle 2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40...}


 Return the first number from the list (which is 2).
 (Loop begins here)
 Note then return the second number from the list (which is 4).
 Discard every 4th, (as noted), number from the list to form the new list




2
,
4
,
6
,
10
,
12
,
14
,
18
,
20
,
22
,
26
,
28
,
30
,
34
,
36
,
38
,
42
,
44
,
46
,
50
,
52...


{\displaystyle 2,4,6,10,12,14,18,20,22,26,28,30,34,36,38,42,44,46,50,52...}


 (Expanding the loop a few more times...)
 Note then return the third number from the list (which is 6).
 Discard every 6th, (as noted), number from the list to form the new list




2
,
4
,
6
,
10
,
12
,
18
,
20
,
22
,
26
,
28
,
34
,
36
,
38
,
42
,
44
,
50
,
52
,
54
,
58
,
60...


{\displaystyle 2,4,6,10,12,18,20,22,26,28,34,36,38,42,44,50,52,54,58,60...}


 Take the 4th, i.e. 10. Remove every 10th.
 Take the 5th, i.e. 12. Remove every 12th.
 (Rule for the loop)
 Note the 



n


{\displaystyle n}

th, which is 



m


{\displaystyle m}

.
 Remove every 



m


{\displaystyle m}

th.
 Increment 



n


{\displaystyle n}

.
Task requirements
 Write one or two subroutines (functions) to generate lucky numbers and even lucky numbers 
 Write a command-line interface to allow selection of which kind of numbers and which number(s). Since input is from the command line, tests should be made for the common errors:
 missing arguments
 too many arguments
 number (or numbers) aren't legal
 misspelled argument (lucky or evenLucky)
 The command line handling should:
 support mixed case handling of the (non-numeric) arguments
 support printing a particular number
 support printing a range of numbers by their index
 support printing a range of numbers by their values
 The resulting list of numbers should be printed on a single line.

The program should support the arguments:

                             what is displayed  (on a single line)
       argument(s)              (optional verbiage is encouraged)
  ╔═══════════════════╦════════════════════════════════════════════════════╗
  ║  j                ║  Jth       lucky number                            ║
  ║  j  ,      lucky  ║  Jth       lucky number                            ║
  ║  j  ,  evenLucky  ║  Jth  even lucky number                            ║
  ║                   ║                                                    ║
  ║  j  k             ║  Jth  through  Kth (inclusive)       lucky numbers ║
  ║  j  k      lucky  ║  Jth  through  Kth (inclusive)       lucky numbers ║
  ║  j  k  evenLucky  ║  Jth  through  Kth (inclusive)  even lucky numbers ║
  ║                   ║                                                    ║
  ║  j -k             ║  all       lucky numbers in the range  j ──► |k|   ║
  ║  j -k      lucky  ║  all       lucky numbers in the range  j ──► |k|   ║
  ║  j -k  evenLucky  ║  all  even lucky numbers in the range  j ──► |k|   ║
  ╚═══════════════════╩════════════════════════════════════════════════════╝
                           where    |k|    is the absolute value of   k

Demonstrate the program by:

 showing the first twenty lucky numbers
 showing the first twenty even lucky numbers
 showing all lucky numbers between 6,000 and 6,100 (inclusive)
 showing all even lucky numbers in the same range as above
 showing the 10,000th lucky number (extra credit)
 showing the 10,000th even lucky number (extra credit)
See also

 This task is related to the Sieve of Eratosthenes task.
 OEIS Wiki Lucky numbers.
 Sequence A000959 lucky numbers on The On-Line Encyclopedia of Integer Sequences.
 Sequence A045954 even lucky numbers or ELN on The On-Line Encyclopedia of Integer Sequences.
 Entry lucky numbers on The Eric Weisstein's World of Mathematics.

",Python,"from __future__ import print_function
 
def lgen(even=False, nmax=1000000):
    start = 2 if even else 1
    n, lst = 1, list(range(start, nmax + 1, 2))
    lenlst = len(lst)
    yield lst[0]
    while n < lenlst and lst[n] < lenlst:
        yield lst[n]
        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]
        lenlst = len(lst)
    # drain
    for i in lst[n:]:
        yield i",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Largest_int_from_concatenated_ints,Largest int from concatenated ints,"Task
 
Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.

Use the following two sets of integers as tests   and   show your program output here.

   {1, 34, 3, 98, 9, 76, 45, 4}
   {54, 546, 548, 60}


Possible algorithms

 A solution could be found by trying all combinations and return the best. 
 Another way to solve this is to note that in the best arrangement, for any two adjacent original integers X and Y, the concatenation X followed by Y will be numerically greater than or equal to the concatenation Y followed by X.
 Yet another way to solve this is to pad the integers to the same size by repeating the digits then sort using these repeated integers as a sort key.


See also

   Algorithms: What is the most efficient way to arrange the given numbers to form the biggest number?
   Constructing the largest number possible by rearranging a list

",Python,"try:
    cmp     # Python 2 OK or NameError in Python 3
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              cmp=lambda x,y:cmp(y+x, x+y)))
except NameError:
    # Python 3
    from functools import cmp_to_key
    def cmp(x, y):
        return -1 if x<y else ( 0 if x==y else 1)
    def maxnum(x):
        return ''.join(sorted((str(n) for n in x),
                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y))))
 
for numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:
    print('Numbers: %r\n  Largest integer: %15s' % (numbers, maxnum(numbers)))",Human_written,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting algorithms/Shell sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort.

The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.

Shell sort is a sequence of interleaved insertion sorts based on an increment sequence.
The increment size is reduced after each pass until the increment size is 1.

With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"".

Any sequence will sort the data as long as it ends in 1, but some work better than others.

Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]

Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.



",Python,"def shell(seq):
    inc = len(seq) // 2
    while inc:
        for i, el in enumerate(seq[inc:], inc):
            while i >= inc and seq[i - inc] > el:
                seq[i] = seq[i - inc]
                i -= inc
            seq[i] = el
        inc = 1 if inc == 2 else inc * 5 // 11",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Run-length_encoding,Run-length encoding,"Run-length encoding

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Given a string containing uppercase characters (A-Z), compress repeated 'runs' of the same character by storing the length of that run, and provide a function to reverse the compression.

The output can be anything, as long as you can recreate the input with it.



Example

 Input: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
 Output: 12W1B12W3B24W1B14W


Note: the encoding step in the above example is the same as a step of the Look-and-say sequence.



",Python,"def run_length_encoding(text, prev=""""):
    if not text:
        return prev
    initial_char = text[0]
    count = 0
    for i in range(len(text)):
        if text[i] == initial_char:
            count += 1
        else:
            break
    return run_length_encoding(text[count:], prev + str(count) + initial_char)

assert run_length_encoding(""TTESSST"") == ""2T1E3S1T""
assert run_length_encoding(""WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW"") == ""12W1B12W3B24W1B14W""",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Python,"import random
def s_of_n_creator(n):
    sample = []
    i = 0
    def s_of_n(item):
        nonlocal i
        i += 1
        if i <= n:
            sample.append(item)
        elif random.random() < n/i:
            sample[random.randint(0,n-1)] = item
        return sample
    return s_of_n
 
frequency = [0]*10
for i in range(100000):
    s_of_n = s_of_n_creator(3)
    sample = None
    for digit in range(10):
        sample = s_of_n(digit)
    for digit in sample:
        frequency[digit] += 1
 
for digit in range(10):
    print(f""{digit}\t{frequency[digit]}"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Digital_root,Digital root,"The digital root, 



X


{\displaystyle X}

, of a number, 



n


{\displaystyle n}

, is calculated:

 find 



X


{\displaystyle X}

 as the sum of the digits of 



n


{\displaystyle n}


 find a new 



X


{\displaystyle X}

 by summing the digits of 



X


{\displaystyle X}

, repeating until 



X


{\displaystyle X}

 has only one digit.
The additive persistence is the number of summations required to obtain the single digit.

The task is to calculate the additive persistence and the digital root of a number, e.g.:





627615


{\displaystyle 627615}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;




39390


{\displaystyle 39390}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



6


{\displaystyle 6}

;




588225


{\displaystyle 588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



3


{\displaystyle 3}

;




393900588225


{\displaystyle 393900588225}

 has additive persistence 



2


{\displaystyle 2}

 and digital root of 



9


{\displaystyle 9}

;
The digital root may be calculated in bases other than 10.



See

 Casting out nines for this wiki's use of this procedure.
 Digital root/Multiplicative digital root
 Sum digits of an integer
 Digital root sequence on OEIS
 Additive persistence sequence on OEIS
 Iterated digits squaring

",Python,"def digital_root (n):
    ap = 0
    n = abs(int(n))
    while n >= 10:
        n = sum(int(digit) for digit in str(n))
        ap += 1
    return ap, n
 
if __name__ == '__main__':
    for n in [627615, 39390, 588225, 393900588225, 55]:
        persistance, root = digital_root(n)
        print(""%12i has additive persistance %2i and digital root %i."" 
              % (n, persistance, root))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file,Append a record to the end of a text file,"Many systems offer the ability to open a file for writing, such that any data written will be appended to the end of the file. Further, the file operations will always adjust the position pointer to guarantee the end of the file, even in a multitasking environment.

This feature is most useful in the case of log files, where many jobs may be appending to the log file at the same time, or where care must be taken to avoid concurrently overwriting the same record from another job.



Task

Given a two record sample for a mythical ""passwd"" file:

 Write these records out in the typical system format.
 Ideally these records will have named fields of various types.
 Close the file, then reopen the file for append.
 Append a new record to the file and close the file again.
 Take appropriate care to avoid concurrently overwrites from another job.
 Open the file and demonstrate the new record has indeed written to the end.

 Source record field types and contents.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


jsmith
x
1001
1000
Joe Smith,Room 1007,(234)555-8917,(234)555-0077,jsmith@rosettacode.org
/home/jsmith
/bin/bash


jdoe
x
1002
1000
Jane Doe,Room 1004,(234)555-8914,(234)555-0044,jdoe@rosettacode.org
/home/jdoe
/bin/bash


 Record to be appended.


account
password
UID
GID
fullname,office,extension,homephone,email
directory
shell


string
string
int
int
struct(string,string,string,string,string)
string
string


xyz
x
1003
1000
X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org
/home/xyz
/bin/bash

Resulting file format: should mimic Linux's /etc/passwd file format with particular attention to the "","" separator used in the GECOS field. But if the specific language has a particular or unique format of storing records in text file, then this format should be named and demonstrated with an additional example.

Expected output:

Appended record: xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,xyz@rosettacode.org:/home/xyz:/bin/bash

Finally: Provide a summary of the language's ""append record"" capabilities in a table. eg.


 Append Capabilities.


 Data Representation

 IO
Library

 Append
Possible

 Automatic
Append

 Multi-tasking
Safe


 In core 
 On disk


 C struct 
 CSV text file 
 glibc/stdio 
 ☑ 
 ☑ 
 ☑ (Not all, eg NFS)

Alternatively: If the language's appends can not guarantee its writes will always append, then note this restriction in the table. If possible, provide an actual code example (possibly using file/record locking) to guarantee correct concurrent appends.



",Python,"import os
import sys
 
class pw:
    def __init__(self, account, password, uid, gid, gecos, directory, shell):
        self.account = account
        self.password = 
        self.uid = uid
        self.gid = gid
        self.gecos = gecos
        self.directory = directory
        self.shell = shell
 
    def encode(self, w):
        return w.write(""%s:%s:%d:%d:%s,%s,%s,%s,%s:%s:%s\n"" % (
            self.account, self.password, self.uid, self.gid,
            self.gecos.fullname, self.gecos.office, self.gecos.extension,
            self.gecos.homephone, self.gecos.email,
            self.directory, self.shell))
 
class gecos:
    def __init__(self, fullname, office, extension, homephone, email):
        self.fullname = fullname
        self.office = office
        self.extension = extension
        self.homephone = homephone
        self.email = email
 
p2 = [
    pw(""jsmith"", ""x"", 1001, 1000, gecos("""", ""Room 1007"",
        ""(234)555-8917"", ""(234)555-0077"", """"),
        ""/home/jsmith"", ""/bin/bash""),
    pw(""jdoe"", ""x"", 1002, 1000, gecos("""", ""Room 1004"",
        ""(234)555-8914"", ""(234)555-0044"", """"),
        ""/home/jsmith"", ""/bin/bash""),
]
 
pa = pw(""xyz"", ""x"", 1003, 1000, gecos(""X Yz"", ""Room 1003"",
    ""(234)555-8913"", ""(234)555-0033"", """"),
    ""/home/xyz"", ""/bin/bash"")
 
expected = ""xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,"" + \
    ""(234)555-0033,:/home/xyz:/bin/bash""
 
pfn = ""mythical""
 
def writeTwo():
    # overwrites any existing file
    f = open(pfn, ""w"")
    for p in p2:
        p.encode(f)
    f.close()
 
def appendOneMore():
    # file must already exist
    f = open(pfn, ""a"")
    pa.encode(f)
    f.close()
 
def checkResult():
    # reads entire file then closes it
    f = open(pfn, ""r"")
    b = f.read()
    f.close()
    if b.split(""\n"")[2] == expected:
        print ""append okay""
    else:
        print ""it didn't work""
 
def main():
    writeTwo()
    appendOneMore()
    checkResult()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Multi-dimensional_array,Multi-dimensional array,"For the purposes of this task, the actual memory layout or access method of this data structure is not mandated.

It is enough to:

 State the number and extent of each index to the array.
 Provide specific, ordered, integer indices for all dimensions of the array together with a new value to update the indexed value.
 Provide specific, ordered, numeric indices for all dimensions of the array to obtain the arrays value at that indexed position.


Task

 State if the language supports multi-dimensional arrays in its syntax and usual implementation.
 State whether the language uses row-major or column major order for multi-dimensional array storage, or any other relevant kind of storage.
 Show how to create a four dimensional array in your language and set, access, set to another value; and access the new value of an integer-indexed item of the array.
 The idiomatic method for the language is preferred.
 The array should allow a range of five, four, three and two (or two three four five if convenient), in each of the indices, in order. (For example, if indexing starts at zero for the first index then a range of 0..4 inclusive would suffice).
 State if memory allocation is optimised for the array - especially if contiguous memory is likely to be allocated.
 If the language has exceptional native multi-dimensional array support such as optional bounds checking, reshaping, or being able to state both the lower and upper bounds of index ranges, then this is the task to mention them.


Show all output here, (but you may judiciously use ellipses to shorten repetitive output text).



",Python,"#include <iostream>
#include <vector>
 
// convienince for printing the contents of a collection
template<typename T>
std::ostream& operator<<(std::ostream& out, const std::vector<T>& c) {
    auto it = c.cbegin();
    auto end = c.cend();
 
    out << '[';
    if (it!= end) {
        out << *it;
        it = std::next(it);
    }
    while (it!= end) {
        out << "", "" << *it;
        it = std::next(it);
    }
    return out << ']';
}
 
def fourDim():
    using namespace std;
 
    # create a 4d jagged array, with bounds checking etc...
    arr = []
    cnt = 0
 
    arr.append([])
    arr[0].append([])
    arr[0][0].append([])
    arr[0][0][0].append(cnt)
    cnt += 1
    arr[0][0][0].append(cnt)
    cnt += 1
    arr[0][0][0].append(cnt)
    cnt += 1
    arr[0][0][0].append(cnt)
    cnt += 1
    arr[0].append([])
    arr[0][1].append([])
    arr[0][1][0].append(cnt)
    cnt += 1
    arr[0][1][0].append(cnt)
    cnt += 1
    arr[0][1][0].append(cnt)
    cnt += 1
    arr[0][1][0].append(cnt)
    cnt += 1
    arr[0][1].append([])
    arr[0][1][1].append(cnt)
    cnt += 1
    arr[0][1][1].append(cnt)
    cnt += 1
    arr[0][1][1].append(cnt)
    cnt += 1
    arr[0][1][1].append(cnt)
    cnt += 1
 
    arr.append([])
    arr[1].append([])
    arr[1][0].append([])
    arr[1][0][0].append(cnt)
    cnt += 1
    arr[1][0][0].append(cnt)
    cnt += 1
    arr[1][0][0].append(cnt)
    cnt += 1
    arr[1][0][0].append(cnt)
    cnt += 1
 
    print(arr)
 
if __name__ == '__main__':
    # C++ does not have native support for multi-dimensional arrays,
    # but classes could be written to make things easier to work with.
    # There are standard library classes which can be used for single dimension arrays.
    # Also raw access is supported through pointers as in C.
 
    fourDim()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/JSON,JSON,"Load a JSON string into a data structure.
Also, create a new data structure and serialize it into JSON.

Use objects and arrays (as appropriate for your language)
and make sure your JSON is valid (https://jsonformatter.org).
",Python,">>> import json
>>> data = json.loads('{ ""foo"": 1, ""bar"": [10, ""apples""] }')
>>> sample = { ""blue"": [1,2], ""ocean"": ""water"" }
>>> json_string = json.dumps(sample)
>>> json_string
'{""blue"": [1, 2], ""ocean"": ""water""}'
>>> sample
{'blue': [1, 2], 'ocean': 'water'}
>>> data
{'foo': 1, 'bar': [10, 'apples']}",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Permutations,Permutations,"Task

Write a program that generates all   permutations   of   n   different objects.   (Practically numerals!)



Related tasks
 
   Find the missing permutation
   Permutations/Derangements



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"import itertools
for values in itertools.permutations([1,2,3]):
    print (values)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Calkin-Wilf_sequence,Calkin-Wilf sequence,"The Calkin-Wilf sequence contains every nonnegative rational number exactly once.

It can be calculated recursively as follows:

       a1   =  1 
       an+1  =  1/(2⌊an⌋+1-an) for n > 1 



Task part 1

 Show on this page terms 1 through 20 of the Calkin-Wilf sequence.

To avoid floating point error, you may want to use a rational number data type.



It is also possible, given a non-negative rational number, to determine where it appears in the sequence without calculating the sequence. The procedure is to get the continued fraction representation of the rational and use it as the run-length encoding of the binary representation of the term number, beginning from the end of the continued fraction.
It only works if the number of terms in the continued fraction is odd- use either of the two equivalent representations to achieve this:

       [a0; a1, a2, ..., an]  =  [a0; a1, a2 ,..., an-1, 1] 



Example

The fraction   9/4   has odd continued fraction representation      2; 3, 1,     giving a binary representation of   100011,

which means   9/4   appears as the   35th   term of the sequence.



Task part 2

 Find the position of the number   83116/51639   in the Calkin-Wilf sequence.


See also

 Wikipedia entry: Calkin-Wilf tree
 Continued fraction
 Continued fraction/Arithmetic/Construct from rational number

",Python,"from fractions import Fraction
from math import floor
from itertools import islice, groupby
 
 
def cw():
    a = Fraction(1)
    while True:
        yield a
        a = 1 / (2 * floor(a) + 1 - a)
 
def r2cf(rational):
    num, den = rational.numerator, rational.denominator
    while den:
        num, (digit, den) = den, divmod(num, den)
        yield digit
 
def get_term_num(rational):
    ans, dig, pwr = 0, 1, 0
    for n in r2cf(rational):
        for _ in range(n):
            ans |= dig << pwr
            pwr += 1
        dig ^= 1
    return ans
 
 
if __name__ == '__main__':
    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))
    x = Fraction(83116, 51639)
    print(f""\n{x} is the {get_term_num(x):_}'th term."")",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",Python,"# version 1.1.2
 
class Angle:
    def __init__(self, d):
        self.value = d
        if d in range(-180, 180):
            self.value = d
        elif d > 180:
            self.value = (d - 180) % 360 - 180
        else:
            self.value = (d + 180) % 360 + 180
 
    def __sub__(self, other):
        return Angle(self.value - other.value)
 
def main():
    anglePairs = [
        (20.0, 45.0),
        (-45.0, 45.0),
        (-85.0, 90.0),
        (-95.0, 90.0),
        (-45.0, 125.0),
        (-45.0, 145.0),
        (29.4803, -88.6381),
        (-78.3251, -159.036),
        (-70099.74233810938, 29840.67437876723),
        (-165313.6666297357, 33693.9894517456),
        (1174.8380510598456, -154146.66490124757),
        (60175.77306795546, 42213.07192354373)
    ]
    print(""       b1            b2           diff"")
    f = ""% 12.4f  % 12.4f  % 12.4f""
    for ap in anglePairs:
        diff = Angle(ap[1]) - Angle(ap[0])
        print(f % (ap[0], ap[1], diff.value))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Quine,Quine,"A quine is a self-referential program that can,
without any external access, output its own source.



A   quine   (named after Willard Van Orman Quine)   is also known as:

   self-reproducing automata   (1972)
   self-replicating program         or   self-replicating computer program
   self-reproducing program      or   self-reproducing computer program
   self-copying program             or   self-copying computer program


It is named after the philosopher and logician
who studied self-reference and quoting in natural language,
as for example in the paradox ""'Yields falsehood when preceded by its quotation' yields falsehood when preceded by its quotation.""

""Source"" has one of two meanings. It can refer to the text-based program source.
For languages in which program source is represented as a data structure, ""source"" may refer to the data structure: quines in these languages fall into two categories: programs which print a textual representation of themselves, or expressions which evaluate to a data structure which is equivalent to that expression.

The usual way to code a quine works similarly to this paradox: The program consists of two identical parts, once as plain code and once quoted in some way (for example, as a character string, or a literal data structure). The plain code then accesses the quoted code and prints it out twice, once unquoted and once with the proper quotation marks added. Often, the plain code and the quoted code have to be nested.



Task

Write a program that outputs its own source code in this way. If the language allows it, you may add a variant that accesses the code directly. You are not allowed to read any external files with the source code. The program should also contain some sort of self-reference, so constant expressions which return their own value which some top-level interpreter will print out. Empty programs producing no output are not allowed.

There are several difficulties that one runs into when writing a quine, mostly dealing with quoting:

 Part of the code usually needs to be stored as a string or structural literal in the language, which needs to be quoted somehow. However, including quotation marks in the string literal itself would be troublesome because it requires them to be escaped, which then necessitates the escaping character (e.g. a backslash) in the string, which itself usually needs to be escaped, and so on.
 Some languages have a function for getting the ""source code representation"" of a string (i.e. adds quotation marks, etc.); in these languages, this can be used to circumvent the quoting problem.
 Another solution is to construct the quote character from its character code, without having to write the quote character itself. Then the character is inserted into the string at the appropriate places. The ASCII code for double-quote is 34, and for single-quote is 39.
 Newlines in the program may have to be reproduced as newlines in the string, which usually requires some kind of escape sequence (e.g. ""\n""). This causes the same problem as above, where the escaping character needs to itself be escaped, etc.
 If the language has a way of getting the ""source code representation"", it usually handles the escaping of characters, so this is not a problem.
 Some languages allow you to have a string literal that spans multiple lines, which embeds the newlines into the string without escaping.
 Write the entire program on one line, for free-form languages (as you can see for some of the solutions here, they run off the edge of the screen), thus removing the need for newlines. However, this may be unacceptable as some languages require a newline at the end of the file; and otherwise it is still generally good style to have a newline at the end of a file. (The task is not clear on whether a newline is required at the end of the file.) Some languages have a print statement that appends a newline; which solves the newline-at-the-end issue; but others do not.

Next to the Quines presented here, many other versions can be found on the Quine page.



Related task

   print itself.

",Python,"w = ""print('w = ' + chr(34) + w + chr(34) + chr(10) + w)""
print('w = ' + chr(34) + w + chr(34) + chr(10) + w)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",Python,"from sys import stdout
 
 
def factors(n):
    rt = []
    f = 2
    if n == 1:
        rt.append(1);
    else:
        while 1:
            if 0 == ( n % f ):
                rt.append(f);
                n //= f
                if n == 1:
                    return rt
            else:
                f += 1
    return rt
 
 
def sum_digits(n):
    sum = 0
    while n > 0:
        m = n % 10
        sum += m
        n -= m
        n //= 10
 
    return sum
 
 
def add_all_digits(lst):
    sum = 0
    for i in range (len(lst)):
        sum += sum_digits(lst[i])
 
    return sum
 
 
def list_smith_numbers(cnt):
    for i in range(4, cnt):
        fac = factors(i)
        if len(fac) > 1:
            if sum_digits(i) == add_all_digits(fac):
                stdout.write(""{0} "".format(i) )
 
# entry point
list_smith_numbers(10_000)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Roman_numerals/Decode,Roman numerals/Decode,"Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately,

starting with the leftmost decimal digit and skipping any 0s   (zeroes).

1990 is rendered as   MCMXC     (1000 = M,   900 = CM,   90 = XC)     and

2008 is rendered as   MMVIII       (2000 = MM,   8 = VIII).

The Roman numeral for 1666,   MDCLXVI,   uses each letter in descending order.



",Python,"import sys

def main():
    # Decode and print the numerals.
    print(""{0}: {1}"".format(""MCMXC"", decode(""MCMXC"")))
    print(""{0}: {1}"".format(""MMVIII"", decode(""MMVIII"")))
    print(""{0}: {1}"".format(""MDCLXVI"", decode(""MDCLXVI"")))

# Dictionary to hold our numerals and their values.
roman_dictionary = {
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000
}

def decode(roman):
    """"""Make the input string upper-case,
    because the dictionary doesn't support lower-case characters.""""""
    roman = roman.upper()

    """"""total = the current total value that will be returned.
    minus = value to subtract from next numeral.""""""
    total = 0
    minus = 0

    for i in range(len(roman)): # Iterate through characters.
        # Get the value for the current numeral. Takes subtraction into account.
        this_numeral = roman_dictionary[roman[i]] - minus

        """"""Checks if this is the last character in the string, or if the current numeral
        is greater than or equal to the next numeral. If so, we will reset our minus
        variable and add the current numeral to the total value. Otherwise, we will
        subtract the current numeral from the next numeral, and continue.""""""
        if i >= len(roman) - 1 or this_numeral + minus >= roman_dictionary[roman[i + 1]]:
            total += this_numeral
            minus = 0
        else:
            minus = this_numeral

    return total # Return the total.

if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file,Bitmap/Write a PPM file,"Using the data storage type defined on this page for raster images, write the image to a PPM file (binary P6 prefered).

(Read the definition of PPM file on Wikipedia.)



",Python,"import struct
 
class RGB(object):
    def __init__(self, r, g, b):
        self.r = r
        self.g = g
        self.b = b
 
class PPM(object):
    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.data = bytearray(3 * height * width)
 
    def buffer_size(self):
        return 3 * self.height * self.width
 
    def get_offset(self, x, y):
        offset = (y * self.width * 3) + (x * 3)
        if offset < self.buffer_size():
            return offset
        else:
            return None
 
    def get_pixel(self, x, y):
        offset = self.get_offset(x, y)
        if offset is not None:
            r = self.data[offset]
            g = self.data[offset + 1]
            b = self.data[offset + 2]
            return RGB(r, g, b)
        else:
            return None
 
    def set_pixel(self, x, y, color):
        offset = self.get_offset(x, y)
        if offset is not None:
            self.data[offset] = color.r
            self.data[offset + 1] = color.g
            self.data[offset + 2] = color.b
            return True
        else:
            return False
 
    def write_file(self, filename):
        with open(filename, 'wb') as f:
            header = 'P6 {} {} 255\n'.format(self.width, self.height)
            f.write(header.encode('ascii'))
            f.write(self.data)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Colour_bars/Display,Colour bars/Display,"Task

Display a series of vertical color bars across the width of the display.

The color bars should either use:

   the system palette,   or 
   the sequence of colors: 
   black
   red
   green
   blue
   magenta
   cyan
   yellow
   white

",Python,"from java.awt import Color
from java.awt import Graphics
from javax.swing import JFrame
 
class ColorFrame(JFrame):
    def __init__(self, width, height):
        super().__init__()
        self.defaultCloseOperation = JFrame.EXIT_ON_CLOSE
        self.setSize(width, height)
        self.setVisible(True)
 
    def paint(self, g):
        colors = [Color.black, Color.red, Color.green, Color.blue,
                  Color.pink, Color.cyan, Color.yellow, Color.white]
        size = len(colors)
        for i in range(size):
            g.color = colors[i]
            g.fillRect(self.width / size * i, 0, self.width / size, self.height)
 
if __name__ == '__main__':
    ColorFrame(400, 400)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Count_the_coins,Count the coins,"There are four types of common coins in   US   currency:

   quarters   (25 cents)
   dimes   (10 cents)
   nickels   (5 cents),   and 
   pennies   (1 cent) 


There are six ways to make change for 15 cents:

   A dime and a nickel 
   A dime and 5 pennies
   3 nickels
   2 nickels and 5 pennies
   A nickel and 10 pennies
   15 pennies


Task

How many ways are there to make change for a dollar using these common coins?     (1 dollar = 100 cents).



Optional

Less common are dollar coins (100 cents);   and very rare are half dollars (50 cents).   With the addition of these two coins, how many ways are there to make change for $1000?

(Note:   the answer is larger than   232).



References

 an algorithm from the book Structure and Interpretation of Computer Programs.
 an article in the algorithmist.
 Change-making problem on Wikipedia.

",Python,"# version 1.0.6
 
def countCoins(c, m, n):
    table = [0] * (n + 1)
    table[0] = 1
    for i in range(0, m):
        for j in range(c[i], n + 1):
            table[j] += table[j - c[i]]
    return table[n]
 
c = [1, 5, 10, 25, 50, 100]
print(countCoins(c, 4, 100))
print(countCoins(c, 6, 1000 * 100))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Pseudo-random_numbers/PCG32,Pseudo-random numbers/PCG32,"Some definitions to help in the explanation

Floor operation

https://en.wikipedia.org/wiki/Floor_and_ceiling_functions

Greatest integer less than or equal to a real number.
Bitwise Logical shift operators (c-inspired)

https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts

Binary bits of value shifted left or right, with zero bits shifted in where appropriate. 
Examples are shown for 8 bit binary numbers; most significant bit to the left.
 << Logical shift left by given number of bits.
E.g Binary 00110101 << 2 == Binary 11010100
 >> Logical shift right by given number of bits.
E.g Binary 00110101 >> 2 == Binary 00001101
^ Bitwise exclusive-or operator
https://en.wikipedia.org/wiki/Exclusive_or
Bitwise comparison for if bits differ
E.g Binary 00110101 ^ Binary 00110011 == Binary 00000110
| Bitwise or operator
https://en.wikipedia.org/wiki/Bitwise_operation#OR
Bitwise comparison gives 1 if any of corresponding bits are 1
E.g Binary 00110101 | Binary 00110011 == Binary 00110111


PCG32 Generator (pseudo-code)

PCG32 has two unsigned 64-bit integers of internal state:

 state: All 2**64 values may be attained.
 sequence: Determines which of 2**63 sequences that state iterates through. (Once set together with state at time of seeding will stay constant for this generators lifetime).
Values of sequence allow 2**63 different sequences of random numbers from the same state.

The algorithm is given 2 U64 inputs called seed_state, and seed_sequence. The algorithm proceeds in accordance with the following pseudocode:-

const N<-U64 6364136223846793005
const inc<-U64 (seed_sequence << 1) | 1
state<-U64 ((inc+seed_state)*N+inc
do forever
  xs<-U32 (((state>>18)^state)>>27)
  rot<-INT (state>>59)
  OUTPUT U32 (xs>>rot)|(xs<<((-rot)&31))
  state<-state*N+inc
end do

Note that this an anamorphism – dual to catamorphism, and encoded in some languages as a general higher-order `unfold` function, dual to `fold` or `reduce`.

Task

 Generate a class/set of functions that generates pseudo-random
numbers using the above.

 Show that the first five integers generated with the seed 42, 54
are: 2707161783 2068313097 3122475824 2211639955 3215226955



 Show that for an initial seed of 987654321, 1 the counts of 100_000 repetitions of
   floor(random_gen.next_float() * 5)

Is as follows:
   0: 20049, 1: 20022, 2: 20115, 3: 19809, 4: 20005

 Show your output here, on this page.

",Python,"import math
 
class PCG32:
    def __init__(self):
        self.N = 6364136223846793005
        self.state = 0x853c49e6748fea9b
        self.inc = 0xda3e39cb94b95bdb
 
    def nextInt(self):
        old = self.state
        self.state = old * self.N + self.inc
        shifted = (old >> 18) ^ old
        shifted = shifted >> 27
        rot = old >> 59
        return (shifted >> rot) | (shifted << ((~rot + 1) & 31))
 
    def nextFloat(self):
        return self.nextInt() / (1 << 32)
 
    def seed(self, seed_state, seed_sequence):
        self.state = 0
        self.inc = (seed_sequence << 1) | 1
        self.nextInt()
        self.state = self.state + seed_state
        self.nextInt()
 
r = PCG32()
 
r.seed(42, 54)
print(r.nextInt())
print(r.nextInt())
print(r.nextInt())
print(r.nextInt())
print(r.nextInt())
print()
 
counts = [0, 0, 0, 0, 0]
r.seed(987654321, 1)
for i in range(100000):
    j = math.floor(r.nextFloat() * 5.0)
    counts[j] += 1
 
print(""The counts for 100,000 repetitions are:"")
for i in range(len(counts)):
    print(""  {} : {}"".format(i, counts[i]))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Sort_disjoint_sublist,Sort disjoint sublist,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, while preserving the values at indices outside the set of those to be sorted.

Make your example work with the following list of values and set of indices:

 Values: [7, 6, 5, 4, 3, 2, 1, 0]
 Indices: {6, 1, 7}
Where the correct result would be:

 [7, 0, 5, 4, 3, 2, 1, 6].
In case of one-based indexing, rather than the zero-based indexing above, you would use the indices {7, 2, 8} instead.

The indices are described as a set rather than a list but any collection-type of those indices without duplication may be used as long as the example is insensitive to the order of indices given.



Cf.
   Order disjoint list items

",Python,">>> def sort_disjoint_sublist(data, indices):
	indices = sorted(indices)
	values  = sorted(data[i] for i in indices)
	for index, value in zip(indices, values):
		data[index] = value
 
 
>>> d = [7, 6, 5, 4, 3, 2, 1, 0]
>>> i = set([6, 1, 7])
>>> sort_disjoint_sublist(d, i)
>>> d
[7, 0, 5, 4, 3, 2, 1, 6]
>>> # Which could be more cryptically written as:
>>> def sort_disjoint_sublist(data, indices):
	for index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value
 
 
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Synchronous_concurrency,Synchronous concurrency,"The goal of this task is to create two concurrent activities (""Threads"" or ""Tasks"", not processes.) that share data synchronously. Your language may provide syntax or libraries to perform concurrency. Different languages provide different implementations of concurrency, often with different names. Some languages use the term threads, others use the term tasks, while others use co-processes. This task should not be implemented using fork, spawn, or the Linux/UNIX/Win32 pipe command, as communication should be between threads, not processes.

One of the concurrent units will read from a file named ""input.txt"" and send the contents of that file, one line at a time, to the other concurrent unit, which will print the line it receives to standard output. The printing unit must count the number of lines it prints. After the concurrent unit reading the file sends its last line to the printing unit, the reading unit will request the number of lines printed by the printing unit. The reading unit will then print the number of lines printed by the printing unit.

This task requires two-way communication between the concurrent units. All concurrent units must cleanly terminate at the end of the program.
",Python,"import queue
import threading
import sys
 
EOT = ""\u0004""  # end of transmission
 
def main():
    queue = queue.Queue()
 
    def work():
        count = 0
 
        while True:
            line = queue.get()
            if line == EOT:
                queue.put(count)
                break
            print(line)
            count += 1
 
    work_thread = threading.Thread(target=work)
    work_thread.start()
 
    for line in sys.stdin:
        queue.put(line.rstrip())
    queue.put(EOT)
    work_thread.join()
 
    count = queue.get()
    print(""\nNumber of lines printed ="", count)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Spiral_matrix,Spiral matrix,"Task

Produce a spiral array.



A   spiral array   is a square arrangement of the first    N2   natural numbers,   where the

numbers increase sequentially as you go around the edges of the array spiraling inwards.



For example, given   5,   produce this array:

 0  1  2  3  4
15 16 17 18  5
14 23 24 19  6
13 22 21 20  7
12 11 10  9  8



Related tasks

   Zig-zag matrix 
   Identity_matrix
   Ulam_spiral_(for_primes)

",Python,"from __future__ import print_function
import math
 
def getSpiralArray(dimension):
	spiralArray = [[0 for x in range(dimension)] for y in range(dimension)]
 
	numConcentricSquares = int(math.ceil(dimension / 2.0))
 
	j = 0
	sideLen = dimension
	currNum = 0
 
	for i in range(numConcentricSquares):
		# do top side
		for j in range(sideLen):
			spiralArray[i][i + j] = currNum
			currNum += 1
 
		# do right side
		for j in range(1, sideLen):
			spiralArray[i + j][dimension - 1 - i] = currNum
			currNum += 1
 
		# do bottom side
		for j in range(sideLen - 2, -1, -1):
			spiralArray[dimension - 1 - i][i + j] = currNum
			currNum += 1
 
		# do left side
		for j in range(sideLen - 2, 0, -1):
			spiralArray[i + j][i] = currNum
			currNum += 1
 
		sideLen -= 2
 
	return spiralArray
 
def printSpiralArray(spiralArray):
	dimension = len(spiralArray)
 
	fieldWidth = int(math.floor(math.log10(dimension * dimension - 1))) + 2
 
	for row in range(dimension):
		for col in range(dimension):
			print(str(spiralArray[row][col]).rjust(fieldWidth), end=' ')
		print()
 
printSpiralArray(getSpiralArray(5))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Abundant_odd_numbers,Abundant odd numbers,"An Abundant number is a number n for which the   sum of divisors   σ(n) > 2n,

or,   equivalently,   the   sum of proper divisors   (or aliquot sum)       s(n) > n.



E.G.

12   is abundant, it has the proper divisors     1,2,3,4 & 6     which sum to   16   ( > 12 or n);

       or alternately,   has the sigma sum of   1,2,3,4,6 & 12   which sum to   28   ( > 24 or 2n).



Abundant numbers are common, though even abundant numbers seem to be much more common than odd abundant numbers.

To make things more interesting, this task is specifically about finding   odd abundant numbers.



Task
Find and display here: at least the first 25 abundant odd numbers and either their proper divisor sum or sigma sum.
Find and display here: the one thousandth abundant odd number and either its proper divisor sum or sigma sum.
Find and display here: the first abundant odd number greater than one billion (109) and either its proper divisor sum or sigma sum.


References

   OEIS:A005231: Odd abundant numbers (odd numbers n whose sum of divisors exceeds 2n)
   American Journal of Mathematics, Vol. 35, No. 4 (Oct., 1913), pp. 413-422 - Finiteness of the Odd Perfect and Primitive Abundant Numbers with n Distinct Prime Factors (LE Dickson)

",Python,"import math
 
def abundantOdd(start, finish, listSize, printOne):
    result = []
    for oddNum in range(start, finish, 2):
        list = []
        for toDivide in range(1, oddNum, 2):
            if oddNum % toDivide == 0:
                list.append(toDivide)
        if sum(list) > oddNum:
            if not printOne:
                print(f""{oddNum} <= {sum(list)}"")
            result.append(oddNum)
        if printOne and len(result) >= listSize:
            print(f""{oddNum} <= {sum(list)}"")
        if len(result) >= listSize:
            break
    return result
 
print(""First 25: "")
print(abundantOdd(1, 100000, 25, False))
 
print(""\n\nThousandth: "")
print(abundantOdd(1, 2500000, 1000, True))
 
print(""\n\nFirst over 1bn:"")
print(abundantOdd(1000000001, 2147483647, 1, False))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Summarize_and_say_sequence,Summarize and say sequence,"There are several ways to generate a self-referential sequence. One very common one (the Look-and-say sequence) is to start with a positive integer, then generate the next term by concatenating enumerated groups of adjacent alike digits:

       0, 10, 1110, 3110, 132110, 1113122110, 311311222110 ...

The terms generated grow in length geometrically and never converge.

Another way to generate a self-referential sequence is to summarize the previous term.

Count how many of each alike digit there is, then concatenate the sum and digit for each of the sorted enumerated digits. Note that the first five terms are the same as for the previous sequence.

       0, 10, 1110, 3110, 132110, 13123110, 23124110 ... 

Sort the digits largest to smallest. Do not include counts of digits that do not appear in the previous term.

Depending on the seed value, series generated this way always either converge to a stable value or to a short cyclical pattern. (For our purposes, I'll use converge to mean an element matches a previously seen element.) The sequence shown, with a seed value of 0, converges to a stable value of 1433223110 after 11 iterations. The seed value that converges most quickly is 22. It goes stable after the first element. (The next element is 22, which has been seen before.)



Task

Find all the positive integer seed values under 1000000, for the above convergent self-referential sequence, that takes the largest number of iterations before converging. Then print out the number of iterations and the sequence they return. Note that different permutations of the digits of the seed will yield the same sequence. For this task, assume leading zeros are not permitted.

Seed Value(s): 9009 9090 9900

Iterations: 21 

Sequence: (same for all three seeds except for first element)
9009
2920
192210
19222110
19323110
1923123110
1923224110
191413323110
191433125110
19151423125110
19251413226110
1916151413325110
1916251423127110
191716151413326110
191726151423128110
19181716151413327110
19182716151423129110
29181716151413328110
19281716151423228110
19281716151413427110
19182716152413228110

Related tasks

   Fours is the number of letters in the ...
   Look-and-say sequence
   Number names
   Self-describing numbers
   Spelling of ordinal numbers



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Also see

   The On-Line Encyclopedia of Integer Sequences.

",Python,"import sys
import time
 
class rec_t:
	def __init__(self):
		self.depth = 0
		self.p = [0] * 10
 
root = rec_t()
 
def find_rec(s):
	r = root
	for c in s:
		i = ord(c) - ord('0')
		if not r.p[i]:
			r.p[i] = rec_t()
		r = r.p[i]
	return r
 
number = [0] * 100
def init():
	for i in range(100):
		number[i] = str(i)
 
def count(buf):
	c = [0] * 10
	for c in buf:
		i = ord(c) - ord('0')
		c[i] += 1
 
	buf = ''
	for i in range(9, -1, -1):
		if not c[i]:
			continue
		s = number[c[i]]
		buf += s[0]
		if len(s) > 1:
			buf += s[1]
		buf += chr(i + ord('0'))
	return buf
 
def depth(in_str, d):
	r = find_rec(in_str)
 
	if r.depth > 0:
		return r.depth
 
	d += 1
	if not r.depth:
		r.depth = -d
	else:
		r.depth += d
 
	in_str = count(in_str)
	d = depth(in_str, d)
 
	if r.depth <= 0:
		r.depth = d + 1
	return r.depth
 
def main():
	best_len = 0
	n_best = 0
	best_ints = [0] * 32
	for i in range(1000000):
		d = depth(str(i), 0)
 
		if d < best_len:
			continue
		if d > best_len:
			n_best = 0
			best_len = d
		if d == best_len:
			best_ints[n_best] = i
			n_best += 1
 
	print ""longest length: %d"" % best_len
	for i in range(n_best):
		print best_ints[i]
		in_str = str(best_ints[i])
		for d in range(best_len + 1):
			r = find_rec(in_str)
			print ""%3d: %s"" % (r.depth, in_str)
			in_str = count(in_str)
		print
 
if __name__ == '__main__':
	init()
	start = time.time()
	main()
	print ""time: %f"" % (time.time() - start)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Exceptions,Exceptions,"Control Structures
These are examples of control structures. You may also be interested in:

 Conditional structures
 Exceptions
 Flow-control structures
 Loops

This task is to give an example of an exception handling routine
and to ""throw"" a new exception.



Related task

   Exceptions Through Nested Calls

",Python,"def main():
	print(""Hello, playground"")
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Temperature_conversion,Temperature conversion,"There are quite a number of temperature scales. For this task we will concentrate on four of the perhaps best-known ones:
Kelvin, Celsius, Fahrenheit, and Rankine.

The Celsius and Kelvin scales have the same magnitude, but different null points.

 0 degrees Celsius corresponds to 273.15 kelvin.
 0 kelvin is absolute zero.
The Fahrenheit and Rankine scales also have the same magnitude, but different null points.

 0 degrees Fahrenheit corresponds to 459.67 degrees Rankine.
 0 degrees Rankine is absolute zero.
The Celsius/Kelvin and Fahrenheit/Rankine scales have a ratio of 5 : 9.



Task
Write code that accepts a value of kelvin, converts it to values of the three other scales, and prints the result.



Example

K  21.00

C  -252.15

F  -421.87

R  37.80


",Python,">>> while True:
    k = float(input('K ? '))
    print(""%g Kelvin = %g Celsius = %g Fahrenheit = %g Rankine degrees.""
          % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))
 
 
K ? 21.0
21 Kelvin = -252.15 Celsius = -421.87 Fahrenheit = 37.8 Rankine degrees.
K ? 222.2
222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.
K ?",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Non-decimal_radices/Input,Non-decimal radices/Input,"It is common to have a string containing a number written in some format, with the most common ones being decimal, hexadecimal, octal and binary. Such strings are found in many places (user interfaces, configuration files, XML data, network protocols, etc.)

This task requires parsing of such a string (which may be assumed to contain nothing else) using the language's built-in facilities if possible. Parsing of decimal strings is required, parsing of other formats is optional but should be shown (i.e., if the language can parse in base-19 then that should be illustrated).

The solutions may assume that the base of the number in the string is known. In particular, if your language has a facility to guess the base of a number by looking at a prefix (e.g. ""0x"" for hexadecimal) or other distinguishing syntax as it parses it, please show that.

The reverse operation is in task Non-decimal radices/Output

For general number base conversion, see Non-decimal radices/Convert.
",Python,"def main():
    print(f""Parse from plain decimal: {float('123.456')}"")
    print(f""Parse with a given radix (2-36 supported): {float.from_bytes(b'deadbeef', 'big')}"")

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",Python,"csvtxt = '''\
Character,Speech
The multitude,The messiah! Show us the messiah!
Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
The multitude,Who are you?
Brians mother,I'm his mother; that's who!
The multitude,Behold his mother! Behold his mother!\
'''
 
from cgi import escape
 
def _row2tr(row, attr=None):
    cols = escape(row).split(',')
    return ('<TR>'
            + ''.join('<TD>%s</TD>' % data for data in cols)
            + '</TR>')
 
def csv2html(txt):
    htmltxt = '<TABLE summary=""csv2html program output"">\n'
    for rownum, row in enumerate(txt.split('\n')):
        htmlrow = _row2tr(row)
        htmlrow = '  <TBODY>%s</TBODY>\n' % htmlrow
        htmltxt += htmlrow
    htmltxt += '</TABLE>\n'
    return htmltxt
 
htmltxt = csv2html(csvtxt)
print(htmltxt)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Jewels_and_stones,Jewels and stones,"Jewels and stones

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a function which takes two string parameters: 'stones' and 'jewels' and returns an integer.

Both strings can contain any number of upper or lower case letters. However, in the case of 'jewels', all letters must be distinct.

The function should count (and return) how many 'stones' are 'jewels' or, in other words, how many letters in 'stones' are also letters in 'jewels'.



Note that:

 Only letters in the ISO basic Latin alphabet i.e. 'A to Z' or 'a to z' need be considered. 
 A lower case letter is considered to be different from its upper case equivalent for this purpose, i.e., 'a' != 'A'.
 The parameters do not need to have exactly the same names.
 Validating the arguments is unnecessary. 
So, for example, if passed ""aAAbbbb"" for 'stones' and ""aA"" for 'jewels', the function should return 3.

This task was inspired by this problem.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def js(stones, jewels):
    n = 0
    for b in stones:
        if b in jewels:
            n += 1
    return n
 
print(js(""aAAbbbb"", ""aA""))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Palindrome_dates,Palindrome dates,"Today   (2020-02-02,   at the time of this writing)   happens to be a palindrome,   without the hyphens,   not only for those countries which express their dates in the   yyyy-mm-dd   format but,   unusually,   also for countries which use the   dd-mm-yyyy   format.



Task
Write a program which calculates and shows the next 15 palindromic dates for those countries which express their dates in the   yyyy-mm-dd   format.



",Python,"'''Palindrome dates'''
 
from datetime import datetime
from itertools import chain
 
 
# palinDay :: Int -> [ISO Date]
def palinDay(y):
    '''A possibly empty list containing the palindromic
       date for the given year, if such a date exists.
    '''
    s = str(y)
    r = s[::-1]
    iso = '-'.join([s, r[0:2], r[2:]])
    try:
        datetime.strptime(iso, '%Y-%m-%d')
        return [iso]
    except ValueError:
        return []
 
 
# --------------------------TEST---------------------------
# main :: IO ()
def main():
    '''Count and samples of palindromic dates [2021..9999]
    '''
    palinDates = list(chain.from_iterable(
        map(palinDay, range(2021, 10000))
    ))
    for x in [
            'Count of palindromic dates [2021..9999]:',
            len(palinDates),
            '\nFirst 15:',
            '\n'.join(palinDates[0:15]),
            '\nLast 15:',
            '\n'.join(palinDates[-15:])
    ]:
        print(x)
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Linear_congruential_generator,Linear congruential generator,"The linear congruential generator is a very simple example of a random number generator.

All linear congruential generators use this formula:

 




r

n
+
1


=
a
×

r

n


+
c


(
mod

m
)



{\displaystyle r_{n+1}=a\times r_{n}+c{\pmod {m}}}




Where:

 




r

0




{\displaystyle r_{0}}

 is a seed.
 




r

1




{\displaystyle r_{1}}

, 




r

2




{\displaystyle r_{2}}

, 




r

3




{\displaystyle r_{3}}

, ..., are the random numbers.
 



a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.


If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m-1}

.

LCG numbers have poor quality. 




r

n




{\displaystyle r_{n}}

 and 




r

n
+
1




{\displaystyle r_{n+1}}

 are not independent, as true random numbers would be. Anyone who knows 




r

n




{\displaystyle r_{n}}

 can predict 




r

n
+
1




{\displaystyle r_{n+1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r

0




{\displaystyle r_{0}}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.

The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.

In these formulas, the seed becomes 



s
t
a
t

e

0




{\displaystyle state_{0}}

. The random sequence is 



r
a
n

d

1




{\displaystyle rand_{1}}

, 



r
a
n

d

2




{\displaystyle rand_{2}}

 and so on.



BSD formula

 



s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e

n


+
12345


(
mod


2

31


)



{\displaystyle state_{n+1}=1103515245\times state_{n}+12345{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n




{\displaystyle rand_{n}=state_{n}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 2147483647.


Microsoft formula

 



s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}=214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.


The BSD formula was so awful that FreeBSD switched to a different formula.

More info is at Random number generator (included)#C.



",Python,"import random
 
def lcg(a, c, m, seed):
    r = seed
    while True:
        r = (a*r + c) % m
        yield r
 
def msg(seed):
    g = lcg(214013, 2531011, 1<<31, seed)
    while True:
        yield next(g) / (1 << 16)
 
def example(seed):
    print(""\nWith seed = %d"" % seed)
    bsd = lcg(1103515245, 12345, 1<<31, seed)
    msf = msg(seed)
    print(""       BSD  Microsoft"")
    for i in range(5):
        print(""%10d    %5d"" % (next(bsd), next(msf)))
 
example(0)
example(1)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Heronian_triangles,Heronian triangles,"Hero's formula for the area of a triangle given the length of its three sides    a,   b,   and   c   is given by:

 



A
=


s
(
s
−
a
)
(
s
−
b
)
(
s
−
c
)


,


{\displaystyle A={\sqrt {s(s-a)(s-b)(s-c)}},}


where   s   is half the perimeter of the triangle; that is,

 



s
=



a
+
b
+
c

2


.


{\displaystyle s={\frac {a+b+c}{2}}.}



Heronian triangles
are triangles whose sides and area are all integers.

 An example is the triangle with sides   3, 4, 5   whose area is   6   (and whose perimeter is   12). 


Note that any triangle whose sides are all an integer multiple of   3, 4, 5;   such as   6, 8, 10,   will also be a Heronian triangle.

Define a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor
of all three sides is   1   (unity).

This will exclude, for example, triangle   6, 8, 10.



Task

 Create a named function/method/procedure/... that implements Hero's formula.
 Use the function to generate all the primitive Heronian triangles with sides <= 200.
 Show the count of how many triangles are found.
 Order the triangles by first increasing area, then by increasing perimeter, then by increasing maximum side lengths
 Show the first ten ordered triangles in a table of sides, perimeter, and area.
 Show a similar ordered table for those triangles with area = 210


Show all output here.

Note: when generating triangles it may help to restrict 



a
<=
b
<=
c


{\displaystyle a<=b<=c}


",Python,"import math
 
class Triangle:
    def __init__(self, a, b, c):
        self.sides = sorted([a, b, c])
        self.perimeter = a + b + c
        s = self.perimeter / 2.0
        self.area = math.sqrt(s * (s - a) * (s - b) * (s - c))
 
    def heronian(self):
        return self.area == int(self.area)
 
    def __lt__(self, other):
        return (self.area, self.perimeter, self.sides) < (other.area, other.perimeter, other.sides)
 
    def __str__(self):
        return ""%-11s%6d%8.1f"" % (str(self.sides[0]) + 'x' + str(self.sides[1]) + 'x' + str(self.sides[2]), self.perimeter, self.area)
 
max, area = 200, 210
prim_triangles = []
for a in range(1, max + 1):
    for b in range(a, max + 1):
        for c in range(b, max + 1):
            if math.gcd(a, math.gcd(b, c)) == 1:
                if Triangle.valid(a, b, c):
                    prim_triangles.append(Triangle(a, b, c))
 
sorted = sorted(filter(Triangle.heronian, prim_triangles))
 
print(""Primitive heronian triangles with sides upto {0}: {1}"".format(max, len(sorted)))
print(""\nsides       perim.   area"")
for i in range(10):
    print(sorted[i])
 
print(""\nTriangles with an area of: {0}"".format(area))
for tr in sorted:
    if tr.area == area:
        print(tr)
 
def valid(a, b, c):
    short, middle, long = sorted([a, b, c])
    return short + middle > long
 
Triangle.valid = staticmethod(valid)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Jacobsthal_numbers,Jacobsthal numbers,"Jacobsthal numbers are an integer sequence related to Fibonacci numbers. Similar to Fibonacci, where each term is the sum of the previous two terms, each term is the sum of the previous, plus twice the one before that. Traditionally the sequence starts with the given terms 0, 1.


   J0 = 0
   J1 = 1
   Jn = Jn-1 + 2 × Jn-2


Terms may be calculated directly using one of several possible formulas:


   Jn = ( 2n - (-1)n ) / 3



Jacobsthal-Lucas numbers are very similar. They have the same recurrence relationship, the only difference is an initial starting value J0 = 2 rather than J0 = 0.

Terms may be calculated directly using one of several possible formulas:

   
   JLn = 2n + (-1)n
   

Jacobsthal oblong numbers is the sequence obtained from multiplying each Jacobsthal number Jn by its direct successor Jn+1.


Jacobsthal primes are Jacobsthal numbers that are prime.



Task
 Find and display the first 30 Jacobsthal numbers
 Find and display the first 30 Jacobsthal-Lucas numbers
 Find and display the first 20 Jacobsthal oblong numbers
 Find and display at least the first 10 Jacobsthal primes


See also
 Wikipedia: Jacobsthal number
 Numbers Aplenty - Jacobsthal number
 OEIS:A001045 - Jacobsthal sequence (or Jacobsthal numbers)
 OEIS:A014551 - Jacobsthal-Lucas numbers.
 OEIS:A084175 - Jacobsthal oblong numbers
 OEIS:A049883 - Primes in the Jacobsthal sequence
 Related task: Fibonacci sequence
 Related task: Leonardo numbers



",Python,"#!/usr/bin/python
from math import floor, pow
 
def isPrime(n):
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False        
    return True
 
def odd(n):
    return n and 1 != 0
 
def jacobsthal(n):
    return floor((pow(2,n)+odd(n))/3)
 
def jacobsthal_lucas(n):
    return int(pow(2,n)+pow(-1,n))
 
def jacobsthal_oblong(n):
    return jacobsthal(n)*jacobsthal(n+1)
 
 
if __name__ == '__main__':
    print(""First 30 Jacobsthal numbers:"")
    for j in range(0, 30):
        print(jacobsthal(j), end=""  "")
 
    print(""\n\nFirst 30 Jacobsthal-Lucas numbers: "")
    for j in range(0, 30):
        print(jacobsthal_lucas(j), end = '\t')
 
    print(""\n\nFirst 20 Jacobsthal oblong numbers: "")
    for j in range(0, 20):
        print(jacobsthal_oblong(j), end=""  "")
 
    print(""\n\nFirst 10 Jacobsthal primes: "")
    for j in range(3, 33):
        if isPrime(jacobsthal(j)):
            print(jacobsthal(j))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division,Sequence of primes by trial division,"Sequence of primes by trial division

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Generate a sequence of primes by means of trial division.



Trial division is an algorithm where a candidate number is tested for being a prime by trying to divide it by other numbers.

You may use primes, or any numbers of your choosing, as long as the result is indeed a sequence of primes.

The sequence may be bounded (i.e. up to some limit), unbounded, starting from the start (i.e. 2) or above some given value.

Organize your function as you wish, in particular, it might resemble a filtering operation, or a sieving operation.

If you want to use a ready-made is_prime function, use one from the Primality by trial division page (i.e., add yours there if it isn't there already).



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Python,"def prime(a):
    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))
 
def primes_below(n):
    return [i for i in range(n) if prime(i)]",Human_written,Python_from_Java
http://rosettacode.org/wiki/Ethiopian_multiplication,Ethiopian multiplication,"Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.


Method:

 Take two numbers to be multiplied and write them down at the top of two columns.
 In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
 In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
 Examine the table produced and discard any row where the value in the left column is even.
 Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.



Task

The task is to define three named functions/methods/procedures/subroutines:

 one to halve an integer,
 one to double an integer, and
 one to state if an integer is even.


Use these functions to create a function that does Ethiopian multiplication.



References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication

",Python,"tutor = True
 
def halve(x):
    return x // 2
 
def double(x):
    return x * 2
 
def even(x):
    return not x % 2
 
def ethiopian(multiplier, multiplicand):
    if tutor:
        print(""Ethiopian multiplication of %i and %i"" %
              (multiplier, multiplicand))
    result = 0
    while multiplier >= 1:
        if even(multiplier):
            if tutor:
                print(""%4i %6i STRUCK"" %
                      (multiplier, multiplicand))
        else:
            if tutor:
                print(""%4i %6i KEPT"" %
                      (multiplier, multiplicand))
            result += multiplicand
        multiplier   = halve(multiplier)
        multiplicand = double(multiplicand)
    if tutor:
        print()
    return result",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Nim_game,Nim game,"Nim game

You are encouraged to solve this task according to the task description, using any language you may know.
Nim is a simple game where the second player ─── if they know the trick ─── will always win.



The game has only 3 rules:

   start with   12   tokens
   each player takes   1,  2,  or  3   tokens in turn
  the player who takes the last token wins.


To win every time,   the second player simply takes 4 minus the number the first player took.   So if the first player takes 1,   the second takes 3 ─── if the first player takes 2,   the second should take 2 ─── and if the first player takes 3,   the second player will take 1.



Task

Design a simple Nim game where the human player goes first, and the computer always wins. The game should enforce the rules.



",Python,"print(""Py Nim\n"")
 
def getTokens(curTokens):
	global tokens
 
	print(""How many tokens would you like to take? "", end='')
	take = int(input())
 
	if (take < 1 or take > 3):
		print(""Number must be between 1 and 3.\n"")
		getTokens(curTokens)
		return
 
	tokens = curTokens - take
	print(f'You take {take} tokens.')
	print(f'{tokens} tokens remaining.\n')
 
def compTurn(curTokens):
	global tokens
 
	take = curTokens % 4
	tokens = curTokens - take
	print (f'Computer takes {take} tokens.')
	print (f'{tokens} tokens remaining.\n')
 
 
tokens = 12
while (tokens > 0):
	getTokens(tokens)
	compTurn(tokens)
 
print(""Computer wins!"")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"import json
 
class Node:
    def __init__(self, name, children):
        self.name = name
        self.children = children
 
tree = Node(""root"", [
    Node(""a"", [
        Node(""d"", None),
        Node(""e"", [
            Node(""f"", None),
        ]),
    ]),
    Node(""b"", None),
    Node(""c"", None),
])
 
print(json.dumps(tree.__dict__, indent=3))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Variable_size/Get,Variable size/Get,"Demonstrate how to get the size of a variable.

See also: Host introspection
",Python,">>> from array import array
>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \u2641'),
	('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]
>>> for typecode, initializer in argslist:
	a = array(typecode, initializer)
	print a, '\tSize =', a.buffer_info()[1] * a.itemsize
	del a
 
 
array('l') 	Size = 0
array('c', 'hello world') 	Size = 11
array('u', u'hello \u2641') 	Size = 14
array('l', [1, 2, 3, 4, 5]) 	Size = 20
array('d', [1.0, 2.0, 3.1400000000000001]) 	Size = 24
>>>",Human_written,Python_from_C#
http://rosettacode.org/wiki/Bitmap/Histogram,Bitmap/Histogram,"Extend the basic bitmap storage defined on this page to support dealing with image histograms. The image histogram contains for each luminance the count of image pixels having this luminance. Choosing a histogram representation take care about the data type used for the counts. It must have range of at least 0..NxM, where N is the image width and M is the image height.

Test task

Histogram is useful for many image processing operations. As an example, use it to convert an image into black and white art. The method works as follows:

 Convert image to grayscale;
 Compute the histogram
 Find the median: defined as the luminance such that the image has an approximately equal number of pixels with lesser and greater luminance.
 Replace each pixel of luminance lesser than the median to black, and others to white.
Use  read/write ppm file, and grayscale image solutions.
",Python,"import numpy as np
from PIL import Image
 
def luminance(rgba):
    r, g, b, _a = rgba
    return 55 * r + 183 * g + 19 * b
 
def get_median(total, histogram):
    sum = 0
    for index, count in enumerate(histogram):
        sum += count
        if sum >= total / 2:
            return index
 
def compute_histogram(img):
    histogram = np.zeros(1 << 16, dtype=np.uint32)
 
    for pixel in img.getdata():
        histogram[luminance(pixel)] += 1
 
    return histogram
 
def black_white(is_white, alpha):
    if is_white:
        return (255, 255, 255, alpha)
    else:
        return (0, 0, 0, alpha)
 
def convert_to_monochrome(img):
    histogram = compute_histogram(img)
 
    width, height = img.size
    pixel_count = width * height
    median = get_median(pixel_count, histogram)
 
    pixel_buffer = []
    for pixel in img.getdata():
        pixel_buffer.append(black_white(luminance(pixel) > median, pixel[3]))
 
    return Image.frombytes(""RGBA"", img.size, bytes(pixel_buffer))
 
if __name__ == ""__main__"":
    img = Image.open(""lena.jpg"")
    img = convert_to_monochrome(img)
    img.save(""lena-mono.png"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Hamming_numbers,Hamming numbers,"Hamming numbers are numbers of the form  

    H = 2i × 3j × 5k
           where 
     i,  j,  k  ≥  0 

Hamming numbers   are also known as   ugly numbers   and also   5-smooth numbers   (numbers whose prime divisors are less or equal to 5).



Task

Generate the sequence of Hamming numbers, in increasing order.   In particular:

 Show the   first twenty   Hamming numbers.
 Show the   1691st   Hamming number (the last one below   231).
 Show the   one millionth   Hamming number (if the language – or a convenient library – supports arbitrary-precision integers).


Related tasks

 Humble numbers
 N-smooth numbers


References

 Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
 Wikipedia entry:   Smooth number
 OEIS entry:   A051037   5-smooth   or   Hamming numbers
 Hamming problem from Dr. Dobb's CodeTalk (dead link as of Sep 2011; parts of the thread here and here).

",Python,"from itertools import islice
 
def hamming2():
    '''\
    This version is based on a snippet from:
        https://web.archive.org/web/20081219014725/http://dobbscodetalk.com:80
                         /index.php?option=com_content&task=view&id=913&Itemid=85
        http://www.drdobbs.com/architecture-and-design/hamming-problem/228700538
        Hamming problem
        Written by Will Ness
        December 07, 2008
 
        When expressed in some imaginary pseudo-C with automatic
        unlimited storage allocation and BIGNUM arithmetics, it can be
        expressed as:
            hamming = h where
              array h;
              n=0; h[0]=1; i=0; j=0; k=0;
              x2=2*h[ i ]; x3=3*h[j]; x5=5*h[k];
              repeat:
                h[++n] = min(x2,x3,x5);
                if (x2==h[n]) { x2=2*h[++i]; }
                if (x3==h[n]) { x3=3*h[++j]; }
                if (x5==h[n]) { x5=5*h[++k]; } 
    '''
    h = 1
    _h=[h]    # memoized
    multipliers  = (2, 3, 5)
    multindeces  = [0 for i in multipliers] # index into _h for multipliers
    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]
    yield h
    while True:
        h = min(multvalues)
        _h.append(h)
        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):
            if v == h:
                i += 1
                multindeces[n] = i
                multvalues[n]  = x * _h[i]
        # cap the memoization
        mini = min(multindeces)
        if mini >= 1000:
            del _h[:mini]
            multindeces = [i - mini for i in multindeces]
        #
        yield h",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import fileinput
 
changerow, changecolumn, changevalue = 2, 4, '""Spam""'
 
with fileinput.input('csv_data_manipulation.csv', inplace=True) as f:
    for line in f:
        if fileinput.filelineno() == changerow:
            fields = line.rstrip().split(',')
            fields[changecolumn-1] = changevalue
            line = ','.join(fields) + '\n'
        print(line, end='')",Human_written,Python_from_C++
http://rosettacode.org/wiki/Metronome,Metronome,"
The task is to implement a   metronome.

The metronome should be capable of producing high and low audio beats, accompanied by a visual beat indicator, and the beat pattern and tempo should be configurable.

For the purpose of this task, it is acceptable to play sound files for production of the beat notes, and an external player may be used.

However, the playing of the sounds should not interfere with the timing of the metronome.

The visual indicator can simply be a blinking red or green area of the screen (depending on whether a high or low beat is being produced), and the metronome can be implemented using a terminal display, or optionally, a graphical display, depending on the language capabilities.

If the language has no facility to output sound, then it is permissible for this to implemented using just the visual indicator.



",Python,"import time
import sys
import os
 
def draw(dir, period, cur, next):
	len = 40 * (next - cur) / period
	if len > 20:
		len = 40 - len
	s = 20 + (dir and len or -len)
	print ""\033[H""
	for i in range(41):
		if i == 20:
			sys.stdout.write(""|"")
		elif i == s:
			sys.stdout.write(""#"")
		else:
			sys.stdout.write(""-"")
 
def beat(delay):
	start = time.time()
	dir = 0
	d = 0
	corr = 0
	slp = 0
	cur = 0
	next = start + delay
	draw_interval = 0.02
	os.system(""clear"")
	while True:
		cur = time.time()
		slp = next - cur - corr
		time.sleep(slp)
		cur = time.time()
		sys.stdout.write(""\a"")
		sys.stdout.flush()
		print ""\033[5;1Hdrift: %d compensate: %d (usec)   "" % (d, corr)
		dir = not dir
		d = cur - next
		corr = (corr + d) / 2
		next += delay
		while cur + d + draw_interval < next:
			time.sleep(draw_interval)
			cur = time.time()
			draw(dir, delay, cur, next)
			sys.stdout.flush()
 
if __name__ == ""__main__"":
	bpm = 60
	if len(sys.argv) > 1:
		bpm = int(sys.argv[1])
	if bpm > 600:
		print ""frequency %d too high"" % bpm
		sys.exit(1)
	beat(60.0 / bpm)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",Python,">>> def maprange( a, b, s):
	(a1, a2), (b1, b2) = a, b
	return  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))
 
>>> for s in range(11):
	print(""%2g maps to %g"" % (s, maprange( (0, 10), (-1, 0), s)))
 
 
 0 maps to -1
 1 maps to -0.9
 2 maps to -0.8
 3 maps to -0.7
 4 maps to -0.6
 5 maps to -0.5
 6 maps to -0.4
 7 maps to -0.3
 8 maps to -0.2
 9 maps to -0.1
10 maps to 0",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Emirp_primes,Emirp primes,"An   emirp   (prime spelled backwards)   are primes that when reversed   (in their decimal representation)   are a different prime.

(This rules out palindromic primes.)



Task

   show the first   twenty   emirps
   show all emirps between   7,700   and   8,000
   show the   10,000th   emirp


In each list, the numbers should be in order.

Invoke the (same) program once per task requirement, this will show what limit is used as the upper bound for calculating surplus (regular) primes.

The specific method of how to determine if a range or if specific values are to be shown will be left to the programmer.



See also

   Wikipedia, Emirp.
   The Prime Pages, emirp.
   Wolfram MathWorld™, Emirp.
   The On‑Line Encyclopedia of Integer Sequences, emirps (A6567).

",Python,"from __future__ import print_function
from prime_decomposition import primes, is_prime
from heapq import *
from itertools import islice
 
def emirp():
    largest = set()
    emirps = []
    heapify(emirps)
    for pr in primes():
        while emirps and pr > emirps[0]:
            yield heappop(emirps)
        if pr in largest:
            yield pr
        else:
            rp = int(str(pr)[::-1])
            if rp > pr and is_prime(rp):
                heappush(emirps, pr)
                largest.add(rp)
 
print('First 20:\n  ', list(islice(emirp(), 20)))
print('Between 7700 and 8000:\n  [', end='')
for pr in emirp():
    if pr >= 8000: break
    if pr >= 7700: print(pr, end=', ')
print(']')
print('10000th:\n  ', list(islice(emirp(), 10000-1, 10000)))",Human_written,Python_from_C
http://rosettacode.org/wiki/Balanced_brackets,Balanced brackets,"Task:

 Generate a string with   N   opening brackets   [   and with   N   closing brackets   ],   in some arbitrary order. 
 Determine whether the generated string is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.


Examples

   (empty)      OK
   []           OK   
   [][]         OK   
   [[][]]       OK 
   ][         NOT OK
   ][][       NOT OK
   []][[]     NOT OK


",Python,">>> def gen(N):
...     txt = ['[', ']'] * N
...     random.shuffle( txt )
...     return ''.join(txt)
... 
>>> def balanced(txt):
...     braced = 0
...     for ch in txt:
...         if ch == '[': braced += 1
...         if ch == ']':
...             braced -= 1
...             if braced < 0: return False
...     return braced == 0
... 
>>> for txt in (gen(N) for N in range(10)):
...     print (""%-22r is%s balanced"" % (txt, '' if balanced(txt) else ' not'))
... 
''                     is balanced
'[]'                   is balanced
'[][]'                 is balanced
'][[[]]'               is not balanced
'[]][[][]'             is not balanced
'[][[][]]]['           is not balanced
'][]][][[]][['         is not balanced
'[[]]]]][]][[[['       is not balanced
'[[[[]][]]][[][]]'     is balanced
'][[][[]]][]]][[[[]'   is not balanced",Human_written,Python_from_Go
http://rosettacode.org/wiki/Roman_numerals/Decode,Roman numerals/Decode,"Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately,

starting with the leftmost decimal digit and skipping any 0s   (zeroes).

1990 is rendered as   MCMXC     (1000 = M,   900 = CM,   90 = XC)     and

2008 is rendered as   MMVIII       (2000 = MM,   8 = VIII).

The Roman numeral for 1666,   MDCLXVI,   uses each letter in descending order.



",Python,"_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))
 
def decode( roman ):
    result = 0
    for r, r1 in zip(roman, roman[1:]):
        rd, rd1 = _rdecode[r], _rdecode[r1]
        result += -rd if rd < rd1 else rd
    return result + _rdecode[roman[-1]]
 
if __name__ == '__main__':
    for r in 'MCMXC MMVIII MDCLXVI'.split():
        print( r, decode(r) )",Human_written,Python_from_C++
http://rosettacode.org/wiki/Address_of_a_variable,Address of a variable,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses




Task

Demonstrate how to get the address of a variable and how to set the address of a variable.



",Python,"i = 5
address_of_i = addressof(i)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/String_interpolation_(included),String interpolation (included),"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Given a string and defined variables or values, string interpolation is the replacement of defined character sequences in the string by values or variable values.

 For example, given an original string of ""Mary had a X lamb."", a value of ""big"", and if the language replaces X in its interpolation routine, then the result of its interpolation would be the string ""Mary had a big lamb"".
(Languages usually include an infrequently used character or sequence of characters to indicate what is to be replaced such as ""%"", or ""#"" rather than ""X"").


Task

 Use your languages inbuilt string interpolation abilities to interpolate a string missing the text ""little"" which is held in a variable, to produce the output string ""Mary had a little lamb"".
 If possible, give links to further documentation on your languages string interpolation features.

Note: The task is not to create a string interpolation routine, but to show a language's built-in capability.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> original = 'Mary had a %s lamb.'
>>> extra = 'little'
>>> original % extra
'Mary had a little lamb.'",Human_written,Python_from_Go
http://rosettacode.org/wiki/Day_of_the_week,Day of the week,"A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).



Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?

Using any standard date handling libraries of your programming language;
compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.



",Python,"import datetime

for i in range(2008,2121):
	cal = datetime.datetime(i,12,25)
	if cal.weekday() == 6:
		print(cal)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Generator/Exponential,Generator/Exponential,"A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.

Generators are often built on top of coroutines or objects so that the internal state of the object is handled “naturally”.

Generators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.



Task

 Create a function that returns a generation of the m'th powers of the positive integers starting from zero, in order, and without obvious or simple upper limit. (Any upper limit to the generator should not be stated in the source but should be down to factors such as the languages natural integer size limit or computational time/size).
 Use it to create a generator of:
   Squares.
   Cubes. 
 Create a new generator that filters all cubes from the generator of squares.
 Drop the first 20 values from this last generator of filtered results, and then show the next 10 values.


Note that this task requires the use of generators in the calculation of the result.



Also see

 Generator

",Python,"from itertools import count, islice
from operator import eq, gt, lt
from typing import Iterator, Tuple
 
def powers(m: int) -> Iterator[int]:
    return map(lambda x: x ** m, count())
 
def noncubic_squares() -> Iterator[int]:
    return NoncubicSquares(powers(2), powers(3))
 
class NoncubicSquares:
    def __init__(self, squares: Iterator[int], cubes: Iterator[int]):
        self.squares = map(lambda x: x ** 2, count())
        self.cubes = map(lambda x: x ** 3, count())
 
    def __iter__(self) -> Iterator[int]:
        return self
 
    def __next__(self) -> int:
        while True:
            if eq(next(self.squares), next(self.cubes)):
                next(self.squares)
            elif gt(next(self.squares), next(self.cubes)):
                next(self.cubes)
            else:
                return next(self.squares)
 
print(list(islice(noncubic_squares(), 20, 30)))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",Python,"$ python -c 'print ""Hello""'
Hello",Human_written,Python_from_Go
http://rosettacode.org/wiki/100_doors,100 doors,"There are 100 doors in a row that are all initially closed.

You make 100 passes by the doors.

The first time through, visit every door and  toggle  the door  (if the door is closed,  open it;   if it is open,  close it).

The second time, only visit every 2nd door   (door #2, #4, #6, ...),   and toggle it.

The third time, visit every 3rd door   (door #3, #6, #9, ...), etc,   until you only visit the 100th door.



Task

Answer the question:   what state are the doors in after the last pass?   Which are open, which are closed?


Alternate:
As noted in this page's   discussion page,   the only doors that remain open are those whose numbers are perfect squares.

Opening only those doors is an   optimization   that may also be expressed;
however, as should be obvious, this defeats the intent of comparing implementations across programming languages.



",Python,"doors = [False] * 101

for i in range(1, len(doors)):
    for j in range(i, len(doors), i):
        doors[j] = not doors[j]

for i in range(1, len(doors)):
    if doors[i]:
        print(""Door "", i, "" is open."")",Ai_generated,Python_from_Java
"http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications","Abundant, deficient and perfect number classifications","These define three classifications of positive integers based on their   proper divisors.

Let   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.

   if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
   if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
   if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).



Example

6   has proper divisors of   1,   2,   and   3.

1 + 2 + 3 = 6,   so   6   is classed as a perfect number.



Task

Calculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.

Show the results here.



Related tasks

   Aliquot sequence classifications.   (The whole series from which this task is a subset.)
   Proper divisors
   Amicable pairs

",Python,"dpa = [1,0,0]
for n in range(2,20001):
    ds = 0
    for d in range(1,n//2+1):
        if n%d == 0:
            ds += d
    if ds < n:
        dpa[0] += 1
    elif ds == n:
        dpa[1] += 1
    else:
        dpa[2] += 1
print('Deficient:',dpa[0], ', Perfect:',dpa[1], ', Abundant:',dpa[2])",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Walk_a_directory/Non-recursively,Walk a directory/Non-recursively,"Task

Walk a given directory and print the names of files matching a given pattern.

(How is ""pattern"" defined? substring match? DOS pattern? BASH pattern? ZSH pattern? Perl regular expression?)


Note: This task is for non-recursive methods.   These tasks should read a single directory, not an entire directory tree.

Note: Please be careful when running any code presented here.



Related task

   Walk Directory Tree   (read entire directory tree). 

",Python,"import glob
for filename in glob.glob('/foo/bar/*.mp3'):
    print(filename)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Knuth%27s_algorithm_S,Knuth's algorithm S,"This is a method of randomly sampling n items from a set of M items, with equal probability; where M >= n and M, the number of items is unknown until the end.
This means that the equal probability sampling should be maintained for all successive items > n as they become available (although the content of successive samples can change).



The algorithm

 Select the first n items as the sample as they become available;
 For the i-th item where i > n, have a random chance of n/i of keeping it. If failing this chance, the sample remains the same. If not, have it randomly (1/n) replace one of the previously selected n items of the sample.
 Repeat   2nd step   for any subsequent items.


The Task

 Create a function s_of_n_creator that given 



n


{\displaystyle n}

 the maximum sample size, returns a function s_of_n that takes one parameter, item.
 Function s_of_n when called with successive items returns an equi-weighted random sample of up to n of its items so far, each time it is called, calculated using Knuths Algorithm S.
 Test your functions by printing and showing the frequency of occurrences of the selected digits from 100,000 repetitions of:
 Use the s_of_n_creator with n == 3 to generate an s_of_n.
 call s_of_n with each of the digits 0 to 9 in order, keeping the returned three digits of its random sampling from its last call with argument item=9.


Note: A class taking n and generating a callable instance/function might also be used.



Reference

 The Art of Computer Programming, Vol 2, 3.4.2 p.142


Related tasks
 
 One of n lines in a file 
 Accumulator factory

",Python,"from random import randrange
 
def s_of_n_creator(n):
    sample, i = [], 0
    def s_of_n(item):
        nonlocal i
 
        i += 1
        if i <= n:
            # Keep first n items
            sample.append(item)
        elif randrange(i) < n:
            # Keep item
            sample[randrange(n)] = item
        return sample
    return s_of_n
 
if __name__ == '__main__':
    bin = [0]* 10
    items = range(10)
    print(""Single run samples for n = 3:"")
    s_of_n = s_of_n_creator(3)
    for item in items:
        sample = s_of_n(item)
        print(""  Item: %i -> sample: %s"" % (item, sample))
    #
    for trial in range(100000):
        s_of_n = s_of_n_creator(3)
        for item in items:
            sample = s_of_n(item)
        for s in sample:
            bin[s] += 1
    print(""\nTest item frequencies for 100000 runs:\n "",
          '\n  '.join(""%i:%i"" % x for x in enumerate(bin)))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",Python,"def bubble_sort(seq):
    """"""Inefficiently sort the mutable sequence (list) in place.
       seq MUST BE A MUTABLE SEQUENCE.
 
       As with list.sort() and random.shuffle this does NOT return 
    """"""
    changed = True
    while changed:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i]
                changed = True
    return seq
 
if __name__ == ""__main__"":
   """"""Sample usage and simple test suite""""""
 
   from random import shuffle
 
   testset = [_ for _ in range(100)]
   testcase = testset.copy() # make a copy
   shuffle(testcase)
   assert testcase != testset  # we've shuffled it
   bubble_sort(testcase)
   assert testcase == testset  # we've unshuffled it back into a copy",Human_written,Python_from_C#
http://rosettacode.org/wiki/Pell%27s_equation,Pell's equation,"Pell's equation   (also called the Pell–Fermat equation)   is a   Diophantine equation   of the form:

   x2   -   ny2   =   1  
with integer solutions for   x   and   y,   where   n   is a given non-square positive integer.



Task requirements

   find the smallest solution in positive integers to Pell's equation for   n = {61, 109, 181, 277}.


See also

   Wikipedia entry: Pell's equation.

",Python,"from math import sqrt
 
def solvePell(n):
    x = int(sqrt(n))
    y = x
    z = 1
    r = 2*x
    e1 = 1
    e2 = 0
    f1 = 0
    f2 = 1
    while True:
        t = r*z
        y = t - y
        t = y*y
        t = n - t
        z = t // z
        t = x + y
        r = t // z
        u = e1
        e1 = e2
        e2 = r*e2 + u
        u = f1
        f1 = f2
        f2 = r*f2 + u
        t = x*f2
        a = e2 + t
        b = f2
        t = a*a
        u = n*b*b
        t = t - u
        if t == 1:
            return a, b
 
ns = [61, 109, 181, 277]
for n in ns:
    x, y = solvePell(n)
    print(""x^2 - %3d*y^2 = 1 for x = %-21s and y = %s"" % (n, x, y))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",Python,"i = 0
u = 0
for i, u in enumerate(""voilà""):
    print(i, u)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Stern-Brocot_sequence,Stern-Brocot sequence,"For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the Fibonacci sequence.

 The first and second members of the sequence are both 1:
     1, 1
 Start by considering the second member of the sequence
 Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the sequence:
     1, 1, 2
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1
 Consider the next member of the series, (the third member i.e. 2)
 GOTO 3
 
         ─── Expanding another loop we get: ───

 Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the sequence:
     1, 1, 2, 1, 3
 Append the considered member of the sequence to the end of the sequence:
     1, 1, 2, 1, 3, 2
 Consider the next member of the series, (the fourth member i.e. 1)


The task is to

 Create a function/method/subroutine/procedure/... to generate the Stern-Brocot sequence of integers using the method outlined above.
 Show the first fifteen members of the sequence. (This should be: 1, 1, 2, 1, 3, 2, 3, 1, 4, 3, 5, 2, 5, 3, 4)
 Show the (1-based) index of where the numbers 1-to-10 first appears in the sequence.
 Show the (1-based) index of where the number 100 first appears in the sequence.
 Check that the greatest common divisor of all the two consecutive members of the series up to the 1000th member, is always one.

Show your output on this page.



Related tasks

   Fusc sequence.
   Continued fraction/Arithmetic


Ref

 Infinite Fractions - Numberphile (Video).
 Trees, Teeth, and Time: The mathematics of clock making. 
 A002487 The On-Line Encyclopedia of Integer Sequences.

",Python,"def stern_brocot(predicate=lambda series: len(series) < 20):
    """"""\
    Generates members of the stern-brocot series, in order, returning them when the predicate becomes false
 
    >>> print('The first 10 values:',
              stern_brocot(lambda series: len(series) < 10)[:10])
    The first 10 values: [1, 1, 2, 1, 3, 2, 3, 1, 4, 3]
    >>>
    """"""
 
    sb, i = [1, 1], 0
    while predicate(sb):
        sb += [sum(sb[i:i + 2]), sb[i + 1]]
        i += 1
    return sb
 
 
if __name__ == '__main__':
    from fractions import gcd
 
    n_first = 15
    print('The first %i values:\n  ' % n_first,
          stern_brocot(lambda series: len(series) < n_first)[:n_first])
    print()
    n_max = 10
    for n_occur in list(range(1, n_max + 1)) + [100]:
        print('1-based index of the first occurrence of %3i in the series:' % n_occur,
              stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)
              # The following would be much faster. Note that new values always occur at odd indices
              # len(stern_brocot(lambda series: n_occur != series[-2])) - 1)
 
    print()
    n_gcd = 1000
    s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]
    assert all(gcd(prev, this) == 1
               for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Fermat_numbers,Fermat numbers,"In mathematics, a Fermat number, named after Pierre de Fermat who first studied them, is a positive integer of the form Fn = 22n + 1 where n is a non-negative integer.

Despite the simplicity of generating Fermat numbers, they have some powerful mathematical properties and are extensively used in cryptography & pseudo-random number generation, and are often linked to other number theoric fields.

As of this writing, (mid 2019), there are only five known prime Fermat numbers, the first five (F0 through F4). Only the first twelve Fermat numbers have been completely factored, though many have been partially factored.



Task

 Write a routine (function, procedure, whatever) to generate Fermat numbers.
 Use the routine to find and display here, on this page, the first 10 Fermat numbers - F0 through F9.
 Find and display here, on this page, the prime factors of as many Fermat numbers as you have patience for. (Or as many as can be found in five minutes or less of processing time). Note: if you make it past F11, there may be money, and certainly will be acclaim in it for you.


See also

 Wikipedia - Fermat numbers
 OEIS:A000215 - Fermat numbers
 OEIS:A019434 - Fermat primes

",Python,"def factors(x):
    factors = []
    i = 2
    s = int(x ** 0.5)
    while i < s:
        if x % i == 0:
            factors.append(i)
            x = int(x / i)
            s = int(x ** 0.5)
        i += 1
    factors.append(x)
    return factors
 
print(""First 10 Fermat numbers:"")
for i in range(10):
    fermat = 2 ** 2 ** i + 1
    print(""F{} = {}"".format(chr(i + 0x2080) , fermat))
 
print(""\nFactors of first few Fermat numbers:"")
for i in range(10):
    fermat = 2 ** 2 ** i + 1
    fac = factors(fermat)
    if len(fac) == 1:
        print(""F{} -> IS PRIME"".format(chr(i + 0x2080)))
    else:
        print(""F{} -> FACTORS: {}"".format(chr(i + 0x2080), fac))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Reduced_row_echelon_form,Reduced row echelon form,"Reduced row echelon form

You are encouraged to solve this task according to the task description, using any language you may know.


Task

Show how to compute the reduced row echelon form
(a.k.a. row canonical form) of a matrix.

The matrix can be stored in any datatype that is convenient
(for most languages, this will probably be a two-dimensional array).

Built-in functions or this pseudocode (from Wikipedia) may be used:

function ToReducedRowEchelonForm(Matrix M) is
    lead := 0
    rowCount := the number of rows in M
    columnCount := the number of columns in M
    for 0 ≤ r < rowCount do
        if columnCount ≤ lead then
            stop
        end if
        i = r
        while M[i, lead] = 0 do
            i = i + 1
            if rowCount = i then
                i = r
                lead = lead + 1
                if columnCount = lead then
                    stop
                end if
            end if
        end while
        Swap rows i and r
        If M[r, lead] is not 0 divide row r by M[r, lead]
        for 0 ≤ i < rowCount do
            if i ≠ r do
                Subtract M[i, lead] multiplied by row r from row i
            end if
        end for
        lead = lead + 1
    end for
end function

For testing purposes, the RREF of this matrix:

 1    2   -1   -4
 2    3   -1   -11
-2    0   -3    22

is:

 1    0    0   -8
 0    1    0    1
 0    0    1   -2


",Python,"def ToReducedRowEchelonForm( M):
    if not M: return
    lead = 0
    rowCount = len(M)
    columnCount = len(M[0])
    for r in range(rowCount):
        if lead >= columnCount:
            return
        i = r
        while M[i][lead] == 0:
            i += 1
            if i == rowCount:
                i = r
                lead += 1
                if columnCount == lead:
                    return
        M[i],M[r] = M[r],M[i]
        lv = M[r][lead]
        M[r] = [ mrx / float(lv) for mrx in M[r]]
        for i in range(rowCount):
            if i != r:
                lv = M[i][lead]
                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]
        lead += 1
 
 
mtx = [
   [ 1, 2, -1, -4],
   [ 2, 3, -1, -11],
   [-2, 0, -3, 22],]
 
ToReducedRowEchelonForm( mtx )
 
for rw in mtx:
  print ', '.join( (str(rv) for rv in rw) )",Human_written,Python_from_Go
http://rosettacode.org/wiki/Mayan_numerals,Mayan numerals,"Task

Present numbers using the Mayan numbering system   (displaying the Mayan numerals in a cartouche).



Mayan numbers

Normally, Mayan numbers are written vertically   (top─to─bottom)   with the most significant
numeral at the top   (in the sense that decimal numbers are written left─to─right with the most significant
digit at the left).   This task will be using a left─to─right (horizontal) format,   mostly for familiarity and
readability,   and to conserve screen space (when showing the output) on this task page.



Mayan numerals

Mayan numerals   (a base─20 ""digit"" or glyph)   are written in two orientations,   this
task will be using the ""vertical"" format   (as displayed below).   Using the vertical format makes
it much easier to draw/construct the Mayan numerals (glyphs) with simple dots (.)
and hyphen (-);     (however, round bullets (•) and long dashes (─)
make a better presentation on Rosetta Code).



Furthermore, each Mayan numeral   (for this task)   is to be displayed as a
cartouche   (enclosed in a box)   to make it easier to parse (read);   the box may be
drawn with any suitable (ASCII or Unicode) characters that are presentable/visible in all web browsers.



Mayan numerals added to Unicode
Mayan numerals (glyphs) were added to the Unicode Standard in June of 2018   (this corresponds with
version 11.0).   But since most web browsers don't support them at this time,   this Rosetta Code
task will be constructing the glyphs with ""simple"" characters and/or ASCII art.



The ""zero"" glyph

The Mayan numbering system has the concept of   zero,   and should be shown by a glyph that represents
an upside─down (sea) shell,   or an egg.   The Greek letter theta   (Θ)   can be
used   (which more─or─less, looks like an
egg).   A   commercial at   symbol   (@)   could make a poor substitute.



Mayan glyphs (constructed)

The Mayan numbering system is
a   [vigesimal (base 20)]   positional numeral system.



The Mayan numerals   (and some random numbers)   shown in the   vertical   format would be shown as

      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║ ∙  ║                            ║    ║    ║
 1──► ║    ║                11──► ║────║                      21──► ║    ║    ║
      ║ ∙  ║                      ║────║                            ║ ∙  ║ ∙  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║ ∙∙ ║                            ║    ║    ║
 2──► ║    ║                12──► ║────║                      22──► ║    ║    ║
      ║ ∙∙ ║                      ║────║                            ║ ∙  ║ ∙∙ ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║∙∙∙ ║                            ║    ║    ║
 3──► ║    ║                13──► ║────║                      40──► ║    ║    ║
      ║∙∙∙ ║                      ║────║                            ║ ∙∙ ║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║∙∙∙∙║                            ║    ║    ║
 4──► ║    ║                14──► ║────║                      80──► ║    ║    ║
      ║∙∙∙∙║                      ║────║                            ║∙∙∙∙║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║    ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 5──► ║    ║                15──► ║────║                      90──► ║    ║────║
      ║────║                      ║────║                            ║∙∙∙∙║────║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║ ∙  ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 6──► ║ ∙  ║                16──► ║────║                     100──► ║    ║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║ ∙∙ ║                            ║    ║    ║
      ║    ║                      ║────║                            ║    ║    ║
 7──► ║ ∙∙ ║                17──► ║────║                     200──► ║────║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╗
      ║    ║                      ║∙∙∙ ║                            ║    ║    ║
      ║    ║                      ║────║                     300──► ║────║    ║
 8──► ║∙∙∙ ║                18──► ║────║                            ║────║    ║
      ║────║                      ║────║                            ║────║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╝
      ╔════╗                      ╔════╗                            ╔════╦════╦════╗
      ║    ║                      ║∙∙∙∙║                            ║    ║    ║    ║
      ║    ║                      ║────║                     400──► ║    ║    ║    ║
 9──► ║∙∙∙∙║                19──► ║────║                            ║    ║    ║    ║
      ║────║                      ║────║                            ║ ∙  ║ Θ  ║ Θ  ║
      ╚════╝                      ╚════╝                            ╚════╩════╩════╝
      ╔════╗                      ╔════╦════╗                       ╔════╦════╦════╦════╗
      ║    ║                      ║    ║    ║                       ║    ║    ║    ║    ║
      ║    ║                      ║    ║    ║                       ║    ║    ║    ║    ║
10──► ║────║                20──► ║    ║    ║             16,000──► ║    ║    ║    ║    ║
      ║────║                      ║ ∙  ║ Θ  ║                       ║ ∙∙ ║ Θ  ║ Θ  ║ Θ  ║
      ╚════╝                      ╚════╩════╝                       ╚════╩════╩════╩════╝



Note that the Mayan numeral   13   in   horizontal   format would be shown as:

                                  ╔════╗
                                  ║  ││║
                                  ║ ∙││║
                            13──► ║ ∙││║        ◄─── this glyph form won't be used in this Rosetta Code task.
                                  ║ ∙││║
                                  ╚════╝



Other forms of cartouches (boxes) can be used for this task.



Task requirements

   convert the following decimal numbers to Mayan numbers:
       4,005
       8,017
   326,205
   886,205
   show a   unique   interesting/pretty/unusual/intriguing/odd/amusing/weird   Mayan number
   show all output here


Related tasks

   Roman numerals/Encode   ─── convert numeric values into Roman numerals
   Roman numerals/Decode   ─── convert Roman numerals into Arabic numbers


See also

   The Wikipedia entry:   [Mayan numerals]

",Python,"from __future__ import print_function
 
import sys
 
ul = ""╔""
uc = ""╦""
ur = ""╗""
ll = ""╚""
lc = ""╩""
lr = ""╝""
hb = ""═""
vb = ""║""
 
mayan = [
    ""    "",
    "" ∙  "",
    "" ∙∙ "",
    ""∙∙∙ "",
    ""∙∙∙∙"",
]
 
m0 = "" Θ  ""
m5 = ""────""
 
def dec2vig(n):
    vig = str(n).encode('base_20')
    return [int(d) for d in vig]
 
def vig2quin(n):
    if n >= 20:
        raise ValueError(""Cant't convert a number >= 20"")
    res = [mayan[0], mayan[0], mayan[0], mayan[0]]
    if n == 0:
        res[3] = m0
        return res
    fives = n / 5
    rem = n % 5
    res[3-fives] = mayan[rem]
    for i in range(3, 3-fives, -1):
        res[i] = m5
    return res
 
def draw(mayans):
    lm = len(mayans)
    print(ul, end='')
    for i in range(lm):
        for j in range(4):
            print(hb, end='')
        if i < lm-1:
            print(uc, end='')
        else:
            print(ur)
    for i in range(1, 5):
        print(vb, end='')
        for j in range(lm):
            print(mayans[j][i-1], end='')
            print(vb, end='')
        print()
    print(ll, end='')
    for i in range(lm):
        for j in range(4):
            print(hb, end='')
        if i < lm-1:
            print(lc, end='')
        else:
            print(lr)
 
if __name__ == '__main__':
    numbers = [4005, 8017, 326205, 886205, 1081439556]
    for n in numbers:
        print(""Converting %d to Mayan:"" % n)
        vigs = dec2vig(n)
        lv = len(vigs)
        mayans = [vig2quin(vig) for vig in vigs]
        draw(mayans)
        print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/JortSort,JortSort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 Note:   jortSort is considered a work of satire.   It achieves its result in an intentionally roundabout way.   You are encouraged to write your solutions in the spirit of the original jortsort rather than trying to give the most concise or idiomatic solution.



JortSort is a sorting tool set that makes the user do the work and guarantees efficiency because you don't have to sort ever again.

It was originally presented by Jenn ""Moneydollars"" Schiffer at the
prestigious   JSConf.



JortSort is a function that takes a single array of comparable objects as its argument.

It then sorts the array in ascending order and compares the sorted array to the originally provided array.

If the arrays match   (i.e. the original array was already sorted),   the function returns   true.

If the arrays do not match (i.e. the original array was not sorted), the function returns   false.



",Python,"import sys
 
def number_of_digits(x):
    NumberOfDigits=0
    while x!=0:
        x=x/10
        NumberOfDigits+=1
    return NumberOfDigits
 
def convert_array(array, NumberOfElements):
    convertedArray=[0]*NumberOfElements
    originalElement=0
    convertedElement=0
    while convertedElement<NumberOfElements:
        convertedArray[convertedElement]=int(array[originalElement])
        originalElement+=number_of_digits(convertedArray[convertedElement])+1
        convertedElement+=1
    return convertedArray
 
def isSorted(array, numberOfElements):
    sorted=1
    counter=0
    while counter<numberOfElements:
        if counter!=0 and array[counter-1]>array[counter]:
            sorted-=1
        counter+=1
    return sorted
 
if __name__ == ""__main__"":
    convertedArray=convert_array(sys.argv[1], len(sys.argv)-1)
    if isSorted(convertedArray, len(sys.argv)-1)==1:
        print ""Did you forgot to turn on your brain?! This array is already sorted!""
    elif len(sys.argv)-1<=10:
        print ""Am I really supposed to sort this? Sort it by yourself!""
    else:
        print ""Am I really supposed to sort this? Bhahahaha!""",Ai_generated,Python_from_C
"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence","Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",Python,"import sys
import math

a_list = [0] * (1<<20 + 1)

def doSqnc(m):
    max_df = 0
    p2_max = 2
    v = 0
    n = 0
    k1 = 2
    lg2 = 1
    amax = 0
    a_list[0] = -50000
    a_list[1] = a_list[2] = 1
    v = a_list[2]
    for n in range(3, m+1):
        v = a_list[n] = a_list[v] + a_list[n-v]
        if amax < v*1.0/n:
            amax = v*1.0/n
        if 0 == (k1&n):
            print(""Maximum between 2^%d and 2^%d was %f"" % (lg2,lg2+1, amax))
            amax = 0
            lg2 += 1
        k1 = n
    return 1

if __name__ == ""__main__"":
    doSqnc(int(sys.argv[1]))",Ai_generated,Python_from_C
"http://rosettacode.org/wiki/Abbreviations,_automatic","Abbreviations, automatic","The use of   abbreviations   (also sometimes called synonyms, nicknames, AKAs, or aliases)   can be an

easy way to add flexibility when specifying or using commands, sub─commands, options, etc.



It would make a list of words easier to maintain   (as words are added, changed, and/or deleted)   if
the minimum abbreviation length of that list could be automatically (programmatically) determined.



For this task, use the list (below) of the days-of-the-week names that are expressed in about a hundred languages   (note that there is a blank line in the list).

Sunday Monday Tuesday Wednesday Thursday Friday Saturday
Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag
E_djelë E_hënë E_martë E_mërkurë E_enjte E_premte E_shtunë
Ehud Segno Maksegno Erob Hamus Arbe Kedame
Al_Ahad Al_Ithinin Al_Tholatha'a Al_Arbia'a Al_Kamis Al_Gomia'a Al_Sabit
Guiragui Yergou_shapti Yerek_shapti Tchorek_shapti Hink_shapti Ourpat Shapat
domingu llunes martes miércoles xueves vienres sábadu
Bazar_gÜnÜ Birinci_gÜn Çkinci_gÜn ÜçÜncÜ_gÜn DÖrdÜncÜ_gÜn Bes,inci_gÜn Altòncò_gÜn
Igande Astelehen Astearte Asteazken Ostegun Ostiral Larunbat
Robi_bar Shom_bar Mongal_bar Budhh_bar BRihashpati_bar Shukro_bar Shoni_bar
Nedjelja Ponedeljak Utorak Srijeda Cxetvrtak Petak Subota
Disul Dilun Dimeurzh Dimerc'her Diriaou Digwener Disadorn
nedelia ponedelnik vtornik sriada chetvartak petak sabota
sing_kei_yaht sing_kei_yat sing_kei_yee sing_kei_saam sing_kei_sie sing_kei_ng sing_kei_luk
Diumenge Dilluns Dimarts Dimecres Dijous Divendres Dissabte
Dzeenkk-eh Dzeehn_kk-ehreh Dzeehn_kk-ehreh_nah_kay_dzeeneh Tah_neesee_dzeehn_neh Deehn_ghee_dzee-neh Tl-oowey_tts-el_dehlee Dzeentt-ahzee
dy_Sul dy_Lun dy_Meurth dy_Mergher dy_You dy_Gwener dy_Sadorn
Dimanch Lendi Madi Mèkredi Jedi Vandredi Samdi
nedjelja ponedjeljak utorak srijeda cxetvrtak petak subota
nede^le ponde^lí úterÿ str^eda c^tvrtek pátek sobota
Sondee Mondee Tiisiday Walansedee TOOsedee Feraadee Satadee
s0ndag mandag tirsdag onsdag torsdag fredag l0rdag
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
Diman^co Lundo Mardo Merkredo ^Jaùdo Vendredo Sabato
pÜhapäev esmaspäev teisipäev kolmapäev neljapäev reede laupäev

Diu_prima Diu_sequima Diu_tritima Diu_quartima Diu_quintima Diu_sextima Diu_sabbata
sunnudagur mánadagur tÿsdaguy mikudagur hósdagur friggjadagur leygardagur
Yek_Sham'beh Do_Sham'beh Seh_Sham'beh Cha'har_Sham'beh Panj_Sham'beh Jom'eh Sham'beh
sunnuntai maanantai tiistai keskiviiko torsktai perjantai lauantai
dimanche lundi mardi mercredi jeudi vendredi samedi
Snein Moandei Tiisdei Woansdei Tonersdei Freed Sneon
Domingo Segunda_feira Martes Mércores Joves Venres Sábado
k'vira orshabati samshabati otkhshabati khutshabati p'arask'evi shabati
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag
Kiriaki' Defte'ra Tri'ti Teta'rti Pe'mpti Paraskebi' Sa'bato
ravivaar somvaar mangalvaar budhvaar guruvaar shukravaar shanivaar
pópule pó`akahi pó`alua pó`akolu pó`ahá pó`alima pó`aono
Yom_rishon Yom_sheni Yom_shlishi Yom_revi'i Yom_chamishi Yom_shishi Shabat
ravivara somavar mangalavar budhavara brahaspativar shukravara shanivar
vasárnap hétfö kedd szerda csütörtök péntek szombat
Sunnudagur Mánudagur ╞riδjudagur Miδvikudagar Fimmtudagur FÖstudagur Laugardagur
sundio lundio mardio merkurdio jovdio venerdio saturdio
Minggu Senin Selasa Rabu Kamis Jumat Sabtu
Dominica Lunedi Martedi Mercuridi Jovedi Venerdi Sabbato
Dé_Domhnaigh Dé_Luain Dé_Máirt Dé_Ceadaoin Dé_ardaoin Dé_hAoine Dé_Sathairn
domenica lunedí martedí mercoledí giovedí venerdí sabato
Nichiyou_bi Getzuyou_bi Kayou_bi Suiyou_bi Mokuyou_bi Kin'you_bi Doyou_bi
Il-yo-il Wol-yo-il Hwa-yo-il Su-yo-il Mok-yo-il Kum-yo-il To-yo-il
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
sve-tdien pirmdien otrdien tresvdien ceturtdien piektdien sestdien
Sekmadienis Pirmadienis Antradienis Trec^iadienis Ketvirtadienis Penktadienis S^es^tadienis
Wangu Kazooba Walumbe Mukasa Kiwanuka Nnagawonye Wamunyi
xing-_qi-_rì xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
Jedoonee Jelune Jemayrt Jecrean Jardaim Jeheiney Jesam
Jabot Manre Juje Wonje Taije Balaire Jarere
geminrongo minòmishi mártes mièrkoles misheushi bèrnashi mishábaro
Ahad Isnin Selasa Rabu Khamis Jumaat Sabtu
sφndag mandag tirsdag onsdag torsdag fredag lφrdag
lo_dimenge lo_diluns lo_dimarç lo_dimèrcres lo_dijòus lo_divendres lo_dissabte
djadomingo djaluna djamars djarason djaweps djabièrna djasabra
Niedziela Poniedzial/ek Wtorek S,roda Czwartek Pia,tek Sobota
Domingo segunda-feire terça-feire quarta-feire quinta-feire sexta-feira såbado
Domingo Lunes martes Miercoles Jueves Viernes Sabado
Duminicª Luni Mart'i Miercuri Joi Vineri Sâmbªtª
voskresenie ponedelnik vtornik sreda chetverg pyatnitsa subbota
Sunday Di-luain Di-màirt Di-ciadain Di-ardaoin Di-haoine Di-sathurne
nedjelja ponedjeljak utorak sreda cxetvrtak petak subota
Sontaha Mmantaha Labobedi Laboraro Labone Labohlano Moqebelo
Iridha- Sandhudha- Anga.haruwa-dha- Badha-dha- Brahaspa.thindha- Sikura-dha- Sena.sura-dha-
nedel^a pondelok utorok streda s^tvrtok piatok sobota
Nedelja Ponedeljek Torek Sreda Cxetrtek Petek Sobota
domingo lunes martes miércoles jueves viernes sábado
sonde mundey tude-wroko dride-wroko fode-wroko freyda Saturday
Jumapili Jumatatu Jumanne Jumatano Alhamisi Ijumaa Jumamosi
söndag måndag tisdag onsdag torsdag fredag lordag
Linggo Lunes Martes Miyerkoles Huwebes Biyernes Sabado
Lé-pài-jít Pài-it Pài-jï Pài-sañ Pài-sì Pài-gÖ. Pài-lák
wan-ar-tit wan-tjan wan-ang-kaan wan-phoet wan-pha-ru-hat-sa-boh-die wan-sook wan-sao
Tshipi Mosupologo Labobedi Laboraro Labone Labotlhano Matlhatso
Pazar Pazartesi Sali Çar,samba Per,sembe Cuma Cumartesi
nedilya ponedilok vivtorok sereda chetver pyatnytsya subota
Chu?_Nhâ.t Thú*_Hai Thú*_Ba Thú*_Tu* Thú*_Na'm Thú*_Sáu Thú*_Ba?y
dydd_Sul dyds_Llun dydd_Mawrth dyds_Mercher dydd_Iau dydd_Gwener dyds_Sadwrn
Dibeer Altine Talaata Allarba Al_xebes Aljuma Gaaw
iCawa uMvulo uLwesibini uLwesithathu uLuwesine uLwesihlanu uMgqibelo
zuntik montik dinstik mitvokh donershtik fraytik shabes
iSonto uMsombuluko uLwesibili uLwesithathu uLwesine uLwesihlanu uMgqibelo
Dies_Dominica Dies_Lunæ Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Saturni
Bazar_gÜnÜ Bazar_ærtæsi Çærs,ænbæ_axs,amò Çærs,ænbæ_gÜnÜ CÜmæ_axs,amò CÜmæ_gÜnÜ CÜmæ_Senbæ
Sun Moon Mars Mercury Jove Venus Saturn
zondag maandag dinsdag woensdag donderdag vrijdag zaterdag
KoseEraa GyoOraa BenEraa Kuoraa YOwaaraa FeEraa Memenaa
Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Sonnabend
Domingo Luns Terza_feira Corta_feira Xoves Venres Sábado
Dies_Solis Dies_Lunae Dies_Martis Dies_Mercurii Dies_Iovis Dies_Veneris Dies_Sabbatum
xing-_qi-_tiàn xing-_qi-_yi-. xing-_qi-_èr xing-_qi-_san-. xing-_qi-_sì xing-_qi-_wuv. xing-_qi-_liù
djadomingu djaluna djamars djarason djaweps djabièrnè djasabra
Killachau Atichau Quoyllurchau Illapachau Chaskachau Kuychichau Intichau

Caveat:   The list (above) most surely contains errors (or, at the least, differences) of what the actual (or true) names for the days-of-the-week.



To make this Rosetta Code task page as small as possible, if processing the complete list, read the days-of-the-week from a file (that is created from the above list).



Notes concerning the above list of words

   each line has a list of days-of-the-week for a language, separated by at least one blank
   the words on each line happen to be in order, from Sunday ──► Saturday
   most lines have words in mixed case and some have all manner of accented words and other characters
   some words were translated to the nearest character that was available to code page   437
   the characters in the words are not restricted except that they may not have imbedded blanks
   for this example, the use of an underscore (_) was used to indicate a blank in a word


Task

   The list of words   (days of the week)   needn't be verified/validated.
   Write a function to find the (numeric) minimum length abbreviation for each line that would make abbreviations unique.
   A blank line   (or a null line)   should return a null string.
   Process and show the output for at least the first five lines of the file.
   Show all output here.

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.1.4-3

import re

r = re.compile(r""[ ]+"")

def main(args):
    with open(""days_of_week.txt"") as f:
        lines = f.readlines()
    for i, line in enumerate(lines):
        line = line.strip()
        if not line:
            print()
            continue
        days = r.split(line)
        if len(days)!= 7:
            raise RuntimeError(f""There aren't 7 days in line {i + 1}"")
        if len(set(days)) < 7: # implies some days have the same name
            print(f"" ∞  {line}"")
            continue
        len = 1
        while True:
            if len(set(map(lambda x: x[:len], days))) == 7:
                print(f""{len:2d}  {line}"")
                break
            len += 1

if __name__ == ""__main__"":
    import sys
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Cantor_set,Cantor set,"Task

Draw a Cantor set.



See details at this Wikipedia webpage:   Cantor set
",Python,"WIDTH = 81
HEIGHT = 5
 
lines=[]
def cantor(start, len, index):
    seg = len / 3
    if seg == 0:
        return None
    for it in xrange(HEIGHT-index):
        i = index + it
        for jt in xrange(seg):
            j = start + seg + jt
            pos = i * WIDTH + j
            lines[pos] = ' '
    cantor(start,           seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)
    return None
 
lines = ['*'] * (WIDTH*HEIGHT)
cantor(0, WIDTH, 1)
 
for i in xrange(HEIGHT):
    beg = WIDTH * i
    print ''.join(lines[beg : beg+WIDTH])",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Align_columns,Align columns,"Given a text file of many lines, where fields within a line
are delineated by a single 'dollar' character, write a program
that aligns each column of fields by ensuring that words in each
column are separated by at least one space.
Further, allow for each word in a column to be either left
justified, right justified, or center justified within its column.

Use the following text to test your programs:

Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.


Note that:

   The example input texts lines may, or may not, have trailing dollar characters.
   All columns should share the same alignment.
   Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.
   Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.
   The minimum space between columns should be computed from the text and not hard-coded.
   It is not a requirement to add separating characters between or around columns.



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from itertools import zip_longest
 
txt = """"""Given$a$txt$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.""""""
 
parts = [line.rstrip(""$"").split(""$"") for line in txt.splitlines()]
widths = [max(len(word) for word in col) 
          for col in zip_longest(*parts, fillvalue='')]
 
for justify in ""<_Left ^_Center >_Right"".split():
    j, jtext = justify.split('_')
    print(f""{jtext} column-aligned output:\n"")
    for line in parts:
        print(' '.join(f""{wrd:{j}{wdth}}"" for wdth, wrd in zip(widths, line)))
    print(""- "" * 52)",Human_written,Python_from_C
http://rosettacode.org/wiki/Quaternion_type,Quaternion type,"Quaternions   are an extension of the idea of   complex numbers.

A complex number has a real and complex part,   sometimes written as     a + bi,  

where     a     and     b     stand for real numbers, and     i     stands for the square root of minus 1.

An example of a complex number might be     -3 + 2i,    

where the real part,     a     is     -3.0     and the complex part,     b     is     +2.0.  

A quaternion has one real part and three imaginary parts,     i,       j,     and     k.  

A quaternion might be written as     a + bi + cj + dk.  

In the quaternion numbering system:

     i∙i = j∙j = k∙k = i∙j∙k = -1,         or more simply,
     ii  = jj  = kk  = ijk   = -1.  
The order of multiplication is important, as, in general, for two quaternions:

     q1     and     q2:         q1q2 ≠ q2q1.  
An example of a quaternion might be     1 +2i +3j +4k  

There is a list form of notation where just the numbers are shown and the imaginary multipliers    i,       j,     and     k     are assumed by position.

So the example above would be written as     (1, 2, 3, 4)  



Task

Given the three quaternions and their components: 

   q  = (1, 2, 3, 4) = (a,  b,  c,  d)
   q1 = (2, 3, 4, 5) = (a1, b1, c1, d1)
   q2 = (3, 4, 5, 6) = (a2, b2, c2, d2) 

And a wholly real number     r = 7.  



Create functions   (or classes)   to perform simple maths with quaternions including computing:

 The norm of a quaternion: 




=



a

2


+

b

2


+

c

2


+

d

2






{\displaystyle ={\sqrt {a^{2}+b^{2}+c^{2}+d^{2}}}}

 
 The negative of a quaternion: 
   = (-a, -b, -c, -d)  
 The conjugate of a quaternion: 
   = ( a, -b, -c, -d)  
 Addition of a real number     r     and a quaternion     q:  
  r + q = q + r = (a+r, b, c, d)  
 Addition of two quaternions: 
   q1 + q2 = (a1+a2, b1+b2, c1+c2, d1+d2)  
 Multiplication of a real number and a quaternion: 
   qr = rq = (ar, br, cr, dr)  
 Multiplication of two quaternions     q1     and   q2     is given by: 
   ( a1a2 − b1b2 − c1c2 − d1d2, 
   a1b2 + b1a2 + c1d2 − d1c2, 
   a1c2 − b1d2 + c1a2 + d1b2, 
   a1d2 + b1c2 − c1b2 + d1a2 )  
 Show that, for the two quaternions     q1     and     q2: 
 q1q2 ≠ q2q1  


If a language has built-in support for quaternions, then use it.



C.f.

   Vector products
   On Quaternions;   or on a new System of Imaginaries in Algebra.   By Sir William Rowan Hamilton LL.D, P.R.I.A., F.R.A.S., Hon. M. R. Soc. Ed. and Dub., Hon. or Corr. M. of the Royal or Imperial Academies of St. Petersburgh, Berlin, Turin and Paris, Member of the American Academy of Arts and Sciences, and of other Scientific Societies at Home and Abroad, Andrews' Prof. of Astronomy in the University of Dublin, and Royal Astronomer of Ireland.

",Python,"from collections import namedtuple
import math
 
class Q(namedtuple('Quaternion', 'real, i, j, k')):
    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' 
 
    __slots__ = () 
 
    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):
        'Defaults all parts of quaternion to zero'
        return super().__new__(_cls, float(real), float(i), float(j), float(k))
 
    def conjugate(self):
        return Q(self.real, -self.i, -self.j, -self.k)
 
    def _norm2(self):
        return sum( x*x for x in self)
 
    def norm(self):
        return math.sqrt(self._norm2())
 
    def reciprocal(self):
        n2 = self._norm2()
        return Q(*(x / n2 for x in self.conjugate())) 
 
    def __str__(self):
        'Shorter form of Quaternion as string'
        return 'Q(%g, %g, %g, %g)' % self
 
    def __neg__(self):
        return Q(-self.real, -self.i, -self.j, -self.k)
 
    def __add__(self, other):
        if type(other) == Q:
            return Q( *(s+o for s,o in zip(self, other)) )
        try:
            f = float(other)
        except:
            return NotImplemented
        return Q(self.real + f, self.i, self.j, self.k)
 
    def __radd__(self, other):
        return Q.__add__(self, other)
 
    def __mul__(self, other):
        if type(other) == Q:
            a1,b1,c1,d1 = self
            a2,b2,c2,d2 = other
            return Q(
                 a1*a2 - b1*b2 - c1*c2 - d1*d2,
                 a1*b2 + b1*a2 + c1*d2 - d1*c2,
                 a1*c2 - b1*d2 + c1*a2 + d1*b2,
                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )
        try:
            f = float(other)
        except:
            return NotImplemented
        return Q(self.real * f, self.i * f, self.j * f, self.k * f)
 
    def __rmul__(self, other):
        return Q.__mul__(self, other)
 
    def __truediv__(self, other):
        if type(other) == Q:
            return self.__mul__(other.reciprocal())
        try:
            f = float(other)
        except:
            return NotImplemented
        return Q(self.real / f, self.i / f, self.j / f, self.k / f)
 
    def __rtruediv__(self, other):
        return other * self.reciprocal()
 
    __div__, __rdiv__ = __truediv__, __rtruediv__
 
Quaternion = Q       
 
q  = Q(1, 2, 3, 4)
q1 = Q(2, 3, 4, 5)
q2 = Q(3, 4, 5, 6)
r  = 7",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Hash_from_two_arrays,Hash from two arrays,"Task

Using two Arrays of equal length, create a Hash object
where the elements from one array (the keys) are linked
to the elements of the other (the values)



Related task

   Associative arrays/Creation

",Python,"keys = ['a', 'b', 'c']
values = [1, 2, 3]
hash = {key: value for key, value in zip(keys, values)}",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Repeat_a_string,Repeat a string,"Take a string and repeat it some number of times.

Example: repeat(""ha"", 5)   =>   ""hahahahaha""

If there is a simpler/more efficient way to repeat a single “character” (i.e. creating a string filled with a certain character), you might want to show that as well (i.e. repeat-char(""*"", 5) => ""*****"").




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"""ha"" * 5  # ==> ""hahahahaha""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sierpinski_square_curve,Sierpinski square curve,"

Task
Produce a graphical or ASCII-art representation of a Sierpinski square curve of at least order 3.
",Python,"import matplotlib.pyplot as plt
import math
 
 
def nextPoint(x, y, angle):
    a = math.pi * angle / 180
    x2 = (int)(round(x + (1 * math.cos(a))))
    y2 = (int)(round(y + (1 * math.sin(a))))
    return x2, y2
 
 
def expand(axiom, rules, level):
    for l in range(0, level):
        a2 = """"
        for c in axiom:
            if c in rules:
                a2 += rules[c]
            else:
                a2 += c
        axiom = a2
    return axiom
 
 
def draw_lsystem(axiom, rules, angle, iterations):
    xp = [1]
    yp = [1]
    direction = 0
    for c in expand(axiom, rules, iterations):
        if c == ""F"":
            xn, yn = nextPoint(xp[-1], yp[-1], direction)
            xp.append(xn)
            yp.append(yn)
        elif c == ""-"":
            direction = direction - angle
            if direction < 0:
                direction = 360 + direction
        elif c == ""+"":
            direction = (direction + angle) % 360
 
    plt.plot(xp, yp)
    plt.show()
 
 
if __name__ == '__main__':
    # Sierpinski Square L-System Definition
    s_axiom = ""F+XF+F+XF""
    s_rules = {""X"": ""XF-F+F-XF+F+XF-F+F-X""}
    s_angle = 90
 
    draw_lsystem(s_axiom, s_rules, s_angle, 3)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Stirling_numbers_of_the_second_kind,Stirling numbers of the second kind,"Stirling numbers of the second kind, or Stirling partition numbers, are the
number of ways to partition a set of n objects into k non-empty subsets. They are
closely related to Bell numbers, and may be derived from them.



Stirling numbers of the second kind obey the recurrence relation:

   S2(n, 0) and S2(0, k) = 0 # for n, k > 0
   S2(n, n) = 1
   S2(n + 1, k) = k * S2(n, k) + S2(n, k - 1)



Task

 Write a routine (function, procedure, whatever) to find Stirling numbers of the second kind. There are several methods to generate Stirling numbers of the second kind. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the Stirling numbers of the second kind, S2(n, k), up to S2(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where S2(n, k) == 0 (when k > n).
 If your language supports large integers, find and show here, on this page, the maximum value of S2(n, k) where n == 100.


See also

 Wikipedia - Stirling numbers of the second kind
 OEIS:A008277 - Stirling numbers of the second kind


Related Tasks

 Stirling numbers of the first kind
 Bell numbers
 Lah numbers

",Python,"import math
 
def sterling2(n, k):
    if n == 0 and k == 0:
        return 1
    if (n > 0 and k == 0) or (n == 0 and k > 0):
        return 0
    if n == k:
        return 1
    if k > n:
        return 0
    return k * sterling2(n-1, k) + sterling2(n-1, k-1)
 
print(""Stirling numbers of the second kind:"")
max = 12
print(""n/k"", end="""")
for n in range(0, max+1):
    print(""%10d"" % n, end="""")
print()
for n in range(0, max+1):
    print(""%-3d"" % n, end="""")
    for k in range(0, n+1):
        print(""%10s"" % sterling2(n, k), end="""")
    print()
print(""The maximum value of S2(100, k) = "")
previous = 0
for k in range(1, 101):
    current = sterling2(100, k)
    if current > previous:
        previous = current
    else:
        print(""%s"" % previous)
        print(""(%d digits, k = %d)"" % (len(str(previous)), k-1))
        break",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Integer_comparison,Integer comparison,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Get two integers from the user.

Then,   display a message if the first integer is:

   less than, 
   equal to,   or 
   greater than
the second integer.



Test the condition   for each case separately,   so that   all three comparison operators are used   in the code.



Related task

   String comparison

",Python,"#!/usr/bin/env python
a = input('Enter value of a: ')
b = input('Enter value of b: ')
 
if a < b:
    print 'a is less than b'
elif a > b:
    print 'a is greater than b'
elif a == b:
    print 'a is equal to b'",Human_written,Python_from_C
http://rosettacode.org/wiki/CUSIP,CUSIP,"

 This page uses content from Wikipedia. The original article was at CUSIP. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



A   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.



Task

Ensure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:

   037833100       Apple Incorporated 
   17275R102       Cisco Systems 
   38259P508       Google Incorporated 
   594918104       Microsoft Corporation 
   68389X106       Oracle Corporation   (incorrect)
   68389X105       Oracle Corporation 


Example pseudo-code below.
algorithm Cusip-Check-Digit(cusip) is
   Input: an 8-character CUSIP
 
   sum := 0
   for 1 ≤ i ≤ 8 do
      c := the ith character of cusip
      if c is a digit then
         v := numeric value of the digit c
      else if c is a letter then
         p := ordinal position of c in the alphabet (A=1, B=2...)
         v := p + 9
      else if c = ""*"" then
         v := 36
      else if c = ""@"" then
         v := 37
      else if' c = ""#"" then
         v := 38
      end if
      if i is even then
         v := v × 2
      end if
 
      sum := sum + int ( v div 10 ) + v mod 10
   repeat
 
   return (10 - (sum mod 10)) mod 10
end function
See related tasks
 
 SEDOL
 ISIN

",Python,"#!/usr/bin/env python
# -*- coding: utf-8 -*-

def check_cusip(cusip):
    if len(cusip)!= 9:
        raise ValueError('CUSIP must be 9 characters')

    sum = 0
    for i, char in enumerate(cusip):
        if i == len(cusip) - 1:
            continue
        if char.isdigit():
            v = int(char)
        elif char.isalpha():
            v = ord(char.upper()) - ord('A') + 1 + 9
        elif char == '*':
            v = 36
        elif char == '@':
            v = 37
        elif char == '#':
            v = 38
        else:
            raise ValueError('Invalid character')

        if i % 2 == 0:
            v *= 2
        sum += v / 10 + v % 10

    check = (10 - (sum % 10)) % 10
    return 'VALID' if check == int(cusip[-1]) else 'INVALID'

CUSIPs = [
    '037833100', '17275R102', '38259P508', '594918104', '68389X106', '68389X105'
]

for cusip in CUSIPs:
    print('{}: {}'.format(cusip, check_cusip(cusip)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Generic_swap,Generic swap,"Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types.

If your solution language is statically typed please describe the way your language provides genericity.

If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation.
That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.

Generic swap is a task which brings together a few separate issues in programming language semantics.

Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.

Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.

Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism).

Do your best!



",Python,"def swap(a, b):
    temp = a
    a = b
    b = temp",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Polymorphic_copy,Polymorphic copy,"An object is polymorphic when its specific type may vary.
The types a specific value may take, is called class.

It is trivial to copy an object if its type is known:

int x;
int y = x;
Here x is not polymorphic, so y is declared of same type (int) as x.
But if the specific type of x were unknown, then y could not be declared of any specific type.

The task: let a polymorphic object contain an instance of some specific type S derived from a type T.
The type T is known.
The type S is possibly unknown until run time.
The objective is to create an exact copy of such polymorphic object (not to create a reference, nor a pointer to).
Let further the type T have a method overridden by S.
This method is to be called on the copy to demonstrate that the specific type of the copy is indeed S.
",Python,"import copy
 
class T:
   def classname(self): 
      return self.__class__.__name__
 
   def __init__(self):
      self.myValue = ""I'm a T.""
 
   def speak(self):
      print self.classname(), 'Hello', self.myValue
 
   def clone(self):
      return copy.copy(self)
 
class S1(T):
   def speak(self):
      print self.classname(),""Meow"", self.myValue
 
class S2(T):
   def speak(self):
      print self.classname(),""Woof"", self.myValue
 
 
print ""creating initial objects of types S1, S2, and T""
a = S1()
a.myValue = 'Green'
a.speak()
 
b = S2()
b.myValue = 'Blue'
b.speak()
 
u = T()
u.myValue = 'Purple'
u.speak()
 
print ""Making copy of a as u, colors and types should match""
u = a.clone()
u.speak()
a.speak()
print ""Assigning new color to u, A's color should be unchanged.""
u.myValue = ""Orange""
u.speak()
a.speak()
 
print ""Assigning u to reference same object as b, colors and types should match""
u = b
u.speak()
b.speak()
print ""Assigning new color to u. Since u,b references same object b's color changes as well""
u.myValue = ""Yellow""
u.speak()
b.speak()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Repunit_primes,Repunit primes,"Repunit is a portmanteau of the words ""repetition"" and ""unit"", with unit being ""unit value""... or in laymans terms, 1. So 1, 11, 111, 1111 & 11111 are all repunits.

Every standard integer base has repunits since every base has the digit 1. This task involves finding the repunits in different bases that are prime.

In base two, the repunits 11, 111, 11111, 1111111, etc. are prime. (These correspond to the Mersenne primes.)

In base three: 111, 1111111, 1111111111111, etc.

Repunit primes, by definition, are also circular primes.

Any repunit in any base having a composite number of digits is necessarily composite. Only repunits (in any base) having a prime number of digits might be prime.



Rather than expanding the repunit out as a giant list of 1s or converting to base 10, it is common to just list the number of 1s in the repunit; effectively the digit count. The base two repunit primes listed above would be represented as: 2, 3, 5, 7, etc.

Many of these sequences exist on OEIS, though they aren't specifically listed as ""repunit prime digits"" sequences.

Some bases have very few repunit primes. Bases 4, 8, and likely 16 have only one. Base 9 has none at all. Bases above 16 may have repunit primes as well... but this task is getting large enough already.



Task
 For bases 2 through 16, Find and show, here on this page, the repunit primes as digit counts, up to a limit of 1000.


Stretch
 Increase the limit to 2700 (or as high as you have patience for.)


See also
 Wikipedia: Repunit primes
 OEIS:A000043 - Mersenne exponents: primes p such that 2^p - 1 is prime. Then 2^p - 1 is called a Mersenne prime (base 2)
 OEIS:A028491 - Numbers k such that (3^k - 1)/2 is prime (base 3)
 OEIS:A004061 - Numbers n such that (5^n - 1)/4 is prime (base 5)
 OEIS:A004062 - Numbers n such that (6^n - 1)/5 is prime (base 6)
 OEIS:A004063 - Numbers k such that (7^k - 1)/6 is prime (base 7)
 OEIS:A004023 - Indices of prime repunits: numbers n such that 11...111 (with n 1's) = (10^n - 1)/9 is prime (base 10)
 OEIS:A005808 - Numbers k such that (11^k - 1)/10 is prime (base 11)
 OEIS:A004064 - Numbers n such that (12^n - 1)/11 is prime (base 12)
 OEIS:A016054 - Numbers n such that (13^n - 1)/12 is prime (base 13)
 OEIS:A006032 - Numbers k such that (14^k - 1)/13 is prime (base 14)
 OEIS:A006033 - Numbers n such that (15^n - 1)/14 is prime (base 15)
 Related task: Circular primes

",Python,"from sympy import isprime
for b in range(2, 17):
    print(b, [n for n in range(2, 1001) if isprime(n) and isprime(int('1'*n, base=b))])",Human_written,Python_from_Go
http://rosettacode.org/wiki/Hofstadter_Q_sequence,Hofstadter Q sequence,"Hofstadter Q sequence


 







Q
(
1
)



=
Q
(
2
)
=
1
,




Q
(
n
)



=
Q


(


n
−
Q
(
n
−
1
)


)


+
Q


(


n
−
Q
(
n
−
2
)


)


,

n
>
2.






{\displaystyle {\begin{aligned}Q(1)&=Q(2)=1,\\Q(n)&=Q{\big (}n-Q(n-1){\big )}+Q{\big (}n-Q(n-2){\big )},\quad n>2.\end{aligned}}}




It is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.



Task

 Confirm and display that the first ten terms of the sequence are: 1, 1, 2, 3, 3, 4, 5, 5, 6, and 6 
 Confirm and display that the 1000th term is:   502


Optional extra credit
 Count and display how many times a member of the sequence is less than its preceding term for terms up to and including the 100,000th term.
 Ensure that the extra credit solution   safely   handles being initially asked for an nth term where   n   is large.

(This point is to ensure that caching and/or recursion limits, if it is a concern, is correctly handled).



",Python,"import numpy as np

size = 100000
hofstadters = np.zeros(size, dtype=np.int32)
hofstadters[0] = 1
hofstadters[1] = 1
for i in range(2, size):
    hofstadters[i] = hofstadters[i - hofstadters[i - 1]] + hofstadters[i - hofstadters[i - 2]]

print(""The first 10 numbers are: "", end="""")
for i in range(0, 10):
    print(hofstadters[i], end="" "")
print(""\nThe 1000'th term is "", hofstadters[999], ""!"")
less_than_preceding = 0
for i in range(0, size - 1):
    if hofstadters[i + 1] < hofstadters[i]:
        less_than_preceding += 1
print(""In array of size: "", size, "", "", less_than_preceding, "" times a number was preceded by a greater number!"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Langton%27s_ant,Langton's ant,"Langton's ant is a cellular automaton that models an ant sitting on a plane of cells, all of which are white initially, the ant facing in one of four directions.

Each cell can either be black or white.

The ant moves according to the color of the cell it is currently sitting in, with the following rules:

   If the cell is black, it changes to white and the ant turns left;
   If the cell is white, it changes to black and the ant turns right;
   The ant then moves forward to the next cell, and repeat from step 1.

This rather simple ruleset leads to an initially chaotic movement pattern, and after about 10000 steps, a cycle appears where the ant moves steadily away from the starting location in a diagonal corridor about 10 cells wide.
Conceptually the ant can then walk infinitely far away.



Task

Start the ant near the center of a 100x100 field of cells, which is about big enough to contain the initial chaotic part of the movement.

Follow the movement rules for the ant, terminate when it moves out of the region, and show the cell colors it leaves behind.



The problem has received some analysis; for more details, please take a look at the Wikipedia article   (a link is below)..



See also

   Wikipedia:   Langton's ant.


Related task

   Rosetta Code:   Conway's Game of Life.

",Python,"import sys
import time
import os
 
w = 0
h = 0
pix = []
 
def refresh(x, y):
	i = 0
	j = 0
	k = 0
	print(""\033[H"")
	for i in range(0, h):
		for j in range(0, w):
			k = i * w + j
			if pix[k]:
				print('#')
			else:
				print(' ')
		print('\n')
 
def walk():
	dx = 0
	dy = 1
	i = 0
	k = 0
	x = w / 2
	y = h / 2
	pix = [0] * (w * h)
	print(""\033[H\033[J"")
	while True:
		i = y * w + x
		if pix[i]:
			k = dx
			dx = -dy
			dy = k
		else:
			k = dy
			dy = -dx
			dx = k
		pix[i] = not pix[i]
		print(""\033[%d;%dH%c"" % (y + 1, x + 1, pix[i] and '#' or''))
		x += dx
		y += dy
		k = 0
		if x < 0:
			for i in range(0, w * h - 1):
				pix[i] = pix[i + 1]
			for i in range(0, w * h):
				if i % w == 0:
					pix[i] = 0
			x += 1
			k = 1
		elif x >= w:
			for i in range(0, w * h - 1):
				pix[i] = pix[i + 1]
			for i in range(0, w * h):
				if i % w == w - 1:
					pix[i] = 0
			x -= 1
			k = 1
		if y >= h:
			for i in range(0, w * (h - 1)):
				pix[i] = pix[i + w]
			for i in range(0, w):
				pix[i + w * (h - 1)] = 0
			y -= 1
			k = 1
		elif y < 0:
			for i in range(0, w * (h - 1)):
				pix[i + w] = pix[i]
			for i in range(0, w):
				pix[i] = 0
			y += 1
			k = 1
		if k:
			refresh(x, y)
		print(""\033[%d;%dH\033[31m@\033[m"" % (y + 1, x + 1))
		time.sleep(0.01)
 
def main(c, v):
	global w
	global h
	if c > 1:
		w = int(v[1])
	if c > 2:
		h = int(v[2])
	if w < 40:
		w = 40
	if h < 25:
		h = 25
	walk()
 
if __name__ == ""__main__"":
	main(len(sys.argv), sys.argv)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Exponentiation_operator,Exponentiation operator,"Most programming languages have a built-in implementation of exponentiation.



Task

Re-implement integer exponentiation for both   intint   and   floatint   as both a procedure,   and an operator (if your language supports operator definition).

If the language supports operator (or procedure) overloading, then an overloaded form should be provided for both   intint   and   floatint   variants.



Related tasks

   Exponentiation order
   arbitrary-precision integers (included)
   Exponentiation with infix operators in (or operating on) the base

",Python,"MULTIPLY = lambda x, y: x*y
 
class num(float):
    # the following method has complexity O(b)
    # rather than O(log b) via the rapid exponentiation
    def __pow__(self, b):
        return reduce(MULTIPLY, [self]*b, 1)
 
# works with ints as function or operator
print num(2).__pow__(3)
print num(2) ** 3
 
# works with floats as function or operator
print num(2.3).__pow__(8)
print num(2.3) ** 8",Human_written,Python_from_Kotlin
"http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications","Abundant, deficient and perfect number classifications","These define three classifications of positive integers based on their   proper divisors.

Let   P(n)   be the sum of the proper divisors of   n   where the proper divisors are all positive divisors of   n   other than   n   itself.

   if    P(n) <  n    then  n  is classed as  deficient  (OEIS A005100).
   if    P(n) == n    then  n  is classed as  perfect    (OEIS A000396).
   if    P(n) >  n    then  n  is classed as  abundant   (OEIS A005101).



Example

6   has proper divisors of   1,   2,   and   3.

1 + 2 + 3 = 6,   so   6   is classed as a perfect number.



Task

Calculate how many of the integers   1   to   20,000   (inclusive) are in each of the three classes.

Show the results here.



Related tasks

   Aliquot sequence classifications.   (The whole series from which this task is a subset.)
   Proper divisors
   Amicable pairs

",Python,">>> from proper_divisors import proper_divs
>>> from collections import Counter
>>> 
>>> rangemax = 20000
>>> 
>>> def pdsum(n):
...     return sum(proper_divs(n))
... 
>>> def classify(n, p):
...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'
... 
>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))
>>> classes.most_common()
[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Hailstone_sequence,Hailstone sequence,"The Hailstone sequence of numbers can be generated from a starting positive integer,   n   by:

   If   n   is     1     then the sequence ends.
   If   n   is   even then the next   n   of the sequence    = n/2 
   If   n   is   odd   then the next   n   of the sequence    = (3 * n) + 1 


The (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.



This sequence was named by Lothar Collatz in 1937   (or possibly in 1939),   and is also known as (the):

   hailstone sequence,   hailstone numbers
   3x + 2 mapping,   3n + 1 problem
   Collatz sequence
   Hasse's algorithm
   Kakutani's problem
   Syracuse algorithm,   Syracuse problem
   Thwaites conjecture 
   Ulam's problem


The hailstone sequence is also known as   hailstone numbers   (because the values are usually subject to multiple descents and ascents like hailstones in a cloud).



Task

 Create a routine to generate the hailstone sequence for a number.
 Use the routine to show that the hailstone sequence for the number 27 has 112 elements starting with 27, 82, 41, 124 and ending with 8, 4, 2, 1
 Show the number less than 100,000 which has the longest hailstone sequence together with that sequence's length.
   (But don't show the actual sequence!)


See also

   xkcd (humourous).
   The Notorious Collatz conjecture Terence Tao, UCLA (Presentation, pdf).
   The Simplest Math Problem No One Can Solve Veritasium (video, sponsored).

",Python,"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
 
class Hailstone:
 
  def getHailstoneSequence(self, n):
    if n <= 0:
      raise Exception(""Invalid starting sequence number"")
    list = []
    list.append(n)
    while n!= 1:
      if (n & 1) == 0:
        n = n / 2
      else:
        n = 3 * n + 1
      list.append(n)
    return list
 
  def main(self, args):
    sequence27 = getHailstoneSequence(27)
    print(""Sequence for 27 has "" + str(len(sequence27)) + "" elements: "" + str(sequence27))
 
    MAX = 100000
    # Simple way
    {
      highestNumber = 1
      highestCount = 1
      for i in range(2, MAX):
        count = len(getHailstoneSequence(i))
        if count > highestCount:
          highestCount = count
          highestNumber = i
      print(""Method 1, number "" + str(highestNumber) + "" has the longest sequence, with a length of "" + str(highestCount))
    }
 
    # More memory efficient way
    {
      highestNumber = 1
      highestCount = 1
      for i in range(2, MAX):
        count = 1
        n = i
        while n!= 1:
          if (n & 1) == 0:
            n = n / 2
          else:
            n = 3 * n + 1
          count++
        if count > highestCount:
          highestCount = count
          highestNumber = i
      print(""Method 2, number "" + str(highestNumber) + "" has the longest sequence, with a length of "" + str(highestCount))
    }
 
    # Efficient for analyzing all sequences
    {
      highestNumber = 1
      highestCount = 1
      sequenceMap = {}
      sequenceMap[1] = 1
 
      currentList = []
      for i in range(2, MAX):
        currentList.clear()
        n = i
        count = None
        while (count = sequenceMap.get(n)) == None:
          currentList.append(n)
          nValue = n
          if (nValue & 1) == 0:
            n = nValue / 2
          else:
            n = 3 * nValue + 1
        curCount = count
        for j in range(len(currentList) - 1, -1, -1):
          sequenceMap[currentList[j]] = curCount + 1
        if curCount > highestCount:
          highestCount = curCount
          highestNumber = i
      print(""Method 3, number "" + str(highestNumber) + "" has the longest sequence, with a length of "" + str(highestCount))
    }
    return
 
Hailstone().main(None)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Guess_the_number,Guess the number,"Task

Write a program where the program chooses a number between   1   and   10.

A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct.

When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.

A   conditional loop   may be used to repeat the guessing until the user is correct.



Related tasks

   Bulls and cows
   Bulls and cows/Player
   Guess the number/With Feedback
   Mastermind

",Python,"import random
t,g=random.randint(1,10),0
g=int(input(""Guess a number that's between 1 and 10: ""))
while t!=g:g=int(input(""Guess again! ""))
print(""That's right!"")",Human_written,Python_from_C++
http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",Python,"from itertools import permutations
from operator import mul
from math import fsum
from spermutations import spermutations
 
def prod(lst):
    return reduce(mul, lst, 1)
 
def perm(a):
    n = len(a)
    r = range(n)
    s = permutations(r)
    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)
 
def det(a):
    n = len(a)
    r = range(n)
    s = spermutations(n)
    return fsum(sign * prod(a[i][sigma[i]] for i in r)
                for sigma, sign in s)
 
if __name__ == '__main__':
    from pprint import pprint as pp
 
    for a in ( 
            [
             [1, 2], 
             [3, 4]], 
 
            [
             [1, 2, 3, 4],
             [4, 5, 6, 7],
             [7, 8, 9, 10],
             [10, 11, 12, 13]],        
 
            [
             [ 0,  1,  2,  3,  4],
             [ 5,  6,  7,  8,  9],
             [10, 11, 12, 13, 14],
             [15, 16, 17, 18, 19],
             [20, 21, 22, 23, 24]],
        ):
        print('')
        pp(a)
        print('Perm: %s Det: %s' % (perm(a), det(a)))",Human_written,Python_from_C
http://rosettacode.org/wiki/Visualize_a_tree,Visualize a tree,"A tree structure   (i.e. a rooted, connected acyclic graph)   is often used in programming.

It's often helpful to visually examine such a structure.

There are many ways to represent trees to a reader, such as:

   indented text   (à la unix  tree  command)
   nested HTML tables
   hierarchical GUI widgets
   2D   or   3D   images
   etc.
Task

Write a program to produce a visual representation of some tree.

The content of the tree doesn't matter, nor does the output format, the only requirement being that the output is human friendly.

Make do with the vague term ""friendly"" the best you can.



",Python,"Python 3.2.3 (default, May  3 2012, 15:54:42) 
[GCC 4.6.3] on linux2
Type ""copyright"", ""credits"" or ""license()"" for more information.
>>> help('pprint.pprint')
Help on function pprint in pprint:
 
pprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)
    Pretty-print a Python object to a stream [default is sys.stdout].
 
>>> from pprint import pprint
>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),
	          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),
	          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:
	print(""\nTree %r can be pprint'd as:"" % (tree, ))
	pprint(tree, indent=1, width=1)
 
 
 
Tree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:
(1,
 2,
 3,
 4,
 5,
 6,
 7,
 8)
 
Tree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:
(1,
 ((2,
   3),
  (4,
   (5,
    ((6,
      7),
     8)))))
 
Tree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:
((((1,
    2),
   3),
  4),
 5,
 6,
 7,
 8)
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Brazilian_numbers,Brazilian numbers,"Brazilian numbers are so called as they were first formally presented at the 1994 math Olympiad Olimpiada Iberoamericana de Matematica in Fortaleza, Brazil.

Brazilian numbers are defined as:

The set of positive integer numbers where each number N has at least one natural number B where 1 < B < N-1 where the representation of N in base B has all equal digits.



E.G.

 1, 2 & 3 can not be Brazilian; there is no base B that satisfies the condition 1 < B < N-1.
 4 is not Brazilian; 4 in base 2 is 100. The digits are not all the same.
 5 is not Brazilian; 5 in base 2 is 101, in base 3 is 12. There is no representation where the digits are the same.
 6 is not Brazilian; 6 in base 2 is 110, in base 3 is 20, in base 4 is 12. There is no representation where the digits are the same.
 7 is Brazilian; 7 in base 2 is 111. There is at least one representation where the digits are all the same.
 8 is Brazilian; 8 in base 3 is 22. There is at least one representation where the digits are all the same.
 and so on...


All even integers 2P >= 8 are Brazilian because 2P = 2(P-1) + 2, which is 22 in base P-1 when P-1 > 2. That becomes true when P >= 4.

More common: for all all integers R and S, where R > 1 and also S-1 > R, then R*S is Brazilian because R*S = R(S-1) + R, which is RR in base S-1

The only problematic numbers are squares of primes, where R = S. Only 11^2 is brazilian to base 3.

All prime integers, that are brazilian, can only have the digit 1. Otherwise one could factor out the digit, therefore it cannot be a prime number. Mostly in form of 111 to base Integer(sqrt(prime number)). Must be an odd count of 1 to stay odd like primes > 2


Task

Write a routine (function, whatever) to determine if a number is Brazilian and use the routine to show here, on this page;

 the first 20 Brazilian numbers;
 the first 20 odd Brazilian numbers;
 the first 20 prime Brazilian numbers;


See also

 OEIS:A125134 - Brazilian numbers
 OEIS:A257521 - Odd Brazilian numbers
 OEIS:A085104 - Prime Brazilian numbers

",Python,"'''Brazilian numbers'''
 
from itertools import count, islice
 
 
# isBrazil :: Int -> Bool
def isBrazil(n):
    '''True if n is a Brazilian number,
       in the sense of OEIS:A125134.
    '''
    return 7 <= n and (
        0 == n % 2 or any(
            map(monoDigit(n), range(2, n - 1))
        )
    )
 
 
# monoDigit :: Int -> Int -> Bool
def monoDigit(n):
    '''True if all the digits of n,
       in the given base, are the same.
    '''
    def go(base):
        def g(b, n):
            (q, d) = divmod(n, b)
 
            def p(qr):
                return d != qr[1] or 0 == qr[0]
 
            def f(qr):
                return divmod(qr[0], b)
            return d == until(p)(f)(
                (q, d)
            )[1]
        return g(base, n)
    return go
 
 
# -------------------------- TEST --------------------------
# main :: IO ()
def main():
    '''First 20 members each of:
        OEIS:A125134
        OEIS:A257521
        OEIS:A085104
    '''
    for kxs in ([
            (' ', count(1)),
            (' odd ', count(1, 2)),
            (' prime ', primes())
    ]):
        print(
            'First 20' + kxs[0] + 'Brazilians:\n' +
            showList(take(20)(filter(isBrazil, kxs[1]))) + '\n'
        )
 
 
# ------------------- GENERIC FUNCTIONS --------------------
 
# primes :: [Int]
def primes():
    ''' Non finite sequence of prime numbers.
    '''
    n = 2
    dct = {}
    while True:
        if n in dct:
            for p in dct[n]:
                dct.setdefault(n + p, []).append(p)
            del dct[n]
        else:
            yield n
            dct[n * n] = [n]
        n = 1 + n
 
 
# showList :: [a] -> String
def showList(xs):
    '''Stringification of a list.'''
    return '[' + ','.join(str(x) for x in xs) + ']'
 
 
# take :: Int -> [a] -> [a]
# take :: Int -> String -> String
def take(n):
    '''The prefix of xs of length n,
       or xs itself if n > length xs.
    '''
    def go(xs):
        return (
            xs[0:n]
            if isinstance(xs, (list, tuple))
            else list(islice(xs, n))
        )
    return go
 
 
# until :: (a -> Bool) -> (a -> a) -> a -> a
def until(p):
    '''The result of repeatedly applying f until p holds.
       The initial seed value is x.
    '''
    def go(f):
        def g(x):
            v = x
            while not p(v):
                v = f(v)
            return v
        return g
    return go
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_C#
http://rosettacode.org/wiki/Floyd-Warshall_algorithm,Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",Python,"import math
 
def floyd_warshall(weights, num_verticies):
    dist = [[math.inf for _ in range(num_verticies)] for _ in range(num_verticies)]
    for i in range(num_verticies):
        for j in range(num_verticies):
            if i == j:
                dist[i][j] = 0
 
    for i in range(len(weights)):
        dist[weights[i][0] - 1][weights[i][1] - 1] = weights[i][2]
 
    next = [[j + 1 for j in range(num_verticies)] for _ in range(num_verticies)]
 
    for k in range(num_verticies):
        for i in range(num_verticies):
            for j in range(num_verticies):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    next[i][j] = next[i][k]
 
    print_result(dist, next)
 
def print_result(dist, next):
    print(""pair     dist    path"")
    for i in range(len(next)):
        for j in range(len(next[0])):
            if i!= j:
                u = i + 1
                v = j + 1
                path = ""{0} -> {1}    {2:G}     {3}"".format(u, v, dist[i][j], u)
                while u!= v:
                    u = next[u - 1][v - 1]
                    path += "" -> "" + str(u)
                print(path)
 
weights = [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]]
num_verticies = 4
 
floyd_warshall(weights, num_verticies)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Extreme_floating_point_values,Extreme floating point values,"The IEEE floating point specification defines certain 'extreme' floating point values such as minus zero, -0.0, a value distinct from plus zero; not a number, NaN; and plus and minus infinity.

The task is to use expressions involving other 'normal' floating point values in your language to calculate these, (and maybe other), extreme floating point values in your language and assign them to variables.

Print the values of these variables if possible; and show some arithmetic with these values and variables.

If your language can directly enter these extreme floating point values then show it.



See also

   What Every Computer Scientist Should Know About Floating-Point Arithmetic


Related tasks

   Infinity
   Detect division by zero
   Literals/Floating point

",Python,">>> # Extreme values from expressions
>>> inf = 1e234 * 1e234
>>> _inf = 1e234 * -1e234
>>> _zero = 1 / _inf
>>> nan = inf + _inf
>>> inf, _inf, _zero, nan
(inf, -inf, -0.0, nan)
>>> # Print
>>> for value in (inf, _inf, _zero, nan): print (value)
 
inf
-inf
-0.0
nan
>>> # Extreme values from other means
>>> float('nan')
nan
>>> float('inf')
inf
>>> float('-inf')
-inf
>>> -0.
-0.0
>>> # Some arithmetic
>>> nan == nan
False
>>> nan is nan
True
>>> 0. == -0.
True
>>> 0. is -0.
False
>>> inf + _inf
nan
>>> 0.0 * nan
nan
>>> nan * 0.0
nan
>>> 0.0 * inf
nan
>>> inf * 0.0
nan",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Roman_numerals/Decode,Roman numerals/Decode,"Task

Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer.

You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately,

starting with the leftmost decimal digit and skipping any 0s   (zeroes).

1990 is rendered as   MCMXC     (1000 = M,   900 = CM,   90 = XC)     and

2008 is rendered as   MMVIII       (2000 = MM,   8 = VIII).

The Roman numeral for 1666,   MDCLXVI,   uses each letter in descending order.



",Python,"_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))
 
def decode( roman ):
    result = 0
    for r, r1 in zip(roman, roman[1:]):
        rd, rd1 = _rdecode[r], _rdecode[r1]
        result += -rd if rd < rd1 else rd
    return result + _rdecode[roman[-1]]
 
if __name__ == '__main__':
    for r in 'MCMXC MMVIII MDCLXVI'.split():
        print( r, decode(r) )",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Fibonacci_word,Fibonacci word,"The   Fibonacci Word   may be created in a manner analogous to the   Fibonacci Sequence   as described here:

    Define   F_Word1   as   1
    Define   F_Word2   as   0
    Form     F_Word3   as   F_Word2     concatenated with   F_Word1    i.e.:   01
    Form     F_Wordn   as   F_Wordn-1   concatenated with   F_wordn-2



Task

Perform the above steps for     n = 37.

You may display the first few but not the larger values of   n.

{Doing so will get the task's author into trouble with them what be (again!).} 

Instead, create a table for   F_Words   1   to   37   which shows:

   The number of characters in the word
   The word's Entropy


Related tasks
 
   Fibonacci word/fractal
   Entropy
   Entropy/Narcissist

",Python,"import math
 
def print_headings():
	print ""%2s"" % ""N"",
	print ""%10s"" % ""Length"",
	print ""%-20s"" % ""Entropy"",
	print ""%-40s"" % ""Word"",
	print
 
def calculate_entropy(ones, zeros):
	result = 0
 
	total = ones + zeros
	result -= (float(ones) / total) * math.log(float(ones) / total, 2)
	result -= (float(zeros) / total) * math.log(float(zeros) / total, 2)
 
	if result!= result: # NAN
		result = 0
 
	return result
 
def print_entropy(word):
	ones = 0
	zeros = 0
 
	for c in word:
		if c == '0':
			zeros += 1
		elif c == '1':
			ones += 1
 
	entropy = calculate_entropy(ones, zeros)
	print ""%-20.18f"" % entropy,
 
def print_word(n, word):
	print ""%2d"" % n,
 
	print ""%10d"" % len(word),
 
	print_entropy(word)
 
	if n < 10:
		print ""%-40s"" % word,
	else:
		print ""%-40s"" % ""..."",
 
	print
 
print_headings()
 
last_word = ""1""
current_word = ""0""
 
print_word(1, last_word)
for i in range(2, 38):
	print_word(i, current_word)
 
	next_word = current_word + last_word
 
	last_word = current_word
	current_word = next_word",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Angle_difference_between_two_bearings,Angle difference between two bearings,"Finding the angle between two bearings is often confusing.[1]



Task

Find the angle which is the result of the subtraction b2 - b1, where b1 and b2 are the bearings.


Input bearings are expressed in the range   -180   to   +180   degrees.

The  result  is also expressed in the range   -180   to   +180   degrees.



Compute the angle for the following pairs:

 20 degrees (b1) and 45 degrees (b2)
 -45 and 45
 -85 and 90
 -95 and 90
 -45 and 125
 -45 and 145
 29.4803 and -88.6381
 -78.3251 and -159.036


Optional extra
 
Allow the input bearings to be any (finite) value.



Test cases

 -70099.74233810938 and 29840.67437876723
 -165313.6666297357 and 33693.9894517456
 1174.8380510598456 and -154146.66490124757
 60175.77306795546 and 42213.07192354373

",Python,"# -*- coding: utf-8 -*-
""""""
Created on Mon Oct 14 15:00:00 2019

@author: 
""""""

def Delta_Bearing(b1, b2):
	""""""
	Optimal solution
	""""""
	d = 0
	d = (b2-b1)%360
	if(d>180):
		d -= 360
	elif(d<-180):
		d += 360
	return d

def Delta_Bearing(b1, b2):
	""""""
	""""""
	d = 0
	if(b1<0):
		b1 += 360
	if(b2<0):
		b2 += 360
	d = (b2 - b1)%360
	if(d>180):
		d -= 360
	elif(d<-180):
		d += 360
	return d

if __name__ == '__main__':
	print()
	print(""Hello World!"")
	print()
	print(Delta_Bearing( 20,45))
	print(Delta_Bearing(-45,45))
	print(Delta_Bearing(-85,90))
	print(Delta_Bearing(-95,90))
	print(Delta_Bearing(-45,125))
	print(Delta_Bearing(-45,145))
	print(Delta_Bearing( 29.4803,-88.6381))
	print(Delta_Bearing(-78.3251, -159.036))
	print(Delta_Bearing(-70099.74233810938,   29840.67437876723))
	print(Delta_Bearing(-165313.6666297357,   33693.9894517456))
	print(Delta_Bearing( 1174.8380510598456, -154146.66490124757))
	print(Delta_Bearing( 60175.77306795546,   42213.07192354373))
	print()
	input(""Press Enter to continue..."")",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/XML/Output,XML/Output,"Create a function that takes a list of character names and a list of corresponding remarks and returns an XML document of <Character> elements each with a name attributes and each enclosing its remarks.
All <Character> elements are to be enclosed in turn, in an outer <CharacterRemarks> element.

As an example, calling the function with the three names of:

April
Tam O'Shanter
Emily
And three remarks of:

Bubbly: I'm > Tam and <= Emily
Burns: ""When chapman billies leave the street ...""
Short & shrift
Should produce the XML (but not necessarily with the indentation):

<CharacterRemarks>
    <Character name=""April"">Bubbly: I'm &gt; Tam and &lt;= Emily</Character>
    <Character name=""Tam O'Shanter"">Burns: ""When chapman billies leave the street ...""</Character>
    <Character name=""Emily"">Short &amp; shrift</Character>
</CharacterRemarks>
The document may include an <?xml?> declaration and document type declaration, but these are optional. If attempting this task by direct string manipulation, the implementation must include code to perform entity substitution for the characters that have entities defined in the XML 1.0 specification.

Note: the example is chosen to show correct escaping of XML strings.
Note too that although the task is written to take two lists of corresponding data, a single mapping/hash/dictionary of names to remarks is also acceptable.

Note to editors: Program output with escaped characters will be viewed as the character on the page so you need to 'escape-the-escapes' to make the RC entry display what would be shown in a plain text viewer (See this).
Alternately, output can be placed in <lang xml></lang> tags without any special treatment.
",Python,">>> from xml.etree import ElementTree as ET
>>> from itertools import izip
>>> def characterstoxml(names, remarks):
	root = ET.Element(""CharacterRemarks"")
	for name, remark in izip(names, remarks):
		c = ET.SubElement(root, ""Character"", {'name': name})
		c.text = remark
	return ET.tostring(root)
 
>>> print characterstoxml(
	names = [""April"", ""Tam O'Shanter"", ""Emily""],
	remarks = [ ""Bubbly: I'm > Tam and <= Emily"",
		    'Burns: ""When chapman billies leave the street ...""',
		    'Short & shrift' ] ).replace('><','>\n<')",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Haversine_formula,Haversine formula,"

 This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes.

It is a special case of a more general formula in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".



Task

Implement a great-circle distance function, or use a library function,
to show the great-circle distance between:

 Nashville International Airport (BNA)   in Nashville, TN, USA,   which is: 
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

 Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius. However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased). When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km. This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.





",Python,"from math import radians, sin, cos, sqrt, asin
 
 
def haversine(lat1, lon1, lat2, lon2):
    R = 6372.8  # Earth radius in kilometers
 
    dLat = radians(lat2 - lat1)
    dLon = radians(lon2 - lon1)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
 
    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2
    c = 2 * asin(sqrt(a))
 
    return R * c
 
>>> haversine(36.12, -86.67, 33.94, -118.40)
2887.2599506071106
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Amicable_pairs,Amicable pairs,"Two integers 



N


{\displaystyle N}

 and 



M


{\displaystyle M}

 are said to be amicable pairs if 



N
≠
M


{\displaystyle N\neq M}

 and the sum of the proper divisors of 



N


{\displaystyle N}

 (




s
u
m

(

p
r
o
p
D
i
v
s

(
N
)
)


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (N))}

) 



=
M


{\displaystyle =M}

 as well as 




s
u
m

(

p
r
o
p
D
i
v
s

(
M
)
)
=
N


{\displaystyle \mathrm {sum} (\mathrm {propDivs} (M))=N}

.



Example

1184 and 1210 are an amicable pair, with proper divisors:

   1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592   and 
   1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605   respectively.


Task

Calculate and show here the Amicable pairs below 20,000; (there are eight).



Related tasks
 Proper divisors
 Abundant, deficient and perfect number classifications
 Aliquot sequence classifications and its amicable classification. 

",Python,"from proper_divisors import proper_divs
 
def amicable(rangemax=20000):
    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}
    for num, divsum in n2divsum.items():
        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:
            yield num, divsum
 
if __name__ == '__main__':
    for num, divsum in amicable():
        print('Amicable pair: %i and %i With proper divisors:\n    %r\n    %r'
              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Echo_server,Echo server,"Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.

The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.

The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.
",Python,"import SocketServer
 
HOST = ""localhost""
PORT = 12321
 
# this server uses ThreadingMixIn - one thread per connection
# replace with ForkMixIn to spawn a new process per connection
 
class EchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    # no need to override anything - default behavior is just fine
    pass
 
class EchoRequestHandler(SocketServer.StreamRequestHandler):
    """"""
    Handles one connection to the client.
    """"""
    def handle(self):
        print ""connection from %s"" % self.client_address[0]
        while True:
            line = self.rfile.readline()
            if not line: break
            print ""%s wrote: %s"" % (self.client_address[0], line.rstrip())
            self.wfile.write(line)
        print ""%s disconnected"" % self.client_address[0]
 
 
# Create the server
server = EchoServer((HOST, PORT), EchoRequestHandler)
 
# Activate the server; this will keep running until you
# interrupt the program with Ctrl-C
print ""server listening on %s:%s"" % server.server_address
server.serve_forever()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,Generate lower case ASCII alphabet,"Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence.

For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code.

During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# From the standard library:
from string import ascii_lowercase
 
# Generation:
lower = [chr(i) for i in range(ord('a'), ord('z') + 1)]",Human_written,Python_from_Go
http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,Strip a set of characters from a string,"Task

Create a function that strips a set of characters from a string.



The function should take two arguments:

   a string to be stripped 
   a string containing the set of characters to be stripped


The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import re
def stripchars(str, chars):
    return re.sub(r'[' + re.escape(chars) + ']', '', str)
 
print(stripchars(""She was a soul stripper. She took my heart!"", ""aei""))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"for i in range(16):
    for j in range(32+i, 127+1, 16):
        if j == 32:
            k = 'Spc'
        elif j == 127:
            k = 'Del'
        else:
            k = chr(j)
        print(""%3d : %-3s"" % (j,k), end="""")
    print()",Human_written,Python_from_C++
http://rosettacode.org/wiki/Truth_table,Truth table,"A truth table is a display of the inputs to, and the output of a Boolean function organized as a table where each row gives one combination of input values and the corresponding value of the function.



Task

 Input a Boolean function from the user as a string then calculate and print a formatted truth table for the given function.
 (One can assume that the user input is correct).
 Print and show output for Boolean functions of two and three input variables, but any program should not be limited to that many variables in the function. 
 Either reverse-polish or infix notation expressions are allowed.


Related tasks

   Boolean values
   Ternary logic


See also

   Wolfram MathWorld entry on truth tables.
   some ""truth table"" examples from Google.

",Python,"while True:
    print(""\ninput a boolean expression (e.g. 'a & b'): "")
    expr = input().strip().lower()
    if expr == """":
        break
    vars = re.findall(r""\p{Alpha}+"", expr)
    if vars == []:
        print(""no variables detected in your boolean expression"")
        continue
    for v in vars:
        print(v, end=""\t"")
    print(""|"", expr)
    prefix = []
    suffix = []
    for v in vars:
        prefix.append(""for "" + v + "" in [False, True]:"")
        suffix.append(""end"")
    body = ""print(""
    for v in vars:
        body += v + "", end='\t', ""
    body += '""| "", eval(expr))'
    exec(""\n"".join(prefix + [body] + suffix))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously,First-class functions/Use numbers analogously,"In First-class functions, a language is showing how its manipulation of functions is similar to its manipulation of other types.

This tasks aim is to compare and contrast a language's implementation of first class functions, with its normal handling of numbers.



Write a program to create an ordered collection of a mixture of literally typed and expressions producing a real number, together with another ordered collection of their multiplicative inverses. Try and use the following pseudo-code to generate the numbers for the ordered collections:

  x  = 2.0
  xi = 0.5
  y  = 4.0
  yi = 0.25
  z  = x + y
  zi = 1.0 / ( x + y )

Create a function multiplier, that given two numbers as arguments returns a function that when called with one argument, returns the result of multiplying the two arguments to the call to multiplier that created it and the argument in the call:

 new_function = multiplier(n1,n2)
 # where new_function(m) returns the result of n1 * n2 * m

Applying the multiplier of a number and its inverse from the two ordered collections of numbers in pairs, show that the result in each case is one.

Compare and contrast the resultant program with the corresponding entry in First-class functions. They should be close.

To paraphrase the task description: Do what was done before, but with numbers rather than functions
",Python,"IDLE 2.6.1      
>>> # Number literals
>>> x,xi, y,yi = 2.0,0.5, 4.0,0.25
>>> # Numbers from calculation
>>> z  = x + y
>>> zi = 1.0 / (x + y)
>>> # The multiplier function is similar to 'compose' but with numbers
>>> multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)
>>> # Numbers as members of collections
>>> numlist = [x, y, z]
>>> numlisti = [xi, yi, zi]
>>> # Apply numbers from list
>>> [multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)]
[0.5, 0.5, 0.5]
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Safe_addition,Safe addition,"Implementation of   interval arithmetic   and more generally fuzzy number arithmetic require operations that yield safe upper and lower bounds of the exact result.

For example, for an addition, it is the operations    +↑    and    +↓    defined as:    a +↓ b ≤ a + b ≤ a +↑ b. 

Additionally it is desired that the width of the interval    (a +↑ b) - (a +↓ b)    would be about the machine epsilon after removing the exponent part.

Differently to the standard floating-point arithmetic, safe interval arithmetic is accurate (but still imprecise).

I.E.:   the result of each defined operation contains (though does not identify) the exact mathematical outcome.

Usually a   FPU's   have machine    +,-,*,/    operations accurate within the machine precision.

To illustrate it, let us consider a machine with decimal floating-point arithmetic that has the precision is 3 decimal points.

If the result of the machine addition is    1.23,    then the exact mathematical result is within the interval    ]1.22, 1.24[. 

When the machine rounds towards zero, then the exact result is within    [1.23,1.24[.    This is the basis for an implementation of safe addition.



Task;
Show how    +↓    and    +↑    can be implemented in your language using the standard floating-point type.

Define an interval type based on the standard floating-point one,   and implement an interval-valued addition of two floating-point numbers considering them exact, in short an operation that yields the interval    [a +↓ b, a +↑ b]. 
",Python,"import ctypes
import sys
import struct
 
def NextUp(d):
    if d == 0.0:
        return sys.float_info.epsilon
    if (math.isnan(d) or math.isinf(d)):
        return d
 
    bytes = struct.pack('f', d)
    dl = struct.unpack('i', bytes)[0]
    dl += 1
    bytes = struct.pack('i', dl)
 
    return struct.unpack('f', bytes)[0]
 
def NextDown(d):
    if d == 0.0:
        return -sys.float_info.epsilon
    if (math.isnan(d) or math.isinf(d)):
        return d
 
    bytes = struct.pack('f', d)
    dl = struct.unpack('i', bytes)[0]
    dl -= 1
    bytes = struct.pack('i', dl)
 
    return struct.unpack('f', bytes)[0]
 
def SafeAdd(a, b):
    return (NextDown(a + b), NextUp(a + b))
 
a = 1.20
b = 0.03
 
print(""({0} + {1}) is in the range {2}"".format(a, b, SafeAdd(a, b)))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Show_ASCII_table,Show ASCII table,"Task

Show  the ASCII character set  from values   32   to   127   (decimal)   in a table format.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"for i in range(16):
    for j in range(32+i, 127+1, 16):
        if j == 32:
            k = 'Spc'
        elif j == 127:
            k = 'Del'
        else:
            k = chr(j)
        print(""%3d : %-3s"" % (j,k), end="""")
    print()",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Sierpinski_carpet,Sierpinski carpet,"Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N.



For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art.

The important requirement is the placement of whitespace and non-whitespace characters.



Related task

   Sierpinski triangle

",Python,"def in_carpet(x, y):
    while True:
        if x == 0 or y == 0:
            return True
        elif x % 3 == 1 and y % 3 == 1:
            return False
 
        x /= 3
        y /= 3
 
def carpet(n):
    for i in xrange(3 ** n):
        for j in xrange(3 ** n):
            if in_carpet(i, j):
                print '*',
            else:
                print ' ',
        print",Human_written,Python_from_C++
http://rosettacode.org/wiki/Terminal_control/Dimensions,Terminal control/Dimensions,"Determine the height and width of the terminal, and store this information into variables for subsequent use.
",Python,"import os
 
def get_windows_terminal():
    from ctypes import windll, create_string_buffer
    h = windll.kernel32.GetStdHandle(-12)
    csbi = create_string_buffer(22)
    res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
 
    #return default size if actual size can't be determined
    if not res: return 80, 25 
 
    import struct
    (bufx, bufy, curx, cury, wattr, left, top, right, bottom, maxx, maxy)\
    = struct.unpack(""hhhhHhhhhhh"", csbi.raw)
    width = right - left + 1
    height = bottom - top + 1
 
    return width, height
 
def get_linux_terminal():
    width = os.popen('tput cols', 'r').readline()
    height = os.popen('tput lines', 'r').readline()
 
    return int(width), int(height)
 
print get_linux_terminal() if os.name == 'posix' else get_windows_terminal()",Human_written,Python_from_C
http://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi,Arithmetic-geometric mean/Calculate Pi,"Almkvist Berndt 1988 begins with an investigation of why the agm is such an efficient algorithm, and proves that it converges quadratically. This is an efficient method to calculate 



π


{\displaystyle \pi }

.

With the same notations used in Arithmetic-geometric mean, we can summarize the paper by writing:





π
=



4


a
g
m

(
1
,
1

/



2



)

2




1
−

∑

n
=
1


∞



2

n
+
1


(

a

n


2


−

g

n


2


)





{\displaystyle \pi ={\frac {4\;\mathrm {agm} (1,1/{\sqrt {2}})^{2}}{1-\sum \limits _{n=1}^{\infty }2^{n+1}(a_{n}^{2}-g_{n}^{2})}}}



This allows you to make the approximation, for any large   N:





π
≈



4


a

N


2




1
−

∑

k
=
1


N



2

k
+
1


(

a

k


2


−

g

k


2


)





{\displaystyle \pi \approx {\frac {4\;a_{N}^{2}}{1-\sum \limits _{k=1}^{N}2^{k+1}(a_{k}^{2}-g_{k}^{2})}}}



The purpose of this task is to demonstrate how to use this approximation in order to compute a large number of decimals of 



π


{\displaystyle \pi }

.
",Python,"from decimal import *
 
D = Decimal
getcontext().prec = 100
a = n = D(1)
g, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)
for i in range(18):
    x = [(a + g) * half, (a * g).sqrt()]
    var = x[0] - a
    z -= var * var * n
    n += n
    a, g = x    
print(a * a / z)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Variadic_function,Variadic function,"Task

Create a function which takes in a variable number of arguments and prints each one on its own line.

Also show, if possible in your language, how to call the function on a list of arguments constructed at runtime.



Functions of this type are also known as Variadic Functions.



Related task

   Call a function

",Python,"from __future__ import print_function
 
def print(*args):
  for arg in args:
    print(arg, end='')
 
if __name__ == '__main__':
  i = 10
  s = ""Hello world""
  print(""i = "", i, "" and s = \"""", s, ""\""\n"")",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Magic_squares_of_odd_order,Magic squares of odd order,"A magic square is an   NxN   square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,   and   both long (main) diagonals are equal to the same sum (which is called the   magic number   or   magic constant).

The numbers are usually (but not always) the first   N2   positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.



 8 
 1 
 6


 3 
 5 
 7


 4 
 9 
 2



Task
For any odd   N,   generate a magic square with the integers    1 ──► N,   and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for   N = 5.



 Related tasks
 Magic squares of singly even order
 Magic squares of doubly even order



 See also

 MathWorld™ entry: Magic_square 
 Odd Magic Squares (1728.org)

",Python,"#include <iostream>
#include <sstream>
#include <iomanip>
#include <cassert>
#include <vector>
 
class MagicSquare:
 
    def __init__(self, d):
        self.sqr = [0] * (d*d)
        self.sz = d
        assert(d&1)
        self.fillSqr()
 
    def display(self):
        print ""Odd Magic Square: "", self.sz, "" x "", self.sz
        print ""It's Magic Sum is: "", self.magicNumber()
        print ""\n""
        cvr = str(self.sz * self.sz)
        l = len(cvr)
 
        for y in range(0, self.sz):
            yy = y * self.sz
            for x in range(0, self.sz):
                print ""%*d"" % (l + 2, self.sqr[yy + x]),
            print ""\n""
        print ""\n\n""
 
    def fillSqr(self):
        sx = self.sz / 2
        sy = 0
        c = 0
        while c < self.sz * self.sz:
            if not self.sqr[sx + sy * self.sz]:
                self.sqr[sx + sy * self.sz] = c + 1
                self.inc(sx)
                self.dec(sy)
                c += 1
            else:
                self.dec(sx)
                self.inc(sy)
                self.inc(sy)
 
    def magicNumber(self):
        return self.sz * ( ( self.sz * self.sz ) + 1 ) / 2
 
    def inc(self, a):
        if a == self.sz:
            a = 0
 
    def dec(self, a):
        if a < 0:
            a = self.sz - 1
 
    def checkPos(self, x, y):
        return( self.isInside( x ) and self.isInside( y ) and not self.sqr[self.sz * y + x] )
 
    def isInside(self, s):
        return ( s < self.sz and s > -1 )
 
s = MagicSquare(7)
s.display()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Shortest_common_supersequence,Shortest common supersequence,"The   shortest common supersequence   is a problem closely related to the   longest common subsequence,   which you can use as an external function for this task.



Task

Given two strings 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

, find the shortest possible sequence 



s


{\displaystyle s}

, which is the shortest common super-sequence of 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 where both 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 are a subsequence of 



s


{\displaystyle s}

. Defined as such, 



s


{\displaystyle s}

 is not necessarily unique.

Demonstrate this by printing 



s


{\displaystyle s}

 where 



u
=


{\displaystyle u=}

“abcbdab” and 



v
=


{\displaystyle v=}

“bdcaba”.



Also see

 Wikipedia: shortest common supersequence 

",Python,"# Use the Longest Common Subsequence algorithm
 
def shortest_common_supersequence(a, b):
    lcs = longest_common_subsequence(a, b)
    scs = """"
    # Consume lcs
    while len(lcs) > 0:
        if a[0]==lcs[0] and b[0]==lcs[0]:
        # Part of the LCS, so consume from all strings
            scs += lcs[0]
            lcs = lcs[1:]
            a = a[1:]
            b = b[1:]
        elif a[0]==lcs[0]:
            scs += b[0]
            b = b[1:]
        else:
            scs += a[0]
            a = a[1:]
    # append remaining characters
    return scs + a + b",Human_written,Python_from_C
http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls,GUI enabling/disabling of controls,"In addition to fundamental GUI component interaction, an application should
dynamically enable and disable GUI components, to give some guidance to the
user, and prohibit (inter)actions which are inappropriate in the current state
of the application.



Task

Similar to the task GUI component interaction, write a program
that presents a form with three components to the user:

   a numeric input field (""Value"") 
   a button   (""increment"")
   a button   (""decrement"")


The field is initialized to zero.
The user may manually enter a new value into the field,
increment its value with the ""increment"" button,
or decrement the value with the ""decrement"" button.

The input field should be enabled only when its value is zero.
The ""increment"" button only as long as the field's value is less then 10:
When the value 10 is reached, the button should go into a disabled state.
Analogously, the ""decrement"" button should be enabled only as long as
the value is greater than zero.

Effectively, the user can now either increment up to 10, or down to zero.
Manually entering values outside that range is still legal,
but the buttons should reflect that and enable/disable accordingly.



",Python,"#!/usr/bin/env python3
 
import tkinter as tk
 
class MyForm(tk.Frame):
 
    def __init__(self, master=None):
        tk.Frame.__init__(self, master)
        self.pack(expand=True, fill=""both"", padx=10, pady=10)
        self.master.title(""Controls"")
        self.setupUI()
 
    def setupUI(self):
        self.value_entry = tk.Entry(self, justify=tk.CENTER)
        self.value_entry.grid(row=0, column=0, columnspan=2,
                              padx=5, pady=5, sticky=""nesw"")
        self.value_entry.insert('end', '0')
        self.value_entry.bind(""<KeyPress-Return>"", self.eventHandler)
 
        self.decre_btn = tk.Button(self, text=""Decrement"", state=tk.DISABLED)
        self.decre_btn.grid(row=1, column=0, padx=5, pady=5)
        self.decre_btn.bind(""<Button-1>"", self.eventHandler)
 
        self.incre_btn = tk.Button(self, text=""Increment"")
        self.incre_btn.grid(row=1, column=1, padx=5, pady=5)
        self.incre_btn.bind(""<Button-1>"", self.eventHandler)
 
    def eventHandler(self, event):
        value = int(self.value_entry.get())
        if event.widget == self.value_entry:
            if value > 10:
                self.value_entry.delete(""0"", ""end"")
                self.value_entry.insert(""end"", ""0"")
            elif value == 10:
                self.value_entry.config(state=tk.DISABLED)
                self.incre_btn.config(state=tk.DISABLED)
                self.decre_btn.config(state=tk.NORMAL)
            elif value == 0:
                self.value_entry.config(state=tk.NORMAL)
                self.incre_btn.config(state=tk.NORMAL)
                self.decre_btn.config(state=tk.DISABLED)
            elif (value > 0) and (value < 10):
                self.value_entry.config(state=tk.DISABLED)
                self.incre_btn.config(state=tk.NORMAL)
                self.decre_btn.config(state=tk.NORMAL)
        else:
            if event.widget == self.incre_btn:
                if (value >= 0) and (value < 10):
                    value += 1
                    self.value_entry.config(state=tk.NORMAL)
                    self.value_entry.delete(""0"", ""end"")
                    self.value_entry.insert(""end"", str(value))
                if value > 0:
                    self.decre_btn.config(state=tk.NORMAL)
                    self.value_entry.config(state=tk.DISABLED)
                if value == 10:
                    self.incre_btn.config(state=tk.DISABLED)
            elif event.widget == self.decre_btn:
                if (value > 0) and (value <= 10):
                    value -= 1
                    self.value_entry.config(state=tk.NORMAL)
                    self.value_entry.delete(""0"", ""end"")
                    self.value_entry.insert(""end"", str(value))
                    self.value_entry.config(state=tk.DISABLED)
                if (value) < 10:
                    self.incre_btn.config(state=tk.NORMAL)
                if (value) == 0:
                    self.decre_btn.config(state=tk.DISABLED)
                    self.value_entry.config(state=tk.NORMAL)
 
def main():
    app = MyForm()
    app.mainloop()
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",Python,">>> float('infinity')
inf",Human_written,Python_from_C
http://rosettacode.org/wiki/Primality_by_Wilson%27s_theorem,Primality by Wilson's theorem,"Task

Write a boolean function that tells whether a given integer is prime using Wilson's theorem.

By Wilson's theorem, a number p is prime if and only if p divides (p - 1)! + 1.

Remember that 1 and all non-positive integers are not prime.



See also

 Cut-the-knot: Wilson's theorem.
 Wikipedia: Wilson's theorem

",Python,"def w_prime(i):
    if i < 2:
        return False
    return (1 + sum(range(1, i))) % i == 0
 
print([i for i in range(1, 101) if w_prime(i)])",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/CSV_data_manipulation,CSV data manipulation,"CSV spreadsheet files are suitable for storing tabular data in a relatively portable way.

The CSV format is flexible but somewhat ill-defined.

For present purposes, authors may assume that the data fields contain no commas, backslashes, or quotation marks.



Task

Read a CSV file, change some values and save the changes back to a file.

For this task we will use the following CSV file:

C1,C2,C3,C4,C5
1,5,9,13,17
2,6,10,14,18
3,7,11,15,19
4,8,12,16,20

Suggestions


 Show how to add a column, headed 'SUM', of the sums of the rows.
 If possible, illustrate the use of built-in or standard functions, methods, or libraries, that handle generic CSV files.


",Python,"import csv
# read:
ar = csv.reader(open(""test.csv""))
 
# manipulate:
ar.next()
ar.next()
ar.next()
ar.next()
 
# write:
csv.writer(open(""out.csv"", 'w')).writerows(ar)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Assertions,Assertions,"Assertions are a way of breaking out of code when there is an error or an unexpected input.

Some languages throw exceptions and some treat it as a break point.



Task

Show an assertion in your language by asserting that an integer variable is equal to 42.



",Python,"a = 5
#...input or change a here
assert a == 42 # throws an AssertionError when a is not 42
assert a == 42, ""Error message"" # throws an AssertionError
       # when a is not 42 with ""Error message"" for the message
       # the error message can be any expression",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Casting_out_nines,Casting out nines,"Task   (in three parts)



Part 1
Write a procedure (say 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

) which implements Casting Out Nines as described by returning the checksum for 



x


{\displaystyle x}

. Demonstrate the procedure using the examples given there, or others you may consider lucky.

Part 2
Notwithstanding past Intel microcode errors, checking computer calculations like this would not be sensible. To find a computer use for your procedure:

 Consider the statement ""318682 is 101558 + 217124 and squared is 101558217124"" (see: Kaprekar numbers#Casting Out Nines (fast)).
 note that 



318682


{\displaystyle 318682}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

);
 note that 



101558217124


{\displaystyle 101558217124}

 has the same checksum as (



101558
+
217124


{\displaystyle 101558+217124}

) because for a Kaprekar they are made up of the same digits (sometimes with extra zeroes);
 note that this implies that for Kaprekar numbers the checksum of 



k


{\displaystyle k}

 equals the checksum of 




k

2




{\displaystyle k^{2}}

.
Demonstrate that your procedure can be used to generate or filter a range of numbers with the property 





c
o
9


(
k
)
=


c
o
9


(

k

2


)


{\displaystyle {\mathit {co9}}(k)={\mathit {co9}}(k^{2})}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.

Part 3
Considering this MathWorld page, produce a efficient algorithm based on the more mathematical treatment of Casting Out Nines, and realizing:

 





c
o
9


(
x
)


{\displaystyle {\mathit {co9}}(x)}

 is the residual of 



x


{\displaystyle x}

 mod 



9


{\displaystyle 9}

;
 the procedure can be extended to bases other than 9.
Demonstrate your algorithm by generating or filtering a range of numbers with the property 



k
%
(


B
a
s
e


−
1
)
==
(

k

2


)
%
(


B
a
s
e


−
1
)


{\displaystyle k\%({\mathit {Base}}-1)==(k^{2})\%({\mathit {Base}}-1)}

 and show that this subset is a small proportion of the range and contains all the Kaprekar in the range.



related tasks
 First perfect square in base N with N unique digits
 Kaprekar numbers

",Python,"# Casting out Nines
#
# Nigel Galloway: June 27th., 2012,
#
def CastOut(Base=10, Start=1, End=999999):
  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]
  x,y = divmod(Start, Base-1)
  while True:
    for n in ran:
      k = (Base-1)*x + n
      if k < Start:
        continue
      if k > End:
        return
      yield k
    x += 1
 
for V in CastOut(Base=16,Start=1,End=255):
  print(V, end=' ')",Human_written,Python_from_C
http://rosettacode.org/wiki/Stirling_numbers_of_the_first_kind,Stirling numbers of the first kind,"Stirling numbers of the first kind, or Stirling cycle numbers, count permutations according to their number
of cycles (counting fixed points as cycles of length one).

They may be defined directly to be the number of permutations of n
elements with k disjoint cycles.

Stirling numbers of the first kind express coefficients of polynomial expansions of falling or rising factorials.

Depending on the application, Stirling numbers of the first kind may be ""signed""
or ""unsigned"". Signed Stirling numbers of the first kind arise when the
polynomial expansion is expressed in terms of falling factorials; unsigned when
expressed in terms of rising factorials. The only substantial difference is that,
for signed Stirling numbers of the first kind, values of S1(n, k) are negative
when n + k is odd.

Stirling numbers of the first kind follow the simple identities:

   S1(0, 0) = 1
   S1(n, 0) = 0 if n > 0
   S1(n, k) = 0 if k > n
   S1(n, k) = S1(n - 1, k - 1) + (n - 1) * S1(n - 1, k) # For unsigned
     or
   S1(n, k) = S1(n - 1, k - 1) - (n - 1) * S1(n - 1, k) # For signed



Task

 Write a routine (function, procedure, whatever) to find Stirling numbers of the first kind. There are several methods to generate Stirling numbers of the first kind. You are free to choose the most appropriate for your language. If your language has a built-in, or easily, publicly available library implementation, it is acceptable to use that.
 Using the routine, generate and show here, on this page, a table (or triangle) showing the Stirling numbers of the first kind, S1(n, k), up to S1(12, 12). it is optional to show the row / column for n == 0 and k == 0. It is optional to show places where S1(n, k) == 0 (when k > n). You may choose to show signed or unsigned Stirling numbers of the first kind, just make a note of which was chosen.
 If your language supports large integers, find and show here, on this page, the maximum value of S1(n, k) where n == 100.


See also

 Wikipedia - Stirling numbers of the first kind
 OEIS:A008275 - Signed Stirling numbers of the first kind
 OEIS:A130534 - Unsigned Stirling numbers of the first kind


Related Tasks

 Stirling numbers of the second kind
 Lah numbers

",Python,"computed = {}
 
def sterling1(n, k):
	key = str(n) + "","" + str(k)
 
	if key in computed.keys():
		return computed[key]
	if n == k == 0:
		return 1
	if n > 0 and k == 0:
		return 0
	if k > n:
		return 0
	result = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)
	computed[key] = result
	return result
 
print(""Unsigned Stirling numbers of the first kind:"")
MAX = 12
print(""n/k"".ljust(10), end="""")
for n in range(MAX + 1):
	print(str(n).rjust(10), end="""")
print()
for n in range(MAX + 1):
	print(str(n).ljust(10), end="""")
	for k in range(n + 1):
		print(str(sterling1(n, k)).rjust(10), end="""")
	print()
print(""The maximum value of S1(100, k) = "")
previous = 0
for k in range(1, 100 + 1):
	current = sterling1(100, k)
	if current > previous:
		previous = current
	else:
		print(""{0}\n({1} digits, k = {2})\n"".format(previous, len(str(previous)), k - 1))
		break",Human_written,Python_from_Java
http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player),Guess the number/With feedback (player),"Task

Write a player for the game that follows the following rules:

The scorer will choose a number between set limits. The computer player will print a guess of the target number. The computer asks for a score of whether its guess is higher than, lower than, or equal to the target. The computer guesses, and the scorer scores, in turn, until the computer correctly guesses the target number.
The computer should guess intelligently based on the accumulated scores given. One way is to use a Binary search based algorithm.



Related tasks

   Guess the number/With Feedback
   Bulls and cows/Player

",Python,"inclusive_range = mn, mx = (1, 10)
 
print('''\
Think of a number between %i and %i and wait for me to guess it.
On every guess of mine you should state whether the guess was
too high, too low, or equal to your number by typing h, l, or =
''' % inclusive_range)
 
i = 0
while True:
    i += 1
    guess = (mn+mx)//2
    txt = input(""Guess %2i is: %2i. The score for which is (h,l,=): ""
                % (i, guess)).strip().lower()[0]
    if txt not in 'hl=':
        print(""  I don't understand your input of '%s' ?"" % txt)
        continue
    if txt == 'h':
        mx = guess-1
    if txt == 'l':
        mn = guess+1
    if txt == '=':
        print(""  Ye-Haw!!"")
        break
    if (mn > mx) or (mn < inclusive_range[0]) or (mx > inclusive_range[1]):
        print(""Please check your scoring as I cannot find the value"")
        break
 
print(""\nThanks for keeping score."")",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Harshad_or_Niven_series,Harshad or Niven series,"The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.

For example,   42   is a Harshad number as   42   is divisible by   (4 + 2)   without remainder.

Assume that the series is defined as the numbers in increasing order.



Task

The task is to create a function/method/procedure to generate successive members of the Harshad sequence.

Use it to:

   list the first 20 members of the sequence,   and
   list the first Harshad number greater than 1000.


Show your output here.



Related task
   Increasing gaps between consecutive Niven numbers


See also
    OEIS: A005349

",Python,">>> import itertools
>>> def harshad():
	for n in itertools.count(1):
		if n % sum(int(ch) for ch in str(n)) == 0:
			yield n
 
 
>>> list(itertools.islice(harshad(), 0, 20))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]
>>> for n in harshad():
	if n > 1000:
		print(n)
		break
 
 
1002
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Python,"def solve( problem ):
    lines = problem.split(""."")
    names = lines[0].split()
    re_names = re.compile( ""|"".join( names ) )
    # Later on, search for these keywords (the word ""not"" is handled separately).
    words = [ ""first"", ""second"", ""third"", ""fourth"", ""fifth"", ""sixth"", ""seventh"", ""eighth"", ""ninth"", ""tenth"", ""bottom"", ""top"", ""higher"", ""lower"", ""adjacent"" ]
    re_keywords = re.compile( ""|"".join( words ) )

    predicates = []
    for line in lines[1:-1]:
        keywords = re_keywords.findall( line )
        name1, name2 = re_names.findall( line )
        for keyword in keywords:
            l = lambda c: c[words.index(keyword)] == name1
            if keyword == ""bottom"":
                l = lambda c: c[0] == name1
            elif keyword == ""top"":
                l = lambda c: c[-1] == name1
            elif keyword == ""higher"":
                l = lambda c: c.index( name1 ) > c.index( name2 )
            elif keyword == ""lower"":
                l = lambda c: c.index( name1 ) < c.index( name2 )
            elif keyword == ""adjacent"":
                l = lambda c: abs( c.index( name1 ) - c.index( name2 ) ) == 1
            if ""not"" in line:
                l = lambda c: not l(c)
            predicates.append( l )

    for candidate in itertools.permutations( names ):
        if all( predicate(candidate) for predicate in predicates ):
            return candidate",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Euler%27s_sum_of_powers_conjecture,Euler's sum of powers conjecture,"There is a conjecture in mathematics that held for over two hundred years before it was disproved by the finding of a counterexample in 1966 by Lander and Parkin.



Euler's (disproved) sum of powers   conjecture

  At least  k  positive  kth  powers are required to sum to a  kth  power,  
  except for the trivial case of one  kth power:  yk = yk 



In 1966,   Leon J. Lander   and   Thomas R. Parkin   used a brute-force search on a   CDC 6600   computer restricting numbers to those less than 250.



Task

Write a program to search for an integer solution for:


  x05 + x15 + x25 + x35 == y5 

Where all     xi's   and    y    are distinct integers between   0   and   250   (exclusive).

Show an answer here.



Related tasks

   Pythagorean quadruples. 
   Pythagorean triples.

",Python,"p5 = [i**5 for i in range(250)]
found = False
for x0 in range(250):
    for x1 in range(x0):
        for x2 in range(x1):
            for x3 in range(x2):
                sum = p5[x0] + p5[x1] + p5[x2] + p5[x3]
                y = bisect_left(p5, sum)
                if y < len(p5) and p5[y] == sum:
                    print(f""{x0}^5 + {x1}^5 + {x2}^5 + {x3}^5 = {y}^5"")
                    found = True
                    break
if not found:
    print(""No solution was found"")",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Matrix_chain_multiplication,Matrix chain multiplication,"Problem
Using the most straightfoward algorithm (which we assume here), computing the product of two matrices of dimensions (n1,n2) and (n2,n3) requires n1*n2*n3 FMA operations. The number of operations required to compute the product of matrices A1, A2... An depends on the order of matrix multiplications, hence on where parens are put. Remember that the matrix product is associative, but not commutative, hence only the parens can be moved.

For instance, with four matrices, one can compute A(B(CD)), A((BC)D), (AB)(CD), (A(BC))D, (AB)C)D. The number of different ways to put the parens is a Catalan number, and grows exponentially with the number of factors.

Here is an example of computation of the total cost, for matrices A(5,6), B(6,3), C(3,1):

 AB costs 5*6*3=90 and produces a matrix of dimensions (5,3), then (AB)C costs 5*3*1=15. The total cost is 105.
 BC costs 6*3*1=18 and produces a matrix of dimensions (6,1), then A(BC) costs 5*6*1=30. The total cost is 48.
In this case, computing (AB)C requires more than twice as many operations as A(BC). The difference can be much more dramatic in real cases.

Task
Write a function which, given a list of the successive dimensions of matrices A1, A2... An, of arbitrary length, returns the optimal way to compute the matrix product, and the total cost. Any sensible way to describe the optimal solution is accepted. The input list does not duplicate shared dimensions: for the previous example of matrices A,B,C, one will only pass the list [5,6,3,1] (and not [5,6,6,3,3,1]) to mean the matrix dimensions are respectively (5,6), (6,3) and (3,1). Hence, a product of n matrices is represented by a list of n+1 dimensions.

Try this function on the following two lists:

 [1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2]
 [1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10]
To solve the task, it's possible, but not required, to write a function that enumerates all possible ways to parenthesize the product. This is not optimal because of the many duplicated computations, and this task is a classic application of dynamic programming.

See also Matrix chain multiplication on Wikipedia.
",Python,"def parens(n):
    def aux(n, k):
        if n == 1:
            yield k
        elif n == 2:
            yield [k, k + 1]
        else:
            a = []
            for i in range(1, n):
                for u in aux(i, k):
                    for v in aux(n - i, k + i):
                        yield [u, v]
    yield from aux(n, 0)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Chinese_zodiac,Chinese zodiac,"Traditionally, the Chinese have counted years using two simultaneous cycles, one of length 10 (the ""celestial stems"") and one of length 12 (the ""terrestrial branches""); the combination results in a repeating 60-year pattern. Mapping the branches to twelve traditional animal deities results in the well-known ""Chinese zodiac"", assigning each year to a given animal. For example, Tuesday, February 1, 2022 CE (in the common Gregorian calendar) will begin the lunisolar Year of the Tiger.

The celestial stems have no one-to-one mapping like that of the branches to animals; however, the five pairs of consecutive stems each belong to one of the five traditional Chinese elements (Wood, Fire, Earth, Metal, and Water). Further, one of the two years within each element's governance is associated with yin, the other with yang.

Thus, 2022 is also the yang year of Water. Note that since 12 is an even number, the association between animals and yin/yang doesn't change. Consecutive Years of the Rooster will cycle through the five elements, but will always be yin, despite the apparent conceptual mismatch between the specifically-male English animal name and the female aspect denoted by yin.

Task
 Create a subroutine or program that will return or output the animal, yin/yang association, and element for the lunisolar year that begins in a given CE year.
You may optionally provide more information in the form of the year's numerical position within the 60-year cycle and/or its actual Chinese stem-branch name (in Han characters or Pinyin transliteration).

Requisite information

 The animal cycle runs in this order: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.
 The element cycle runs in this order: Wood, Fire, Earth, Metal, Water.
 The yang year precedes the yin year within each element.
 The current 60-year cycle began in 1984 CE; the first cycle of the Common Era began in 4 CE.
Thus, 1984 was the year of the Wood Rat (yang), 1985 was the year of the Wood Ox (yin), and 1986 the year of the Fire Tiger (yang); 2022 - which, as already noted, is the year of the Water Tiger (yang) - is the 39th year of the current cycle.

Information for optional task

 The ten celestial stems are 甲 jiă, 乙 yĭ, 丙 bĭng, 丁 dīng, 戊 wù, 己 jĭ, 庚 gēng, 辛 xīn, 壬 rén, and 癸 gŭi. With the ASCII version of Pinyin tones, the names are written ""jia3"", ""yi3"", ""bing3"", ""ding1"", ""wu4"", ""ji3"", ""geng1"", ""xin1"", ""ren2"", and ""gui3"".
 The twelve terrestrial branches are 子 zĭ, 丑 chŏu, 寅 yín, 卯 măo, 辰 chén, 巳 sì, 午 wŭ, 未 wèi, 申 shēn, 酉 yŏu, 戌 xū, 亥 hài. In ASCII Pinyin, those are ""zi3"", ""chou3"", ""yin2"", ""mao3"", ""chen2"", ""si4"", ""wu3"", ""wei4"", ""shen1"", ""you3"", ""xu1"", and ""hai4"".
Therefore 1984 was 甲子 (jiă-zĭ, or jia3-zi3). 2022 is 壬寅 (rén-yín or ren2-yin2).
",Python,"animals = [""Rat"", ""Ox"", ""Tiger"", ""Rabbit"", ""Dragon"", ""Snake"", ""Horse"", ""Goat"", ""Monkey"", ""Rooster"", ""Dog"", ""Pig""]
elements = [""Wood"", ""Fire"", ""Earth"", ""Metal"", ""Water""]
 
def getElement(year):
    element = int(math.floor((year - 4) % 10 / 2))
    return elements[element]
 
def getAnimal(year):
    return animals[(year - 4) % 12]
 
def getYY(year):
    if year % 2 == 0:
        return ""yang""
    else:
        return ""yin""
 
years = [1935, 1938, 1968, 1972, 1976, 2017]
 
for year in years:
    print(""%d is the year of the %s %s (%s)."" % (year, getElement(year), getAnimal(year), getYY(year)))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Continued_fraction,Continued fraction,"continued fraction
Mathworld





a

0


+









b

1












a

1


+









b

2












a

2


+









b

3












a

3


+
⋱

















{\displaystyle a_{0}+{\cfrac {b_{1}}{a_{1}+{\cfrac {b_{2}}{a_{2}+{\cfrac {b_{3}}{a_{3}+\ddots }}}}}}}


The task is to write a program which generates such a number and prints a real representation of it. The code should be tested by calculating and printing the square root of 2, Napier's Constant, and Pi, using the following coefficients:

For the square root of 2, use 




a

0


=
1


{\displaystyle a_{0}=1}

 then 




a

N


=
2


{\displaystyle a_{N}=2}

. 




b

N




{\displaystyle b_{N}}

 is always 



1


{\displaystyle 1}

.







2


=
1
+








1









2
+








1









2
+








1









2
+
⋱

















{\displaystyle {\sqrt {2}}=1+{\cfrac {1}{2+{\cfrac {1}{2+{\cfrac {1}{2+\ddots }}}}}}}


For Napier's Constant, use 




a

0


=
2


{\displaystyle a_{0}=2}

, then 




a

N


=
N


{\displaystyle a_{N}=N}

. 




b

1


=
1


{\displaystyle b_{1}=1}

 then 




b

N


=
N
−
1


{\displaystyle b_{N}=N-1}

.





e
=
2
+








1









1
+








1









2
+








2









3
+








3









4
+
⋱






















{\displaystyle e=2+{\cfrac {1}{1+{\cfrac {1}{2+{\cfrac {2}{3+{\cfrac {3}{4+\ddots }}}}}}}}}


For Pi, use 




a

0


=
3


{\displaystyle a_{0}=3}

 then 




a

N


=
6


{\displaystyle a_{N}=6}

. 




b

N


=
(
2
N
−
1

)

2




{\displaystyle b_{N}=(2N-1)^{2}}

.





π
=
3
+








1









6
+








9









6
+








25









6
+
⋱

















{\displaystyle \pi =3+{\cfrac {1}{6+{\cfrac {9}{6+{\cfrac {25}{6+\ddots }}}}}}}




See also

   Continued fraction/Arithmetic for tasks that do arithmetic over continued fractions.

",Python,"from fractions import Fraction
import itertools
try: zip = itertools.izip
except: pass
 
# The Continued Fraction
def CF(a, b, t):
  terms = list(itertools.islice(zip(a, b), t))
  z = Fraction(1,1)
  for a, b in reversed(terms):
    z = a + b / z
  return z
 
# Approximates a fraction to a string
def pRes(x, d):
  q, x = divmod(x, 1)
  res = str(q)
  res += "".""
  for i in range(d):
    x *= 10
    q, x = divmod(x, 1)
    res += str(q)
  return res
 
# Test the Continued Fraction for sqrt2
def sqrt2_a():
  yield 1
  for x in itertools.repeat(2):
    yield x
 
def sqrt2_b():
  for x in itertools.repeat(1):
    yield x
 
cf = CF(sqrt2_a(), sqrt2_b(), 950)
print(pRes(cf, 200))
#1.41421356237309504880168872420969807856967187537694807317667973799073247846210703885038753432764157273501384623091229702492483605585073721264412149709993583141322266592750559275579995050115278206057147
 
 
# Test the Continued Fraction for Napier's Constant
def Napier_a():
  yield 2
  for x in itertools.count(1):
    yield x
 
def Napier_b():
  yield 1
  for x in itertools.count(1):
    yield x
 
cf = CF(Napier_a(), Napier_b(), 950)
print(pRes(cf, 200))
#2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901
 
# Test the Continued Fraction for Pi
def Pi_a():
  yield 3
  for x in itertools.repeat(6):
    yield x
 
def Pi_b():
  for x in itertools.count(1,2):
    yield x*x
 
cf = CF(Pi_a(), Pi_b(), 950)
print(pRes(cf, 10))
#3.1415926532",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Zeckendorf_number_representation,Zeckendorf number representation,"Just as numbers can be represented in a positional notation as sums of multiples of the powers of ten (decimal) or two (binary); all the positive integers can be represented as the sum of one or zero times the distinct members of the Fibonacci series.

Recall that the first six distinct Fibonacci numbers are: 1, 2, 3, 5, 8, 13.

The decimal number eleven can be written as 0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1 or 010100 in positional notation where the columns represent multiplication by a particular member of the sequence. Leading zeroes are dropped so that 11 decimal becomes 10100.

10100 is not the only way to make 11 from the Fibonacci numbers however; 0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1 or 010011 would also represent decimal 11. For a true Zeckendorf number there is the added restriction that no two consecutive Fibonacci numbers can be used which leads to the former unique solution.



Task

Generate and show here a table of the Zeckendorf number representations of the decimal numbers zero to twenty, in order.

The intention in this task to find the Zeckendorf form of an arbitrary integer. The Zeckendorf form can be iterated by some bit twiddling rather than calculating each value separately but leave that to another separate task.



Also see

   OEIS A014417   for the the sequence of required results.
   Brown's Criterion - Numberphile


Related task

   Fibonacci sequence

",Python,"def zeckendorf():
    x = 0
    while True:
        bin = bin(x)
        if ""11"" not in bin:
            yield bin
        x += 1
 
for i, x in enumerate(zeckendorf()):
    print(""%3d: %8s""% (i, x))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/LU_decomposition,LU decomposition,"Every square matrix 



A


{\displaystyle A}

 can be decomposed into a product of a lower triangular matrix 



L


{\displaystyle L}

 and a upper triangular matrix 



U


{\displaystyle U}

,
as described in LU decomposition.





A
=
L
U


{\displaystyle A=LU}


It is a modified form of Gaussian elimination.
While the Cholesky decomposition only works for symmetric,
positive definite matrices, the more general LU decomposition
works for any square matrix.

There are several algorithms for calculating L and U.
To derive Crout's algorithm for a 3x3 example,
we have to solve the following system:





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(




l

11




0


0





l

21





l

22




0





l

31





l

32





l

33





)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}l_{11}&0&0\\l_{21}&l_{22}&0\\l_{31}&l_{32}&l_{33}\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}=LU}


We now would have to solve 9 equations with 12 unknowns. To make the system uniquely solvable, usually the diagonal elements of 



L


{\displaystyle L}

 are set to 1






l

11


=
1


{\displaystyle l_{11}=1}







l

22


=
1


{\displaystyle l_{22}=1}







l

33


=
1


{\displaystyle l_{33}=1}


so we get a solvable system of 9 unknowns and 9 equations.





A
=


(




a

11





a

12





a

13







a

21





a

22





a

23







a

31





a

32





a

33





)


=


(



1


0


0





l

21




1


0





l

31





l

32




1



)




(




u

11





u

12





u

13






0



u

22





u

23






0


0



u

33





)


=


(




u

11





u

12





u

13







u

11



l

21





u

12



l

21


+

u

22





u

13



l

21


+

u

23







u

11



l

31





u

12



l

31


+

u

22



l

32





u

13



l

31


+

u

23



l

32


+

u

33





)


=
L
U


{\displaystyle A={\begin{pmatrix}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{pmatrix}}={\begin{pmatrix}1&0&0\\l_{21}&1&0\\l_{31}&l_{32}&1\\\end{pmatrix}}{\begin{pmatrix}u_{11}&u_{12}&u_{13}\\0&u_{22}&u_{23}\\0&0&u_{33}\end{pmatrix}}={\begin{pmatrix}u_{11}&u_{12}&u_{13}\\u_{11}l_{21}&u_{12}l_{21}+u_{22}&u_{13}l_{21}+u_{23}\\u_{11}l_{31}&u_{12}l_{31}+u_{22}l_{32}&u_{13}l_{31}+u_{23}l_{32}+u_{33}\end{pmatrix}}=LU}


Solving for the other 



l


{\displaystyle l}

 and 



u


{\displaystyle u}

, we get the following equations:






u

11


=

a

11




{\displaystyle u_{11}=a_{11}}







u

12


=

a

12




{\displaystyle u_{12}=a_{12}}







u

13


=

a

13




{\displaystyle u_{13}=a_{13}}







u

22


=

a

22


−

u

12



l

21




{\displaystyle u_{22}=a_{22}-u_{12}l_{21}}







u

23


=

a

23


−

u

13



l

21




{\displaystyle u_{23}=a_{23}-u_{13}l_{21}}







u

33


=

a

33


−
(

u

13



l

31


+

u

23



l

32


)


{\displaystyle u_{33}=a_{33}-(u_{13}l_{31}+u_{23}l_{32})}


and for 



l


{\displaystyle l}

:






l

21


=


1

u

11





a

21




{\displaystyle l_{21}={\frac {1}{u_{11}}}a_{21}}







l

31


=


1

u

11





a

31




{\displaystyle l_{31}={\frac {1}{u_{11}}}a_{31}}







l

32


=


1

u

22




(

a

32


−

u

12



l

31


)


{\displaystyle l_{32}={\frac {1}{u_{22}}}(a_{32}-u_{12}l_{31})}


We see that there is a calculation pattern, which can be expressed as the following formulas, first for 



U


{\displaystyle U}








u

i
j


=

a

i
j


−

∑

k
=
1


i
−
1



u

k
j



l

i
k




{\displaystyle u_{ij}=a_{ij}-\sum _{k=1}^{i-1}u_{kj}l_{ik}}


and then for 



L


{\displaystyle L}








l

i
j


=


1

u

j
j




(

a

i
j


−

∑

k
=
1


j
−
1



u

k
j



l

i
k


)


{\displaystyle l_{ij}={\frac {1}{u_{jj}}}(a_{ij}-\sum _{k=1}^{j-1}u_{kj}l_{ik})}


We see in the second formula that to get the 




l

i
j




{\displaystyle l_{ij}}

 below the diagonal, we have to divide by the diagonal element (pivot) 




u

j
j




{\displaystyle u_{jj}}

, so we get problems when 




u

j
j




{\displaystyle u_{jj}}

 is either 0 or very small, which leads to numerical instability.

The solution to this problem is pivoting 



A


{\displaystyle A}

, which means rearranging the rows of 



A


{\displaystyle A}

, prior to the 



L
U


{\displaystyle LU}

 decomposition, in a way that the largest element of each column gets onto the diagonal of 



A


{\displaystyle A}

. Rearranging the rows means to multiply 



A


{\displaystyle A}

 by a permutation matrix 



P


{\displaystyle P}

:





P
A
⇒

A
′



{\displaystyle PA\Rightarrow A'}


Example:







(



0


1




1


0



)




(



1


4




2


3



)


⇒


(



2


3




1


4



)




{\displaystyle {\begin{pmatrix}0&1\\1&0\end{pmatrix}}{\begin{pmatrix}1&4\\2&3\end{pmatrix}}\Rightarrow {\begin{pmatrix}2&3\\1&4\end{pmatrix}}}


The decomposition algorithm is then applied on the rearranged matrix so that





P
A
=
L
U


{\displaystyle PA=LU}




Task description

The task is to implement a routine which will take a square nxn matrix 



A


{\displaystyle A}

 and return a lower triangular matrix 



L


{\displaystyle L}

, a upper triangular matrix 



U


{\displaystyle U}

 and a permutation matrix 



P


{\displaystyle P}

,
so that the above equation is fulfilled.

You should then test it on the following two examples and include your output.



Example 1

A

1   3   5
2   4   7
1   1   0

L

1.00000   0.00000   0.00000
0.50000   1.00000   0.00000
0.50000  -1.00000   1.00000

U

2.00000   4.00000   7.00000
0.00000   1.00000   1.50000
0.00000   0.00000  -2.00000

P

0   1   0
1   0   0
0   0   1

Example 2

A

11    9   24    2
 1    5    2    6
 3   17   18    1
 2    5    7    1

L

1.00000   0.00000   0.00000   0.00000
0.27273   1.00000   0.00000   0.00000
0.09091   0.28750   1.00000   0.00000
0.18182   0.23125   0.00360   1.00000

U

11.00000    9.00000   24.00000    2.00000
 0.00000   14.54545   11.45455    0.45455
 0.00000    0.00000   -3.47500    5.68750
 0.00000    0.00000    0.00000    0.51079

P

1   0   0   0
0   0   1   0
0   1   0   0
0   0   0   1


",Python,"from functools import reduce
from operator import mul
from itertools import starmap
from math import sqrt
from random import random
from pprint import pprint
 
def dot_product(a, b):
    return sum(starmap(mul, zip(a, b)))
 
def matrix_mul(A, B):
    return [[dot_product(row, col) for col in zip(*B)] for row in A]
 
def pivotize(m):
    n = len(m)
    id_m = [[float(i == j) for i in range(n)] for j in range(n)]
 
    for i in range(n):
        row = max(((val, j) for j, val in enumerate(m[i:])),
                  key=lambda x: abs(x[0]))[1] + i
        if i!= row:
            id_m[i], id_m[row] = id_m[row], id_m[i]
    return id_m
 
def lu(A):
    n = len(A)
    L = [[0.0] * n for i in range(n)]
    U = [[0.0] * n for i in range(n)]
    P = pivotize(A)
    A2 = matrix_mul(P, A)
 
    for j in range(n):
        L[j][j] = 1.0
        for i in range(j + 1):
            s1 = sum(U[k][j] * L[i][k] for k in range(i))
            U[i][j] = A2[i][j] - s1
        for i in range(j, n):
            s2 = sum(U[k][j] * L[i][k] for k in range(j))
            L[i][j] = (A2[i][j] - s2) / U[j][j]
    return L, U, P
 
def print_matrix(m):
    pprint(m, width=100)
    print()
 
if __name__ == '__main__':
    a = [[1.0, 3, 5], [2.0, 4, 7], [1.0, 1, 0]]
    b = [[11.0, 9, 24, 2], [1.0, 5, 2, 6], [3.0, 17, 18, 1], [2.0, 5, 7, 1]]
 
    for m in lu(a):
        print_matrix(m)
 
    print()
 
    for m in lu(b):
        print_matrix(m)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Vampire_number,Vampire number,"A vampire number is a natural decimal number with an even number of digits,   that can be factored into two integers.

These two factors are called the   fangs,   and must have the following properties:

   they each contain half the number of the decimal digits of the original number
   together they consist of exactly the same decimal digits as the original number
   at most one of them has a trailing zero


An example of a vampire number and its fangs:    1260 : (21, 60) 



Task

 Print the first   25   vampire numbers and their fangs. 
 Check if the following numbers are vampire numbers and,   if so,   print them and their fangs: 
 16758243290880, 24959017348650, 14593825548650 



Note that a vampire number can have more than one pair of fangs.



See also

 numberphile.com.
 vampire search algorithm
 vampire numbers on OEIS

",Python,"from __future__ import division
 
import math
from operator import mul
from itertools import product
from functools import reduce
 
 
def fac(n):
    '''\
    return the prime factors for n
    >>> fac(600)
    [5, 5, 3, 2, 2, 2]
    >>> fac(1000)
    [5, 5, 5, 2, 2, 2]
    >>>  
    '''
    step = lambda x: 1 + x*4 - (x//2)*2
    maxq = int(math.floor(math.sqrt(n)))
    d = 1
    q = n % 2 == 0 and 2 or 3 
    while q <= maxq and n % q != 0:
        q = step(d)
        d += 1
    res = []
    if q <= maxq:
        res.extend(fac(n//q))
        res.extend(fac(q)) 
    else: res=[n]
    return res
 
def fact(n):
    '''\
    return the prime factors and their multiplicities for n
    >>> fact(600)
    [(2, 3), (3, 1), (5, 2)]
    >>> fact(1000)
    [(2, 3), (5, 3)]
    >>> 
    '''
    res = fac(n)
    return [(c, res.count(c)) for c in set(res)]
 
def divisors(n):
    'Returns all the divisors of n'
    factors = fact(n)   # [(primefactor, multiplicity), ...]
    primes, maxpowers = zip(*factors)
    powerranges = (range(m+1) for m in maxpowers)
    powers = product(*powerranges)
    return (
        reduce(mul,
               (prime**power for prime, power in zip(primes, powergroup)),
               1)
        for powergroup in powers)
 
def vampire(n):
    fangsets = set( frozenset([d, n//d])
                    for d in divisors(n)
                    if (len(str(d)) == len(str(n))/2.
                        and sorted(str(d) + str(n//d)) == sorted(str(n))
                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )
    return sorted(tuple(sorted(fangs)) for fangs in fangsets)
 
 
if __name__ == '__main__':
    print('First 25 vampire numbers')
    count = n = 0
    while count <25:
        n += 1
        fangpairs = vampire(n)
        if fangpairs:
            count += 1
            print('%i: %r' % (n, fangpairs))
    print('\nSpecific checks for fangpairs')
    for n in (16758243290880, 24959017348650, 14593825548650):
        fangpairs = vampire(n)
        print('%i: %r' % (n, fangpairs))",Human_written,Python_from_C#
http://rosettacode.org/wiki/Farey_sequence,Farey sequence,"The   Farey sequence    Fn   of order   n   is the sequence of completely reduced fractions between   0   and   1   which, when in lowest terms, have denominators less than or equal to   n,   arranged in order of increasing size.

The   Farey sequence   is sometimes incorrectly called a   Farey series.



Each Farey sequence:

   starts with the value   0   (zero),   denoted by the fraction     





0
1




{\displaystyle {\frac {0}{1}}}


   ends with the value   1   (unity),   denoted by the fraction   





1
1




{\displaystyle {\frac {1}{1}}}

.


The Farey sequences of orders   1   to   5   are:

 







F




1


=


0
1


,


1
1




{\displaystyle {\bf {\it {F}}}_{1}={\frac {0}{1}},{\frac {1}{1}}}



 







F




2


=


0
1


,


1
2


,


1
1




{\displaystyle {\bf {\it {F}}}_{2}={\frac {0}{1}},{\frac {1}{2}},{\frac {1}{1}}}



 







F




3


=


0
1


,


1
3


,


1
2


,


2
3


,


1
1




{\displaystyle {\bf {\it {F}}}_{3}={\frac {0}{1}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {1}{1}}}



 







F




4


=


0
1


,


1
4


,


1
3


,


1
2


,


2
3


,


3
4


,


1
1




{\displaystyle {\bf {\it {F}}}_{4}={\frac {0}{1}},{\frac {1}{4}},{\frac {1}{3}},{\frac {1}{2}},{\frac {2}{3}},{\frac {3}{4}},{\frac {1}{1}}}



 







F




5


=


0
1


,


1
5


,


1
4


,


1
3


,


2
5


,


1
2


,


3
5


,


2
3


,


3
4


,


4
5


,


1
1




{\displaystyle {\bf {\it {F}}}_{5}={\frac {0}{1}},{\frac {1}{5}},{\frac {1}{4}},{\frac {1}{3}},{\frac {2}{5}},{\frac {1}{2}},{\frac {3}{5}},{\frac {2}{3}},{\frac {3}{4}},{\frac {4}{5}},{\frac {1}{1}}}


Task
   Compute and show the Farey sequence for orders   1   through   11   (inclusive).
   Compute and display the   number   of fractions in the Farey sequence for order   100   through   1,000   (inclusive)   by hundreds.
   Show the fractions as    n/d    (using the solidus [or slash] to separate the numerator from the denominator). 


The length   (the number of fractions)   of a Farey sequence asymptotically approaches:

  3 × n2   ÷   



π


{\displaystyle \pi }

2 
See also

   OEIS sequence   A006842 numerators of Farey series of order 1, 2, ··· 
   OEIS sequence   A006843 denominators of Farey series of order 1, 2, ··· 
   OEIS sequence   A005728 number of fractions in Farey series of order n 
   MathWorld entry   Farey sequence
   Wikipedia   entry   Farey sequence

",Python,"from __future__ import print_function
 
class frac(object):
    def __init__(self, num, den):
        self.num = num
        self.den = den
    def __str__(self):
        return ""%d/%d"" % (self.num, self.den)
 
def f(l, r, n):
    m = frac(l.num + r.num, l.den + r.den)
    if m.den <= n:
        f(l, m, n)
        print(m, end="" "")
        f(m, r, n)
 
def main():
    # task 1.  solution by recursive generation of mediants
    for n in range(1, 12):
        l = frac(0, 1)
        r = frac(1, 1)
        print(""F(%d): %s "" % (n, l), end="""")
        f(l, r, n)
        print(r)
    # task 2.  direct solution by summing totient function
    # 2.1 generate primes to 1000
    composite = [False] * 1001
    for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]:
        for n in range(p * 2, 1001, p):
            composite[n] = True
    # 2.2 generate totients to 1000
    tot = [1] * 1001
    for n in range(2, 1001):
        if not composite[n]:
            tot[n] = n - 1
            for a in range(n * 2, 1001, n):
                f = n - 1
                while r % n == 0:
                    f *= n
                    r /= n
                tot[a] *= f
    # 2.3 sum totients
    for n, sum in enumerate(tot):
        sum += tot[n]
        if n % 100 == 0:
            print(""|F(%d)|: %d"" % (n, sum))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Shell_one-liner,Shell one-liner,"Task

Show how to specify and execute a short program in the language from a command shell, where the input to the command shell is only one line in length.

Avoid depending on the particular shell or operating system used as much as is reasonable; if the language has notable implementations which have different command argument syntax, or the systems those implementations run on have different styles of shells, it would be good to show multiple examples.



",Python,"$ python -c 'print ""Hello""'
Hello",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Knuth_shuffle,Knuth shuffle,"The   Knuth shuffle   (a.k.a. the Fisher-Yates shuffle)   is an algorithm for randomly shuffling the elements of an array.



Task

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).



Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

       for i from last downto 1 do:
           let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 j 
  
    
      
        ≤
      
    
    {\displaystyle \leq }
  
 i
           swap items[i] with items[j]

Notes

   It modifies the input array in-place. 
   If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
   The algorithm can also be amended to iterate from left to right, if that is more convenient.


Test cases



 Input array

 Possible output arrays


 []

 []


 [10]

 [10]


 [10, 20]

 [10, 20]
[20, 10]


 [10, 20, 30]

 [10, 20, 30]
[10, 30, 20]
[20, 10, 30]
[20, 30, 10]
[30, 10, 20]
[30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)



Related task

 Sattolo cycle



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"import random
def KnuthShuffle(array):
    for i in range(0, len(array)):
        j = random.randint(i, len(array))
        temp = array[i]
        array[i] = array[j]
        array[j] = temp",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Combinations,Combinations,"Task

Given non-negative integers    m    and    n,   generate all size    m    combinations   of the integers from    0   (zero)   to    n-1    in sorted order   (each combination is sorted and the entire table is sorted).



Example

3   comb    5      is:

0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

If it is more ""natural"" in your language to start counting from    1   (unity) instead of    0   (zero),

the combinations can be of the integers from    1   to    n. 



See also


 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"def comb(n, m, emit):
    s = [0] * m
    last = m - 1
    def rc(i, next):
        for j in range(next, n):
            s[i] = j
            if i == last:
                emit(s)
            else:
                rc(i+1, j+1)
    rc(0, 0)
 
def main():
    comb(5, 3, lambda c: print(c))
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Loops/For,Loops/For,"“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code.

Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.



Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop.

Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges




Reference

 For loop Wikipedia.

",Python,"import sys
for i in xrange(5):
    for j in xrange(i+1):
        sys.stdout.write(""*"")
    print",Human_written,Python_from_Go
http://rosettacode.org/wiki/Box_the_compass,Box the compass,"There be many a land lubber that knows naught of the pirate ways and gives direction by degree!
They know not how to box the compass!



Task description

 Create a function that takes a heading in degrees and returns the correct 32-point compass heading.
 Use the function to print and display a table of Index, Compass point, and Degree; rather like the corresponding columns from, the first table of the wikipedia article, but use only the following 33 headings as input:
[0.0, 16.87, 16.88, 33.75, 50.62, 50.63, 67.5, 84.37, 84.38, 101.25, 118.12, 118.13, 135.0, 151.87, 151.88, 168.75, 185.62, 185.63, 202.5, 219.37, 219.38, 236.25, 253.12, 253.13, 270.0, 286.87, 286.88, 303.75, 320.62, 320.63, 337.5, 354.37, 354.38]. (They should give the same order of points but are spread throughout the ranges of acceptance).


Notes;
 The headings and indices can be calculated from this pseudocode:
for i in 0..32 inclusive:
    heading = i * 11.25
    case i %3:
      if 1: heading += 5.62; break
      if 2: heading -= 5.62; break
    end
    index = ( i mod 32) + 1
 The column of indices can be thought of as an enumeration of the thirty two cardinal points (see talk page)..

",Python,"def createRow(i, point, heading):
    tr = ""<tr>""
    td = ""<td>"" + str(i) + ""</td>""
    tr += td
    td = ""<td>"" + point + ""</td>""
    tr += td
    td = ""<td>"" + str(heading) + ""</td>""
    tr += td
    tr += ""</tr>""
    return tr
 
def getPoint(i):
    j = i % 8
    i = int(i / 8) % 4
    cardinal = ['north', 'east','south', 'west']
    pointDesc = ['1', '1 by 2', '1-C', 'C by 1', 'C', 'C by 2', '2-C', '2 by 1']
    str1 = cardinal[i]
    str2 = cardinal[(i + 1) % 4]
    strC = str1 + str2 if str1 == 'north' or str1 =='south' else str2 + str1
    return pointDesc[j].replace('1', str1).replace('2', str2).replace('C', strC)
 
i = 0
heading = 0
table = ""<table>""
tbody = ""<tbody>""
tr = """"
while i <= 32:
    heading = i * 11.25 + [0, 5.62, -5.62][i % 3]
    tr = createRow(i % 32 + 1, getPoint(i), heading)
    tbody += tr
    i += 1
table += tbody
table += ""</tbody></table>""
print(table)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Sexy_primes,Sexy primes,"

 This page uses content from Wikipedia. The original article was at Sexy_prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In mathematics, sexy primes are prime numbers that differ from each other by six.

For example, the numbers 5 and 11 are both sexy primes, because 11 minus 6 is 5.

The term ""sexy prime"" is a pun stemming from the Latin word for six: sex.



Sexy prime pairs: Sexy prime pairs are groups of two primes that differ by 6. e.g. (5 11), (7 13), (11 17)

See sequences: OEIS:A023201 and OEIS:A046117

Sexy prime triplets: Sexy prime triplets are groups of three primes where each differs from the next by 6. e.g. (5 11 17), (7 13 19), (17 23 29)

See sequences: OEIS:A046118, OEIS:A046119 and OEIS:A046120

Sexy prime quadruplets: Sexy prime quadruplets are groups of four primes where each differs from the next by 6. e.g. (5 11 17 23), (11 17 23 29)

See sequences: OEIS:A023271, OEIS:A046122, OEIS:A046123 and OEIS:A046124

Sexy prime quintuplets: Sexy prime quintuplets are groups of five primes with a common difference of 6. One of the terms must be divisible by 5, because 5 and 6 are relatively prime. Thus, the only possible sexy prime quintuplet is (5 11 17 23 29)

Task

For each of pairs, triplets, quadruplets and quintuplets, Find and display the count of each group type of sexy primes less than one million thirty-five (1,000,035).
Display at most the last 5, less than one million thirty-five, of each sexy prime group type.
Find and display the count of the unsexy primes less than one million thirty-five.
Find and display the last 10 unsexy primes less than one million thirty-five.
Note that 1000033 SHOULD NOT be counted in the pair count. It is sexy, but not in a pair within the limit. However, it also SHOULD NOT be listed in the unsexy primes since it is sexy. 

",Python,"LIMIT = 1_000_035
def primes2(limit=LIMIT):
    if limit < 2: return []
    if limit < 3: return [2]
    lmtbf = (limit - 3) // 2
    buf = [True] * (lmtbf + 1)
    for i in range((int(limit ** 0.5) - 3) // 2 + 1):
        if buf[i]:
            p = i + i + 3
            s = p * (i + 1) + i
            buf[s::p] = [False] * ((lmtbf - s) // p + 1)
    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]
 
primes = primes2(LIMIT +6)
primeset = set(primes)
primearray = [n in primeset for n in range(LIMIT)]
 
#%%
s = [[] for x in range(4)]
unsexy = []
 
for p in primes:
    if p > LIMIT:
        break
    if p + 6 in primeset and p + 6 < LIMIT:
        s[0].append((p, p+6))
    elif p + 6 in primeset:
        break
    else:
        if p - 6 not in primeset:
            unsexy.append(p)
        continue
    if p + 12 in primeset and p + 12 < LIMIT:
        s[1].append((p, p+6, p+12))
    else:
        continue
    if p + 18 in primeset and p + 18 < LIMIT:
        s[2].append((p, p+6, p+12, p+18))
    else:
        continue
    if p + 24 in primeset and p + 24 < LIMIT:
        s[3].append((p, p+6, p+12, p+18, p+24))
 
#%%
print('""SEXY"" PRIME GROUPINGS:')
for sexy, name in zip(s, 'pairs triplets quadruplets quintuplets'.split()):
    print(f'  {len(sexy)} {na (not isPrime(n-6))))) |> Array.ofSeq
printfn ""There are %d unsexy primes less than 1,000,035. The last 10 are:"" n.Length
Array.skip (n.Length-10) n |> Array.iter(fun n->printf ""%d "" n); printfn """"
let ni=pCache |> Seq.takeWhile(fun n->nme} ending with ...')
    for sx in sexy[-5:]:
        print('   ',sx)
 
print(f'\nThere are {len(unsexy)} unsexy primes ending with ...')
for usx in unsexy[-10:]:
    print(' ',usx)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Josephus_problem,Josephus problem,"Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.

An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

,
removing every 



k


{\displaystyle k}

-th prisoner and killing him.

As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >

For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.



Task

Given any   



n
,
k
>
0


{\displaystyle n,k>0}

,   find out which prisoner will be the final survivor.

In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).

Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.

Which number was he?



Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free,

and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.

Provide a way to calculate which prisoner is at any given position on the killing sequence.



Notes

 You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way. This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

. However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
 If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
 An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.

",Python,"class Josephus:
    def __init__(self, n):
        self.head = {}
        current = self.head
        for i in range(n-1):
            current['label'] = i+1
            current['next'] = {'prev': current}
            current = current['next']
        current['label'] = n
        current['next'] = self.head
        self.head['prev'] = current
        return self

    def kill(self, spacing):
        current = self.head
        while current['next']!= current:
            for i in range(spacing-1):
                current = current['next']
            current['prev']['next'] = current['next']
            current['next']['prev'] = current['prev']
            current = current['next']
        return current['label']",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def can_make_words(blocks, word):
	if not word:
		return True
	if not blocks:
		return False
	c = word[0].upper()
	for i, block in enumerate(blocks):
		if c not in block:
			continue
		blocks[0], blocks[i] = blocks[i], blocks[0]
		if can_make_words(blocks[1:], word[1:]):
			return True
		blocks[0], blocks[i] = blocks[i], blocks[0]
	return False
 
blocks = [
	""BO"", ""XK"", ""DQ"", ""CP"", ""NA"", 
	""GT"", ""RE"", ""TG"", ""QD"", ""FS"", 
	""JW"", ""HU"", ""VI"", ""AN"", ""OB"", 
	""ER"", ""FS"", ""LY"", ""PC"", ""ZM""
]
 
words = [
	"""", ""A"", ""BARK"", ""BOOK"", ""TREAT"", ""COMMON"", ""SQUAD"", ""Confuse""
]
 
for word in words:
	print word, can_make_words(blocks, word)",Ai_generated,Python_from_C
http://rosettacode.org/wiki/McNuggets_problem,McNuggets problem,"Wikipedia
The McNuggets version of the coin problem was introduced by Henri Picciotto,
who included it in his algebra textbook co-authored with Anita Wah. Picciotto
thought of the application in the 1980s while dining with his son at
McDonald's, working the problem out on a napkin. A McNugget number is
the total number of McDonald's Chicken McNuggets in any number of boxes.
In the United Kingdom, the original boxes (prior to the introduction of
the Happy Meal-sized nugget boxes) were of 6, 9, and 20 nuggets.

Task

Calculate (from 0 up to a limit of 100) the largest non-McNuggets
number (a number n which cannot be expressed with 6x + 9y + 20z = n
where x, y and z are natural numbers).



",Python,">>> from itertools import product
>>> nuggets = set(range(101))
>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):
	nuggets.discard(6*s + 9*n + 20*t)
 
 
>>> max(nuggets)
43
>>>",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Singly-linked_list/Traversal,Singly-linked list/Traversal,"Traverse from the beginning of a singly-linked list to the end.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"first = None
#...
iter = first
while iter is not None:
  # access data, e.g. with iter.data
  iter = iter.next",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Scope/Function_names_and_labels,Scope/Function names and labels,"Task

Explain or demonstrate the levels of visibility of function names and labels within the language.



See also

 Variables for levels of scope relating to visibility of program variables
 Scope modifiers for general scope modification facilities

",Python,"(define (foo x)
  (define (bar y) (+ x y))
  (bar 2))
(foo 1) ; => 3
(bar 1) ; => error",Human_written,Python_from_C
http://rosettacode.org/wiki/Binary_search,Binary search,"A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a ""divide and conquer"" algorithm.

As an analogy, consider the children's game ""guess a number."" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.

As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.



Task

Given the starting point of a range, the ending point of a range, and the ""secret value"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.

There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.

All of the following code examples use an ""inclusive"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using ""exclusive"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

 change high = N-1 to high = N
 change high = mid-1 to high = mid
 (for recursive algorithm) change if (high < low) to if (high <= low)
 (for iterative algorithm) change while (low <= high) to while (low < high)
Traditional algorithm
The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the ""insertion point"" for it (the index that the value would have if it were inserted into the array).

Recursive Pseudocode:

  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index ""low""
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

Iterative Pseudocode:

  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index ""low""
  }

Leftmost insertion point
The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Rightmost insertion point
The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Extra credit
Make sure it does not have overflow bugs.

The line in the pseudo-code above to calculate the mean of two integers:

mid = (low + high) / 2
could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.

One way to fix it is to manually add half the range to the low number:

mid = low + (high - low) / 2
Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

Another way for signed integers, possibly faster, is the following:

mid = (low + high) >>> 1
where  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.



Related task

 Guess the number/With Feedback (Player)


See also

 wp:Binary search algorithm
 Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.

",Python,"import math
 
class Search:
 
    @staticmethod
    def RecursiveBinarySearchForGLB(entries, value, left=0, right=None):
        if right is None:
            right = len(entries) - 1
        if left <= right:
            middle = left + math.floor((right - left) / 2)
            if entries[middle] < value:
                return Search.RecursiveBinarySearchForGLB(entries, value, middle + 1, right)
            else:
                return Search.RecursiveBinarySearchForGLB(entries, value, left, middle - 1)
        else:
            # [Assert]left == right + 1
            # GLB: entries[right] < value && value <= entries[right + 1]
            return right
 
    @staticmethod
    def RecursiveBinarySearchForLUB(entries, value, left=0, right=None):
        if right is None:
            right = len(entries) - 1
        if left <= right:
            middle = left + math.floor((right - left) / 2)
            if entries[middle] <= value:
                return Search.RecursiveBinarySearchForLUB(entries, value, middle + 1, right)
            else:
                return Search.RecursiveBinarySearchForLUB(entries, value, left, middle - 1)
        else:
            # [Assert]left == right + 1
            # LUB: entries[left] > value && value >= entries[left - 1]
            return left",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Anagrams/Deranged_anagrams,Anagrams/Deranged anagrams,"Two or more words are said to be anagrams if they have the same characters, but in a different order.

By analogy with derangements we define a deranged anagram as two words with the same characters, but in which the same character does not appear in the same position in both words.

Task[edit]
Use the word list at unixdict to find and display the longest deranged anagram.



Related tasks
 Permutations/Derangements
 Best shuffle
Word plays

Ordered words
Palindrome detection
Semordnilap
Anagrams
Anagrams/Deranged anagrams





Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# Deranged anagrams
import collections
import itertools
import operator
import sys
 
# Get words from unix dictionary file
def get_words():
    words = []
    with open(""data/unixdict.txt"") as f:
        for line in f:
            words.append(line.strip())
    return words
 
# Get the longest deranged anagram in the given list of word if any
def longest_deranged(words):
    # sort by length descending then by alphabetical order
    words.sort(key=lambda s: (-len(s), s))
    # keep all strings keyed by sorted characters (since anagrams have the same list of sorted characters)
    signatures = collections.defaultdict(list)
    # save on memory by only keeping in the map strings of the current processed length
    previous_length = sys.maxsize
    for s in words:
        # length change, clear the map
        if len(s)<previous_length:
            signatures.clear()
            previous_length = len(s)
        # generate key as sorted characters
        sorted_chars = sorted(s)
        anagrams = signatures[tuple(sorted_chars)]
        # find if any anagram (string with the same sorted character vector) is deranged
        for a in anagrams:
            if is_deranged(a, s):
                return (a, s)
        anagrams.append(s)
    return None
 
# check if two strings do NOT have the same character in the same position
def is_deranged(s1, s2):
    # we zip the character iterators and check we find no position with the same two characters
    return not any(map(operator.eq, s1, s2))
 
# an example main method printing the results
if __name__ == ""__main__"":
    words = get_words()
    od = longest_deranged(words)
    if od is None:
        print(""No deranged anagrams found!"")
    else:
        print(od[0], od[1])",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",Python,"'''Hilbert curve'''
 
from itertools import (chain, islice)
 
 
# hilbertCurve :: Int -> SVG String
def hilbertCurve(n):
    '''An SVG string representing a
       Hilbert curve of degree n.
    '''
    w = 1024
    return svgFromPoints(w)(
        hilbertPoints(w)(
            hilbertTree(n)
        )
    )
 
 
# hilbertTree :: Int -> Tree Char
def hilbertTree(n):
    '''Nth application of a rule to a seedling tree.'''
 
    # rule :: Dict Char [Char]
    rule = {
        'a': ['d', 'a', 'a', 'b'],
        'b': ['c', 'b', 'b', 'a'],
        'c': ['b', 'c', 'c', 'd'],
        'd': ['a', 'd', 'd', 'c']
    }
 
    # go :: Tree Char -> Tree Char
    def go(tree):
        c = tree['root']
        xs = tree['nest']
        return Node(c)(
            map(go, xs) if xs else map(
                flip(Node)([]),
                rule[c]
            )
        )
    seed = Node('a')([])
    return list(islice(
        iterate(go)(seed), n
    ))[-1] if 0 < n else seed
 
 
# hilbertPoints :: Int -> Tree Char -> [(Int, Int)]
def hilbertPoints(w):
    '''Serialization of a tree to a list of points
       bounded by a square of side w.
    '''
 
    # vectors :: Dict Char [(Int, Int)]
    vectors = {
        'a': [(-1, 1), (-1, -1), (1, -1), (1, 1)],
        'b': [(1, -1), (-1, -1), (-1, 1), (1, 1)],
        'c': [(1, -1), (1, 1), (-1, 1), (-1, -1)],
        'd': [(-1, 1), (1, 1), (1, -1), (-1, -1)]
    }
 
    # points :: Int -> ((Int, Int), Tree Char) -> [(Int, Int)]
    def points(d):
        '''Size -> Centre of a Hilbert subtree -> All subtree points
        '''
        def go(xy, tree):
            r = d // 2
 
            def deltas(v):
                return (
                    xy[0] + (r * v[0]),
                    xy[1] + (r * v[1])
                )
            centres = map(deltas, vectors[tree['root']])
            return chain.from_iterable(
                map(points(r), centres, tree['nest'])
            ) if tree['nest'] else centres
        return go
 
    d = w // 2
    return lambda tree: list(points(d)((d, d), tree))
 
 
# svgFromPoints :: Int -> [(Int, Int)] -> SVG String
def svgFromPoints(w):
    '''Width of square canvas -> Point list -> SVG string'''
 
    def go(xys):
        def points(xy):
            return str(xy[0]) + ' ' + str(xy[1])
        xs = ' '.join(map(points, xys))
        return '\n'.join(
            ['<svg xmlns=""http://www.w3.org/2000/svg""',
             f'width=""512"" height=""512"" viewBox=""5 5 {w} {w}"">',
             f'<path d=""M{xs}"" ',
             'stroke-width=""2"" stroke=""red"" fill=""transparent""/>',
             '</svg>'
             ]
        )
    return go
 
 
# ------------------------- TEST --------------------------
def main():
    '''Testing generation of the SVG for a Hilbert curve'''
    print(
        hilbertCurve(6)
    )
 
 
# ------------------- GENERIC FUNCTIONS -------------------
 
# Node :: a -> [Tree a] -> Tree a
def Node(v):
    '''Contructor for a Tree node which connects a
       value of some kind to a list of zero or
       more child trees.'''
    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}
 
 
# flip :: (a -> b -> c) -> b -> a -> c
def flip(f):
    '''The (curried or uncurried) function f with its
       arguments reversed.
    '''
    return lambda a: lambda b: f(b)(a)
 
 
# iterate :: (a -> a) -> a -> Gen [a]
def iterate(f):
    '''An infinite list of repeated
       applications of f to x.
    '''
    def go(x):
        v = x
        while True:
            yield v
            v = f(v)
    return go
 
 
#  TEST ---------------------------------------------------
if __name__ == '__main__':
    main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Law_of_cosines_-_triples,Law of cosines - triples,"The Law of cosines states that for an angle γ, (gamma) of any triangle, if the sides adjacent to the angle are A and B and the side opposite is C; then the lengths of the sides are related by this formula:

           A2 + B2 - 2ABcos(γ) = C2 

Specific angles

For an angle of of   90º   this becomes the more familiar ""Pythagoras equation"":

           A2 + B2  =  C2           

For an angle of   60º   this becomes the less familiar equation:

           A2 + B2 - AB  =  C2       

And finally for an angle of   120º   this becomes the equation:

           A2 + B2 + AB  =  C2      



Task

   Find all integer solutions (in order) to the three specific cases, distinguishing between each angle being considered.
   Restrain all sides to the integers   1..13   inclusive.
   Show how many results there are for each of the three angles mentioned above.
   Display results on this page.


Note: Triangles with the same length sides but different order are to be treated as the same.

Optional Extra credit

 How many 60° integer triples are there for sides in the range 1..10_000 where the sides are not all of the same length.


Related Task
 Pythagorean triples


See also

 Visualising Pythagoras: ultimate proofs and crazy contortions Mathlogger Video

",Python,"N = 13
 
def method1(N=N):
    squares = [x**2 for x in range(0, N+1)]
    sqrset = set(squares)
    tri90, tri60, tri120 = (set() for _ in range(3))
    for a in range(1, N+1):
        a2 = squares[a]
        for b in range(1, a + 1):
            b2 = squares[b]
            c2 = a2 + b2
            if c2 in sqrset:
                tri90.add(tuple(sorted((a, b, int(c2**0.5)))))
            ab = a * b
            c2 -= ab
            if c2 in sqrset:
                tri60.add(tuple(sorted((a, b, int(c2**0.5)))))
            c2 += 2 * ab
            if c2 in sqrset:
                tri120.add(tuple(sorted((a, b, int(c2**0.5)))))
    return  sorted(tri90), sorted(tri60), sorted(tri120)
#%%
if __name__ == '__main__':
    print(f'Integer triangular triples for sides 1..{N}:')
    for angle, triples in zip([90, 60, 120], method1(N)):
        print(f'  {angle:3}° has {len(triples)} solutions:\n    {triples}')
    _, t60, _ = method1(10_000)
    notsame = sum(1 for a, b, c in t60 if a != b or b != c)
    print('Extra credit:', notsame)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",Python,">>> import time
>>> time.asctime(time.gmtime(0))
'Thu Jan  1 00:00:00 1970'
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Floyd%27s_triangle,Floyd's triangle,"Floyd's triangle   lists the natural numbers in a right triangle aligned to the left where

 the first row is   1     (unity)
 successive rows start towards the left with the next number followed by successive naturals listing one more number than the line above.


The first few lines of a Floyd triangle looks like this:

 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15



Task

 Write a program to generate and display here the first   n   lines of a Floyd triangle. 
(Use   n=5   and   n=14   rows).
 Ensure that when displayed in a mono-space font, the numbers line up in vertical columns as shown and that only one space separates numbers of the last row.

",Python,"def printTriangle(n):
    print(n, ""rows:"")
    for rowNum, printMe, numsPrinted in zip(range(1, n+1), range(1, n*(n-1)//2+2), range(0, n*(n-1)//2+1)):
        cols = int(math.ceil(math.log10(n*(n-1)//2 + numsPrinted + 2)))
        print(""{:>{}}"".format(printMe, cols), end="" "")
        if numsPrinted == rowNum:
            print()
            rowNum += 1
            numsPrinted = 0

printTriangle(5)
printTriangle(14)",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Jensen%27s_Device,Jensen's Device,"Jensen's Device

You are encouraged to solve this task according to the task description, using any language you may know.
This task is an exercise in call by name.

Jensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.

The following program was proposed to illustrate the technique. It computes the 100th harmonic number:

begin
   integer i;
   real procedure sum (i, lo, hi, term);
      value lo, hi;
      integer i, lo, hi;
      real term;
      comment term is passed by-name, and so is i;
   begin
      real temp;
      temp := 0;
      for i := lo step 1 until hi do
         temp := temp + term;
      sum := temp
   end;
   comment note the correspondence between the mathematical notation and the call to sum;
   print (sum (i, 1, 100, 1/i))
end

The above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.

Moreover, the first parameter to sum, representing the ""bound"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.
(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)

Donald Knuth later proposed the Man or Boy Test as a more rigorous exercise.



",Python,"def harmonic_sum(lo, hi, term):
    return sum(term(i) for i in range(lo, hi + 1))
 
def main():
    print(harmonic_sum(1, 100, lambda i: 1.0 / i))
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Currying,Currying,"

 This page uses content from Wikipedia. The original article was at Currying. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Create a simple demonstrative example of Currying in a specific language.

Add any historic details as to how the feature made its way into the language.



",Python,"def run():
    def divide(x, y):
        return x / y
    partsOf120 = curry(divide)(120)
    print(""half of 120 is "" + str(partsOf120(2)) + "" a third is "" + str(partsOf120(3)) + "" and a quarter is "" + str(partsOf120(4)))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Command-line_arguments,Command-line arguments,"Command-line arguments is part of Short Circuit's Console Program Basics selection.
Scripted main
See also Program name.

For parsing command line arguments intelligently, see Parsing command-line arguments.

Example command line:

myprogram -c ""alpha beta"" -h ""gamma""
",Python,"numbers = [1, 2, 2, 1, 6, 99, 99, 7, 1, 1, 2, 3, 1]

sum = 0
ignore = False
for i in numbers:
    if i == 6:
        ignore = True
    elif i == 9:
        ignore = False
    elif not ignore:
        sum += i

print(sum)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Play_recorded_sounds,Play recorded sounds,"Load at least two prerecorded sounds, and demonstrate as many of these features as you can:

 playing them individually and simultaneously
 stopping before the end of the sound
 looping (preferably glitch-free)
 setting the volume of each sound
 stereo or 3D positional mixing
 performing other actions when marked times in the sound arrive
Describe:

 The supported audio formats, briefly.
 Whether it is suitable for game sound effects (low-latency start, resource efficiency, supports many simultaneous sounds, etc.)
 Whether it is suitable for playing music (long duration ).
[Note: If it seems to be a good idea, this task may be revised to specify a particular timeline rather than just 'demonstrate these features'.]

Where applicable, please categorize examples primarily by the audio facility used (library/API/program/platform) rather than the language if the language is incidental (e.g. ""Mac OS X CoreAudio"" or ""mplayer"" rather than ""C"" or ""bash"").
",Python,"import time
from pygame import mixer
 
mixer.init(frequency=16000) #set frequency for wav file
s1 = mixer.Sound('test.wav')
s2 = mixer.Sound('test2.wav')
 
#individual
s1.play(-1)         #loops indefinitely
time.sleep(0.5)
 
#simultaneously
s2.play()          #play once 
time.sleep(2)
s2.play(2)         #optional parameter loops three times 
time.sleep(10)
 
#set volume down
s1.set_volume(0.1)
time.sleep(5)
 
#set volume up
s1.set_volume(1)
time.sleep(5)
 
s1.stop()
s2.stop()
mixer.quit()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort,Sorting algorithms/Sleep sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


In general, sleep sort works by starting a separate task for each item to be sorted, where each task sleeps for an interval corresponding to the item's sort key, then emits the item. Items are then collected sequentially in time.

Task: Write a program that implements sleep sort. Have it accept non-negative integers on the command line and print the integers in sorted order. If this is not idomatic in your language or environment, input and output may be done differently. Enhancements for optimization, generalization, practicality, robustness, and so on are not required.

Sleep sort was presented anonymously on 4chan and has been discussed on Hacker News.
",Python,"def timeoutSort(self, f):
	for n in self:
		threading.Timer(5 * n, f, [n]).start()",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Jump_anywhere,Jump anywhere,"Imperative programs
conditional structures
loops
local jumps
This task is to demonstrate a local jump and a global jump and the various other types of jumps that the language supports.
For the purpose of this task, the jumps need not be used for a single purpose and you have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.
This task provides a ""grab bag"" for several types of jumps. There are non-local jumps across function calls, or long jumps to anywhere within a program. Anywhere means not only to the tops of functions!

 Some languages can go to any global label in a program.
 Some languages can break multiple function calls, also known as unwinding the call stack.
 Some languages can save a continuation. The program can later continue from the same place. So you can jump anywhere, but only if you have a previous visit there (to save the continuation).

These jumps are not all alike.
A simple goto never touches the call stack.
A continuation saves the call stack, so you can continue a function call after it ends.



Task

Use your language to demonstrate the various types of jumps that it supports.

Because the possibilities vary by language, this task is not specific.
You have the freedom to use these jumps for different purposes.
You may also defer to more specific tasks, like Exceptions or Generator.



",Python,"# Example 2: Restarting a loop:
from goto import goto, label
label .start
for i in range(1, 4):
    print i
    if i == 2:
        try:
            output = message
        except NameError:
            print ""Oops - forgot to define 'message'!  Start again.""
            message = ""Hello world""
            goto .start
print output, ""\n""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pascal_matrix_generation,Pascal matrix generation,"A pascal matrix is a two-dimensional square matrix holding numbers from   Pascal's triangle,   also known as   binomial coefficients   and which can be shown as   nCr.

Shown below are truncated   5-by-5   matrices   M[i, j]   for   i,j   in range   0..4. 


A Pascal upper-triangular matrix that is populated with   jCi:

[[1, 1, 1, 1, 1],
 [0, 1, 2, 3, 4],
 [0, 0, 1, 3, 6],
 [0, 0, 0, 1, 4],
 [0, 0, 0, 0, 1]]

A Pascal lower-triangular matrix that is populated with   iCj   (the transpose of the upper-triangular matrix):

[[1, 0, 0, 0, 0],
 [1, 1, 0, 0, 0],
 [1, 2, 1, 0, 0],
 [1, 3, 3, 1, 0],
 [1, 4, 6, 4, 1]]

A Pascal symmetric matrix that is populated with   i+jCi:

[[1, 1, 1, 1, 1],
 [1, 2, 3, 4, 5],
 [1, 3, 6, 10, 15],
 [1, 4, 10, 20, 35],
 [1, 5, 15, 35, 70]]



Task

Write functions capable of generating each of the three forms of   n-by-n   matrices.

Use those functions to display upper, lower, and symmetric Pascal   5-by-5   matrices on this page.

The output should distinguish between different matrices and the rows of each matrix   (no showing a list of 25 numbers assuming the reader should split it into rows).



Note
 
The   Cholesky decomposition   of a Pascal symmetric matrix is the Pascal lower-triangle matrix of the same size.



",Python,"from pprint import pprint as pp
 
def pascal_upp(n):
    s = [[0] * n for _ in range(n)]
    s[0] = [1] * n
    for i in range(1, n):
        for j in range(i, n):
            s[i][j] = s[i-1][j-1] + s[i][j-1]
    return s
 
def pascal_low(n):
    # transpose of pascal_upp(n)
    return [list(x) for x in zip(*pascal_upp(n))]
 
def pascal_sym(n):
    s = [[1] * n for _ in range(n)]
    for i in range(1, n):
        for j in range(1, n):
            s[i][j] = s[i-1][j] + s[i][j-1]
    return s
 
 
if __name__ == ""__main__"":
    n = 5
    print(""\nUpper:"")
    pp(pascal_upp(n))
    print(""\nLower:"")
    pp(pascal_low(n))
    print(""\nSymmetric:"")
    pp(pascal_sym(n))",Human_written,Python_from_C++
http://rosettacode.org/wiki/A%2BB,A+B,"A+B   ─── a classic problem in programming contests,   it's given so contestants can gain familiarity with the online judging system being used.



Task

Given two integers,   A and B.

Their sum needs to be calculated.



Input data

Two integers are written in the input stream, separated by space(s):

 



(
−
1000
≤
A
,
B
≤
+
1000
)


{\displaystyle (-1000\leq A,B\leq +1000)}




Output data

The required output is one integer:   the sum of A and B.



Example



 input  

 output  


 2 2 

 4 


 3 2 

 5 


",Python,"# Standard input-output streams
import sys
a, b = map(int, sys.stdin.readline().split())
print(a + b)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Primality_by_Wilson%27s_theorem,Primality by Wilson's theorem,"Task

Write a boolean function that tells whether a given integer is prime using Wilson's theorem.

By Wilson's theorem, a number p is prime if and only if p divides (p - 1)! + 1.

Remember that 1 and all non-positive integers are not prime.



See also

 Cut-the-knot: Wilson's theorem.
 Wikipedia: Wilson's theorem

",Python,"from math import factorial
 
def is_wprime(n):
    return n == 2 or (
        n > 1
        and n % 2 != 0
        and (factorial(n - 1) + 1) % n == 0
    )
 
if __name__ == '__main__':
    c = int(input('Enter upper limit: '))
    print(f'Primes under {c}:')
    print([n for n in range(c) if is_wprime(n)])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Averages/Mean_time_of_day,Averages/Mean time of day,"Task[edit]
A particular activity of bats occurs at these times of the day:

23:00:17, 23:40:20, 00:12:45, 00:17:19
Using the idea that there are twenty-four hours in a day,
which is analogous to there being 360 degrees in a circle,
map times of day to and from angles;
and using the ideas of Averages/Mean angle
compute and show the average time of the nocturnal activity
to an accuracy of one second of time.

See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation



",Python,"from cmath import rect, phase
from math import radians, degrees
 
 
def mean_angle(deg):
    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))
 
def mean_time(times):
    t = (time.split(':') for time in times)
    seconds = ((float(s) + int(m) * 60 + int(h) * 3600) 
               for h, m, s in t)
    day = 24 * 60 * 60
    to_angles = [s * 360. / day for s in seconds]
    mean_as_angle = mean_angle(to_angles)
    mean_seconds = mean_as_angle * day / 360.
    if mean_seconds < 0:
        mean_seconds += day
    h, m = divmod(mean_seconds, 3600)
    m, s = divmod(m, 60)
    return '%02i:%02i:%02i' % (h, m, s)
 
 
if __name__ == '__main__':
    print( mean_time([""23:00:17"", ""23:40:20"", ""00:12:45"", ""00:17:19""]) )",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Subleq,Subleq,"Subleq is an example of a One-Instruction Set Computer (OISC).

It is named after its only instruction, which is SUbtract and Branch if Less than or EQual to zero.

Task
Your task is to create an interpreter which emulates a SUBLEQ machine.

The machine's memory consists of an array of signed integers.   These integers may be interpreted in three ways:

   simple numeric values 
   memory addresses 
   characters for input or output
Any reasonable word size that accommodates all three of the above uses is fine.

The program should load the initial contents of the emulated machine's memory, set the instruction pointer to the first address (which is defined to be address 0), and begin emulating the machine, which works as follows:

   Let A be the value in the memory location identified by the instruction pointer;   let B and C be the values stored in the next two consecutive addresses in memory.
   Advance the instruction pointer three words, to point at the address after the address containing C.
   If A is   -1   (negative unity),   then a character is read from the machine's input and its numeric value stored in the address given by B.   C is unused.
   If B is   -1   (negative unity),   then the number contained in the address given by A is interpreted as a character and written to the machine's output.   C is unused.
   Otherwise, both A and B are treated as addresses.   The number contained in address A is subtracted from the number in address B (and the difference left in address B).   If the result is positive, execution continues uninterrupted; if the result is zero or negative, the number in C becomes the new instruction pointer.
   If the instruction pointer becomes negative, execution halts.
Your solution may initialize the emulated machine's memory in any convenient manner, but if you accept it as input, it should be a separate input stream from the one fed to the emulated machine once it is running. And if fed as text input, it should be in the form of raw subleq ""machine code"" - whitespace-separated decimal numbers, with no symbolic names or other assembly-level extensions, to be loaded into memory starting at address   0   (zero).

For purposes of this task, show the output of your solution when fed the below   ""Hello, world!""   program.

As written, this example assumes ASCII or a superset of it, such as any of the Latin-N character sets or Unicode;   you may translate the numbers representing characters (starting with 72=ASCII 'H') into another character set if your implementation runs in a non-ASCII-compatible environment. If 0 is not an appropriate terminator in your character set, the program logic will need some adjustment as well.

15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0
The above ""machine code"" corresponds to something like this in a hypothetical assembler language for a signed 8-bit version of the machine:

start:
    0f 11 ff subleq (zero), (message), -1
    11 ff ff subleq (message), -1, -1    ; output character at message
    10 01 ff subleq (neg1), (start+1), -1
    10 03 ff subleq (neg1), (start+3), -1
    0f 0f 00 subleq (zero), (zero), start
; useful constants
zero: 
    00      .data 0  
neg1: 
    ff      .data -1
; the message to print
message: .data ""Hello, world!\n\0""
    48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 0a 00

",Python,"import sys
 
def subleq(code):
	ip = 0
	a = 0
	b = 0
	c = 0
	nextIP = 0
	ch = ''
	while 0 <= ip:
		nextIP = ip + 3
		a = code[ip]
		b = code[ip + 1]
		c = code[ip + 2]
		if a == -1:
			ch = sys.stdin.read(1)
			code[b] = ord(ch)
		elif b == -1:
			sys.stdout.write(chr(code[a]))
		else:
			code[b] -= code[a]
			if code[b] <= 0:
				nextIP = c
		ip = nextIP
 
def processFile(fileName):
	dataSet = []
	num = 0
	fp = open(fileName, 'r')
	num = int(fp.readline())
	for i in range(num):
		dataSet.append(int(fp.readline()))
	fp.close()
	subleq(dataSet)
 
if __name__ == '__main__':
	if len(sys.argv)!= 2:
		print 'Usage : %s <subleq code file>' % sys.argv[0]
	else:
		processFile(sys.argv[1])",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Determine_sentence_type,Determine sentence type,"Use these sentences:
""hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it.""

Task
 Search for the last used punctuation in a sentence, and determine its type according to its punctuation.
 Output one of these letters
 ""E"" (Exclamation!), ""Q"" (Question?), ""S"" (Serious.), ""N"" (Neutral). 
Extra
 Make your code able to determine multiple sentences.


Don't leave any errors!




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def sentence_type(s):
    if len(s) == 0:
        return """"
    types = []
    for c in s:
        if c == '?':
            types.append(""Q"")
        elif c == '!':
            types.append(""E"")
        elif c == '.':
            types.append(""S"")
    if s[-1] not in ""?!."":
        types.append(""N"")
    return ""|"".join(types)
 
if __name__ == ""__main__"":
    s = ""hi there, how are you today? I'd like to present to you the washing machine 9001. You have been nominated to win one of these! Just make sure you don't break it""
    print(sentence_type(s))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Horizontal_sundial_calculations,Horizontal sundial calculations,"Task

Create a program that calculates the hour, sun hour angle, dial hour line angle from 6am to 6pm for an operator entered location.



For example, the user is prompted for a location and inputs the latitude and longitude 4°57′S 150°30′W (4.95°S 150.5°W of Jules Verne's Lincoln Island, aka Ernest Legouve Reef), with a legal meridian of 150°W.

(Note: the ""meridian"" is approximately the same concept as the ""longitude"" - the distinction is that the meridian is used to determine when it is ""noon"" for official purposes. This will typically be slightly different from when the sun appears at its highest location, because of the structure of time zones. For most, but not all, time zones (hour wide zones with hour zero centred on Greenwich), the legal meridian will be an even multiple of 15 degrees.)

Wikipedia: A sundial is a device that measures time by the position of the Sun. In common designs such as the horizontal sundial, the sun casts a shadow from its style (also called its Gnomon, a thin rod or a sharp, straight edge) onto a flat surface marked with lines indicating the hours of the day (also called the dial face or dial plate). As the sun moves across the sky, the shadow-edge progressively aligns with different hour-lines on the plate. Such designs rely on the style being aligned with the axis of the Earth's rotation. Hence, if such a sundial is to tell the correct time, the style must point towards true north (not the north or south magnetic pole) and the style's angle with horizontal must equal the sundial's geographical latitude.



",Python,"import math
 
# constants used in the calculations
DegreesPerHour = 15.0
DegreesPerRadian = 180.0 * math.pi
 
# a structure for the calculation results
class SundialCalculation:
  def __init__(self, hourAngle, hourLineAngle):
    self.HourAngle = hourAngle
    self.HourLineAngle = hourLineAngle
 
# a class for a sundial at a location
class Sundial:
  # intermediate values used in the caclulations
  def __init__(self, latitude, longitude, legalMeridian):
    self.m_sinLatitude = math.sin(latitude / DegreesPerRadian)
    self.m_timeZoneCorrection = legalMeridian - longitude
 
  def CalculateShadow(self, hoursSinceNoon):
    hourAngle = hoursSinceNoon * DegreesPerHour + self.m_timeZoneCorrection
    hourAngleRad = hourAngle / DegreesPerRadian
    hlaRad = math.atan2(self.m_sinLatitude * math.sin(hourAngleRad), math.cos(hourAngleRad))
    hourLineAngle = hlaRad * DegreesPerRadian
    return SundialCalculation(hourAngle, hourLineAngle)
 
def main():
  latitude = float(input(""Enter latitude:""))
  longitude = float(input(""Enter longitude:""))
  legalMeridian = float(input(""Enter legal meridian:""))
 
  # create a sundial at the user specified location
  sundial = Sundial(latitude, longitude, legalMeridian)
  for hour in range(-6, 7):
    # cacluate the angles
    result = sundial.CalculateShadow(hour)
 
    # print the results
    amOrPm = ""am"" if hour < 0 else ""pm""
    hourString = str(12 + hour if hour < 1 else hour)
    print(hourString + amOrPm + 
    "" - sun hour angle:"" + str(result.HourAngle) +
    "", dial hour line angle:"" + str(result.HourLineAngle))
 
if __name__ == ""__main__"":
  main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Deal_cards_for_FreeCell,Deal cards for FreeCell,"Free Cell is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. 

This version introduced 32000 numbered deals. (The FreeCell FAQ tells this history.)

As the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. 

These deals are numbered from 1 to 32000.
Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.

The algorithm uses this linear congruential generator from Microsoft C:

 



s
t
a
t

e

n
+
1


≡
214013
×
s
t
a
t

e

n


+
2531011


(
mod


2

31


)



{\displaystyle state_{n+1}\equiv 214013\times state_{n}+2531011{\pmod {2^{31}}}}


 



r
a
n

d

n


=
s
t
a
t

e

n


÷

2

16




{\displaystyle rand_{n}=state_{n}\div 2^{16}}


 



r
a
n

d

n




{\displaystyle rand_{n}}

 is in range 0 to 32767.
 Rosetta Code has another task, linear congruential generator, with code for this RNG in several languages.


The algorithm follows:

 Seed the RNG with the number of the deal.
 Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.
 Until the array is empty:
 Choose a random card at index ≡ next random number (mod array length).
 Swap this random card with the last card of the array.
 Remove this random card from the array. (Array length goes down by 1.)
 Deal this random card.
 Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.


 Order to deal cards

 Game #1

 Game #617


  1  2  3  4  5  6  7  8
 9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52

 JD 2D 9H JC 5D 7H 7C 5H
KD KC 9S 5S AD QC KH 3H
2S KS 9D QD JS AS AH 3C
4C 5C TS QH 4H AC 4D 7S
3S TD 4S TH 8H 2C JH 7D
6D 8S 8D QS 6C 3D 8C TC
6S 9C 2H 6H

 7D AD 5C 3S 5S 8C 2D AH
TD 7S QD AC 6D 8H AS KH
TH QC 3H 9D 6S 8D 3D TC
KD 5H 9S 3C 8S 7H 4D JS
4C QS 9C 9H 7C 6H 2C 2S
4S TS 2H 5D JC 6C JH QH
JD KS KC 4H

Deals can also be checked against FreeCell solutions to 1000000 games.
(Summon a video solution, and it displays the initial deal.)

Write a program to take a deal number and deal cards in the same order as this algorithm.
The program may display the cards with ASCII, with Unicode, by drawing graphics, or any other way.

Related tasks:

 Playing cards
 Card shuffles
 War Card_Game
 Poker hand_analyser
 Go Fish

",Python,"def randomGenerator(seed=1):
    max_int32 = (1 << 31) - 1
    seed = seed & max_int32
 
    while True:
        seed = (seed * 214013 + 2531011) & max_int32
        yield seed >> 16
 
def deal(seed):
    nc = 52
    cards = list(range(nc - 1, -1, -1))
    rnd = randomGenerator(seed)
    for i, r in zip(range(nc), rnd):
        j = (nc - 1) - r % (nc - i)
        cards[i], cards[j] = cards[j], cards[i]
    return cards
 
def show(cards):
    l = [""A23456789TJQK""[int(c/4)] + ""CDHS""[c%4] for c in cards]
    for i in range(0, len(cards), 8):
        print("" "".join(l[i : i+8]))
 
if __name__ == '__main__':
    from sys import argv
    seed = int(argv[1]) if len(argv) == 2 else 11982
    print(""Hand {}"".format(seed))
    deck = deal(seed)
    show(deck)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Magic_squares_of_odd_order,Magic squares of odd order,"A magic square is an   NxN   square matrix whose numbers (usually integers) consist of consecutive numbers arranged so that the sum of each row and column,   and   both long (main) diagonals are equal to the same sum (which is called the   magic number   or   magic constant).

The numbers are usually (but not always) the first   N2   positive integers.

A magic square whose rows and columns add up to a magic number but whose main diagonals do not, is known as a semimagic square.



 8 
 1 
 6


 3 
 5 
 7


 4 
 9 
 2



Task
For any odd   N,   generate a magic square with the integers    1 ──► N,   and show the results here.

Optionally, show the magic number.

You should demonstrate the generator by showing at least a magic square for   N = 5.



 Related tasks
 Magic squares of singly even order
 Magic squares of doubly even order



 See also

 MathWorld™ entry: Magic_square 
 Odd Magic Squares (1728.org)

",Python,">>> def magic(n):
    for row in range(1, n + 1):
        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in
                       (n * ((row + col - 1 + n // 2) % n) +
                       ((row + 2 * col - 2) % n) + 1
                       for col in range(1, n + 1))))
    print('\nAll sum to magic number %i' % ((n * n + 1) * n // 2))
 
 
>>> for n in (5, 3, 7):
	print('\nOrder %i\n=======' % n)
	magic(n)
 
 
 
Order 5
=======
17 24  1  8 15
23  5  7 14 16
 4  6 13 20 22
10 12 19 21  3
11 18 25  2  9
 
All sum to magic number 65
 
Order 3
=======
8 1 6
3 5 7
4 9 2
 
All sum to magic number 15
 
Order 7
=======
30 39 48  1 10 19 28
38 47  7  9 18 27 29
46  6  8 17 26 35 37
 5 14 16 25 34 36 45
13 15 24 33 42 44  4
21 23 32 41 43  3 12
22 31 40 49  2 11 20
 
All sum to magic number 175
>>>",Human_written,Python_from_C
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"def eca(cells, rule):
    lencells = len(cells)
    c = ""0"" + cells + ""0""    # Zero pad the ends
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    yield c[1:-1]
    while True:
        c = ''.join(['0',
                     ''.join(neighbours2next[c[i-1:i+2]]
                             for i in range(1,lencells+1)),
                     '0'])
        yield c[1:-1]
 
if __name__ == '__main__':
    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)
    zipped = [range(lines)] + [eca(start, rule) for rule in rules]
    print('\n   Rules: %r' % (rules,))
    for data in zip(*zipped):
        i = data[0]
        cells = data[1:]
        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Knapsack_problem/0-1,Knapsack problem/0-1,"A tourist wants to make a good trip at the weekend with his friends.

They will go to the mountains to see the wonders of nature, so he needs to pack well for the trip.

He has a good knapsack for carrying things, but knows that he can carry a maximum of only 4kg in it,   and it will have to last the whole day.

He creates a list of what he wants to bring for the trip but the total weight of all items is too much.

He then decides to add columns to his initial list detailing their weights and a numerical value representing how important the item is for the trip.



Here is the list:


 Table of potential knapsack items


 item 
 weight (dag) 
 value


 map 
 9 
 150


 compass 
 13 
 35


 water 
 153 
 200


 sandwich 
 50 
 160


 glucose 
 15 
 60


 tin 
 68 
 45


 banana 
 27 
 60


 apple 
 39 
 40


 cheese 
 23 
 30


 beer 
 52 
 10


 suntan cream 
 11 
 70


 camera 
 32 
 30


 T-shirt 
 24 
 15


 trousers 
 48 
 10


 umbrella 
 73 
 40


 waterproof trousers 
 42 
 70


 waterproof overclothes 
 43 
 75


 note-case 
 22 
 80


 sunglasses 
 7 
 20


 towel 
 18 
 12


 socks 
 4 
 50


 book 
 30 
 10


 knapsack 
 ≤400 dag 
 ?



The tourist can choose to take any combination of items from the list,
but only one of each item is available.

He may not cut or diminish the items, so he can only take whole units of any item.



Task

Show which items the tourist can carry in his knapsack so that their total weight does not
exceed 400 dag [4 kg],   and their total value is maximized.

[dag = decagram = 10 grams]



Related tasks

   Knapsack problem/Bounded
   Knapsack problem/Unbounded
   Knapsack problem/Continuous
   A* search algorithm

",Python,"from typing import List, Tuple
 
Item = Tuple[str, int, int]
 
wants: List[Item] = [
    (""map"", 9, 150),
    (""compass"", 13, 35),
    (""water"", 153, 200),
    (""sandwich"", 50, 160),
    (""glucose"", 15, 60),
    (""tin"", 68, 45),
    (""banana"", 27, 60),
    (""apple"", 39, 40),
    (""cheese"", 23, 30),
    (""beer"", 52, 10),
    (""suntan cream"", 11, 70),
    (""camera"", 32, 30),
    (""T-shirt"", 24, 15),
    (""trousers"", 48, 10),
    (""umbrella"", 73, 40),
    (""waterproof trousers"", 42, 70),
    (""waterproof overclothes"", 43, 75),
    (""note-case"", 22, 80),
    (""sunglasses"", 7, 20),
    (""towel"", 18, 12),
    (""socks"", 4, 50),
    (""book"", 30, 10),
]
 
max_wt = 400
 
def m(i: int, w: int) -> Tuple[List[str], int, int]:
    if i < 0 or w == 0:
        return [], 0, 0
    elif wants[i][1] > w:
        return m(i - 1, w)
    i0, w0, v0 = m(i - 1, w)
    i1, w1, v1 = m(i - 1, w - wants[i][1])
    v1 += wants[i][2]
    if v1 > v0:
        return i1 + [wants[i][0]], w1 + wants[i][1], v1
    return i0, w0, v0
 
if __name__ == ""__main__"":
    items, w, v = m(len(wants) - 1, max_wt)
    print(items)
    print(""weight:"", w)
    print(""value:"", v)",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Cheryl%27s_birthday,Cheryl's birthday,"Albert and Bernard just became friends with Cheryl, and they want to know when her birthday is.

Cheryl gave them a list of ten possible dates:

     May 15,     May 16,     May 19
     June 17,    June 18
     July 14,    July 16
     August 14,  August 15,  August 17

Cheryl then tells Albert the   month   of birth,   and Bernard the   day   (of the month)   of birth.

 1)  Albert:   I don't know when Cheryl's birthday is, but I know that Bernard does not know too.
 2)  Bernard:  At first I don't know when Cheryl's birthday is, but I know now.
 3)  Albert:   Then I also know when Cheryl's birthday is.



Task
Write a computer program to deduce, by successive elimination, Cheryl's birthday.



Related task

 Sum and Product Puzzle


References
 Wikipedia article of the same name.
 Tuple Relational Calculus

",Python,"'''Cheryl's Birthday'''
 
from itertools import groupby
from re import split
 
 
# main :: IO ()
def main():
    '''Derivation of the date.'''
 
    month, day = 0, 1
    print(
        # (3 :: A ""Then I also know"")
        # (A's month contains only one remaining day)
        uniquePairing(month)(
            # (2 :: B ""I know now"")
            # (B's day is paired with only one remaining month)
            uniquePairing(day)(
                # (1 :: A ""I know that Bernard does not know"")
                # (A's month is not among those with unique days)
                monthsWithUniqueDays(False)([
                    # 0 :: Cheryl's list:
                    tuple(x.split()) for x in
                    split(
                        ', ',
                        'May 15, May 16, May 19, ' +
                        'June 17, June 18, ' +
                        'July 14, July 16, ' +
                        'Aug 14, Aug 15, Aug 17'
                    )
                ])
            )
        )
    )
 
 
# ------------------- QUERY FUNCTIONS --------------------
 
# monthsWithUniqueDays :: Bool -> [(Month, Day)] -> [(Month, Day)]
def monthsWithUniqueDays(blnInclude):
    '''The subset of months with (or without) unique days.
    '''
    def go(xs):
        month, day = 0, 1
        months = [fst(x) for x in uniquePairing(day)(xs)]
        return [
            md for md in xs
            if blnInclude or not (md[month] in months)
        ]
    return go
 
 
# uniquePairing :: DatePart -> [(Month, Day)] -> [(Month, Day)]
def uniquePairing(i):
    '''Subset of months (or days) with a unique intersection.
    '''
    def go(xs):
        def inner(md):
            dct = md[i]
            uniques = [
                k for k in dct.keys()
                if 1 == len(dct[k])
            ]
            return [tpl for tpl in xs if tpl[i] in uniques]
        return inner
    return ap(bindPairs)(go)
 
 
# bindPairs :: [(Month, Day)] ->
# ((Dict String [String], Dict String [String])
# -> [(Month, Day)]) -> [(Month, Day)]
def bindPairs(xs):
    '''List monad injection operator for lists
       of (Month, Day) pairs.
    '''
    return lambda f: f(
        (
            dictFromPairs(xs),
            dictFromPairs(
                [(b, a) for (a, b) in xs]
            )
        )
    )
 
 
# dictFromPairs :: [(Month, Day)] -> Dict Text [Text]
def dictFromPairs(xs):
    '''A dictionary derived from a list of
       month day pairs.
    '''
    return {
        k: [snd(x) for x in m] for k, m in groupby(
            sorted(xs, key=fst), key=fst
        )
    }
 
 
# ----------------------- GENERIC ------------------------
 
# ap :: (a -> b -> c) -> (a -> b) -> a -> c
def ap(f):
    '''Applicative instance for functions.
    '''
    def go(g):
        def fxgx(x):
            return f(x)(
                g(x)
            )
        return fxgx
    return go
 
 
# fst :: (a, b) -> a
def fst(tpl):
    '''First component of a pair.
    '''
    return tpl[0]
 
 
# snd :: (a, b) -> b
def snd(tpl):
    '''Second component of a pair.
    '''
    return tpl[1]
 
 
if __name__ == '__main__':
    main()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Binary_search,Binary search,"A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a ""divide and conquer"" algorithm.

As an analogy, consider the children's game ""guess a number."" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.

As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.



Task

Given the starting point of a range, the ending point of a range, and the ""secret value"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.

There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.

All of the following code examples use an ""inclusive"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using ""exclusive"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

 change high = N-1 to high = N
 change high = mid-1 to high = mid
 (for recursive algorithm) change if (high < low) to if (high <= low)
 (for iterative algorithm) change while (low <= high) to while (low < high)
Traditional algorithm
The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the ""insertion point"" for it (the index that the value would have if it were inserted into the array).

Recursive Pseudocode:

  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index ""low""
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

Iterative Pseudocode:

  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index ""low""
  }

Leftmost insertion point
The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Rightmost insertion point
The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Extra credit
Make sure it does not have overflow bugs.

The line in the pseudo-code above to calculate the mean of two integers:

mid = (low + high) / 2
could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.

One way to fix it is to manually add half the range to the low number:

mid = low + (high - low) / 2
Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

Another way for signed integers, possibly faster, is the following:

mid = (low + high) >>> 1
where  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.



Related task

 Guess the number/With Feedback (Player)


See also

 wp:Binary search algorithm
 Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.

",Python,"def binary_search(l, value):
    low = 0
    high = len(l)-1
    while low <= high: 
        mid = (low+high)//2
        if l[mid] > value: high = mid-1
        elif l[mid] < value: low = mid+1
        else: return mid
    return -1",Human_written,Python_from_Java
http://rosettacode.org/wiki/Fractran,Fractran,"FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.

A FRACTRAN program is an ordered list of positive fractions 



P
=
(

f

1


,

f

2


,
…
,

f

m


)


{\displaystyle P=(f_{1},f_{2},\ldots ,f_{m})}

, together with an initial positive integer input 



n


{\displaystyle n}

.



The program is run by updating the integer 



n


{\displaystyle n}

 as follows:

 for the first fraction, 




f

i




{\displaystyle f_{i}}

, in the list for which 



n

f

i




{\displaystyle nf_{i}}

 is an integer, replace 



n


{\displaystyle n}

 with 



n

f

i




{\displaystyle nf_{i}}

 ;
 repeat this rule until no fraction in the list produces an integer when multiplied by 



n


{\displaystyle n}

, then halt.


Conway gave a program for primes in FRACTRAN:

 



17

/

91


{\displaystyle 17/91}

, 



78

/

85


{\displaystyle 78/85}

, 



19

/

51


{\displaystyle 19/51}

, 



23

/

38


{\displaystyle 23/38}

, 



29

/

33


{\displaystyle 29/33}

, 



77

/

29


{\displaystyle 77/29}

, 



95

/

23


{\displaystyle 95/23}

, 



77

/

19


{\displaystyle 77/19}

, 



1

/

17


{\displaystyle 1/17}

, 



11

/

13


{\displaystyle 11/13}

, 



13

/

11


{\displaystyle 13/11}

, 



15

/

14


{\displaystyle 15/14}

, 



15

/

2


{\displaystyle 15/2}

, 



55

/

1


{\displaystyle 55/1}


Starting with 



n
=
2


{\displaystyle n=2}

, this FRACTRAN program will change 



n


{\displaystyle n}

 to 



15
=
2
×
(
15

/

2
)


{\displaystyle 15=2\times (15/2)}

, then 



825
=
15
×
(
55

/

1
)


{\displaystyle 825=15\times (55/1)}

, generating the following sequence of integers:

 



2


{\displaystyle 2}

, 



15


{\displaystyle 15}

, 



825


{\displaystyle 825}

, 



725


{\displaystyle 725}

, 



1925


{\displaystyle 1925}

, 



2275


{\displaystyle 2275}

, 



425


{\displaystyle 425}

, 



390


{\displaystyle 390}

, 



330


{\displaystyle 330}

, 



290


{\displaystyle 290}

, 



770


{\displaystyle 770}

, 



…


{\displaystyle \ldots }


After 2, this sequence contains the following powers of 2:






2

2


=
4


{\displaystyle 2^{2}=4}

, 




2

3


=
8


{\displaystyle 2^{3}=8}

, 




2

5


=
32


{\displaystyle 2^{5}=32}

, 




2

7


=
128


{\displaystyle 2^{7}=128}

, 




2

11


=
2048


{\displaystyle 2^{11}=2048}

, 




2

13


=
8192


{\displaystyle 2^{13}=8192}

, 




2

17


=
131072


{\displaystyle 2^{17}=131072}

, 




2

19


=
524288


{\displaystyle 2^{19}=524288}

, 



…


{\displaystyle \ldots }


which are the prime powers of 2.



Task

Write a program that reads a list of fractions in a natural format from the keyboard or from a string,
to parse it into a sequence of fractions (i.e. two integers),
and runs the FRACTRAN starting from a provided integer, writing the result at each step.
It is also required that the number of steps is limited (by a parameter easy to find).



Extra credit

Use this program to derive the first 20 or so prime numbers.



See also

For more on how to program FRACTRAN as a universal programming language, see:

 J. H. Conway (1987). Fractran: A Simple Universal Programming Language for Arithmetic. In: Open Problems in Communication and Computation, pages 4–26. Springer.
 J. H. Conway (2010). ""FRACTRAN: A simple universal programming language for arithmetic"". In Jeffrey C. Lagarias. The Ultimate Challenge: the 3x+1 problem. American Mathematical Society. pp. 249–264. ISBN 978-0-8218-4940-8. Zbl 1216.68068.
 Number Pathology: Fractran by Mark C. Chu-Carroll; October 27, 2006.

",Python,"# version 1.1.3
 
from fractions import Fraction
from math import log
 
def fractran(program, n, limit, primes_only):
    fractions = [Fraction(f) for f in program.split()]
    results = []
    if not primes_only:
        results.append(n)
    nn = n
    while len(results) < limit:
        frac = next((f for f in fractions if f * nn == int(f * nn)), None)
        if frac is None:
            break
        nn = int(nn * frac.numerator / frac.denominator)
        if not primes_only:
            results.append(nn)
        else:
            if nn & (nn - 1) == 0:
                prime = int(log(nn) / log(2))
                results.append(prime)
    return results
 
program = ""17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1""
print(""First twenty numbers:"")
print(fractran(program, 2, 20, False))
print(""\nFirst twenty primes:"")
print(fractran(program, 2, 20, True))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/4-rings_or_4-squares_puzzle,4-rings or 4-squares puzzle,"4-rings or 4-squares puzzle

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Replace       a, b, c, d, e, f,   and
  g        with the decimal
digits   LOW   ───►   HIGH

such that the sum of the letters inside of each of the four large squares add up to
the same sum.

            ╔══════════════╗      ╔══════════════╗
            ║              ║      ║              ║
            ║      a       ║      ║      e       ║
            ║              ║      ║              ║
            ║          ┌───╫──────╫───┐      ┌───╫─────────┐
            ║          │   ║      ║   │      │   ║         │
            ║          │ b ║      ║ d │      │ f ║         │
            ║          │   ║      ║   │      │   ║         │
            ║          │   ║      ║   │      │   ║         │
            ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                       │       c      │      │      g      │
                       │              │      │             │
                       │              │      │             │
                       └──────────────┘      └─────────────┘

Show all output here.



   Show all solutions for each letter being unique with
        LOW=1     HIGH=7

   Show all solutions for each letter being unique with
        LOW=3     HIGH=9

   Show only the   number   of solutions when each letter can be non-unique
        LOW=0     HIGH=9



Related task

 Solve the no connection puzzle

",Python,"from itertools import permutations, combinations
from collections import Counter

def four_squares(low, high, unique=True, show=unique):
    f = lambda a,b,c,d,e,f,g: len(set([a+b, b+c+d, d+e+f, f+g])) == 1
    if unique:
        uniq = ""unique""
        solutions = [ary for ary in permutations(range(low, high+1), 7) if f(*ary)]
    else:
        uniq = ""non-unique""
        solutions = [ary for ary in combinations(range(low, high+1), 7) if f(*ary)]
    if show:
        print("" "" + ""  "".join(map(chr, range(ord(""a""), ord(""g"")+1))))
        for ary in solutions:
            print(ary)
    print(""{} {} solutions in {} to {}"".format(len(solutions), uniq, low, high))
    print()

for low, high in [(1, 7), (3, 9)]:
    four_squares(low, high)
four_squares(0, 9, False)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Water_collected_between_towers,Water collected between towers,"Task

In a two-dimensional world, we begin with any bar-chart (or row of close-packed 'towers', each of unit width), and then it rains,
completely filling all convex enclosures in the chart with water.



9               ██           9               ██    
8               ██           8               ██    
7     ██        ██           7     ██≈≈≈≈≈≈≈≈██    
6     ██  ██    ██           6     ██≈≈██≈≈≈≈██    
5 ██  ██  ██  ████           5 ██≈≈██≈≈██≈≈████    
4 ██  ██  ████████           4 ██≈≈██≈≈████████    
3 ██████  ████████           3 ██████≈≈████████    
2 ████████████████  ██       2 ████████████████≈≈██
1 ████████████████████       1 ████████████████████


In the example above, a bar chart representing the values [5, 3, 7, 2, 6, 4, 5, 9, 1, 2] has filled, collecting 14 units of water.

Write a function, in your language, from a given array of heights, to the number of water units that can be held in this way, by a corresponding bar chart.

Calculate the number of water units that could be collected by bar charts representing each of the following seven series:

   [[1, 5, 3, 7, 2],
    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],
    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],
    [5, 5, 5, 5],
    [5, 6, 7, 8],
    [8, 7, 7, 6],
    [6, 7, 10, 7, 6]]


See, also:

 Four Solutions to a Trivial Problem – a Google Tech Talk by Guy Steele
 Water collected between towers on Stack Overflow, from which the example above is taken)
 An interesting Haskell solution, using the Tardis monad, by Phil Freeman in a Github gist.

",Python,"import sys
 
def getWater(arr,start,end,cutoff):
	sum = 0
 
	for i in range(start,end+1):
		sum += ((arr[cutoff] > arr[i])?(arr[cutoff] - arr[i]):0)
 
	return sum
 
def netWater(arr):
	size = len(arr)
	sum = 0
 
	if(size<3):
		return 0
 
	for i in range(0,size-1):
		if(i!=size-2 && arr[i]>arr[i+1]):
			ref1 = i
 
			for j in range(ref1+1,size):
				if(arr[j]>=arr[ref1]):
					ref2 = j
 
					sum += getWater(arr,ref1+1,ref2-1,ref1)
 
					i = ref2
 
					break
 
				elif(j!=size-1 && arr[j] < arr[j+1] && (markerSet==0||(arr[j+1]>=arr[marker]))):
					marker = j+1
					markerSet = 1
 
			if(markerSet==1):
				sum += getWater(arr,ref1+1,marker-1,marker)
 
				i = marker
 
				markerSet = 0
 
				continue
 
	return sum
 
if __name__ == ""__main__"":
	if(len(sys.argv)==1):
		print(""Usage : %s <followed by space separated series of integers>"")
	else:
		arr = [int(x) for x in sys.argv[1:]]
 
		print(""Water collected : %d""%netWater(arr))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Find_common_directory_path,Find common directory path,"Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.

Test your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:

     '/home/user1/tmp/coverage/test'
     '/home/user1/tmp/covert/operator'
     '/home/user1/tmp/coven/members'

Note: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.

If your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"# version 1.1.51
 
def findCommonDirPath(paths, separator):
    if not paths:
        return """"
    if len(paths) == 1:
        return paths[0]
    splits = paths[0].split(separator)
    n = len(splits)
    paths2 = paths[1:]
    k = 0
    common = """"
    while True:
        prevCommon = common
        common += splits[k] if k == 0 else separator + splits[k]
        if not all(it.startswith(common + separator) or it == common for it in paths2):
            return prevCommon
        if k + 1 == n:
            return common
        k += 1
 
def main(args):
    paths = [
        ""/home/user1/tmp/coverage/test"",
        ""/home/user1/tmp/covert/operator"",
        ""/home/user1/tmp/coven/members""
    ]
    pathsToPrint = ""\n"".join(f""   '{it}'"" for it in paths)
    print(f""The common directory path of:\n\n{pathsToPrint}\n"")
    print(f""is '{findCommonDirPath(paths, '/')}'"")
 
if __name__ == ""__main__"":
    import sys
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Read_a_specific_line_from_a_file,Read a specific line from a file,"Some languages have special semantics for obtaining a known line number from a file.



Task

Demonstrate how to obtain the contents of a specific line within a file.

For the purpose of this task demonstrate how the contents of the seventh line of a file can be obtained,   and store it in a variable or in memory   (for potential future use within the program if the code were to become embedded).

If the file does not contain seven lines,   or the seventh line is empty,   or too big to be retrieved,   output an appropriate message.

If no special semantics are available for obtaining the required line,   it is permissible to read line by line.

Note that empty lines are considered and should still be counted.

Also note that for functional languages or languages without variables or storage,   it is permissible to output the extracted data to standard output.



",Python,"with open('xxx.txt') as f:
    for i, line in enumerate(f):
        if i == 6:
            break
    else:
        print('Not 7 lines in file')
        line = None",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Hilbert_curve,Hilbert curve,"

Task
Produce a graphical or ASCII-art representation of a Hilbert curve of at least order 3.
",Python,"import svgwrite
 
class HilbertCurve:
    def __init__(self, x, y, length, angle):
        self.current_x = x
        self.current_y = y
        self.current_angle = angle
        self.line_length = length
    def rewrite(order):
        str = ""A""
        for _ in range(order):
            tmp = """"
            for ch in str:
                if ch == ""A"":
                    tmp += ""-BF+AFA+FB-""
                elif ch == ""B"":
                    tmp += ""+AF-BFB-FA+""
                else:
                    tmp += ch
            str = tmp
        return str
    def execute(self, order):
        data = ""M {},{}"".format(self.current_x, self.current_y)
        for ch in HilbertCurve.rewrite(order):
            if ch == ""F"":
                data += self.draw_line()
            elif ch == ""+"":
                self.turn(90)
            elif ch == ""-"":
                self.turn(-90)
        return data
    def draw_line(self):
        theta = self.current_angle * 3.141592653589793 / 180
        self.current_x += self.line_length * math.cos(theta)
        self.current_y -= self.line_length * math.sin(theta)
        return "" L {},{}"".format(self.current_x, self.current_y)
    def turn(self, angle):
        self.current_angle = (self.current_angle + angle) % 360
    def save(file, size, order):
        dwg = svgwrite.Drawing(file, (size, size))
        dwg.add(dwg.rect((0, 0), (size, size), fill=""white""))
        hilbert = HilbertCurve(10, 10, 10, 0)
        dwg.add(dwg.path(hilbert.execute(order), fill=""none"", stroke=""black"", stroke_width=1))
        dwg.save()
 
HilbertCurve.save(""hilbert_curve.svg"", 650, 6)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def can_make_word(word, blocks):
    def rec_can_make_word(index, word, blocks, used):
        c = word[index].upper()
        for i in range(len(blocks)):
            if not used[i] and c in blocks[i]:
                used[i] = True
                if index == 0 or rec_can_make_word(index - 1, word, blocks, used):
                    return True
                used[i] = False
        return False
    return rec_can_make_word(len(word) - 1, word, blocks, [False] * len(blocks))
 
blocks = [""BO"", ""XK"", ""DQ"", ""CP"", ""NA"", ""GT"", ""RE"", ""TG"", ""QD"", ""FS"", ""JW"", ""HU"", ""VI"", ""AN"", ""OB"", ""ER"", ""FS"", ""LY"", ""PC"", ""ZM""]
words = [""A"", ""BARK"", ""BOOK"", ""TREAT"", ""COMMON"", ""SQUAD"", ""CONFUSE""]
for word in words:
    print(word, ""->"", can_make_word(word, blocks))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Twin_primes,Twin primes,"Twin primes are pairs of natural numbers   (P1  and  P2)   that satisfy the following:

     P1   and   P2   are primes
     P1  +  2   =   P2


Task

Write a program that displays the number of pairs of twin primes that can be found under a user-specified number

(P1 < user-specified number & P2 < user-specified number).



Extension

 Find all twin prime pairs under 100000, 10000000 and 1000000000.
 What is the time complexity of the program? Are there ways to reduce computation time?


Examples

> Search Size: 100
> 8 twin prime pairs.

> Search Size: 1000
> 35 twin prime pairs.



Also see

   The OEIS entry: A001097: Twin primes. 
   The OEIS entry: A167874: The number of distinct primes < 10^n which are members of twin-prime pairs. 
   The OEIS entry: A077800: List of twin primes {p, p+2}, with repetition. 
   The OEIS entry: A007508: Number of twin prime pairs below 10^n. 

",Python,"primes = [2, 3, 5, 7, 11, 13, 17, 19]
 
 
def count_twin_primes(limit: int) -> int:
    global primes
    if limit > primes[-1]:
        ram_limit = primes[-1] + 90000000 - len(primes)
        reasonable_limit = min(limit, primes[-1] ** 2, ram_limit) - 1
 
        while reasonable_limit < limit:
            ram_limit = primes[-1] + 90000000 - len(primes)
            if ram_limit > primes[-1]:
                reasonable_limit = min(limit, primes[-1] ** 2, ram_limit)
            else:
                reasonable_limit = min(limit, primes[-1] ** 2)
 
            sieve = list({x for prime in primes for x in
                          range(primes[-1] + prime - (primes[-1] % prime), reasonable_limit, prime)})
            primes += [x - 1 for i, x in enumerate(sieve) if i and x - 1 != sieve[i - 1] and x - 1 < limit]
 
    count = len([(x, y) for (x, y) in zip(primes, primes[1:]) if x + 2 == y])
 
    return count
 
 
def test(limit: int):
    count = count_twin_primes(limit)
    print(f""Number of twin prime pairs less than {limit} is {count}\n"")
 
 
test(10)
test(100)
test(1000)
test(10000)
test(100000)
test(1000000)
test(10000000)
test(100000000)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Enforced_immutability,Enforced immutability,"Task

Demonstrate any means your language has to prevent the modification of values, or to create objects that cannot be modified after they have been created.



",Python,"msg = ""Hello World""
msg += ""!""
print(msg)                #=> Hello World!
 
print(msg.is_frozen())        #=> false
msg.freeze()
print(msg.is_frozen())        #=> true
try:
  msg += ""!""
except Exception as e:
  print(e)                   #=> can't modify frozen String
 
print(msg)                #=> Hello World!
msg2 = msg
 
# The object is frozen, not the variable.
msg = ""hello world""     # A new object was assigned to the variable.
 
print(msg.is_frozen())        #=> false
print(msg2.is_frozen())       #=> true",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Narcissist,Narcissist,"Quoting from the Esolangs wiki page:


A narcissist (or Narcissus program) is the decision-problem version of a quine.



A quine, when run, takes no input, but produces a copy of its own source code at its output. In contrast, a narcissist reads a string of symbols from its input, and produces no output except a ""1"" or ""accept"" if that string matches its own source code, or a ""0"" or ""reject"" if it does not.


For concreteness, in this task we shall assume that symbol = character.

The narcissist should be able to cope with any finite input, whatever its length.

Any form of output is allowed, as long as the program always halts, and ""accept"", ""reject"" and ""not yet finished"" are distinguishable.



",Python,"import sys
src = open(""main.rs"").read()
input = sys.stdin.read()
print(src == input)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/FASTA_format,FASTA format,"In bioinformatics, long character strings are often encoded in a format called FASTA.

A FASTA file can contain several strings, each identified by a name marked by a > (greater than) character at the beginning of the line.



Task

Write a program that reads a FASTA file such as:

>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED


Output:
Rosetta_Example_1: THERECANBENOSPACE
Rosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED

Note that a high-quality implementation will not hold the entire file in memory at once; real FASTA files can be multiple gigabytes in size.



",Python,"import io
 
FASTA='''\
>Rosetta_Example_1
THERECANBENOSPACE
>Rosetta_Example_2
THERECANBESEVERAL
LINESBUTTHEYALLMUST
BECONCATENATED'''
 
infile = io.StringIO(FASTA)
 
def fasta_parse(infile):
    key = ''
    for line in infile:
        if line.startswith('>'):
            if key:
                yield key, val
            key, val = line[1:].rstrip().split()[0], ''
        elif key:
            val += line.rstrip()
    if key:
        yield key, val
 
print('\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Cuban_primes,Cuban primes,"The name   cuban   has nothing to do with   Cuba  (the country),   but has to do with the
fact that cubes   (3rd powers)   play a role in its definition.



Some definitions of cuban primes

   primes which are the difference of two consecutive cubes.
   primes of the form:   (n+1)3 - n3.
   primes of the form:   n3 - (n-1)3.
   primes   p   such that   n2(p+n)   is a cube for some   n>0.
   primes   p   such that   4p = 1 + 3n2.


Cuban primes were named in 1923 by Allan Joseph Champneys Cunningham.



Task requirements

   show the first   200   cuban primes   (in a multi─line horizontal format).
   show the   100,000th   cuban prime.
   show all cuban primes with commas   (if appropriate).
   show all output here.


Note that   cuban prime   isn't capitalized   (as it doesn't refer to the nation of Cuba).



Also see

   Wikipedia entry:     cuban prime.
   MathWorld entry:   cuban prime.
   The OEIS entry:     A002407.     The   100,000th   cuban prime can be verified in the   2nd   example   on this OEIS web page.

",Python,"import math
 
def main():
    primes = [3, 5]
    cut_off = 200
    big_un = 100_000
    chunks = 50
    little = big_un / chunks
 
    print(""The first %d cuban primes:"" % cut_off)
    show_each = True
    c = 0
    u = 0
    v = 1
    i = 1
    while i > 0:
        found = False
        u += 6
        v += u
        mx = math.ceil(math.sqrt(v))
        for item in primes:
            if item > mx:
                break
            if v % item == 0:
                found = True
                break
        if not found:
            c += 1
            if show_each:
                z = primes[-1] + 2
                while z <= v - 2:
                    fnd = False
                    for item in primes:
                        if item > mx:
                            break
                        if z % item == 0:
                            fnd = True
                            break
                    if not fnd:
                        primes.append(z)
                    z += 2
                primes.append(v)
                print(""%11d"" % v, end="""")
                if c % 10 == 0:
                    print()
                if c == cut_off:
                    show_each = False
                    print(""\nProgress to the %dth cuban prime: "" % big_un, end="""")
            if c % little == 0:
                print(""."", end="""")
                if c == big_un:
                    break
        i += 1
    print(""\nThe %dth cuban prime is %17d"" % (c, v))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/User_input/Graphical,User input/Graphical,"

In this task, the goal is to input a string and the integer 75000, from graphical user interface.



See also: User input/Text
",Python,"import Tkinter,tkSimpleDialog
 
root = Tkinter.Tk()
root.withdraw()
 
number = tkSimpleDialog.askinteger(""Integer"", ""Enter a Number"")
string = tkSimpleDialog.askstring(""String"", ""Enter a String"")",Human_written,Python_from_C
http://rosettacode.org/wiki/Make_directory_path,Make directory path,"Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect.
If the directory already exists, return successfully.
Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.



",Python,"import os
os.mkdir(path)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Input_loop,Input loop,"Input loop is part of Short Circuit's Console Program Basics selection.
Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data.

The stream will have an unknown amount of data on it.



",Python,"import sys
 
with open(""file.txt"") as f:
    for line in f:
        print(line)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Determinant_and_permanent,Determinant and permanent,"For a given matrix, return the determinant and the permanent of the matrix.

The determinant is given by

 



det
(
A
)
=

∑

σ


sgn
⁡
(
σ
)

∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \det(A)=\sum _{\sigma }\operatorname {sgn}(\sigma )\prod _{i=1}^{n}M_{i,\sigma _{i}}}


while the permanent is given by

 



perm
⁡
(
A
)
=

∑

σ



∏

i
=
1


n



M

i
,

σ

i






{\displaystyle \operatorname {perm} (A)=\sum _{\sigma }\prod _{i=1}^{n}M_{i,\sigma _{i}}}


In both cases the sum is over the permutations 



σ


{\displaystyle \sigma }

 of the permutations of 1, 2, ..., n. (A permutation's sign is 1 if there are an even number of inversions and -1 otherwise; see parity of a permutation.)

More efficient algorithms for the determinant are known: LU decomposition, see for example wp:LU decomposition#Computing the determinant. Efficient methods for calculating the permanent are not known.



Related task

 Permutations by swapping

",Python,"import numpy as np
import itertools
 
def determinant(m):
    d = 0
    for p in itertools.permutations(range(len(m))):
        pr = 1
        for i, σ in enumerate(p):
            pr *= m[i][σ]
        d += np.sign(np.prod(p)) * pr
    return d
 
def permanent(m):
    d = 0
    for p in itertools.permutations(range(len(m))):
        pr = 1
        for i, σ in enumerate(p):
            pr *= m[i][σ]
        d += pr
    return d
 
m2 = np.array([[1, 2], [3, 4]])
m3 = np.array([[2, 9, 4], [7, 5, 3], [6, 1, 8]])
 
print(determinant(m2), permanent(m2))
print(determinant(m3), permanent(m3))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Date_manipulation,Date manipulation,"Task

Given the date string ""March 7 2009 7:30pm EST"", 

output the time 12 hours later in any human-readable format.

As extra credit, display the resulting time in a time zone different from your own.



",Python,"from datetime import datetime
from pytz import timezone
 
date_str = ""March 7 2009 7:30pm EST""
 
date_obj = datetime.strptime(date_str, ""%B %d %Y %I:%M%p %Z"")
 
after_12_hours = date_obj + timedelta(hours=12)
 
print(""Date: "" + date_str)
print(""+12h: "" + after_12_hours.strftime(""%B %d %Y %I:%M%p %Z""))
 
after_12_hours_in_central_europe_time = after_12_hours.astimezone(timezone(""CET""))
print(""+12h (in Central Europe): "" + after_12_hours_in_central_europe_time.strftime(""%B %d %Y %I:%M%p %Z""))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",Python,"import time
 
seconds = float(raw_input())
print ""Sleeping...""
time.sleep(seconds) # number is in seconds ... but accepts fractions
print ""Awake!""",Human_written,Python_from_C#
http://rosettacode.org/wiki/Number_reversal_game,Number reversal game,"Task

Given a jumbled list of the numbers   1   to   9   that are definitely   not   in
ascending order.

Show the list,   and then ask the player how many digits from the
left to reverse.

Reverse those digits,   then ask again,   until all the digits end up in ascending order.



The score is the count of the reversals needed to attain the ascending order.



Note: Assume the player's input does not need extra validation.



Related tasks

   Sorting algorithms/Pancake sort
   Pancake sorting.
   Topswops

",Python,"'''
number reversal game
    Given a jumbled list of the numbers 1 to 9
    Show the list.
    Ask the player how many digits from the left to reverse.
    Reverse those digits then ask again.
    until all the digits end up in ascending order.
 
'''
 
import random
 
print(__doc__)
data, trials = list('123456789'), 0
while data == sorted(data):
    random.shuffle(data)
while data != sorted(data):
    trials += 1
    flip = int(input('#%2i: LIST: %r Flip how many?: ' % (trials, ' '.join(data))))
    data[:flip] = reversed(data[:flip])
 
print('\nYou took %2i attempts to put the digits in order!' % trials)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Pell%27s_equation,Pell's equation,"Pell's equation   (also called the Pell–Fermat equation)   is a   Diophantine equation   of the form:

   x2   -   ny2   =   1  
with integer solutions for   x   and   y,   where   n   is a given non-square positive integer.



Task requirements

   find the smallest solution in positive integers to Pell's equation for   n = {61, 109, 181, 277}.


See also

   Wikipedia entry: Pell's equation.

",Python,"import math
 
def solvePell(n):
    x = int(math.sqrt(n))
    y, z, r = x, 1, x << 1
    e1, e2 = 1, 0
    f1, f2 = 0, 1
    while True:
        y = r * z - y
        z = (n - y * y) // z
        r = (x + y) // z
 
        e1, e2 = e2, e1 + e2 * r
        f1, f2 = f2, f1 + f2 * r
 
        a, b = f2 * x + e2, f2
        if a * a - n * b * b == 1:
            return a, b
 
for n in [61, 109, 181, 277]:
    x, y = solvePell(n)
    print(""x^2 - %3d * y^2 = 1 for x = %27d and y = %25d"" % (n, x, y))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Longest_common_substring,Longest common substring,"Task

Write a function that returns the longest common substring of two strings.

Use it within a program that demonstrates sample output from the function, which will consist of the longest common substring between ""thisisatest"" and ""testing123testing"".

Note that substrings are consecutive characters within a string.   This distinguishes them from subsequences, which is any sequence of characters within a string, even if there are extraneous characters in between them.

Hence, the longest common subsequence between ""thisisatest"" and ""testing123testing"" is ""tsitest"", whereas the longest common substring is just ""test"".




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




References

Generalize Suffix Tree
Ukkonen’s Suffix Tree Construction

",Python,"s1 = ""thisisatest""
s2 = ""testing123testing""
len1, len2 = len(s1), len(s2)
ir, jr = 0, -1
for i1 in range(len1):
    i2 = s2.find(s1[i1])
    while i2 >= 0:
        j1, j2 = i1, i2
        while j1 < len1 and j2 < len2 and s2[j2] == s1[j1]:
            if j1-i1 >= jr-ir:
                ir, jr = i1, j1
            j1 += 1; j2 += 1
        i2 = s2.find(s1[i1], i2+1)
print (s1[ir:jr+1])",Human_written,Python_from_Go
http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists,Cartesian product of two or more lists,"Task

Show one or more idiomatic ways of generating the Cartesian product of two arbitrary lists in your language.

Demonstrate that your function/method correctly returns:

{1, 2} × {3, 4} = {(1, 3), (1, 4), (2, 3), (2, 4)}
and, in contrast:

{3, 4} × {1, 2} = {(3, 1), (3, 2), (4, 1), (4, 2)}
Also demonstrate, using your function/method, that the product of an empty list with any other list is empty.

 {1, 2} × {} = {}
 {} × {1, 2} = {}
For extra credit, show or write a function returning the n-ary product of an arbitrary number of lists, each of arbitrary length. Your function might, for example, accept a single argument which is itself a list of lists, and return the n-ary product of those lists.

Use your n-ary Cartesian product function to show the following products:

 {1776, 1789} × {7, 12} × {4, 14, 23} × {0, 1}
 {1, 2, 3} × {30} × {500, 100}
 {1, 2, 3} × {} × {500, 100}

",Python,"import itertools
 
def cp(lsts):
    return list(itertools.product(*lsts))
 
if __name__ == '__main__':
    from pprint import pprint as pp
 
    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],
                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),
                  ((1, 2, 3), (30,), (500, 100)),
                  ((1, 2, 3), (), (500, 100))]:
        print(lists, '=>')
        pp(cp(lists), indent=2)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Sudoku,Sudoku,"Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format.

references

 Algorithmics of Sudoku   may help implement this.
 Python Sudoku Solver Computerphile video.

",Python,"def show(x):
    for i in range(9):
        if not i % 3:
            print
        for j in range(9):
            if j % 3:
                print ""%2d"" % x[i * 9 + j],
            else:
                print ""%3d"" % x[i * 9 + j],
        print

def trycell(x, pos):
    row = pos / 9
    col = pos % 9
    i = j = used = 0
    if pos == 81:
        return 1
    if x[pos]:
        return trycell(x, pos + 1)
    for i in range(9):
        used |= 1 << (x[i * 9 + col] - 1)
    for j in range(9):
        used |= 1 << (x[row * 9 + j] - 1)
    row = row / 3 * 3
    col = col / 3 * 3
    for i in range(row, row + 3):
        for j in range(col, col + 3):
            used |= 1 << (x[i * 9 + j] - 1)
    for x[pos] in range(1, 10):
        if not (used & 1):
            if trycell(x, pos + 1):
                return 1
        used >>= 1
    x[pos] = 0
    return 0

def solve(s):
    x = [0] * 81
    for i in range(81):
        x[i] = s[i] >= '1' and s[i] <= '9' and s[i] - '0' or 0
    if trycell(x, 0):
        show(x)
    else:
        print ""no solution""

solve(""5x..7....""
      ""6..195...""
      "".98....6.""
      ""8...6...3""
      ""4..8.3..1""
      ""7...2...6""
      "".6....28.""
      ""...419..5""
      ""....8..79"")",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting algorithms/Quicksort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




 This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm.

The elements must have a   strict weak order   and the index of the array can be of any discrete type.

For languages where this is not possible, sort an array of integers.



Quicksort, also known as   partition-exchange sort,   uses these steps.

   Choose any element of the array to be the pivot.
   Divide all other elements (except the pivot) into two partitions.
   All elements less than the pivot must be in the first partition.
   All elements greater than the pivot must be in the second partition.
   Use recursion to sort both partitions.
   Join the first sorted partition, the pivot, and the second sorted partition.


The best pivot creates partitions of equal length (or lengths differing by   1).

The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array).

The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.



This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

 ""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

 Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
 Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.


With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!

This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.



",Python,"def qsort(lst):
    if len(lst) < 2:
        return lst
    else:
        pivot = lst[0]
        lesser = [i for i in lst[1:] if i <= pivot]
        greater = [i for i in lst[1:] if i > pivot]
        return qsort(lesser) + [pivot] + qsort(greater)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Window_management,Window management,"Treat windows or at least window identities as first class objects.

 Store window identities in variables, compare them for equality.
 Provide examples of performing some of the following:
 hide, 
 show, 
 close, 
 minimize, 
 maximize, 
 move,     and 
 resize a window. 


The window of interest may or may not have been created by your program.



",Python,"import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk
import time
 
def check(err, msg):
    if err!= None:
        print(msg, err)
 
def main():
    Gtk.init(None)
 
    window = Gtk.Window()
    check(err, ""Unable to create window:"")
    window.set_resizable(True)
    window.set_title(""Window management"")
    window.set_border_width(5)
    window.connect(""destroy"", Gtk.main_quit)
 
    stackbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
    check(err, ""Unable to create stack box:"")
 
    bmax = Gtk.Button(label=""Maximize"")
    check(err, ""Unable to create maximize button:"")
    bmax.connect(""clicked"", lambda w: window.maximize())
 
    bunmax = Gtk.Button(label=""Unmaximize"")
    check(err, ""Unable to create unmaximize button:"")
    bunmax.connect(""clicked"", lambda w: window.unmaximize())
 
    bicon = Gtk.Button(label=""Iconize"")
    check(err, ""Unable to create iconize button:"")
    bicon.connect(""clicked"", lambda w: window.iconify())
 
    bdeicon = Gtk.Button(label=""Deiconize"")
    check(err, ""Unable to create deiconize button:"")
    bdeicon.connect(""clicked"", lambda w: window.deiconify())
 
    bhide = Gtk.Button(label=""Hide"")
    check(err, ""Unable to create hide button:"")
    bhide.connect(""clicked"", lambda w: window.hide())
 
    bshow = Gtk.Button(label=""Show"")
    check(err, ""Unable to create show button:"")
    bshow.connect(""clicked"", lambda w: window.show())
 
    bmove = Gtk.Button(label=""Move"")
    check(err, ""Unable to create move button:"")
    isShifted = False
    bmove.connect(""clicked"", lambda w: window.move(w.get_size()[0] + 10 if isShifted else w.get_size()[0] - 10, w.get_size()[1] + 10 if isShifted else w.get_size()[1] - 10))
 
    bquit = Gtk.Button(label=""Quit"")
    check(err, ""Unable to create quit button:"")
    bquit.connect(""clicked"", lambda w: window.destroy())
 
    stackbox.pack_start(bmax, True, True, 0)
    stackbox.pack_start(bunmax, True, True, 0)
    stackbox.pack_start(bicon, True, True, 0)
    stackbox.pack_start(bdeicon, True, True, 0)
    stackbox.pack_start(bhide, True, True, 0)
    stackbox.pack_start(bshow, True, True, 0)
    stackbox.pack_start(bmove, True, True, 0)
    stackbox.pack_start(bquit, True, True, 0)
 
    window.add(stackbox)
    window.show_all()
    Gtk.main()
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/LZW_compression,LZW compression,"The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.

You can read a complete description of it in the   Wikipedia article   on the subject.   It was patented, but it entered the public domain in 2004.



",Python,"def compress(uncompressed):
    """"""Compress a string to a list of output symbols.""""""
 
    # Build the dictionary.
    dict_size = 256
    dictionary = dict((chr(i), i) for i in range(dict_size))
    # in Python 3: dictionary = {chr(i): i for i in range(dict_size)}
 
    w = """"
    result = []
    for c in uncompressed:
        wc = w + c
        if wc in dictionary:
            w = wc
        else:
            result.append(dictionary[w])
            # Add wc to the dictionary.
            dictionary[wc] = dict_size
            dict_size += 1
            w = c
 
    # Output the code for w.
    if w:
        result.append(dictionary[w])
    return result
 
 
def decompress(compressed):
    """"""Decompress a list of output ks to a string.""""""
    from io import StringIO
 
    # Build the dictionary.
    dict_size = 256
    dictionary = dict((i, chr(i)) for i in range(dict_size))
    # in Python 3: dictionary = {i: chr(i) for i in range(dict_size)}
 
    # use StringIO, otherwise this becomes O(N^2)
    # due to string concatenation in a loop
    result = StringIO()
    w = chr(compressed.pop(0))
    result.write(w)
    for k in compressed:
        if k in dictionary:
            entry = dictionary[k]
        elif k == dict_size:
            entry = w + w[0]
        else:
            raise ValueError('Bad compressed k: %s' % k)
        result.write(entry)
 
        # Add w+entry[0] to the dictionary.
        dictionary[dict_size] = w + entry[0]
        dict_size += 1
 
        w = entry
    return result.getvalue()
 
 
# How to use:
compressed = compress('TOBEORNOTTOBEORTOBEORNOT')
print (compressed)
decompressed = decompress(compressed)
print (decompressed)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Xiaolin_Wu%27s_line_algorithm,Xiaolin Wu's line algorithm,"Task

Implement the   Xiaolin Wu's line algorithm   described in Wikipedia.



This algorithm draws anti-aliased lines.



Related task

   See   Bresenham's line algorithm   for aliased lines.

",Python,"""""""Script demonstrating drawing of anti-aliased lines using Xiaolin Wu's line
algorithm
 
usage: python xiaolinwu.py [output-file]
 
""""""
from __future__ import division
import sys
 
from PIL import Image
 
 
def _fpart(x):
    return x - int(x)
 
def _rfpart(x):
    return 1 - _fpart(x)
 
def putpixel(img, xy, color, alpha=1):
    """"""
    Paints color over the background at the point xy in img.
    Use alpha for blending. alpha=1 means a completely opaque foreground.
    """"""
    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))
    c = compose_color(img.getpixel(xy), color)
    img.putpixel(xy, c)
 
def draw_line(img, p1, p2, color):
    """"""Draws an anti-aliased line in img from p1 to p2 with the given color.""""""
    x1, y1 = p1
    x2, y2 = p2
    dx, dy = x2-x1, y2-y1
    steep = abs(dx) < abs(dy)
    p = lambda px, py: ((px,py), (py,px))[steep]
 
    if steep:
        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx
    if x2 < x1:
        x1, x2, y1, y2 = x2, x1, y2, y1
 
    grad = dy/dx
    intery = y1 + _rfpart(x1) * grad
    def draw_endpoint(pt):
        x, y = pt
        xend = round(x)
        yend = y + grad * (xend - x)
        xgap = _rfpart(x + 0.5)
        px, py = int(xend), int(yend)
        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)
        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)
        return px
 
    xstart = draw_endpoint(p(*p1)) + 1
    xend = draw_endpoint(p(*p2))
 
    for x in range(xstart, xend):
        y = int(intery)
        putpixel(img, p(x, y), color, _rfpart(intery))
        putpixel(img, p(x, y+1), color, _fpart(intery))
        intery += grad
 
 
if __name__ == '__main__':
    if len(sys.argv) != 2:
        print 'usage: python xiaolinwu.py [output-file]'
        sys.exit(-1)
 
    blue = (0, 0, 255)
    yellow = (255, 255, 0)
    img = Image.new(""RGB"", (500,500), blue)
    for a in range(10, 431, 60):
        draw_line(img, (10, 10), (490, a), yellow)
        draw_line(img, (10, 10), (a, 490), yellow)
    draw_line(img, (10, 10), (490, 490), yellow)
    filename = sys.argv[1]
    img.save(filename)
    print 'image saved to', filename",Human_written,Python_from_Go
http://rosettacode.org/wiki/Primality_by_trial_division,Primality by trial division,"Task

Write a boolean function that tells whether a given integer is prime.



Remember that   1   and all non-positive numbers are not prime.

Use trial division.

Even numbers greater than   2   may be eliminated right away.

A loop from   3   to   √ n    will suffice,   but other loops are allowed.



Related tasks

   count in factors
   prime decomposition
   AKS test for primes
   factors of an integer
   Sieve of Eratosthenes
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes
   sequence of primes by Trial Division

",Python,"def prime(a):
    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",Python,"#!/usr/bin/env python
 
import sys
 
def main():
    program = sys.argv[0]
    print(""Program: %s"" % program)
 
if __name__ == ""__main__"":
    main()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Pi,Pi,"
Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi }

   (pi).

The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession.

The output should be a decimal sequence beginning   3.14159265 ...



Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.



Related Task Arithmetic-geometric mean/Calculate Pi
",Python,"def calcPi():
    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3
    while True:
        if 4*q+r-t < n*t:
            yield n
            nr = 10*(r-n*t)
            n  = ((10*(3*q+r))//t)-10*n
            q  *= 10
            r  = nr
        else:
            nr = (2*q+r)*l
            nn = (q*(7*k)+2+(r*l))//(t*l)
            q  *= k
            t  *= l
            l  += 2
            k += 1
            n  = nn
            r  = nr
 
import sys
pi_digits = calcPi()
i = 0
for d in pi_digits:
    sys.stdout.write(str(d))
    i += 1
    if i == 40: print(""""); i = 0",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Square_but_not_cube,Square but not cube,"Task

Show the first   30   positive integers which are squares but not cubes of such integers.

Optionally, show also the first   3   positive integers which are both squares and cubes,   and mark them as such.



",Python,"from itertools import count
from itertools import islice
from itertools import tee
from itertools import zip_longest
 
def squares():
    for i in count(1):
        yield i * i
 
def cubes():
    for i in count(1):
        yield i * i * i
 
def merge():
    s, c = tee(squares(), 2)
    for x, y in zip_longest(s, c, fillvalue=None):
        if x is None:
            yield y, False
        elif y is None:
            yield x, False
        elif x < y:
            yield x, False
        elif x == y:
            yield x, True
        else:
            yield y, False
 
for x in islice(merge(), 33):
    print(x[1] and f""{x[0]} (also cube)"" or x[0])",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Find_the_intersection_of_two_lines,Find the intersection of two lines,"[1]


Task

Find the point of intersection of two lines in 2D.



The 1st line passes though    (4,0)    and    (6,10) .

The 2nd line passes though    (0,3)    and    (10,7) .



",Python,"from __future__ import division
from collections import namedtuple
 
Point = namedtuple('Point', ['x', 'y'])
 
class Line(object):
    def __init__(self, point1, point2):
        self.a = (point1.y - point2.y) / (point1.x - point2.x)
        self.b = point1.y - self.a * point1.x
 
    def intersect(self, other):
        if self.a == other.a:
            return None
        x = (other.b - self.b) / (self.a - other.a)
        y = self.a * x + self.b
        return Point(x, y)
 
    def __str__(self):
        return 'y = {0}x + {1}'.format(self.a, self.b)
 
l1 = Line(Point(4, 0), Point(6, 10))
l2 = Line(Point(0, 3), Point(10, 7))
 
print 'Line {0} intersects line {1} at {2}.'.format(l1, l2, l1.intersect(l2))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Solve_a_Hidato_puzzle,Solve a Hidato puzzle,"The task is to write a program which solves Hidato (aka Hidoku) puzzles.

The rules are:

 You are given a grid with some numbers placed in it. The other squares in the grid will be blank.
 The grid is not necessarily rectangular.
 The grid may have holes in it.
 The grid is always connected.
 The number “1” is always present, as is another number that is equal to the number of squares in the grid. Other numbers are present so as to force the solution to be unique.
 It may be assumed that the difference between numbers present on the grid is not greater than lucky 13.
 The aim is to place a natural number in each blank square so that in the sequence of numbered squares from “1” upwards, each square is in the wp:Moore neighborhood of the squares immediately before and after it in the sequence (except for the first and last squares, of course, which only have one-sided constraints).
 Thus, if the grid was overlaid on a chessboard, a king would be able to make legal moves along the path from first to last square in numerical order.
 A square may only contain one number.
 In a proper Hidato puzzle, the solution is unique.

For example the following problem


has the following solution, with path marked on it:




Related tasks

 A* search algorithm
 N-queens problem
 Solve a Holy Knight's tour
 Solve a Knight's tour
 Solve a Hopido puzzle
 Solve a Numbrix puzzle
 Solve the no connection puzzle;

",Python,"board = []
given = []
start = None
 
def setup(s):
    global board, given, start
    lines = s.splitlines()
    ncols = len(lines[0].split())
    nrows = len(lines)
    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]
 
    for r, row in enumerate(lines):
        for c, cell in enumerate(row.split()):
            if cell == ""__"" :
                board[r + 1][c + 1] = 0
                continue
            elif cell == ""."":
                continue # -1
            else:
                val = int(cell)
                board[r + 1][c + 1] = val
                given.append(val)
                if val == 1:
                    start = (r + 1, c + 1)
    given.sort()
 
def solve(r, c, n, next=0):
    if n > given[-1]:
        return True
    if board[r][c] and board[r][c] != n:
        return False
    if board[r][c] == 0 and given[next] == n:
        return False
 
    back = 0
    if board[r][c] == n:
        next += 1
        back = n
 
    board[r][c] = n
    for i in xrange(-1, 2):
        for j in xrange(-1, 2):
            if solve(r + i, c + j, n + 1, next):
                return True
    board[r][c] = back
    return False
 
def print_board():
    d = {-1: ""  "", 0: ""__""}
    bmax = max(max(r) for r in board)
    form = ""%"" + str(len(str(bmax)) + 1) + ""s""
    for r in board[1:-1]:
        print """".join(form % d.get(c, str(c)) for c in r[1:-1])
 
hi = """"""\
__ 33 35 __ __  .  .  .
__ __ 24 22 __  .  .  .
__ __ __ 21 __ __  .  .
__ 26 __ 13 40 11  .  .
27 __ __ __  9 __  1  .
 .  . __ __ 18 __ __  .
 .  .  .  . __  7 __ __
 .  .  .  .  .  .  5 __""""""
 
setup(hi)
print_board()
solve(start[0], start[1], 1)
print
print_board()",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Program_name,Program name,"The task is to programmatically obtain the name used to invoke the program. (For example determine whether the user ran ""python hello.py"", or ""python hellocaller.py"", a program importing the code from ""hello.py"".)

Sometimes a multiline shebang is necessary in order to provide the script name to a language's internal ARGV.

See also Command-line arguments

Examples from GitHub.
",Python,"import sys

class ScriptName:
    def main(self):
        program = sys.argv[0]
        print(""Program: "" + program)

if __name__ == '__main__':
    ScriptName().main()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Evolutionary_algorithm,Evolutionary algorithm,"Starting with:

 The target string: ""METHINKS IT IS LIKE A WEASEL"".
 An array of random characters chosen from the set of upper-case letters together with the space, and of the same length as the target string. (Call it the parent).
 A fitness function that computes the ‘closeness’ of its argument to the target string.
 A mutate function that given a string and a mutation rate returns a copy of the string, with some characters probably mutated.
 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
 Assess the fitness of the parent and all the copies to the target and make the most fit string the new parent, discarding the others.
 repeat until the parent converges, (hopefully), to the target.


See also

   Wikipedia entry:   Weasel algorithm.
   Wikipedia entry:   Evolutionary algorithm.

Note: to aid comparison, try and ensure the variables and functions mentioned in the task description appear in solutions



A cursory examination of a few of the solutions reveals that the instructions have not been followed rigorously in some solutions. Specifically,

 While the parent is not yet the target:
 copy the parent C times, each time allowing some random probability that another character might be substituted using mutate.
Note that some of the the solutions given retain characters in the mutated string that are correct in the target string. However, the instruction above does not state to retain any of the characters while performing the mutation. Although some may believe to do so is implied from the use of ""converges""

(:* repeat until the parent converges, (hopefully), to the target.

Strictly speaking, the new parent should be selected from the new pool of mutations, and then the new parent used to generate the next set of mutations with parent characters getting retained only by not being mutated. It then becomes possible that the new set of mutations has no member that is fitter than the parent!

As illustration of this error, the code for 8th has the following remark.

Create a new string based on the TOS, changing randomly any characters which
don't already match the target:

NOTE: this has been changed, the 8th version is completely random now

Clearly, this algo will be applying the mutation function only to the parent characters that don't match to the target characters!

To ensure that the new parent is never less fit than the prior parent, both the parent and all of the latest mutations are subjected to the fitness test to select the next parent.



",Python,"import random
import string
 
target = ""METHINKS IT IS LIKE A WEASEL""
tbl = string.ascii_uppercase + "" ""
 
def irand(n):
	return random.randint(0, n - 1)
 
def unfitness(a, b):
	return sum(1 for x, y in zip(a, b) if x!= y)
 
def mutate(a):
	return ''.join(tbl[irand(len(tbl))] if irand(15) else x for x in a)
 
def main():
	specimen = [mutate(target) for _ in range(30)]
	while True:
		specimen = [mutate(specimen[0]) for _ in range(30)]
		best = min(specimen, key=lambda x: unfitness(target, x))
		print ""iter %d, score %d: %s"" % (iters, unfitness(target, best), best)
		if not unfitness(target, best):
			break
 
if __name__ == '__main__':
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Extensible_prime_generator,Extensible prime generator,"Task

Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.

The routine should demonstrably rely on either:

 Being based on an open-ended counter set to count without upper limit other than system or programming language limits. In this case, explain where this counter is in the code.
 Being based on a limit that is extended automatically. In this case, choose a small limit that ensures the limit will be passed when generating some of the values to be asked for below.
 If other methods of creating an extensible prime generator are used, the algorithm's means of extensibility/lack of limits should be stated.


The routine should be used to:

 Show the first twenty primes.
 Show the primes between 100 and 150.
 Show the number of primes between 7,700 and 8,000.
 Show the 10,000th prime.


Show output on this page.

Note: You may reference code already on this site if it is written to be imported/included, then only the code necessary for import and the performance of this task need be shown. (It is also important to leave a forward link on the referenced tasks entry so that later editors know that the code is used for multiple tasks).

Note 2: If a languages in-built prime generator is extensible or is guaranteed to generate primes up to a system limit, (231 or memory overflow for example), then this may be used as long as an explanation of the limits of the prime generator is also given. (Which may include a link to/excerpt from, language documentation).

Note 3:The task is written so it may be useful in solving the task   Emirp primes   as well as others (depending on its efficiency).





Reference

 Prime Numbers. Website with large count of primes.

",Python,"islice(count(7), 0, None, 2)",Human_written,Python_from_Java
http://rosettacode.org/wiki/Kaprekar_numbers,Kaprekar numbers,"A positive integer is a Kaprekar number if:

 It is   1     (unity)
 The decimal representation of its square may be split once into two parts consisting of positive integers which sum to the original number. 

Note that a split resulting in a part consisting purely of 0s is not valid,
as 0 is not considered positive.



Example Kaprekar numbers

 



2223


{\displaystyle 2223}

 is a Kaprekar number, as 



2223
∗
2223
=
4941729


{\displaystyle 2223*2223=4941729}

, 



4941729


{\displaystyle 4941729}

 may be split to 



494


{\displaystyle 494}

 and 



1729


{\displaystyle 1729}

, and 



494
+
1729
=
2223


{\displaystyle 494+1729=2223}

.
 The series of Kaprekar numbers is known as A006886, and begins as 



1
,
9
,
45
,
55
,
.
.
.


{\displaystyle 1,9,45,55,...}

.


Example process

10000 (1002) splitting from left to right:

 The first split is [1, 0000], and is invalid; the 0000 element consists entirely of 0s, and 0 is not considered positive.
 Slight optimization opportunity: When splitting from left to right, once the right part consists entirely of 0s, no further testing is needed; all further splits would also be invalid.


Task

Generate and show all Kaprekar numbers less than 10,000.



Extra credit

Optionally, count (and report the count of) how many Kaprekar numbers are less than 1,000,000.



Extra extra credit

The concept of Kaprekar numbers is not limited to base 10 (i.e. decimal numbers);
if you can, show that Kaprekar numbers exist in other bases too.



For this purpose, do the following:

 Find all Kaprekar numbers for base 17 between 1 and 1,000,000 (one million);
 Display each of them in base 10 representation;
 Optionally, using base 17 representation (use letters 'a' to 'g' for digits 10(10) to 16(10)), display each of the numbers, its square, and where to split the square. 


225   d4  a52g  a5 + 2g


Reference

 The Kaprekar Numbers by Douglas E. Iannucci (2000). PDF version


Related task

   Casting out nines

",Python,">>> def k(n):
	n2 = str(n**2)
	for i in range(len(n2)):
		a, b = int(n2[:i] or 0), int(n2[i:])
		if b and a + b == n:
			return n
			#return (n, (n2[:i], n2[i:]))
 
 
>>> [x for x in range(1,10000) if k(x)]
[1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]
>>> len([x for x in range(1,1000000) if k(x)])
54
>>>",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort,Sorting algorithms/Bubble sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


A   bubble   sort is generally considered to be the simplest sorting algorithm.

A   bubble   sort is also known as a   sinking   sort.



Because of its simplicity and ease of visualization, it is often taught in introductory computer science courses.

Because of its abysmal O(n2) performance, it is not used often for large (or even medium-sized) datasets.

The bubble sort works by passing sequentially over a list, comparing each value to the one immediately after it.   If the first value is greater than the second, their positions are switched.   Over a number of passes, at most equal to the number of elements in the list, all of the values drift into their correct positions (large values ""bubble"" rapidly toward the end, pushing others down around them).  
Because each pass finds the maximum item and puts it at the end, the portion of the list to be sorted can be reduced at each pass.  
A boolean variable is used to track whether any changes have been made in the current pass; when a pass completes without changing anything, the algorithm exits.

This can be expressed in pseudo-code as follows (assuming 1-based indexing):

repeat
    if itemCount <= 1
        return
    hasChanged := false
    decrement itemCount
    repeat with index from 1 to itemCount
        if (item at index) > (item at (index + 1))
            swap (item at index) with (item at (index + 1))
            hasChanged := true
until hasChanged = false



Task

Sort an array of elements using the bubble sort algorithm.   The elements must have a total order and the index of the array can be of any discrete type.   For languages where this is not possible, sort an array of integers.



References

 The article on Wikipedia.
 Dance interpretation.

",Python,"def bubble_sort(seq):
    """"""Inefficiently sort the mutable sequence (list) in place.
       seq MUST BE A MUTABLE SEQUENCE.
 
       As with list.sort() and random.shuffle this does NOT return 
    """"""
    changed = True
    while changed:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i]
                changed = True
    return seq
 
if __name__ == ""__main__"":
   """"""Sample usage and simple test suite""""""
 
   from random import shuffle
 
   testset = [_ for _ in range(100)]
   testcase = testset.copy() # make a copy
   shuffle(testcase)
   assert testcase != testset  # we've shuffled it
   bubble_sort(testcase)
   assert testcase == testset  # we've unshuffled it back into a copy",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Constrained_random_points_on_a_circle,Constrained random points on a circle,"Task

Generate 100 <x,y> coordinate pairs such that x and y are integers sampled from the uniform distribution with the condition that 




10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

. 
Then display/plot them. The outcome should be a ""fuzzy"" circle. The actual number of points plotted may be less than 100, given that some pairs may be generated more than once.

There are several possible approaches to accomplish this. Here are two possible algorithms.

1) Generate random pairs of integers and filter out those that don't satisfy this condition:





10
≤



x

2


+

y

2




≤
15


{\displaystyle 10\leq {\sqrt {x^{2}+y^{2}}}\leq 15}

.
2) Precalculate the set of all possible points (there are 404 of them) and select randomly from this set.



",Python,">>> from collections import defaultdict
>>> from random import choice
>>> world = defaultdict(int)
>>> possiblepoints = [(x,y) for x in range(-15,16)
		  for y in range(-15,16)
		  if 10 <= abs(x+y*1j) <= 15]
>>> for i in range(100): world[choice(possiblepoints)] += 1
 
>>> for x in range(-15,16):
	print(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '
			  for y in range(-15,16)))
 
 
 
             1     1           
          1 1                  
      11 1     1  1     1      
     111  1     1211           
      1   2    1 1    11       
      1  11         21         
     1   1            11  1    
   1  2                1 1     
 
 1  2                          
   1 1                      1  
   1 1                         
   2                      11   
  1                         1  
                         1     
 
 
  1                          1 
                         1     
                         2     
                            1  
     1                  1 1    
      1                2   1   
   1   3            11  2      
    11   1    1      1   2     
            1   1    2         
        1  1                   
         1      1     1        
          2 2   1              
               1",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion,Parsing/RPN to infix conversion,"Parsing/RPN to infix conversion

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a program that takes an RPN representation of an expression formatted as a space separated sequence of tokens and generates the equivalent expression in infix notation.

 Assume an input of a correct, space separated, string of tokens
 Generate a space separated output string representing the same expression in infix notation
 Show how the major datastructure of your algorithm changes with each new token parsed.
 Test with the following input RPN strings then print and display the output here.


 RPN input 
 sample output


 3 4 2 * 1 5 - 2 3 ^ ^ / +
 3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3


 1 2 + 3 4 + ^ 5 6 + ^
 ( ( 1 + 2 ) ^ ( 3 + 4 ) ) ^ ( 5 + 6 )

 Operator precedence and operator associativity is given in this table:


 operator 
 precedence 
 associativity 
 operation


  ^  
 4 
 right 
 exponentiation


  *  
 3 
 left 
 multiplication


  /  
 3 
 left 
 division


  +  
 2 
 left 
 addition


  -  
 2 
 left 
 subtraction



See also

   Parsing/Shunting-yard algorithm   for a method of generating an RPN from an infix expression.
   Parsing/RPN calculator algorithm   for a method of calculating a final value from this output RPN expression.
   Postfix to infix   from the RubyQuiz site.

",Python,"""""""
>>> # EXAMPLE USAGE
>>> result = rpn_to_infix('3 4 2 * 1 5 - 2 3 ^ ^ / +', VERBOSE=True)
TOKEN  STACK
3      ['3']
4      ['3', '4']
2      ['3', '4', '2']
*      ['3', Node('2','*','4')]
1      ['3', Node('2','*','4'), '1']
5      ['3', Node('2','*','4'), '1', '5']
-      ['3', Node('2','*','4'), Node('5','-','1')]
2      ['3', Node('2','*','4'), Node('5','-','1'), '2']
3      ['3', Node('2','*','4'), Node('5','-','1'), '2', '3']
^      ['3', Node('2','*','4'), Node('5','-','1'), Node('3','^','2')]
^      ['3', Node('2','*','4'), Node(Node('3','^','2'),'^',Node('5','-','1'))]
/      ['3', Node(Node(Node('3','^','2'),'^',Node('5','-','1')),'/',Node('2','*','4'))]
+      [Node(Node(Node(Node('3','^','2'),'^',Node('5','-','1')),'/',Node('2','*','4')),'+','3')]
""""""
 
prec_dict =  {'^':4, '*':3, '/':3, '+':2, '-':2}
assoc_dict = {'^':1, '*':0, '/':0, '+':0, '-':0}
 
class Node:
    def __init__(self,x,op,y=None):
        self.precedence = prec_dict[op]
        self.assocright = assoc_dict[op]
        self.op = op
        self.x,self.y = x,y
 
    def __str__(self):
        """"""
        Building an infix string that evaluates correctly is easy.
        Building an infix string that looks pretty and evaluates
        correctly requires more effort.
        """"""
        # easy case, Node is unary
        if self.y == None:
            return '%s(%s)'%(self.op,str(self.x))
 
        # determine left side string
        str_y = str(self.y)
        if  self.y < self or \
            (self.y == self and self.assocright) or \
            (str_y[0] is '-' and self.assocright):
 
            str_y = '(%s)'%str_y
        # determine right side string and operator
        str_x = str(self.x)
        str_op = self.op
        if self.op is '+' and not isinstance(self.x, Node) and str_x[0] is '-':
            str_x = str_x[1:]
            str_op = '-'
        elif self.op is '-' and not isinstance(self.x, Node) and str_x[0] is '-':
            str_x = str_x[1:]
            str_op = '+'
        elif self.x < self or \
             (self.x == self and not self.assocright and \
              getattr(self.x, 'op', 1) != getattr(self, 'op', 2)):
 
            str_x = '(%s)'%str_x
        return ' '.join([str_y, str_op, str_x])
 
    def __repr__(self):
        """"""
        >>> repr(Node('3','+','4')) == repr(eval(repr(Node('3','+','4'))))
        True
        """"""
        return 'Node(%s,%s,%s)'%(repr(self.x), repr(self.op), repr(self.y))
 
    def __lt__(self, other):
        if isinstance(other, Node):
            return self.precedence < other.precedence
        return self.precedence < prec_dict.get(other,9)
 
    def __gt__(self, other):
        if isinstance(other, Node):
            return self.precedence > other.precedence
        return self.precedence > prec_dict.get(other,9)
 
    def __eq__(self, other):
        if isinstance(other, Node):
            return self.precedence == other.precedence
        return self.precedence > prec_dict.get(other,9)
 
 
 
def rpn_to_infix(s, VERBOSE=False):
    """"""
 
    converts rpn notation to infix notation for string s
 
    """"""
    if VERBOSE : print('TOKEN  STACK')
 
    stack=[]
    for token in s.replace('^','^').split():
        if token in prec_dict:
            stack.append(Node(stack.pop(),token,stack.pop()))
        else:
            stack.append(token)
 
        # can't use \t in order to make global docstring pass doctest
        if VERBOSE : print(token+' '*(7-len(token))+repr(stack)) 
 
    return str(stack[0])
 
strTest = ""3 4 2 * 1 5 - 2 3 ^ ^ / +""
strResult = rpn_to_infix(strTest, VERBOSE=False)
print (""Input: "",strTest)
print (""Output:"",strResult)
 
print()
 
strTest = ""1 2 + 3 4 + ^ 5 6 + ^""
strResult = rpn_to_infix(strTest, VERBOSE=False)
print (""Input: "",strTest)
print (""Output:"",strResult)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/World_Cup_group_stage,World Cup group stage,"It's World Cup season (or at least it was when this page was created)!

The World Cup is an international football/soccer tournament that happens every 4 years.   Countries put their international teams together in the years between tournaments and qualify for the tournament based on their performance in other international games.   Once a team has qualified they are put into a group with 3 other teams.

For the first part of the World Cup tournament the teams play in ""group stage"" games where each of the four teams in a group plays all three other teams once.   The results of these games determine which teams will move on to the ""knockout stage"" which is a standard single-elimination tournament.   The two teams from each group with the most standings points move on to the knockout stage.

Each game can result in a win for one team and a loss for the other team or it can result in a draw/tie for each team.

   A win is worth three points.
   A draw/tie is worth one point. 
   A loss is worth zero points.


Task

   Generate all possible outcome combinations for the six group stage games.   With three possible outcomes for each game there should be 36 = 729 of them. 
   Calculate the standings points for each team with each combination of outcomes. 
   Show a histogram (graphical,   ASCII art, or straight counts--whichever is easiest/most fun) of the standings points for all four teams over all possible outcomes.


Don't worry about tiebreakers as they can get complicated.   We are basically looking to answer the question ""if a team gets x standings points, where can they expect to end up in the group standings?"".

Hint: there should be no possible way to end up in second place with less than two points as well as no way to end up in first with less than three.   Oddly enough, there is no way to get 8 points at all.
",Python,"from itertools import combinations, product
from operator import itemgetter
from collections import Counter
from pprint import pprint
 
def combinations_with_replacement(iterable, r):
    # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC
    pool = tuple(iterable)
    n = len(pool)
    if not n and r:
        return
    indices = [0] * r
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i]!= n - 1:
                break
        else:
            return
        indices[i:] = [indices[i] + 1] * (r - i)
        yield tuple(pool[i] for i in indices)
 
def combinations(iterable, r):
    # combinations('ABCD', 2) --> AB AC AD BC BD CD
    # combinations(range(4), 3) --> 012 013 023 123
    pool = tuple(iterable)
    n = len(pool)
    if r > n:
        return
    indices = list(range(r))
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i]!= i + n - r:
                break
        else:
            return
        indices[i] += 1
        for j in range(i+1, r):
            indices[j] = indices[j-1] + 1
        yield tuple(pool[i] for i in indices)
 
def cartesian_product(*args, repeat=1):
    # cartesian_product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # cartesian_product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
    pools = [tuple(pool) for pool in args] * repeat
    result = [[]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)
 
def histogram(iterable, bins=10, range=None):
    if range is None:
        range = (min(iterable), max(iterable))
    bin_size = (range[1] - range[0]) / bins
    bins = [range[0] + i * bin_size for i in range(bins + 1)]
    return Counter(map(lambda x: int(x / bin_size), iterable))
 
def main():
    scoring = [0, 1, 3]
    histogram = [Counter() for _ in range(4)]
    team_combos = combinations(range(4), 2)
    for results in product(range(3), repeat=6):
        points = [0] * 4
        for result, teams in zip(results, team_combos):
            points[teams[0]] += scoring[result]
            points[teams[1]] += scoring[2 - result]
        for p, i in enumerate(sorted(points, reverse=True)):
            histogram[i][p] += 1
    pprint(histogram)
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Square-free_integers,Square-free integers,"Task

Write a function to test if a number is   square-free.



A   square-free   is an integer which is divisible by no perfect square other
than   1   (unity).

For this task, only positive square-free numbers will be used.



Show here (on this page) all square-free integers (in a horizontal format) that are between:

   1   ───►   145     (inclusive)
   1 trillion   ───►   1 trillion + 145     (inclusive)


(One trillion = 1,000,000,000,000)



Show here (on this page) the count of square-free integers from:

   1   ───►   one hundred     (inclusive)
   1   ───►   one thousand     (inclusive)
   1   ───►   ten thousand     (inclusive)
   1   ───►   one hundred thousand     (inclusive)
   1   ───►   one million     (inclusive)


See also

   the Wikipedia entry:   square-free integer

",Python,"import math
 
def sieve(limit):
    primes = [2]
    c = [False] * (limit + 1) # composite = True
    # no need to process even numbers > 2
    p = 3
    while True:
        p2 = p * p
        if p2 > limit:
            break
        for i in range(p2, limit + 1, 2 * p):
            c[i] = True
        while True:
            p += 2
            if not c[p]:
                break
    for i in range(3, limit + 1, 2):
        if not c[i]:
            primes.append(i)
    return primes
 
def square_free(from_, to):
    limit = int(math.sqrt(to))
    primes = sieve(limit)
    results = []
 
    for i in range(from_, to + 1):
        for p in primes:
            p2 = p * p
            if p2 > i:
                break
            if i % p2 == 0:
                continue
        results.append(i)
    return results
 
TRILLION = 1000000000000
 
print(""Square-free integers from 1 to 145:"")
sf = square_free(1, 145)
for i in range(len(sf)):
    if i > 0 and i % 20 == 0:
        print()
    print(""%4d"" % sf[i], end="""")
 
print(""\n\nSquare-free integers from"", TRILLION, ""to"", TRILLION + 145, "":"")
sf = square_free(TRILLION, TRILLION + 145)
for i in range(len(sf)):
    if i > 0 and i % 5 == 0:
        print()
    print(""%14d"" % sf[i], end="""")
 
print(""\n\nNumber of square-free integers:"")
tos = [100, 1000, 10000, 100000, 1000000]
for to in tos:
    print(""  from"", 1, ""to"", to, ""="", len(square_free(1, to)))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape,Create a file on magnetic tape,"The task is to create a new file called ""TAPE.FILE"" of any size on Magnetic Tape.
",Python,">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\n')
... 
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic/Integer,"
Basic Data Operation

This is a basic data operation. It represents a fundamental action on a basic data type.
You may see other such operations in the Basic Data Operations category, or:


Integer Operations
Arithmetic |
Comparison
Boolean Operations
Bitwise |
Logical
String Operations
Concatenation |
Interpolation |
Comparison |
Matching
Memory Operations
Pointers & references |
Addresses


Task

Get two integers from the user,   and then (for those two integers), display their:

   sum 
   difference 
   product 
   integer quotient
   remainder 
   exponentiation   (if the operator exists) 


Don't include error handling.

For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.).

For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.



",Python,"x = int(raw_input(""Number 1: ""))
y = int(raw_input(""Number 2: ""))
 
print ""Sum: %d"" % (x + y)
print ""Difference: %d"" % (x - y)
print ""Product: %d"" % (x * y)
print ""Quotient: %d"" % (x / y)     #  or x // y  for newer python versions.
                                   # truncates towards negative infinity
print ""Remainder: %d"" % (x % y)    # same sign as second operand
print ""Quotient: %d with Remainder: %d"" % divmod(x, y)
print ""Power: %d"" % x**y
 
## Only used to keep the display up when the program ends
raw_input( )",Human_written,Python_from_C#
http://rosettacode.org/wiki/Longest_increasing_subsequence,Longest increasing subsequence,"Calculate and show here a longest increasing subsequence of the list:





{
3
,
2
,
6
,
4
,
5
,
1
}


{\displaystyle \{3,2,6,4,5,1\}}


And of the list:





{
0
,
8
,
4
,
12
,
2
,
10
,
6
,
14
,
1
,
9
,
5
,
13
,
3
,
11
,
7
,
15
}


{\displaystyle \{0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15\}}


Note that a list may have more than one subsequence that is of the maximum length.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Ref

 Dynamic Programming #1: Longest Increasing Subsequence on YouTube
 An efficient solution can be based on Patience sorting.

",Python,"def longest_increasing_subsequence(X):
    """"""Returns the Longest Increasing Subsequence in the Given List/Array""""""
    N = len(X)
    P = [0] * N
    M = [0] * (N+1)
    L = 0
    for i in range(N):
       lo = 1
       hi = L
       while lo <= hi:
           mid = (lo+hi)//2
           if (X[M[mid]] < X[i]):
               lo = mid+1
           else:
               hi = mid-1
 
       newL = lo
       P[i] = M[newL-1]
       M[newL] = i
 
       if (newL > L):
           L = newL
 
    S = []
    k = M[L]
    for i in range(L-1, -1, -1):
        S.append(X[k])
        k = P[k]
    return S[::-1]
 
if __name__ == '__main__':
    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:
        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Binary_search,Binary search,"A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a ""divide and conquer"" algorithm.

As an analogy, consider the children's game ""guess a number."" The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.

As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.



Task

Given the starting point of a range, the ending point of a range, and the ""secret value"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.

There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.

All of the following code examples use an ""inclusive"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using ""exclusive"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

 change high = N-1 to high = N
 change high = mid-1 to high = mid
 (for recursive algorithm) change if (high < low) to if (high <= low)
 (for iterative algorithm) change while (low <= high) to while (low < high)
Traditional algorithm
The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the ""insertion point"" for it (the index that the value would have if it were inserted into the array).

Recursive Pseudocode:

  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index ""low""
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

Iterative Pseudocode:

  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index ""low""
  }

Leftmost insertion point
The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Rightmost insertion point
The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.

Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Extra credit
Make sure it does not have overflow bugs.

The line in the pseudo-code above to calculate the mean of two integers:

mid = (low + high) / 2
could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.

One way to fix it is to manually add half the range to the low number:

mid = low + (high - low) / 2
Even though this is mathematically equivalent to the above, it is not susceptible to overflow.

Another way for signed integers, possibly faster, is the following:

mid = (low + high) >>> 1
where  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.



Related task

 Guess the number/With Feedback (Player)


See also

 wp:Binary search algorithm
 Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.

",Python,"def binary_search(arr, val, low=0, high=(len(arr) - 1)):
    if high < low:
        return None
    mid = (low + high) >> 1
    if val < arr[mid]:
        return binary_search(arr, val, low, mid - 1)
    elif val > arr[mid]:
        return binary_search(arr, val, mid + 1, high)
    else:
        return mid
 
ary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]
 
for val in [0,42,45,24324,99999]:
    i = binary_search(ary, val)
    if i:
        print(""found {0} at index {1}: {2}"".format(val, i, ary[i]))
    else:
        print(""{0} not found in array"".format(val))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Regular_expressions,Regular expressions,"

Task

   match a string against a regular expression
   substitute part of a string using a regular expression

",Python,"import re
 
string = ""This is a string""
 
if re.search('string$', string):
    print(""Ends with string."")
 
string = re.sub("" a "", "" another "", string)
print(string)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Literals/Integer,Literals/Integer,"Some programming languages have ways of expressing integer literals in bases other than the normal base ten.



Task

Show how integer literals can be expressed in as many bases as your language allows.



Note:   this should not involve the calling of any functions/methods, but should be interpreted by the compiler or interpreter as an integer written to a given base.

Also show any other ways of expressing literals, e.g. for different types of integers.



Related task

   Literals/Floating point

",Python,">>> # Bin(leading 0b or 0B), Oct(leading 0o or 0O), Dec, Hex(leading 0x or 0X), in order:
>>> 0b1011010111 == 0o1327 == 727 == 0x2d7
True
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Entropy/Narcissist,Entropy/Narcissist,"
Task

Write a computer program that computes and shows its own   entropy.



Related Tasks

   Fibonacci_word
   Entropy

",Python,"import math
from collections import Counter
 
def entropy(s):
    p, lns = Counter(s), float(len(s))
    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())
 
with open(__file__) as f:
    b=f.read()
 
print(entropy(b))",Human_written,Python_from_C++
http://rosettacode.org/wiki/Matrix-exponentiation_operator,Matrix-exponentiation operator,"Most programming languages have a built-in implementation of exponentiation for integers and reals only.



Task

Demonstrate how to implement matrix exponentiation as an operator.



",Python,"from itertools import product
from functools import reduce
from operator import mul
 
def identity(size):
    return [[1 if i == j else 0 for j in range(size)] for i in range(size)]
 
def multiply(left, right):
    if len(left[0])!= len(right):
        raise ValueError(""Matrix dimensions do not match."")
    return [[sum(map(mul, row, col)) for col in zip(*right)] for row in left]
 
def pow(matrix, exp):
    if len(matrix)!= len(matrix[0]):
        raise ValueError(""Matrix must be square."")
    accumulator = identity(len(matrix))
    for _ in range(exp):
        accumulator = multiply(accumulator, matrix)
    return accumulator
 
def print_matrix(m):
    for row in m:
        print(""[ "" + ""   "".join(map(str, row)) + "" ]"")
    print()
 
if __name__ == ""__main__"":
    matrix = [[3, 2], [2, 1]]
 
    print_matrix(pow(matrix, 0))
    print_matrix(pow(matrix, 1))
    print_matrix(pow(matrix, 2))
    print_matrix(pow(matrix, 3))
    print_matrix(pow(matrix, 4))
    print_matrix(pow(matrix, 50))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Even_or_odd,Even or odd,"Task

Test whether an integer is even or odd.

There is more than one way to solve this task:

 Use the even and odd predicates, if the language provides them.
 Check the least significant digit. With binary integers, i bitwise-and 1 equals 0 iff i is even, or equals 1 iff i is odd.
 Divide i by 2. The remainder equals 0 iff i is even. The remainder equals +1 or -1 iff i is odd.
 Use modular congruences:
 i ≡ 0 (mod 2) iff i is even.
 i ≡ 1 (mod 2) iff i is odd.

",Python,"print(""evens: "")
print(list(filter(lambda x: x % 2 == 0, range(-5, 6))))
print(""odds: "")
print(list(filter(lambda x: x % 2!= 0, range(-5, 6))))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Shortest_common_supersequence,Shortest common supersequence,"The   shortest common supersequence   is a problem closely related to the   longest common subsequence,   which you can use as an external function for this task.



Task

Given two strings 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

, find the shortest possible sequence 



s


{\displaystyle s}

, which is the shortest common super-sequence of 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 where both 



u


{\displaystyle u}

 and 



v


{\displaystyle v}

 are a subsequence of 



s


{\displaystyle s}

. Defined as such, 



s


{\displaystyle s}

 is not necessarily unique.

Demonstrate this by printing 



s


{\displaystyle s}

 where 



u
=


{\displaystyle u=}

“abcbdab” and 



v
=


{\displaystyle v=}

“bdcaba”.



Also see

 Wikipedia: shortest common supersequence 

",Python,"# Use the Longest Common Subsequence algorithm
 
def shortest_common_supersequence(a, b):
    lcs = longest_common_subsequence(a, b)
    scs = """"
    # Consume lcs
    while len(lcs) > 0:
        if a[0]==lcs[0] and b[0]==lcs[0]:
        # Part of the LCS, so consume from all strings
            scs += lcs[0]
            lcs = lcs[1:]
            a = a[1:]
            b = b[1:]
        elif a[0]==lcs[0]:
            scs += b[0]
            b = b[1:]
        else:
            scs += a[0]
            a = a[1:]
    # append remaining characters
    return scs + a + b",Human_written,Python_from_C#
http://rosettacode.org/wiki/Roots_of_a_function,Roots of a function,"Task

Create a program that finds and outputs the roots of a given function, range and (if applicable) step width.

The program should identify whether the root is exact or approximate.



For this task, use:      ƒ(x)   =   x3 - 3x2 + 2x 
",Python,"f = lambda x: x * x * x - 3 * x * x + 2 * x
 
step = 0.001 # Smaller step values produce more accurate and precise results
start = -1
stop = 3
 
sign = f(start) > 0
 
x = start
while x <= stop:
    value = f(x)
 
    if value == 0:
        # We hit a root
        print ""Root found at"", x
    elif (value > 0) != sign:
        # We passed a root
        print ""Root found near"", x
 
    # Update our sign
    sign = value > 0
 
    x += step",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Yin_and_yang,Yin and yang,"One well-known symbol of the philosophy of duality known as yin and yang is the taijitu.



Task

   Create a function that, given a parameter representing size, generates such a symbol scaled to the requested size.
   Generate and display the symbol for two different (small) sizes.

",Python,"import math
def yinyang(n=3):
	radii   = [i * n for i in (1, 3, 6)]
	ranges  = [list(range(-r, r+1)) for r in radii]
	squares = [[ (x,y) for x in rnge for y in rnge]
		   for rnge in ranges]
	circles = [[ (x,y) for x,y in sqrpoints
		     if math.hypot(x,y) <= radius ]
		   for sqrpoints, radius in zip(squares, radii)]
	m = {(x,y):' ' for x,y in squares[-1]}
	for x,y in circles[-1]:
		m[x,y] = '*'
	for x,y in circles[-1]:
		if x>0: m[(x,y)] = '·'
	for x,y in circles[-2]:
		m[(x,y+3*n)] = '*'
		m[(x,y-3*n)] = '·'
	for x,y in circles[-3]:
		m[(x,y+3*n)] = '·'
		m[(x,y-3*n)] = '*'
	return '\n'.join(''.join(m[(x,y)] for x in reversed(ranges[-1])) for y in ranges[-1])",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Stack,Stack,"
Data Structure

This illustrates a data structure, a means of storing data within a program.

You may see other such structures in the Data Structures category.
A stack is a container of elements with   last in, first out   access policy.   Sometimes it also called LIFO.

The stack is accessed through its top.

The basic stack operations are:

   push   stores a new element onto the stack top;
   pop   returns the last pushed stack element, while removing it from the stack;
   empty   tests if the stack contains no elements.


Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

   top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.


Stacks allow a very simple hardware implementation.

They are common in almost all processors.

In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory.

Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks).

This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework.

See stack machine.

Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.



Task

Create a stack supporting the basic operations: push, pop, empty.



See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack

",Python,"stack = []
stack.append(value) # pushing
value = stack.pop() # popping
len(stack) == 0 # is empty?",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Parse_an_IP_Address,Parse an IP Address,"The purpose of this task is to demonstrate parsing of text-format IP addresses, using IPv4 and IPv6.



Taking the following as inputs:



127.0.0.1

The ""localhost"" IPv4 address


127.0.0.1:80

The ""localhost"" IPv4 address, with a specified port (80)


::1

The ""localhost"" IPv6 address


[::1]:80

The ""localhost"" IPv6 address, with a specified port (80)


2605:2700:0:3::4713:93e3

Rosetta Code's primary server's public IPv6 address


[2605:2700:0:3::4713:93e3]:80

Rosetta Code's primary server's public IPv6 address, with a specified port (80)



Task

Emit each described IP address as a hexadecimal integer representing the address, the address space, and the port number specified, if any.

In languages where variant result types are clumsy, the result should be ipv4 or ipv6 address number, something which says which address space was represented, port number and something that says if the port was specified.



Example

127.0.0.1   has the address number   7F000001   (2130706433 decimal)
in the ipv4 address space.

::ffff:127.0.0.1   represents the same address in the ipv6 address space where it has the
address number   FFFF7F000001   (281472812449793 decimal).

::1   has address number   1   and serves the same purpose in the ipv6 address
space that   127.0.0.1   serves in the ipv4 address space.



",Python,"from ipaddress import ip_address
from urllib.parse import urlparse
 
tests = [
    ""127.0.0.1"",
    ""127.0.0.1:80"",
    ""::1"",
    ""[::1]:80"",
    ""::192.168.0.1"",
    ""2605:2700:0:3::4713:93e3"",
    ""[2605:2700:0:3::4713:93e3]:80"" ]
 
def parse_ip_port(netloc):
    try:
        ip = ip_address(netloc)
        port = None
    except ValueError:
        parsed = urlparse('//{}'.format(netloc))
        ip = ip_address(parsed.hostname)
        port = parsed.port
    return ip, port
 
for address in tests:
    ip, port = parse_ip_port(address)
    hex_ip = {4:'{:08X}', 6:'{:032X}'}[ip.version].format(int(ip))
    print(""{:39s}  {:>32s}  IPv{}  port={}"".format(
        str(ip), hex_ip, ip.version, port ))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Catalan_numbers,Catalan numbers,"Catalan numbers

You are encouraged to solve this task according to the task description, using any language you may know.


Catalan numbers are a sequence of numbers which can be defined directly:






C

n


=


1

n
+
1






(



2
n

n


)



=



(
2
n
)
!


(
n
+
1
)
!

n
!





 for 

n
≥
0.


{\displaystyle C_{n}={\frac {1}{n+1}}{2n \choose n}={\frac {(2n)!}{(n+1)!\,n!}}\qquad {\mbox{ for }}n\geq 0.}


Or recursively:






C

0


=
1


and



C

n
+
1


=

∑

i
=
0


n



C

i




C

n
−
i




for 

n
≥
0
;


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n+1}=\sum _{i=0}^{n}C_{i}\,C_{n-i}\quad {\text{for }}n\geq 0;}


Or alternatively (also recursive):






C

0


=
1


and



C

n


=



2
(
2
n
−
1
)


n
+
1




C

n
−
1


,


{\displaystyle C_{0}=1\quad {\mbox{and}}\quad C_{n}={\frac {2(2n-1)}{n+1}}C_{n-1},}




Task

Implement at least one of these algorithms and print out the first 15 Catalan numbers with each.

Memoization   is not required, but may be worth the effort when using the second method above.



Related tasks

Catalan numbers/Pascal's triangle
Evaluate binomial coefficients

",Python,"from math import factorial
 
for n in range(15):
    print(factorial(2*n)//(factorial(n)*factorial(n))//(n+1))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Dutch_national_flag_problem,Dutch national flag problem,"
The Dutch national flag is composed of three coloured bands in the order:

   red     (top)
   then white,   and
   lastly blue   (at the bottom). 


The problem posed by Edsger Dijkstra is:

Given a number of red, blue and white balls in random order, arrange them in the order of the colours in the Dutch national flag.
When the problem was first posed, Dijkstra then went on to successively refine a solution, minimising the number of swaps and the number of times the colour of a ball needed to determined and restricting the balls to end in an array, ...



Task
 Generate a randomized order of balls ensuring that they are not in the order of the Dutch national flag.
 Sort the balls in a way idiomatic to your language.
 Check the sorted balls are in the order of the Dutch national flag.


C.f.

 Dutch national flag problem
 Probabilistic analysis of algorithms for the Dutch national flag problem by Wei-Mei Chen. (pdf)

",Python,"import random
 
class Ball:
    FLAG = {'red': 1, 'white': 2, 'blue': 3}
 
    def __init__(self):
        self.color = random.choice(list(self.FLAG.keys()))
 
    def __lt__(self, other):
        return self.FLAG[self.color] < self.FLAG[other.color]
 
    def __gt__(self, other):
        return self.FLAG[self.color] > self.FLAG[other.color]
 
    def __eq__(self, other):
        return self.FLAG[self.color] == self.FLAG[other.color]
 
    def __repr__(self):
        return self.color
 
balls = []
while balls!= sorted(balls):
    balls = [Ball() for _ in range(8)]
 
print(""Random: {}"".format(balls))
print(""Sorted: {}"".format(sorted(balls)))",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/N-smooth_numbers,N-smooth numbers,"n-smooth   numbers are positive integers which have no prime factors  >  n.

The   n   (when using it in the expression)   n-smooth   is always prime,

there are   no   9-smooth numbers.

1   (unity)   is always included in n-smooth numbers.




2-smooth   numbers are non-negative powers of two.

5-smooth   numbers are also called   Hamming numbers.

7-smooth   numbers are also called    humble   numbers.



A way to express   11-smooth   numbers is:

  11-smooth  =  2i × 3j × 5k × 7m × 11p

           where     i, j, k, m, p ≥ 0  



Task

   calculate and show the first   25   n-smooth numbers   for   n=2   ───►   n=29
   calculate and show   three numbers starting with   3,000   n-smooth numbers   for   n=3   ───►   n=29
   calculate and show twenty numbers starting with  30,000   n-smooth numbers   for   n=503   ───►   n=521   (optional)


All ranges   (for   n)   are to be inclusive, and only prime numbers are to be used.

The (optional) n-smooth numbers for the third range are:   503,   509,   and   521.

Show all n-smooth numbers for any particular   n   in a horizontal list.

Show all output here on this page.



Related tasks

   Hamming numbers
   humble numbers


References

   Wikipedia entry:   Hamming numbers     (this link is re-directed to   Regular number).
   Wikipedia entry:   Smooth number
   OEIS entry:   A000079    2-smooth numbers or non-negative powers of two
   OEIS entry:   A003586    3-smooth numbers
   OEIS entry:   A051037    5-smooth numbers or Hamming numbers
   OEIS entry:   A002473    7-smooth numbers or humble numbers
   OEIS entry:   A051038   11-smooth numbers
   OEIS entry:   A080197   13-smooth numbers
   OEIS entry:   A080681   17-smooth numbers
   OEIS entry:   A080682   19-smooth numbers
   OEIS entry:   A080683   23-smooth numbers

",Python,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]
 
def isPrime(n):
    if n < 2:
        return False
 
    for i in primes:
        if n == i:
            return True
        if n % i == 0:
            return False
        if i * i > n:
            return True
    print ""Oops,"", n, "" is too large""
 
def init():
    s = 24
    while s < 600:
        if isPrime(s - 1) and s - 1 > primes[-1]:
            primes.append(s - 1)
        if isPrime(s + 1) and s + 1 > primes[-1]:
            primes.append(s + 1)
        s += 6
 
def nsmooth(n, size):
    if n < 2 or n > 521:
        raise Exception(""n"")
    if size < 1:
        raise Exception(""n"")
 
    bn = n
    ok = False
    for prime in primes:
        if bn == prime:
            ok = True
            break
    if not ok:
        raise Exception(""must be a prime number: n"")
 
    ns = [0] * size
    ns[0] = 1
 
    next = []
    for prime in primes:
        if prime > bn:
            break
        next.append(prime)
 
    indicies = [0] * len(next)
    for m in xrange(1, size):
        ns[m] = min(next)
        for i in xrange(0, len(indicies)):
            if ns[m] == next[i]:
                indicies[i] += 1
                next[i] = primes[i] * ns[indicies[i]]
 
    return ns
 
def main():
    init()
 
    for p in primes:
        if p >= 30:
            break
        print ""The first"", p, ""-smooth numbers are:""
        print nsmooth(p, 25)
        print
 
    for p in primes[1:]:
        if p >= 30:
            break
        print ""The 3000 to 3202"", p, ""-smooth numbers are:""
        print nsmooth(p, 3002)[2999:]
        print
 
    for p in [503, 509, 521]:
        print ""The 30000 to 3019"", p, ""-smooth numbers are:""
        print nsmooth(p, 30019)[29999:]
        print
 
main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/String_concatenation,String concatenation,"String concatenation

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Create a string variable equal to any text value.

Create another string variable whose value is the original variable concatenated with another string literal.

To illustrate the operation, show the content of the variables.


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"s = ""hello""
print(s)

s1 = s + "" world""
print(s1)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Singly-linked_list/Element_definition,Singly-linked list/Element definition,"singly-linked list
See also

 Array
 Associative array: Creation, Iteration
 Collections
 Compound data type
 Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
 Linked list
 Queue: Definition, Usage
 Set
 Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
 Stack",Python,"class LinkedList(object):
     """"""USELESS academic/classroom example of a linked list implemented in Python.
        Don't ever consider using something this crude!  Use the built-in list() type!
     """"""
	class Node(object):
		def __init__(self, item):
			self.value  = item
			self.next = None
	def __init__(self, item=None):
		if item is not None:
			self.head = Node(item); self.tail = self.head
		else:
			self.head = None; self.tail = None
	def append(self, item):
		if not self.head:
			self.head = Node(item)
			self.tail = self.head
		elif self.tail:
			self.tail.next = Node(item)
			self.tail = self.tail.next
		else:
			self.tail = Node(item)
	def __iter__(self):
		cursor = self.head
		while cursor:
			yield cursor.value
			cursor = cursor.next",Human_written,Python_from_Go
http://rosettacode.org/wiki/Barnsley_fern,Barnsley fern,"
A Barnsley fern is a fractal named after British mathematician Michael Barnsley and can be created using an iterated function system (IFS).



Task

Create this fractal fern, using the following transformations:

 ƒ1   (chosen 1% of the time)
        xn + 1 = 0
        yn + 1 = 0.16 yn

 ƒ2   (chosen 85% of the time)
        xn + 1 = 0.85 xn + 0.04 yn
        yn + 1 = −0.04 xn + 0.85 yn + 1.6

 ƒ3   (chosen 7% of the time)
        xn + 1 = 0.2 xn − 0.26 yn
        yn + 1 = 0.23 xn + 0.22 yn + 1.6

 ƒ4   (chosen 7% of the time)
        xn + 1 = −0.15 xn + 0.28 yn
        yn + 1 = 0.26 xn + 0.24 yn + 0.44.

Starting position: x = 0, y = 0



",Python,"import random
from PIL import Image

w = 600
h = 600
bm = Image.new('RGB', (w, h))
r = random.Random()
x = 0
y = 0
for count in range(100000):
    bm.putpixel((int(300 + 58 * x), int(58 * y)), (0, 128, 0))
    roll = r.randint(0, 99)
    xp = x
    if roll < 1:
        x = 0
        y = 0.16 * y
    elif roll < 86:
        x = 0.85 * x + 0.04 * y
        y = -0.04 * xp + 0.85 * y + 1.6
    elif roll < 93:
        x = 0.2 * x - 0.26 * y
        y = 0.23 * xp + 0.22 * y + 1.6
    else:
        x = -0.15 * x + 0.28 * y
        y = 0.26 * xp + 0.24 * y + 0.44

filename = ""Fern.png""
bm.save(filename)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sleeping_Beauty_problem,Sleeping Beauty problem,"Background on the task
In decision theory, The Sleeping Beauty Problem
is a problem invented by Arnold Zoboff and first publicized on Usenet. The experimental
subject, named Sleeping Beauty, agrees to an experiment as follows:
Sleeping Beauty volunteers to be put into a deep sleep on a Sunday. There is then a fair coin toss.
If this coin toss comes up heads, Sleeping Beauty wakes once (on Monday) and is asked to
estimate the probability that the coin toss was heads. Her estimate is recorded and she is
then put back to sleep for 2 days until Wednesday, at which time the experiment's results are tallied.



If instead the coin toss is tails, Sleeping Beauty wakes as before on Monday and asked to
estimate the probability the coin toss was heads, but is then given a drug which makes her forget
that she had been woken on Monday before being put back to sleep again. She then wakes only 1 day
later, on Tuesday. She is then asked (on Tuesday) again to guess the probability that the coin toss
was heads or tails. She is then put back to sleep and awakes as before 1 day later, on Wednesday.



Some decision makers have argued that since the coin toss was fair Sleeping Beauty should always
estimate the probability of heads as 1/2, since she does not have any additional information. Others
have disagreed, saying that if Sleeping Beauty knows the study design she also knows that she is twice
as likely to wake up and be asked to estimate the coin flip on tails than on heads, so the estimate
should be 1/3 heads.

Task
Given the above problem, create a Monte Carlo estimate of the actual results. The program should find the
proportion of heads on waking and asking Sleeping Beauty for an estimate, as a credence or as a percentage of the times Sleeping Beauty
is asked the question.


",Python,"import random

experiments = 1000000
heads = 0
wakenings = 0
for i in range(experiments):
    wakenings += 1
    if random.randint(0, 1) == 0:
        heads += 1
    else:
        wakenings += 1
print(""Wakenings over {} experiments: {}"".format(experiments, wakenings))
print(""Sleeping Beauty should estimate a credence of: {}"".format(heads / wakenings))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/File_size_distribution,File size distribution,"Task

Beginning from the current directory, or optionally from a directory specified as a command-line argument, determine how many files there are of various sizes in a directory hierarchy.



My suggestion is to sort by logarithmn of file size, since a few bytes here or there, or even a factor of two or three, may not be that significant.

Don't forget that empty files may exist, to serve as a marker.



Is your file system predominantly devoted to a large number of smaller files, or a smaller number of huge files?



",Python,"import os
import sys
from pathlib import Path
from typing import List, Tuple
 
def file_size_distribution(directory: str) -> None:
    sizes: List[int] = [0, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000]
    count: List[int] = [0] * (len(sizes) + 1)
    files: int = 0
    total_size: int = 0
    for dir_entry in os.scandir(directory):
        if dir_entry.is_file() and not dir_entry.is_symlink():
            file_size = dir_entry.stat().st_size
            total_size += file_size
            index = bisect.bisect_left(sizes, file_size)
            count[index] += 1
            files += 1
    print(f""File size distribution for {directory}:"")
    for i in range(len(sizes) + 1):
        if i == len(sizes):
            print(f""> {sizes[i - 1]:16} bytes: {count[i]}"")
        else:
            print(f""{sizes[i]:16} bytes: {count[i]}"")
    print(f""Number of files: {files}"")
    print(f""Total file size: {total_size} bytes"")
 
if __name__ == ""__main__"":
    directory = sys.argv[1] if len(sys.argv) > 1 else "".""
    path = Path(directory)
    if not path.is_dir():
        print(f""{directory} is not a directory."")
        sys.exit(1)
    file_size_distribution(directory)",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Levenshtein_distance,Levenshtein distance,"

 This page uses content from Wikipedia. The original article was at Levenshtein distance. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.



Example

The Levenshtein distance between ""kitten"" and ""sitting"" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:

   kitten   sitten   (substitution of 'k' with 's')
   sitten   sittin   (substitution of 'e' with 'i')
   sittin   sitting   (insert 'g' at the end).

The Levenshtein distance between   ""rosettacode"",   ""raisethysword""   is   8.

The distance between two strings is same as that when both strings are reversed.



Task

Implements a Levenshtein distance function, or uses a library function, to show the Levenshtein distance between   ""kitten""   and   ""sitting"".



Related task

   Longest common subsequence



Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def levenshteinDistance(str1, str2):
    m = len(str1)
    n = len(str2)
    d = [[i] for i in range(1, m + 1)]   # d matrix rows
    d.insert(0, list(range(0, n + 1)))   # d matrix columns
    for j in range(1, n + 1):
        for i in range(1, m + 1):
            if str1[i - 1] == str2[j - 1]:   # Python (string) is 0-based
                substitutionCost = 0
            else:
                substitutionCost = 1
            d[i].insert(j, min(d[i - 1][j] + 1,
                               d[i][j - 1] + 1,
                               d[i - 1][j - 1] + substitutionCost))
    return d[-1][-1]
 
print(levenshteinDistance(""kitten"",""sitting""))
print(levenshteinDistance(""rosettacode"",""raisethysword""))",Human_written,Python_from_C
http://rosettacode.org/wiki/Bitmap/Histogram,Bitmap/Histogram,"Extend the basic bitmap storage defined on this page to support dealing with image histograms. The image histogram contains for each luminance the count of image pixels having this luminance. Choosing a histogram representation take care about the data type used for the counts. It must have range of at least 0..NxM, where N is the image width and M is the image height.

Test task

Histogram is useful for many image processing operations. As an example, use it to convert an image into black and white art. The method works as follows:

 Convert image to grayscale;
 Compute the histogram
 Find the median: defined as the luminance such that the image has an approximately equal number of pixels with lesser and greater luminance.
 Replace each pixel of luminance lesser than the median to black, and others to white.
Use  read/write ppm file, and grayscale image solutions.
",Python,"from PIL import Image
 
# Open the image
image = Image.open(""lena.jpg"")
# Get the width and height of the image
width, height = image.size
# Calculate the amount of pixels
amount = width * height
 
# Total amount of greyscale
total = 0
# B/W image
bw_image = Image.new('L', (width, height), 0)
# Bitmap image
bm_image = Image.new('1', (width, height), 0)
 
for h in range(0, height):
    for w in range(0, width):
        r, g, b = image.getpixel((w, h))
 
        greyscale = int((r + g + b) / 3)
        total += greyscale
 
        bw_image.putpixel((w, h), gray_scale)
 
# The average greyscale
avg = total / amount
 
black = 0
white = 1
 
for h in range(0, height):
    for w in range(0, width):
        v = bw_image.getpixel((w, h))
 
        if v >= avg:
            bm_image.putpixel((w, h), white)
        else:
            bm_image.putpixel((w, h), black)
 
bw_image.show()
bm_image.show()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Map_range,Map range,"Given two ranges:

   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}

   and 
   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}

; 
   then a value   



s


{\displaystyle s}

   in range   



[

a

1


,

a

2


]


{\displaystyle [a_{1},a_{2}]}


   is linearly mapped to a value   



t


{\displaystyle t}

   in range   



[

b

1


,

b

2


]


{\displaystyle [b_{1},b_{2}]}


   where:



   



t
=

b

1


+



(
s
−

a

1


)
(

b

2


−

b

1


)


(

a

2


−

a

1


)





{\displaystyle t=b_{1}+{(s-a_{1})(b_{2}-b_{1}) \over (a_{2}-a_{1})}}




Task

Write a function/subroutine/... that takes two ranges and a real number, and returns the mapping of the real number from the first to the second range.

Use this function to map values from the range    [0, 10]    to the range    [-1, 0]. 



Extra credit

Show additional idiomatic ways of performing the mapping, using tools available to the language.



",Python,"from itertools import *
from functools import *
from operator import *
from math import *
 
def map_range(a1, a2, b1, b2, s):
    return b1 + (s - a1) * (b2 - b1) / (a2 - a1)
 
print(*map(lambda i: f""{i} maps to {map_range(0, 10, -1, 0, i)}"", range(0, 11)))",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Get_system_command_output,Get system command output,"Task
Execute a system command and get its output into the program. The output may be stored in any kind of collection (array, list, etc.).




Related task
  Execute a system command

",Python,"import os
import subprocess
 
def execute(command):
    with open(""temp.txt"", ""w"") as f:
        subprocess.call(command, stdout=f, shell=True)
    with open(""temp.txt"", ""r"") as f:
        ret = f.read()
    os.remove(""temp.txt"")
    return ret
 
print(execute(""whoami""))",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Zero_to_the_zero_power,Zero to the zero power,"Some computer programming languages are not exactly consistent   (with other computer programming languages)  

when   raising zero to the zeroth power:     00



Task

Show the results of raising   zero   to the   zeroth   power.



If your computer language objects to      0**0      or      0^0      at compile time,   you may also try something like:

           x = 0
           y = 0
           z = x**y
           say  'z='  z


Show the result here.

And of course use any symbols or notation that is supported in your computer programming language for exponentiation.



See also

 The Wiki entry: Zero to the power of zero. 
 The Wiki entry: History of differing points of view.
 The MathWorld™ entry: exponent laws.
 Also, in the above MathWorld™ entry, see formula (9): 




x

0


=
1


{\displaystyle x^{0}=1}

.
 The OEIS entry: The special case of zero to the zeroth power

",Python,"from decimal import Decimal
from fractions import Fraction
from itertools import product
 
zeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]
for i, j in product(zeroes, repeat=2):
    try:
        ans = i**j
    except:
        ans = '<Exception raised>'
    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')",Human_written,Python_from_C++
http://rosettacode.org/wiki/Pinstripe/Display,Pinstripe/Display," Sample image
The task is to demonstrate the creation of a series of vertical pinstripes across the entire width of the display.

 in the first quarter the pinstripes should alternate one pixel white, one pixel black = 1 pixel wide vertical pinestripes
 Quarter of the way down the display, we can switch to a wider 2 pixel wide vertical pinstripe pattern, alternating two pixels white, two pixels black. 
 Half way down the display, we switch to 3 pixels wide, 
 for the lower quarter of the display we use 4 pixels.


c.f. Colour_pinstripe/Display
",Python,"import numpy as np
from PIL import Image
 
palette = [
    (255, 255, 255), # white
    (0, 0, 0), # black
]
 
def pinstripe(w, h):
    img = Image.new('RGB', (w, h))
    pixels = img.load()
    for b in range(1, 5):
        for x in range(0, w, b):
            ci = x // b % 2
            for y in range(h * (b - 1), h * b):
                pixels[x, y] = palette[ci]
    return img
 
if __name__ == '__main__':
    img = pinstripe(900, 600)
    img.save('w_pinstripe.png')",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Phrase_reversals,Phrase reversals,"Task

Given a string of space separated words containing the following phrase:

 rosetta code phrase reversal

 Reverse the characters of the string.
 Reverse the characters of each individual word in the string, maintaining original word order within the string.
 Reverse the order of each word of the string, maintaining the order of characters in each word.


Show your output here.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,">>> phrase = ""rosetta code phrase reversal""
>>> phrase[::-1]					  # Reversed.
'lasrever esarhp edoc attesor'
>>> ' '.join(word[::-1] for word in phrase.split())	  # Words reversed.
'attesor edoc esarhp lasrever'
>>> ' '.join(phrase.split()[::-1])	                  # Word order reversed.
'reversal phrase code rosetta'
>>>",Human_written,Python_from_C++
http://rosettacode.org/wiki/Create_an_HTML_table,Create an HTML table,"Create an HTML table.

 The table body should have at least three rows of three columns.
 Each of these three columns should be labelled ""X"", ""Y"", and ""Z"". 
 An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. 
 The rows of the ""X"", ""Y"", and ""Z"" columns should be filled with random or sequential integers having 4 digits or less. 
 The numbers should be aligned in the same fashion for all columns.

",Python,"import random
 
def rand9999():
    return random.randint(1000, 9999)
 
def tag(attr='', **kwargs):
    for tag, txt in kwargs.items():
        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())
 
if __name__ == '__main__':
    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\n'
    rows = '\n'.join(tag(tr=tag(' style=""font-weight: bold;""', td=i)
                                    + ''.join(tag(td=rand9999())
                                              for j in range(3)))
                     for i in range(1, 6))
    table = tag(table='\n' + header + rows + '\n')
    print(table)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Arithmetic/Rational,Arithmetic/Rational,"Task

Create a reasonably complete implementation of rational arithmetic in the particular language using the idioms of the language.



Example

Define a new type called frac with binary operator ""//"" of two integers that returns a structure made up of the numerator and the denominator (as per a rational number).

Further define the appropriate rational unary operators abs and '-', with the binary operators for addition '+', subtraction '-', multiplication '×', division '/', integer division '÷', modulo division, the comparison operators (e.g. '<', '≤', '>', & '≥') and equality operators (e.g. '=' & '≠').

Define standard coercion operators for casting int to frac etc.

If space allows, define standard increment and decrement operators (e.g. '+:=' & '-:=' etc.).

Finally test the operators:
Use the new type frac to find all perfect numbers less than 219 by summing the reciprocal of the factors.



Related task

   Perfect Numbers

",Python,"from fractions import Fraction

MAX_NUM = 1 << 19
print(""Searching for perfect numbers in the range [1, "" + (MAX_NUM - 1) + ""]"")

TWO = Fraction(2)
for i in range(1, MAX_NUM):
    reciprocalSum = Fraction(1)
    if i > 1:
        reciprocalSum = reciprocalSum + Fraction(1, i)
    maxDivisor = int(math.sqrt(i))
    if maxDivisor >= i:
        maxDivisor -= 1

    for divisor in range(2, maxDivisor + 1):
        if i % divisor == 0:
            reciprocalSum = reciprocalSum + Fraction(1, divisor)
            dividend = i / divisor
            if divisor!= dividend:
                reciprocalSum = reciprocalSum + Fraction(1, dividend)
    if reciprocalSum == TWO:
        print(str(i) + "" is a perfect number"")",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/General_FizzBuzz,General FizzBuzz,"Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words.

This is basically a ""fizzbuzz"" implementation where the user supplies the parameters.

The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.

For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.



For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"".

In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor.

For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".

If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz


",Python,"def genfizzbuzz(factorwords, numbers):
    # sort entries by factor
    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])
    lines = []
    for num in numbers:
        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)
        lines.append(words if words else str(num))
    return '\n'.join(lines)
 
if __name__ == '__main__':
    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort,Sorting algorithms/Permutation sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Implement a permutation sort, which proceeds by generating the possible permutations
of the input array/list until discovering the sorted one.

Pseudocode:

while not InOrder(list) do
    nextPermutation(list)
done


",Python,"# version 1.1.2
 
def isSorted(list):
    size = len(list)
    if size < 2:
        return True
    for i in range(1, size):
        if list[i] < list[i - 1]:
            return False
    return True
 
def permute(input):
    if len(input) == 1:
        return [input]
    perms = []
    toInsert = input[0]
    for perm in permute(input[1:]):
        for i in range(len(perm) + 1):
            newPerm = perm[:]
            newPerm.insert(i, toInsert)
            perms.append(newPerm)
    return perms
 
def permutationSort(input):
    if len(input) == 1:
        return input
    toInsert = input[0]
    for perm in permute(input[1:]):
        for i in range(len(perm) + 1):
            newPerm = perm[:]
            newPerm.insert(i, toInsert)
            if isSorted(newPerm):
                return newPerm
    return input
 
if __name__ == ""__main__"":
    input = ['d', 'b', 'e', 'a', 'f', 'c']
    print(""Before sorting : {}"".format(input))
    output = permutationSort(input)
    print(""After sorting  : {}"".format(output))
    print()
    input2 = [""first"", ""second"", ""third"", ""fourth"", ""fifth"", ""sixth""]
    print(""Before sorting : {}"".format(input2))
    output2 = permutationSort(input2)
    print(""After sorting  : {}"".format(output2))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Tokenize_a_string,Tokenize a string,"Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word.

Display the words to the 'user', in the simplest manner possible, separated by a period.

To simplify, you may display a trailing period.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"text = ""Hello,How,Are,You,Today""
tokens = text.split(',')
print ('.'.join(tokens))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Zig-zag_matrix,Zig-zag matrix,"Task

Produce a zig-zag array.



A   zig-zag   array is a square arrangement of the first   N2   natural numbers,   where the

numbers increase sequentially as you zig-zag along the array's   anti-diagonals.

For a graphical representation, see   JPG zigzag   (JPG uses such arrays to encode images).



For example, given   5,   produce this array:

 0  1  5  6 14
 2  4  7 13 15
 3  8 12 16 21
 9 11 17 20 22
10 18 19 23 24



Related tasks

   Spiral matrix
   Identity matrix
   Ulam spiral (for primes)


See also

   Wiktionary entry:   anti-diagonals

",Python,"def zigzag(n):
    '''zigzag rows'''
    def compare(xy):
        x, y = xy
        return (x + y, -y if (x + y) % 2 else y)
    xs = range(n)
    return {index: n for n, index in enumerate(sorted(
        ((x, y) for x in xs for y in xs),
        key=compare
    ))}
 
 
def printzz(myarray):
    '''show zigzag rows as lines'''
    n = int(len(myarray) ** 0.5 + 0.5)
    xs = range(n)
    print('\n'.join(
        [''.join(""%3i"" % myarray[(x, y)] for x in xs) for y in xs]
    ))
 
 
printzz(zigzag(6))",Human_written,Python_from_C
http://rosettacode.org/wiki/Number_reversal_game,Number reversal game,"Task

Given a jumbled list of the numbers   1   to   9   that are definitely   not   in
ascending order.

Show the list,   and then ask the player how many digits from the
left to reverse.

Reverse those digits,   then ask again,   until all the digits end up in ascending order.



The score is the count of the reversals needed to attain the ascending order.



Note: Assume the player's input does not need extra validation.



Related tasks

   Sorting algorithms/Pancake sort
   Pancake sorting.
   Topswops

",Python,"'''
number reversal game
    Given a jumbled list of the numbers 1 to 9
    Show the list.
    Ask the player how many digits from the left to reverse.
    Reverse those digits then ask again.
    until all the digits end up in ascending order.
 
'''
 
import random
 
print(__doc__)
data, trials = list('123456789'), 0
while data == sorted(data):
    random.shuffle(data)
while data != sorted(data):
    trials += 1
    flip = int(input('#%2i: LIST: %r Flip how many?: ' % (trials, ' '.join(data))))
    data[:flip] = reversed(data[:flip])
 
print('\nYou took %2i attempts to put the digits in order!' % trials)",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Show_the_epoch,Show the epoch,"Task
 
Choose popular date libraries used by your language and show the   epoch   those libraries use.

A demonstration is preferable   (e.g. setting the internal representation of the date to 0 ms/ns/etc.,   or another way that will still show the epoch even if it is changed behind the scenes by the implementers),   but text from (with links to) documentation is also acceptable where a demonstration is impossible/impractical.

For consistency's sake, show the date in UTC time where possible.



Related task

   Date format

",Python,"import datetime
import pytz

date = datetime.datetime(1970, 1, 1, 0, 0, 0, 0, pytz.utc)
print(date.strftime(""%c""))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Caesar_cipher,Caesar cipher,"

Task

Implement a Caesar cipher, both encoding and decoding. 

The key is an integer from 1 to 25.

This cipher rotates (either towards left or right) the letters of the alphabet (A to Z).

The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).

So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"".

This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.

Caesar cipher is identical to Vigenère cipher with a key of length 1. 

Also, Rot-13 is identical to Caesar cipher with key 13.



Related tasks

 Rot-13
 Substitution Cipher
 Vigenère Cipher/Cryptanalysis

",Python,"class Cipher:
    def __init__(self):
        pass

    @staticmethod
    def encode(enc, offset):
        offset = offset % 26 + 26
        encoded = """"
        for i in enc:
            if i.isalpha():
                if i.isupper():
                    encoded += chr(ord('A') + (ord(i) - ord('A') + offset) % 26)
                else:
                    encoded += chr(ord('a') + (ord(i) - ord('a') + offset) % 26)
            else:
                encoded += i
        return encoded

    @staticmethod
    def decode(enc, offset):
        return Cipher.encode(enc, 26 - offset)

if __name__ == '__main__':
    str = ""The quick brown fox Jumped over the lazy Dog""
    print(Cipher.encode(str, 12))
    print(Cipher.decode(Cipher.encode(str, 12), 12))",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Ordered_partitions,Ordered partitions,"In this task we want to find the ordered partitions into fixed-size blocks.

This task is related to Combinations in that it has to do with discrete mathematics and moreover a helper function to compute combinations is (probably) needed to solve this task.





p
a
r
t
i
t
i
o
n
s
(



a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n


)


{\displaystyle partitions({\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n})}

 should generate all distributions of the elements in 



{
1
,
.
.
.
,

Σ

i
=
1


n





a
r
g



i


}


{\displaystyle \{1,...,\Sigma _{i=1}^{n}{\mathit {arg}}_{i}\}}

 into 



n


{\displaystyle n}

 blocks of respective size 






a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

.

Example 1: 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

 would create:

{({1, 2}, {}, {3, 4}), 
 ({1, 3}, {}, {2, 4}), 
 ({1, 4}, {}, {2, 3}), 
 ({2, 3}, {}, {1, 4}), 
 ({2, 4}, {}, {1, 3}), 
 ({3, 4}, {}, {1, 2})}

Example 2: 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 would create:

{({1}, {2}, {3}), 
 ({1}, {3}, {2}), 
 ({2}, {1}, {3}), 
 ({2}, {3}, {1}), 
 ({3}, {1}, {2}), 
 ({3}, {2}, {1})}

Note that the number of elements in the list is








(






a
r
g



1


+



a
r
g



2


+
.
.
.
+



a
r
g



n






a
r
g



1




)



⋅



(






a
r
g



2


+



a
r
g



3


+
.
.
.
+



a
r
g



n






a
r
g



2




)



⋅
…
⋅



(





a
r
g



n





a
r
g



n




)





{\displaystyle {{\mathit {arg}}_{1}+{\mathit {arg}}_{2}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{1}}\cdot {{\mathit {arg}}_{2}+{\mathit {arg}}_{3}+...+{\mathit {arg}}_{n} \choose {\mathit {arg}}_{2}}\cdot \ldots \cdot {{\mathit {arg}}_{n} \choose {\mathit {arg}}_{n}}}


(see the definition of the binomial coefficient if you are not familiar with this notation) and the number of elements remains the same regardless of how the argument is permuted
(i.e. the multinomial coefficient).

Also, 



p
a
r
t
i
t
i
o
n
s
(
1
,
1
,
1
)


{\displaystyle partitions(1,1,1)}

 creates the permutations of 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 and thus there would be 



3
!
=
6


{\displaystyle 3!=6}

 elements in the list.

Note: Do not use functions that are not in the standard library of the programming language you use. Your file should be written so that it can be executed on the command line and by default outputs the result of 



p
a
r
t
i
t
i
o
n
s
(
2
,
0
,
2
)


{\displaystyle partitions(2,0,2)}

. If the programming language does not support polyvariadic functions pass a list as an argument.

Notation

Here are some explanatory remarks on the notation used in the task description:





{
1
,
…
,
n
}


{\displaystyle \{1,\ldots ,n\}}

 denotes the set of consecutive numbers from 



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

, e.g. 



{
1
,
2
,
3
}


{\displaystyle \{1,2,3\}}

 if 



n
=
3


{\displaystyle n=3}

.





Σ


{\displaystyle \Sigma }

 is the mathematical notation for summation, e.g. 




Σ

i
=
1


3


i
=
6


{\displaystyle \Sigma _{i=1}^{3}i=6}

 (see also [1]).








a
r
g



1


,



a
r
g



2


,
.
.
.
,



a
r
g



n




{\displaystyle {\mathit {arg}}_{1},{\mathit {arg}}_{2},...,{\mathit {arg}}_{n}}

 are the arguments — natural numbers — that the sought function receives.



",Python,"from itertools import combinations
 
def partitions(*args):
    def p(s, *args):
        if not args: return [[]]
        res = []
        for c in combinations(s, args[0]):
            s0 = [x for x in s if x not in c]
            for r in p(s0, *args[1:]):
                res.append([c] + r)
        return res
    s = range(sum(args))
    return p(s, *args)
 
print partitions(2, 0, 2)",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/ABC_problem,ABC problem,"ABC problem

You are encouraged to solve this task according to the task description, using any language you may know.
You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).

There are twenty blocks with two letters on each block.

A complete alphabet is guaranteed amongst all sides of the blocks.

The sample collection of blocks:

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.



The rules are simple:

   Once a letter on a block is used that block cannot be used again
   The function should be case-insensitive
   Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True

Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"words = [""A"", ""BaRK"", ""BOoK"", ""tREaT"", ""COmMOn"", ""SQuAD"", ""CoNfuSE"", """"]
 
for word in words:
    blocks = ""BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM""
    res = all(c in blocks for c in word.upper())
    print(word, res)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Chaos_game,Chaos game,"The Chaos Game is a method of generating the attractor of an iterated function system (IFS).

One of the best-known and simplest examples creates a fractal, using a polygon and an initial point selected at random.



Task
Play the Chaos Game using the corners of an equilateral triangle as the reference points.   Add a starting point at random (preferably inside the triangle).   Then add the next point halfway between the starting point and one of the reference points.   This reference point is chosen at random.

After a sufficient number of iterations, the image of a Sierpinski Triangle should emerge.



See also
 The Game of Chaos

",Python,"import turtle
import random
import math
 
def sierpinski(side,iter):
 
	vertices = [[0,0],[0,0],[0,0]]
	seedX = 0
	seedY = 0
	choice = 0
 
	vertices[0][0] = 0
	vertices[0][1] = side
	vertices[1][0] = side/2
	vertices[1][1] = -side*math.sqrt(3)/2
	vertices[2][0] = -side/2
	vertices[2][1] = -side*math.sqrt(3)/2
 
	seedX = random.randint(0,int(side/2))
	seedY = random.randint(0,int(side*math.sqrt(3)/2))
 
	turtle.penup()
	turtle.goto(seedX,seedY)
	turtle.pendown()
 
	for i in range(0,iter):
		choice = random.randint(0,2)
 
		seedX = (seedX + vertices[choice][0])/2
		seedY = (seedY + vertices[choice][1])/2
 
		turtle.goto(seedX,seedY)
 
def main():
 
	side = 0
	iter = 0
 
	print(""Enter triangle side length : "")
	side = int(input())
 
	print(""Enter number of iterations : "")
	iter = int(input())
 
	turtle.speed(0)
	turtle.hideturtle()
	turtle.penup()
	turtle.goto(0,0)
	turtle.pendown()
	turtle.color(""white"")
	turtle.begin_fill()
	turtle.goto(side/2,-side*math.sqrt(3)/2)
	turtle.goto(-side/2,-side*math.sqrt(3)/2)
	turtle.goto(0,side)
	turtle.goto(0,0)
	turtle.end_fill()
	turtle.color(""black"")
 
	sierpinski(side,iter)
 
	turtle.done()
 
if __name__ == ""__main__"":
	main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Reverse_words_in_a_string,Reverse words in a string,"Task

Reverse the order of all tokens in each of a number of strings and display the result;   the order of characters within a token should not be modified.



Example

Hey you, Bub!    would be shown reversed as:    Bub! you, Hey 



Tokens are any non-space characters separated by spaces (formally, white-space);   the visible punctuation form part of the word within which it is located and should not be modified.

You may assume that there are no significant non-visible characters in the input.   Multiple or superfluous spaces may be compressed into a single space.

Some strings have no tokens, so an empty string   (or one just containing spaces)   would be the result.

Display the strings in order   (1st, 2nd, 3rd, ···),   and one string per line.

(You can consider the ten strings as ten lines, and the tokens as words.)



Input data
             (ten lines within the box)
 line
     ╔════════════════════════════════════════╗
   1 ║  ---------- Ice and Fire ------------  ║
   2 ║                                        ║  ◄─── a blank line here.
   3 ║  fire, in end will world the say Some  ║
   4 ║  ice. in say Some                      ║
   5 ║  desire of tasted I've what From       ║
   6 ║  fire. favor who those with hold I     ║
   7 ║                                        ║  ◄─── a blank line here.
   8 ║  ... elided paragraph last ...         ║
   9 ║                                        ║  ◄─── a blank line here.
  10 ║  Frost Robert -----------------------  ║
     ╚════════════════════════════════════════╝

Cf.
 Phrase reversals

",Python,"def reversed_words(s):
    return "" "".join(reversed(s.split()))

if __name__ == ""__main__"":
    s = ""Hey you, Bub!""
    print(reversed_words(s))
    print()
    sl = [
        "" ---------- Ice and Fire ------------ "", 
        ""                                      "",
        "" fire, in end will world the say Some "", 
        "" ice. in say Some                     "", 
        "" desire of tasted I've what From      "", 
        "" fire. favor who those with hold I    "",  
        ""                                      "",  
        ""... elided paragraph last...        "", 
        ""                                      "",  
        "" Frost Robert ----------------------- "",
    ] 
    for s in sl:
        print(reversed_words(s))",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Superpermutation_minimisation,Superpermutation minimisation,"A superpermutation of N different characters is a string consisting of an arrangement of multiple copies of those N different characters in which every permutation of those characters can be found as a substring.

For example, representing the characters as A..Z, using N=2 we choose to use the first two characters 'AB'. 

The permutations of 'AB' are the two, (i.e. two-factorial), strings: 'AB' and 'BA'.

A too obvious method of generating a superpermutation is to just join all the permutations together forming 'ABBA'.

A little thought will produce the shorter (in fact the shortest) superpermutation of 'ABA' - it contains 'AB' at the beginning and contains 'BA' from the middle to the end.

The ""too obvious"" method of creation generates a string of length N!*N. Using this as a yardstick, the task is to investigate other methods of generating superpermutations of N from 1-to-7 characters, that never generate larger superpermutations.

Show descriptions and comparisons of algorithms used here, and select the ""Best"" algorithm as being the one generating shorter superpermutations.

The problem of generating the shortest superpermutation for each N might be NP complete, although the minimal strings for small values of N have been found by brute -force searches.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




Reference

 The Minimal Superpermutation Problem. by Nathaniel Johnston.
 oeis A180632 gives 0-5 as 0, 1, 3, 9, 33, 153. 6 is thought to be 872.
 Superpermutations - Numberphile. A video
 Superpermutations: the maths problem solved by 4chan - Standupmaths. A video of recent (2018) mathematical progress.
 New Superpermutations Discovered! Standupmaths & Numberphile.

",Python,"""Generate a short Superpermutation of n characters A... as a string using various algorithms.""
 
 
from __future__ import print_function, division
 
from itertools import permutations
from math import factorial
import string
import datetime
import gc
 
 
 
MAXN = 7
 
 
def s_perm0(n):
    """"""
    Uses greedy algorithm of adding another char (or two, or three, ...)
    until an unseen perm is formed in the last n chars
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in permutations(allchars)]
    sp, tofind = allperms[0], set(allperms[1:])
    while tofind:
        for skip in range(1, n):
            for trial_add in (''.join(p) for p in permutations(sp[-n:][:skip])):
                #print(sp, skip, trial_add)
                trial_perm = (sp + trial_add)[-n:]
                if trial_perm in tofind:
                    #print(sp, skip, trial_add)
                    sp += trial_add
                    tofind.discard(trial_perm)
                    trial_add = None    # Sentinel
                    break
            if trial_add is None:
                break
    assert all(perm in sp for perm in allperms) # Check it is a superpermutation
    return sp
 
def s_perm1(n):
    """"""
    Uses algorithm of concatenating all perms in order if not already part
    of concatenation.
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in sorted(permutations(allchars))]
    perms, sp = allperms[::], ''
    while perms:
        nxt = perms.pop()
        if nxt not in sp:
            sp += nxt
    assert all(perm in sp for perm in allperms)
    return sp
 
def s_perm2(n):
    """"""
    Uses algorithm of concatenating all perms in order first-last-nextfirst-
    nextlast... if not already part of concatenation.
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in sorted(permutations(allchars))]
    perms, sp = allperms[::], ''
    while perms:
        nxt = perms.pop(0)
        if nxt not in sp:
            sp += nxt
        if perms:
            nxt = perms.pop(-1)
            if nxt not in sp:
                sp += nxt
    assert all(perm in sp for perm in allperms)
    return sp
 
def _s_perm3(n, cmp):
    """"""
    Uses algorithm of concatenating all perms in order first,
    next_with_LEASTorMOST_chars_in_same_position_as_last_n_chars, ...
    """"""
    allchars = string.ascii_uppercase[:n]
    allperms = [''.join(p) for p in sorted(permutations(allchars))]
    perms, sp = allperms[::], ''
    while perms:
        lastn = sp[-n:]
        nxt = cmp(perms,
                  key=lambda pm:
                    sum((ch1 == ch2) for ch1, ch2 in zip(pm, lastn)))
        perms.remove(nxt)
        if nxt not in sp:
            sp += nxt
    assert all(perm in sp for perm in allperms)
    return sp
 
def s_perm3_max(n):
    """"""
    Uses algorithm of concatenating all perms in order first,
    next_with_MOST_chars_in_same_position_as_last_n_chars, ...
    """"""
    return _s_perm3(n, max)
 
def s_perm3_min(n):
    """"""
    Uses algorithm of concatenating all perms in order first,
    next_with_LEAST_chars_in_same_position_as_last_n_chars, ...
    """"""
    return _s_perm3(n, min)
 
 
longest = [factorial(n) * n for n in range(MAXN + 1)]
weight, runtime = {}, {}
print(__doc__)
for algo in [s_perm0, s_perm1, s_perm2, s_perm3_max, s_perm3_min]:
    print('\n###\n### %s\n###' % algo.__name__)
    print(algo.__doc__)
    weight[algo.__name__], runtime[algo.__name__] = 1, datetime.timedelta(0)
    for n in range(1, MAXN + 1):
        gc.collect()
        gc.disable()
        t = datetime.datetime.now()
        sp = algo(n)
        t = datetime.datetime.now() - t
        gc.enable()
        runtime[algo.__name__] += t
        lensp = len(sp)
        wt = (lensp / longest[n]) ** 2
        print('  For N=%i: SP length %5i Max: %5i Weight: %5.2f'
              % (n, lensp, longest[n], wt))
        weight[algo.__name__] *= wt
    weight[algo.__name__] **= 1 / n  # Geometric mean
    weight[algo.__name__] = 1 / weight[algo.__name__]
    print('%*s Overall Weight: %5.2f in %.1f seconds.'
          % (29, '', weight[algo.__name__], runtime[algo.__name__].total_seconds()))
 
print('\n###\n### Algorithms ordered by shortest superpermutations first\n###')
print('\n'.join('%12s (%.3f)' % kv for kv in
                sorted(weight.items(), key=lambda keyvalue: -keyvalue[1])))
 
print('\n###\n### Algorithms ordered by shortest runtime first\n###')
print('\n'.join('%12s (%.3f)' % (k, v.total_seconds()) for k, v in
                sorted(runtime.items(), key=lambda keyvalue: keyvalue[1])))",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Non-decimal_radices/Input,Non-decimal radices/Input,"It is common to have a string containing a number written in some format, with the most common ones being decimal, hexadecimal, octal and binary. Such strings are found in many places (user interfaces, configuration files, XML data, network protocols, etc.)

This task requires parsing of such a string (which may be assumed to contain nothing else) using the language's built-in facilities if possible. Parsing of decimal strings is required, parsing of other formats is optional but should be shown (i.e., if the language can parse in base-19 then that should be illustrated).

The solutions may assume that the base of the number in the string is known. In particular, if your language has a facility to guess the base of a number by looking at a prefix (e.g. ""0x"" for hexadecimal) or other distinguishing syntax as it parses it, please show that.

The reverse operation is in task Non-decimal radices/Output

For general number base conversion, see Non-decimal radices/Convert.
",Python,"# version 1.1.2

def main(args):
    s = ""100""
    bases = [2, 8, 10, 16, 19, 36]
    for base in bases:
        print(f""{s} in base {base:2d} is {int(s, base)}"")

if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Monty_Hall_problem,Monty Hall problem,"
Suppose you're on a game show and you're given the choice of three doors.

Behind one door is a car; behind the others, goats.

The car and the goats were placed randomly behind the doors before the show.



Rules of the game

After you have chosen a door, the door remains closed for the time being.

The game show host, Monty Hall, who knows what is behind the doors, now has to open one of the two remaining doors, and the door he opens must have a goat behind it.

If both remaining doors have goats behind them, he chooses one randomly.

After Monty Hall opens a door with a goat, he will ask you to decide whether you want to stay with your first choice or to switch to the last remaining door.

Imagine that you chose Door 1 and the host opens Door 3, which has a goat.

He then asks you ""Do you want to switch to Door Number 2?""



The question

Is it to your advantage to change your choice?



Note

The player may initially choose any of the three doors (not just Door 1), that the host opens a different door revealing a goat (not necessarily Door 3), and that he gives the player a second choice between the two remaining unopened doors.



Task

Run random simulations of the Monty Hall game. Show the effects of a strategy of the contestant always keeping his first guess so it can be contrasted with the strategy of the contestant always switching his guess.

Simulate at least a thousand games using three doors for each strategy and show the results in such a way as to make it easy to compare the effects of each strategy.



References

 Stefan Krauss, X. T. Wang, ""The psychology of the Monty Hall problem: Discovering psychological mechanisms for solving a tenacious brain teaser."", Journal of Experimental Psychology: General, Vol 132(1), Mar 2003, 3-22 DOI: 10.1037/0096-3445.132.1.3
 A YouTube video:   Monty Hall Problem - Numberphile. 

",Python,"'''
I could understand the explanation of the Monty Hall problem
but needed some more evidence
 
References:
  http://www.bbc.co.uk/dna/h2g2/A1054306
  http://en.wikipedia.org/wiki/Monty_Hall_problem especially:
  http://en.wikipedia.org/wiki/Monty_Hall_problem#Increasing_the_number_of_doors
'''
from random import randrange
 
doors, iterations = 3,100000  # could try 100,1000
 
def monty_hall(choice, switch=False, doorCount=doors):
  # Set up doors
  door = [False]*doorCount
  # One door with prize
  door[randrange(doorCount)] = True
 
  chosen = door[choice]
 
  unpicked = door
  del unpicked[choice]
 
  # Out of those unpicked, the alternative is either:
  #   the prize door, or
  #   an empty door if the initial choice is actually the prize.
  alternative = True in unpicked
 
  if switch:
    return alternative
  else:
    return chosen
 
print ""\nMonty Hall problem simulation:""
print doors, ""doors,"", iterations, ""iterations.\n""
 
print ""Not switching allows you to win"",
print sum(monty_hall(randrange(3), switch=False)
          for x in range(iterations)),
print ""out of"", iterations, ""times.""
print ""Switching allows you to win"",
print sum(monty_hall(randrange(3), switch=True)
          for x in range(iterations)),
print ""out of"", iterations, ""times.\n""",Human_written,Python_from_C
http://rosettacode.org/wiki/XML/Input,XML/Input,"Given the following XML fragment, extract the list of student names using whatever means desired. If the only viable method is to use XPath, refer the reader to the task XML and XPath.

<Students>
  <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
  <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
  <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
  <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
    <Pet Type=""dog"" Name=""Rover"" />
  </Student>
  <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>
Expected Output

April
Bob
Chad
Dave
Émily
",Python,"# version 1.1.3
import xml.dom.minidom
 
xml = 
""""""
<Students>
    <Student Name=""April"" Gender=""F"" DateOfBirth=""1989-01-02"" />
    <Student Name=""Bob"" Gender=""M""  DateOfBirth=""1990-03-04"" />
    <Student Name=""Chad"" Gender=""M""  DateOfBirth=""1991-05-06"" />
    <Student Name=""Dave"" Gender=""M""  DateOfBirth=""1992-07-08"">
        <Pet Type=""dog"" Name=""Rover"" />
    </Student>
    <Student DateOfBirth=""1993-09-10"" Gender=""F"" Name=""&#x00C9;mily"" />
</Students>
""""""
 
doc = xml.dom.minidom.parseString(xml)
nList = doc.getElementsByTagName(""Student"")
for i in range(0, nList.length):
    node = nList.item(i)
    if node.nodeType == node.ELEMENT_NODE:
        element = node
        name = element.getAttribute(""Name"")
        print(name)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously,First-class functions/Use numbers analogously,"In First-class functions, a language is showing how its manipulation of functions is similar to its manipulation of other types.

This tasks aim is to compare and contrast a language's implementation of first class functions, with its normal handling of numbers.



Write a program to create an ordered collection of a mixture of literally typed and expressions producing a real number, together with another ordered collection of their multiplicative inverses. Try and use the following pseudo-code to generate the numbers for the ordered collections:

  x  = 2.0
  xi = 0.5
  y  = 4.0
  yi = 0.25
  z  = x + y
  zi = 1.0 / ( x + y )

Create a function multiplier, that given two numbers as arguments returns a function that when called with one argument, returns the result of multiplying the two arguments to the call to multiplier that created it and the argument in the call:

 new_function = multiplier(n1,n2)
 # where new_function(m) returns the result of n1 * n2 * m

Applying the multiplier of a number and its inverse from the two ordered collections of numbers in pairs, show that the result in each case is one.

Compare and contrast the resultant program with the corresponding entry in First-class functions. They should be close.

To paraphrase the task description: Do what was done before, but with numbers rather than functions
",Python,"from itertools import izip
 
x = 2.0
xi = 0.5
y = 4.0
yi = 0.25
z = x + y
zi = 1.0 / (x + y)
 
numlist = [x, y, z]
numlisti = [xi, yi, zi]
multiplied = [lambda m: n1 * n2 * m for n1, n2 in izip(numlist, numlisti)]
 
for multiplier in multiplied:
    print multiplier(0.5)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Hello_world/Graphical,Hello world/Graphical,"

Task

Display the string       Goodbye, World!       on a GUI object   (alert box, plain window, text area, etc.).



Related task

   Hello world/Text

",Python,"import gtk
 
def main():
  window = gtk.Window(gtk.WINDOW_TOPLEVEL)
  window.set_title(""Goodbye, World"")
  window.connect(""delete-event"", gtk.main_quit)
  window.show_all()
  gtk.main()
 
if __name__ == ""__main__"":
  main()",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Twelve_statements,Twelve statements,"This puzzle is borrowed from   math-frolic.blogspot.



Given the following twelve statements, which of them are true?

 1.  This is a numbered list of twelve statements.
 2.  Exactly 3 of the last 6 statements are true.
 3.  Exactly 2 of the even-numbered statements are true.
 4.  If statement 5 is true, then statements 6 and 7 are both true.
 5.  The 3 preceding statements are all false.
 6.  Exactly 4 of the odd-numbered statements are true.
 7.  Either statement 2 or 3 is true, but not both.
 8.  If statement 7 is true, then 5 and 6 are both true.
 9.  Exactly 3 of the first 6 statements are true.
10.  The next two statements are both true.
11.  Exactly 1 of statements 7, 8 and 9 are true.
12.  Exactly 4 of the preceding statements are true.



Task

When you get tired of trying to figure it out in your head,
write a program to solve it, and print the correct answer or answers.



Extra credit

Print out a table of near misses, that is, solutions that are contradicted by only a single statement.



",Python,"from itertools import count
 
def twelve_statements():
    checks = [
        lambda st: st[1],
        lambda st: st[2] == (7 <= sum(i <= 12 for i in range(1, 13)) <= 3),
        lambda st: st[3] == (2 <= sum(i <= 12 for i in range(1, 13, 2)) <= 2),
        lambda st: st[4] == (st[5] and st[6] and st[7]),
        lambda st: st[5] == (not st[2] and not st[3] and not st[4]),
        lambda st: st[6] == (1 <= sum(i <= 12 for i in range(1, 13, 2)) <= 4),
        lambda st: st[7] == (st[2]!= st[3]),
        lambda st: st[8] == (st[7] and st[5] and st[6]),
        lambda st: st[9] == (1 <= sum(i <= 6 for i in range(1, 7)) <= 3),
        lambda st: st[10] == (st[11] and st[12]),
        lambda st: st[11] == (7 <= sum(i <= 9 for i in range(1, 10)) <= 1),
        lambda st: st[12] == (1 <= sum(i <= 11 for i in range(1, 12)) <= 4)
    ]
 
    for statements in count():
        count = 0
        false_index = 0
        for i in range(1, 13):
            if checks[i - 1](statements):
                count += 1
            else:
                false_index = i
        if count == 0:
            print(f'{""All wrong:"", -13}{statements}')
        elif count == 11:
            print(f'{""Wrong at {false_index}:"", -13}{statements}')
        elif count == 12:
            print(f'{""All correct:"", -13}{statements}')
 
if __name__ == '__main__':
    twelve_statements()",Ai_generated,Python_from_C#
"http://rosettacode.org/wiki/Abbreviations,_easy","Abbreviations, easy","This task is an easier (to code) variant of the Rosetta Code task:    Abbreviations, simple.



For this task, the following   command table   will be used:

   Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy
   COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find
   NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput
   Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO
   MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT
   READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT
   RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up



Notes concerning the above   command table:

   it can be thought of as one long literal string   (with blanks at end-of-lines)
   it may have superfluous blanks
   it may be in any case (lower/upper/mixed)
   the order of the words in the   command table   must be preserved as shown
   the user input(s) may be in any case (upper/lower/mixed)
   commands will be restricted to the Latin alphabet   (A ──► Z,   a ──► z)
   A valid abbreviation is a word that has:
   at least the minimum length of the number of capital letters of the word in the command table
   compares equal (regardless of case) to the leading characters of the word in the command table
   a length not longer than the word in the command table
   ALT,   aLt,   ALTE,   and   ALTER   are all abbreviations of   ALTer
   AL,   ALF,   ALTERS,   TER,   and   A   aren't valid abbreviations of   ALTer
   The number of capital letters in   ALTer   indicates that any abbreviation for   ALTer   must be at least three letters
   Any word longer than five characters can't be an abbreviation for   ALTer
   o,   ov,   oVe,   over,   overL,   overla   are all acceptable abbreviations for   Overlay
   if there isn't any lowercase letters in the word in the command table,   then there isn't an abbreviation permitted


Task

   The command table needn't be verified/validated.
   Write a function to validate if the user ""words""   (given as input)   are valid   (in the command table).
   If the word   is   valid,   then return the full uppercase version of that ""word"".
   If the word isn't valid,   then return the lowercase string:    *error*        (7 characters).
   A blank input   (or a null input)   should return a null string.
   Show all output here.


An example test case to be used for this task

For a user string of:

 riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin

the computer program should return the string:

 RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT


Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"from collections import defaultdict
 
commands = """"""
    Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy \
    COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find \
    NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput \
    Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO \
    MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT \
    READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT \
    RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up \
""""""
 
count_hashtable = defaultdict(int)
for word in commands.split():
    count_hashtable[word] = len(word) - len(word.rstrip(word.upper()))
 
line = ""riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin""
words_vec = []
for word in line.split():
    abbr = next((x for x in commands.split() if x.lower().startswith(word.lower()) and len(word) >= count_hashtable[x]), None)
    words_vec.append(abbr.upper() if abbr else ""*error*"")
corrected_line = "" "".join(words_vec)
print(corrected_line)",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"import os
os.environ['HOME']",Human_written,Python_from_C++
http://rosettacode.org/wiki/Long_multiplication,Long multiplication,"Task

Explicitly implement   long multiplication.

This is one possible approach to arbitrary-precision integer algebra.



For output, display the result of    264 * 264.

Optionally, verify your result against builtin arbitrary precision support.

The decimal representation of    264    is:

18,446,744,073,709,551,616

The output of    264 * 264    is    2128,    and is:

340,282,366,920,938,463,463,374,607,431,768,211,456


",Python,"#!/usr/bin/env python
print 2**64*2**64",Human_written,Python_from_Java
http://rosettacode.org/wiki/Cantor_set,Cantor set,"Task

Draw a Cantor set.



See details at this Wikipedia webpage:   Cantor set
",Python,"WIDTH = 81
HEIGHT = 5
 
lines=[]
def cantor(start, len, index):
    seg = len / 3
    if seg == 0:
        return None
    for it in xrange(HEIGHT-index):
        i = index + it
        for jt in xrange(seg):
            j = start + seg + jt
            pos = i * WIDTH + j
            lines[pos] = ' '
    cantor(start,           seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)
    return None
 
lines = ['*'] * (WIDTH*HEIGHT)
cantor(0, WIDTH, 1)
 
for i in xrange(HEIGHT):
    beg = WIDTH * i
    print ''.join(lines[beg : beg+WIDTH])",Human_written,Python_from_C++
http://rosettacode.org/wiki/Environment_variables,Environment variables,"Task

Show how to get one of your process's environment variables.

The available variables vary by system;   some of the common ones available on Unix include:

   PATH
   HOME
   USER

",Python,"import os
os.environ['HOME']",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Infinity,Infinity,"Task

Write a function which tests if infinity is supported for floating point numbers (this step should be omitted for languages where the language specification already demands the existence of infinity, e.g. by demanding IEEE numbers), and if so, returns positive infinity.   Otherwise, return the largest possible positive floating point number.

For languages with several floating point types, use the type of the literal constant   1.5   as floating point type.



Related task

   Extreme floating point values

",Python,">>> float('infinity')
inf",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Thue-Morse,Thue-Morse,"Task

Create a Thue-Morse sequence.



See also
   YouTube entry: The Fairest Sharing Sequence Ever
   YouTube entry: Math and OCD - My story with the Thue-Morse sequence
   Task: Fairshare between two and more

",Python,"for i in range(1,101):
    if i%3==0:
        if i%5==0:
            print(""FizzBuzz"",end="", "")
        else:
            print(""Fizz"",end="", "")
    elif i%5==0:
        print(""Buzz"",end="", "")
    else:
        print(i,end="", "")
    if i%40==0:
        print()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Loops/With_multiple_ranges,Loops/With multiple ranges,"Loops/With multiple ranges

You are encouraged to solve this task according to the task description, using any language you may know.
Some languages allow multiple loop ranges, such as the PL/I example (snippet) below.

                                       /* all variables are DECLARED as integers. */
          prod=  1;                    /*start with a product of unity.           */
           sum=  0;                    /*  ""     ""  ""   sum    "" zero.            */
             x= +5;
             y= -5;
             z= -2;
           one=  1;
         three=  3;
         seven=  7;
                                       /*(below)  **  is exponentiation:  4**3=64 */
           do j=   -three  to     3**3        by three   ,
                   -seven  to   +seven        by   x     ,
                      555  to      550 - y               ,
                       22  to      -28        by -three  ,
                     1927  to     1939                   ,
                        x  to        y        by   z     ,
                    11**x  to    11**x + one;
                                                        /* ABS(n) = absolute value*/
           sum= sum + abs(j);                           /*add absolute value of J.*/
           if abs(prod)<2**27 & j¬=0  then prod=prod*j; /*PROD is small enough & J*/
           end;                                         /*not 0, then multiply it.*/
                     /*SUM and PROD are used for verification of J incrementation.*/
         display (' sum= ' ||  sum);                    /*display strings to term.*/
         display ('prod= ' || prod);                    /*   ""       ""     ""   ""  */


Task

Simulate/translate the above PL/I program snippet as best as possible in your
language,   with particular emphasis on the   do   loop construct.

The   do   index must be incremented/decremented in the same order shown.

If feasible, add commas to the two output numbers (being displayed).

Show all output here.

      A simple PL/I   DO  loop  (incrementing or decrementing)  has the construct of:
 
            DO variable = start_expression    {TO ending_expression]       {BY increment_expression} ;
                 ---or---
            DO variable = start_expression    {BY increment_expression}    {TO ending_expression]    ;  
 
      where it is understood that all expressions will have a value.  The  variable  is normally a 
      scaler variable,  but need not be  (but for this task, all variables and expressions are declared
      to be scaler integers).   If the   BY   expression is omitted,  a   BY   value of unity is used.
      All expressions are evaluated before the   DO   loop is executed,  and those values are used
      throughout the   DO   loop execution   (even though, for instance,  the value of   Z   may be
      changed within the   DO   loop.    This isn't the case here for this task.  
 
      A multiple-range   DO   loop can be constructed by using a comma (,) to separate additional ranges
      (the use of multiple   TO   and/or   BY   keywords).     This is the construct used in this task.
 
      There are other forms of   DO   loops in PL/I involving the  WHILE  clause,  but those won't be 
      needed here.    DO  loops without a   TO   clause might need a   WHILE   clause  or some other 
      means of exiting the loop  (such as  LEAVE,  RETURN,  SIGNAL,  GOTO,  or  STOP),  or some other 
      (possible error) condition that causes transfer of control outside the  DO  loop.
 
      Also, in PL/I, the check if the   DO   loop index value is outside the range is made at the 
      ""head""  (start)  of the   DO  loop,  so it's possible that the   DO   loop isn't executed,  but 
      that isn't the case for any of the ranges used in this task. 
 
      In the example above, the clause:                    x    to y       by z     
      will cause the variable   J   to have to following values  (in this order):  5  3  1  -1  -3  -5
 
      In the example above, the clause:                 -seven  to +seven  by x  
      will cause the variable   J   to have to following values  (in this order):  -7  -2   3  


Related tasks

   Loop over multiple arrays simultaneously
   Loops/Break
   Loops/Continue
   Loops/Do-while
   Loops/Downward for
   Loops/For
   Loops/For with a specified step
   Loops/Foreach
   Loops/Increment loop index within loop body
   Loops/Infinite
   Loops/N plus one half
   Loops/Nested
   Loops/While
   Loops/with multiple ranges
   Loops/Wrong ranges

",Python,"import math

def main():
    prod = 1
    sum = 0
    x = 5
    y = -5
    z = -2
    one = 1
    three = 3
    seven = 7
    for j in concat(
        for_range(-three, 3 ** 3, three),
        for_range(-seven, seven, x),
        for_range(555, 550 - y),
        for_range(22, -28, -three),
        for_range(1927, 1939),
        for_range(x, y, z),
        for_range(11 ** x, 11 ** x + one)
    ):
        sum += abs(j)
        if abs(prod) < (1 << 27) and j!= 0:
            prod *= j
    print(f"" sum = {sum:N0}"")
    print(f""prod = {prod:N0}"")

def for_range(start, end, by=1):
    for i in range(start, end + 1, by):
        yield i

def concat(*ranges):
    return (j for r in ranges for j in r)

def pow(b, e):
    return int(math.pow(b, e))

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_C#
"http://rosettacode.org/wiki/Long_literals,_with_continuations","Long literals, with continuations","This task is about writing a computer program that has long literals   (character
literals that may require specifying the words/tokens on more than one (source)
line,   either with continuations or some other method, such as abutments or
concatenations   (or some other mechanisms).



The literal is to be in the form of a ""list"",   a literal that contains many
words (tokens) separated by a blank (space),   in this case   (so as to have a
common list),   the (English) names of the chemical elements of the periodic table.



The list is to be in (ascending) order of the (chemical) element's atomic number:

hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine neon sodium aluminum silicon ...

... up to the last known (named) chemical element   (at this time).



Do not include any of the   ""unnamed""   chemical element names such as:

ununennium unquadnilium triunhexium penthextrium penthexpentium septhexunium octenntrium ennennbium



To make computer programming languages comparable,   the statement widths should be
restricted to less than   81   bytes (characters),   or less
if a computer programming language has more restrictive limitations or standards.

Also mention what column the programming statements can start in if   not  
in column one.



The list   may   have leading/embedded/trailing blanks during the
declaration   (the actual program statements),   this is allow the list to be
more readable.   The ""final"" list shouldn't have any leading/trailing or superfluous
blanks   (when stored in the program's ""memory"").

This list should be written with the idea in mind that the
program   will   be updated,   most likely someone other than the
original author,   as there will be newer (discovered) elements of the periodic
table being added   (possibly in the near future).   These future updates
should be one of the primary concerns in writing these programs and it should be ""easy""
for someone else to add chemical elements to the list   (within the computer
program).

Attention should be paid so as to not exceed the   clause length   of
continued or specified statements,   if there is such a restriction.   If the
limit is greater than (say) 4,000 bytes or so,   it needn't be mentioned here.



Task

   Write a computer program (by whatever name) to contain a list of the known elements.
   The program should eventually contain a long literal of words   (the elements).
   The literal should show how one could create a long list of blank-delineated words.
   The ""final"" (stored) list should only have a single blank between elements.
   Try to use the most idiomatic approach(es) in creating the final list.
   Use continuation if possible, and/or show alternatives   (possibly using concatenation).
   Use a program comment to explain what the continuation character is if it isn't obvious.
   The program should contain a variable that has the date of the last update/revision.
   The program, when run, should display with verbiage:
   The last update/revision date   (and should be unambiguous).
   The number of chemical elements in the list.
   The name of the highest (last) element name.


Show all output here, on this page.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"""""""Long string literal. Requires Python 3.6+ for f-strings.""""""
 
revision = ""October 13th 2020""
 
# String literal continuation. Notice the trailing space at the end of each
# line but the last, and the lack of commas. There is exactly one ""blank""
# between each item in the list.
elements = (
    ""hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine ""
    ""neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon ""
    ""potassium calcium scandium titanium vanadium chromium manganese iron ""
    ""cobalt nickel copper zinc gallium germanium arsenic selenium bromine ""
    ""krypton rubidium strontium yttrium zirconium niobium molybdenum ""
    ""technetium ruthenium rhodium palladium silver cadmium indium tin ""
    ""antimony tellurium iodine xenon cesium barium lanthanum cerium ""
    ""praseodymium neodymium promethium samarium europium gadolinium terbium ""
    ""dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum ""
    ""tungsten rhenium osmium iridium platinum gold mercury thallium lead ""
    ""bismuth polonium astatine radon francium radium actinium thorium ""
    ""protactinium uranium neptunium plutonium americium curium berkelium ""
    ""californium einsteinium fermium mendelevium nobelium lawrencium ""
    ""rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium ""
    ""roentgenium copernicium nihonium flerovium moscovium livermorium ""
    ""tennessine oganesson""
)
 
 
def report():
    """"""Write a summary report to stdout.""""""
    items = elements.split()
 
    print(f""Last revision date: {revision}"")
    print(f""Number of elements: {len(items)}"")
    print(f""Last element      : {items[-1]}"")
 
 
if __name__ == ""__main__"":
    report()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Calendar,Calendar,"Create a routine that will generate a text calendar for any year.
Test the calendar by generating a calendar for the year 1969, on a device of the time.
Choose one of the following devices:

 A line printer with a width of 132 characters.
 An IBM 3278 model 4 terminal (80×43 display with accented characters). Target formatting the months of the year to fit nicely across the 80 character width screen. Restrict number of lines in test output to 43.


(Ideally, the program will generate well-formatted calendars for any page width from 20 characters up.)

Kudos (κῦδος) for routines that also transition from Julian to Gregorian calendar.

This task is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

For further Kudos see task CALENDAR, where all code is to be in UPPERCASE.

For economy of size, do not actually include Snoopy generation in either the code or the output, instead just output a place-holder.



Related task

   Five weekends

",Python,">>> import calendar
>>> help(calendar.prcal)
Help on method pryear in module calendar:
 
pryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance
    Print a years calendar.
 
>>> calendar.prcal(1969)
                                  1969
 
      January                   February                   March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2                      1  2
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9
13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16
20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23
27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30
                                                    31
 
       April                      May                       June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                1  2  3  4                         1
 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8
14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15
21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22
28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29
                                                    30
 
        July                     August                  September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7
 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14
14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21
21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28
28 29 30 31               25 26 27 28 29 30 31      29 30
 
      October                   November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
       1  2  3  4  5                      1  2       1  2  3  4  5  6  7
 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14
13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21
20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28
27 28 29 30 31            24 25 26 27 28 29 30      29 30 31",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Tree_traversal,Tree traversal,"Task

Implement a binary tree where each node carries an integer,   and implement:

   pre-order,
   in-order, 
   post-order,     and 
   level-order   traversal. 


Use those traversals to output the following tree:

         1
        / \
       /   \
      /     \
     2       3
    / \     /
   4   5   6
  /       / \
 7       8   9

The correct output should look like this:

preorder:    1 2 4 7 5 3 6 8 9
inorder:     7 4 2 5 1 8 6 9 3
postorder:   7 4 5 2 8 9 6 3 1
level-order: 1 2 3 4 5 6 7 8 9



See also

   Wikipedia article:   Tree traversal.

",Python,"from collections import namedtuple
 
Node = namedtuple('Node', 'data, left, right')
tree = Node(1,
            Node(2,
                 Node(4,
                      Node(7, None, None),
                      None),
                 Node(5, None, None)),
            Node(3,
                 Node(6,
                      Node(8, None, None),
                      Node(9, None, None)),
                 None))
 
def printwithspace(i):
    print(i, end=' ')
 
def dfs(order, node, visitor):
    if node is not None:
        for action in order:
            if action == 'N':
                visitor(node.data)
            elif action == 'L':
                dfs(order, node.left, visitor)
            elif action == 'R':
                dfs(order, node.right, visitor)
 
def preorder(node, visitor = printwithspace):
    dfs('NLR', node, visitor)
 
def inorder(node, visitor = printwithspace):
    dfs('LNR', node, visitor)
 
def postorder(node, visitor = printwithspace):
    dfs('LRN', node, visitor)
 
def ls(node, more, visitor, order='TB'):
    ""Level-based Top-to-Bottom or Bottom-to-Top tree search""
    if node:
        if more is None:
            more = []
        more += [node.left, node.right]
    for action in order:
        if action == 'B' and more:
            ls(more[0], more[1:], visitor, order)
        elif action == 'T' and node:
            visitor(node.data)
 
def levelorder(node, more=None, visitor = printwithspace):
    ls(node, more, visitor, 'TB') 
 
# Because we can
def reverse_preorder(node, visitor = printwithspace):
    dfs('RLN', node, visitor)
 
def bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):
    ls(node, more, visitor, 'BT')
 
 
if __name__ == '__main__':
    w = 10
    for traversal in [preorder, inorder, postorder, levelorder, 
                      reverse_preorder, bottom_up_order]:
        if traversal == reverse_preorder:
            w = 20
            print('\nThe generalisation of function dfs allows:')
        if traversal == bottom_up_order:
            print('The generalisation of function ls allows:')
        print(f""{traversal.__name__:>{w}}:"", end=' ')
        traversal(tree)
        print()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Cantor_set,Cantor set,"Task

Draw a Cantor set.



See details at this Wikipedia webpage:   Cantor set
",Python,"WIDTH = 81
HEIGHT = 5
 
lines=[]
def cantor(start, len, index):
    seg = len / 3
    if seg == 0:
        return None
    for it in xrange(HEIGHT-index):
        i = index + it
        for jt in xrange(seg):
            j = start + seg + jt
            pos = i * WIDTH + j
            lines[pos] = ' '
    cantor(start,           seg, index + 1)
    cantor(start + seg * 2, seg, index + 1)
    return None
 
lines = ['*'] * (WIDTH*HEIGHT)
cantor(0, WIDTH, 1)
 
for i in xrange(HEIGHT):
    beg = WIDTH * i
    print ''.join(lines[beg : beg+WIDTH])",Human_written,Python_from_Java
http://rosettacode.org/wiki/Arithmetic_evaluation,Arithmetic evaluation,"Create a program which parses and evaluates arithmetic expressions.

Requirements

 An abstract-syntax tree (AST) for the expression must be created from parsing the input. 
 The AST must be used in evaluation, also, so the input may not be directly evaluated (e.g. by calling eval or a similar language feature.) 
 The expression will be a string or list of symbols like ""(1+3)*7"". 
 The four symbols + - * / must be supported as binary operators with conventional precedence rules. 
 Precedence-control parentheses must also be supported.


Note

For those who don't remember, mathematical precedence is as follows:

 Parentheses
 Multiplication/Division (left to right)
 Addition/Subtraction (left to right)


C.f
 
 24 game Player.
 Parsing/RPN calculator algorithm.
 Parsing/RPN to infix conversion.

",Python,"#include <boost/spirit.hpp>
 #include <boost/spirit/tree/ast.hpp>
 #include <string>
 #include <cassert>
 #include <iostream>
 #include <istream>
 #include <ostream>
 
 using boost::spirit::rule;
 using boost::spirit::parser_tag;
 using boost::spirit::ch_p;
 using boost::spirit::real_p;
 
 using boost::spirit::tree_node;
 using boost::spirit::node_val_data;
 
 // The grammar
 struct parser: public boost::spirit::grammar<parser>
 {
   enum rule_ids { addsub_id, multdiv_id, value_id, real_id };
 
   struct set_value
   {
     set_value(parser const& p): self(p) {}
     void operator()(tree_node<node_val_data<std::string::iterator,
                                             double> >& node,
                     std::string::iterator begin,
                     std::string::iterator end) const
     {
       node.value.value(self.tmp);
     }
     parser const& self;
   };
 
   mutable double tmp;
 
   template<typename Scanner> struct definition
   {
     rule<Scanner, parser_tag<addsub_id> > addsub;
     rule<Scanner, parser_tag<multdiv_id> > multdiv;
     rule<Scanner, parser_tag<value_id> > value;
     rule<Scanner, parser_tag<real_id> > real;
 
     definition(parser const& self)
     {
       using namespace boost::spirit;
       addsub = multdiv
         >> *((root_node_d[ch_p('+')] | root_node_d[ch_p('-')]) >> multdiv);
       multdiv = value
         >> *((root_node_d[ch_p('*')] | root_node_d[ch_p('/')]) >> value);
       value = real | inner_node_d[('(' >> addsub >> ')')];
       real = leaf_node_d[access_node_d[real_p[assign_a(self.tmp)]][set_value(self)]];
     }
 
     rule<Scanner, parser_tag<addsub_id> > const& start() const
     {
       return addsub;
     }
   };
 };
 
 template<typename TreeIter>
 double evaluate(TreeIter const& i)
 {
   double op1, op2;
   switch (i->value.id().to_long())
   {
   case parser::real_id:
     return i->value.value();
   case parser::value_id:
   case parser::addsub_id:
   case parser::multdiv_id:
     op1 = evaluate(i->children.begin());
     op2 = evaluate(i->children.begin()+1);
     switch(*i->value.begin())
     {
     case '+':
       return op1 + op2;
     case '-':
       return op1 - op2;
     case '*':
       return op1 * op2;
     case '/':
       return op1 / op2;
     default:
       assert(!""Should not happen"");
     }
   default:
     assert(!""Should not happen"");
   }
   return 0;
 }
 
 // the read/eval/write loop
 int main()
 {
   parser eval;
   std::string line;
   while (std::cout << ""Expression: ""
          && std::getline(std::cin, line)
          &&!line.empty())
   {
     typedef boost::spirit::node_val_data_factory<double> factory_t;
     boost::spirit::tree_parse_info<std::string::iterator, factory_t> info =
       boost::spirit::ast_parse<factory_t>(line.begin(), line.end(),
                                           eval, boost::spirit::space_p);
     if (info.full)
     {
       std::cout << ""Result: "" << evaluate(info.trees.begin()) << std::endl;
     }
     else
     {
       std::cout << ""Error in expression."" << std::endl;
     }
   }
 };",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Create_an_HTML_table,Create an HTML table,"Create an HTML table.

 The table body should have at least three rows of three columns.
 Each of these three columns should be labelled ""X"", ""Y"", and ""Z"". 
 An extra column should be added at either the extreme left or the extreme right of the table that has no heading, but is filled with sequential row numbers. 
 The rows of the ""X"", ""Y"", and ""Z"" columns should be filled with random or sequential integers having 4 digits or less. 
 The numbers should be aligned in the same fashion for all columns.

",Python,"import random
 
def rand9999():
    return random.randint(1000, 9999)
 
def tag(attr='', **kwargs):
    for tag, txt in kwargs.items():
        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())
 
if __name__ == '__main__':
    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\n'
    rows = '\n'.join(tag(tr=tag(' style=""font-weight: bold;""', td=i)
                                    + ''.join(tag(td=rand9999())
                                              for j in range(3)))
                     for i in range(1, 6))
    table = tag(table='\n' + header + rows + '\n')
    print(table)",Human_written,Python_from_C
http://rosettacode.org/wiki/Probabilistic_choice,Probabilistic choice,"Given a mapping between items and their required probability of occurrence, generate a million items randomly subject to the given probabilities and compare the target probability of occurrence versus the generated values.

The total of all the probabilities should equal one. (Because floating point arithmetic is involved, this is subject to rounding errors).

aleph   1/5.0
beth    1/6.0
gimel   1/7.0
daleth  1/8.0
he      1/9.0
waw     1/10.0
zayin   1/11.0
heth    1759/27720 # adjusted so that probabilities add to 1
Related task

 Random number generator (device)

",Python,"import random
import math

def main():
    probabilities = []
    probabilities.append( ( ""aleph"", 1/5.0 ) )
    probabilities.append( ( ""beth"", 1/6.0 ) )
    probabilities.append( ( ""gimel"", 1/7.0 ) )
    probabilities.append( ( ""daleth"", 1/8.0 ) )
    probabilities.append( ( ""he"", 1/9.0 ) )
    probabilities.append( ( ""waw"", 1/10.0 ) )
    probabilities.append( ( ""zayin"", 1/11.0 ) )
    probabilities.append( ( ""heth"", 1759/27720.0 ) )
    generated = []
    decider = []
    for i in range(len(probabilities)):
        if i == 0:
            decider.append( 27720 * (probabilities[ i ][1]) )
        else:
            number = 0
            for j in range(i):
                number +=  27720 * ( probabilities[ j ][1] )
            number += 27720 * probabilities[ i ][1]
            decider.append( number )
    for i in range(1000000):
        randnumber = random.randint(0,27720)
        j = 0
        while randnumber > decider[ j ]:
            j += 1
        generated.append( ( probabilities[ j ] )[0] )
    print(""letter  frequency attained   frequency expected"")
    for i in range(len(probabilities)):
        print(probabilities[i][0], end = "" "")
        found = generated.count(probabilities[i][0])
        print(found / 1000000.0, end = "" "")
        print(probabilities[i][1])

main()",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/URL_parser,URL parser,"URLs are strings with a simple syntax:

  scheme://[username:password@]domain[:port]/path?query_string#fragment_id



Task

Parse a well-formed URL to retrieve the relevant information:   scheme, domain, path, ...



Note:   this task has nothing to do with URL encoding or URL decoding.



According to the standards, the characters:

     ! * ' ( ) ; : @ & = + $ , / ? % # [ ] 
only need to be percent-encoded   (%)   in case of possible confusion.

Also note that the path, query and fragment are case sensitive, even if the scheme and domain are not.

The way the returned information is provided (set of variables, array, structured, record, object,...)
is language-dependent and left to the programmer, but the code should be clear enough to reuse.

Extra credit is given for clear error diagnostics.

   Here is the official standard:     https://tools.ietf.org/html/rfc3986, 
   and here is a simpler   BNF:     http://www.w3.org/Addressing/URL/5_URI_BNF.html.


Test cases

According to T. Berners-Lee

foo://example.com:8042/over/there?name=ferret#nose     should parse into:

   scheme = foo
   domain = example.com
   port = :8042
   path = over/there
   query = name=ferret
   fragment = nose

urn:example:animal:ferret:nose     should parse into:

   scheme = urn
   path = example:animal:ferret:nose

other URLs that must be parsed include:

   jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true 
   ftp://ftp.is.co.za/rfc/rfc1808.txt 
   http://www.ietf.org/rfc/rfc2396.txt#header1 
   ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two 
   mailto:John.Doe@example.com 
   news:comp.infosystems.www.servers.unix 
   tel:+1-816-555-1212 
   telnet://192.0.2.16:80/ 
   urn:oasis:names:specification:docbook:dtd:xml:4.1.2 

",Python,"import json
import urllib.parse

def fnURLParse(strURL):
    e = urllib.parse.urlparse(strURL)
    return {
        'hash': e.fragment,
        'host': e.netloc,
        'hostname': e.hostname,
        'origin': e.scheme + '://' + e.netloc,
        'pathname': e.path,
        'port': e.port,
        'protocol': e.scheme,
       'search': e.query
    }

lstURL = [
    ""foo://example.com:8042/over/there?name=ferret#nose"",
    ""urn:example:animal:ferret:nose"",
    ""jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true"",
    ""ftp://ftp.is.co.za/rfc/rfc1808.txt"",
    ""http://www.ietf.org/rfc/rfc2396.txt#header1"",
    ""ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"",
    ""mailto:"",
    ""news:comp.infosystems.www.servers.unix"",
    ""tel:+1-816-555-1212"",
    ""telnet://192.0.2.16:80/"",
    ""urn:oasis:names:specification:docbook:dtd:xml:4.1.2"",
    ""ssh://alice@example.com"",
    ""https://bob:pass@example.com/place"",
    ""http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64""
]

print(json.dumps(list(map(fnURLParse, lstURL)), indent=2))",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/SHA-256,SHA-256,"SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string ""Rosetta code"" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
",Python,"import hashlib
 
msg = 'Rosetta code'
hash = hashlib.sha256(msg).hexdigest()
 
print(hash)",Ai_generated,Python_from_JavaScript
http://rosettacode.org/wiki/Xiaolin_Wu%27s_line_algorithm,Xiaolin Wu's line algorithm,"Task

Implement the   Xiaolin Wu's line algorithm   described in Wikipedia.



This algorithm draws anti-aliased lines.



Related task

   See   Bresenham's line algorithm   for aliased lines.

",Python,"""""""Script demonstrating drawing of anti-aliased lines using Xiaolin Wu's line
algorithm
 
usage: python xiaolinwu.py [output-file]
 
""""""
from __future__ import division
import sys
 
from PIL import Image
 
 
def _fpart(x):
    return x - int(x)
 
def _rfpart(x):
    return 1 - _fpart(x)
 
def putpixel(img, xy, color, alpha=1):
    """"""
    Paints color over the background at the point xy in img.
    Use alpha for blending. alpha=1 means a completely opaque foreground.
    """"""
    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))
    c = compose_color(img.getpixel(xy), color)
    img.putpixel(xy, c)
 
def draw_line(img, p1, p2, color):
    """"""Draws an anti-aliased line in img from p1 to p2 with the given color.""""""
    x1, y1 = p1
    x2, y2 = p2
    dx, dy = x2-x1, y2-y1
    steep = abs(dx) < abs(dy)
    p = lambda px, py: ((px,py), (py,px))[steep]
 
    if steep:
        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx
    if x2 < x1:
        x1, x2, y1, y2 = x2, x1, y2, y1
 
    grad = dy/dx
    intery = y1 + _rfpart(x1) * grad
    def draw_endpoint(pt):
        x, y = pt
        xend = round(x)
        yend = y + grad * (xend - x)
        xgap = _rfpart(x + 0.5)
        px, py = int(xend), int(yend)
        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)
        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)
        return px
 
    xstart = draw_endpoint(p(*p1)) + 1
    xend = draw_endpoint(p(*p2))
 
    for x in range(xstart, xend):
        y = int(intery)
        putpixel(img, p(x, y), color, _rfpart(intery))
        putpixel(img, p(x, y+1), color, _fpart(intery))
        intery += grad
 
 
if __name__ == '__main__':
    if len(sys.argv) != 2:
        print 'usage: python xiaolinwu.py [output-file]'
        sys.exit(-1)
 
    blue = (0, 0, 255)
    yellow = (255, 255, 0)
    img = Image.new(""RGB"", (500,500), blue)
    for a in range(10, 431, 60):
        draw_line(img, (10, 10), (490, a), yellow)
        draw_line(img, (10, 10), (a, 490), yellow)
    draw_line(img, (10, 10), (490, 490), yellow)
    filename = sys.argv[1]
    img.save(filename)
    print 'image saved to', filename",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/CRC-32,CRC-32,"

Task

Demonstrate a method of deriving the Cyclic Redundancy Check from within the language.



The result should be in accordance with ISO 3309, ITU-T V.42, Gzip and PNG.

Algorithms are described on Computation of CRC in Wikipedia.
This variant of CRC-32 uses LSB-first order, sets the initial CRC to FFFFFFFF16, and complements the final CRC.

For the purpose of this task, generate a CRC-32 checksum for the ASCII encoded string:

 The quick brown fox jumps over the lazy dog

",Python,"import zlib
print ""0x%08x"" % zlib.crc32('The quick brown fox jumps over the lazy dog')
# => 0x414fa339",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Update_a_configuration_file,Update a configuration file,"We have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines begininning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# The first word on each non comment line is the configuration option.
# Remaining words or numbers on the line are configuration parameter
# data fields.

# Note that configuration option names are not case sensitive. However,
# configuration parameter data is case sensitive and the lettercase must
# be preserved.

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# How many bananas we have
NUMBEROFBANANAS 48

The task is to manipulate the configuration file as follows:

 Disable the needspeeling option (using a semicolon prefix)
 Enable the seedsremoved option by removing the semicolon and any leading whitespace
 Change the numberofbananas parameter to 1024
 Enable (or create if it does not exist in the file) a parameter for numberofstrawberries with a value of 62000


Note that configuration option names are not case sensitive. This means that changes should be effected, regardless of the case.

Options should always be disabled by prefixing them with a semicolon.

Lines beginning with hash symbols should not be manipulated and left unchanged in the revised file.

If a configuration option does not exist within the file (in either enabled or disabled form), it should be added during this update. Duplicate configuration option names in the file should be removed, leaving just the first entry.

For the purpose of this task, the revised file should contain appropriate entries, whether enabled or not for needspeeling,seedsremoved,numberofbananas and numberofstrawberries.)

The update should rewrite configuration option names in capital letters. However lines beginning with hashes and any parameter data must not be altered (eg the banana for favourite fruit must not become capitalized). The update process should also replace double semicolon prefixes with just a single semicolon (unless it is uncommenting the option, in which case it should remove all leading semicolons).

Any lines beginning with a semicolon or groups of semicolons, but no following option should be removed, as should any leading or trailing whitespace on the lines. Whitespace between the option and parameters should consist only of a single
space, and any non-ASCII extended characters, tabs characters, or control codes
(other than end of line markers), should also be removed.



Related tasks
 Read a configuration file

",Python,"import re
import os
from collections import OrderedDict
 
class EntryType:
    EMPTY, ENABLED, DISABLED, COMMENT = range(4)
 
class Entry:
    def __init__(self, t, n, v):
        self.type = t
        self.name = n
        self.value = v
 
entries = OrderedDict()
path = None
 
def readConfig(p):
    global path
    path = p
 
    if not os.path.exists(p) or os.path.isdir(p):
        return False
 
    regexString = ""^(;*)\\s*([A-Za-z0-9]+)\\s*([A-Za-z0-9]*)""
    regex = re.compile(regexString)
 
    with open(p) as f:
        emptyLines = 0
        for line in f:
            line = line.strip()
 
            if not line:
                addOption("""" + emptyLines, None, EntryType.EMPTY)
 
            elif line.startswith('#'):
                entries[line] = Entry(EntryType.COMMENT, line, None)
 
            else:
                line = re.sub(""[^a-zA-Z0-9\\x20;]"", """", line)
                m = regex.match(line)
 
                if m and m.group(2):
 
                    t = EntryType.ENABLED
                    if m.group(1):
                        t = EntryType.DISABLED
 
                    addOption(m.group(2), m.group(3), t)
    return True
 
def addOption(name, value):
    addOption(name, value, EntryType.ENABLED)
 
def addOption(name, value, t):
    name = name.upper()
    entries[name] = Entry(t, name, value)
 
def enableOption(name):
    e = entries.get(name.upper())
    if e:
        e.type = EntryType.ENABLED
 
def disableOption(name):
    e = entries.get(name.upper())
    if e:
        e.type = EntryType.DISABLED
 
def setOption(name, value):
    e = entries.get(name.upper())
    if e:
        e.value = value
 
def store():
    with open(path, 'w') as f:
        for e in entries.values():
            if e.type == EntryType.EMPTY:
                f.write(""\n"")
            elif e.type == EntryType.ENABLED:
                f.write(""%s %s\n"" % (e.name, e.value))
            elif e.type == EntryType.DISABLED:
                f.write(""; %s %s\n"" % (e.name, e.value))
            elif e.type == EntryType.COMMENT:
                f.write(""%s\n"" % e.name)
 
if __name__ == ""__main__"":
    if len(sys.argv) < 2:
        print(""filename required"")
    elif readConfig(sys.argv[1]):
        enableOption(""seedsremoved"")
        disableOption(""needspeeling"")
        setOption(""numberofbananas"", ""1024"")
        addOption(""numberofstrawberries"", ""62000"")
        store()",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Topological_sort,Topological sort,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort




Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon.

The compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on.

A tool exists that extracts library dependencies.



Task

Write a function that will return a valid compile order of VHDL libraries from their dependencies.

 Assume library names are single words. 
 Items mentioned as only dependents, (sic), have no dependents of their own, but their order of compiling must be given.
 Any self dependencies should be ignored. 
 Any un-orderable dependencies should be flagged.


Use the following data as an example:

LIBRARY          LIBRARY DEPENDENCIES
=======          ====================
des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
dw01             ieee dw01 dware gtech
dw02             ieee dw02 dware
dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
dw04             dw04 ieee dw01 dware gtech
dw05             dw05 ieee dware
dw06             dw06 ieee dware
dw07             ieee dware
dware            ieee dware
gtech            ieee gtech
ramlib           std ieee
std_cell_lib     ieee std_cell_lib
synopsys


Note: the above data would be un-orderable if, for example, dw04 is added to the list of dependencies of dw01.



C.f.

   Topological sort/Extracted top item.


There are two popular algorithms for topological sorting:

   Kahn's 1962 topological sort [1] 
   depth-first search [2] [3]

",Python,"from collections import defaultdict
 
class Library:
    def __init__(self, name, num_parents):
        self.name = name
        self.children = []
        self.num_parents = num_parents
 
def build_libraries(input):
    libraries = defaultdict(Library)
 
    for input_line in input:
        line_split = input_line.split()
        name = line_split[0]
        num_parents = 0
        for parent in line_split[1:]:
            if parent == name:
                continue
            if parent not in libraries:
                libraries[parent] = Library(parent, 0)
            libraries[parent].children.append(name)
            num_parents += 1
 
        if name not in libraries:
            libraries[name] = Library(name, num_parents)
        else:
            libraries[name].num_parents = num_parents
 
    return libraries
 
def topological_sort(libraries):
    needs_processing = set(libraries.keys())
    options = [k for k, v in libraries.items() if v.num_parents == 0]
    sorted = []
    while options:
        cur = options.pop()
        for children in libraries[cur].children:
            libraries[children].num_parents -= 1
            if libraries[children].num_parents == 0:
                options.append(children)
        sorted.append(cur)
        needs_processing.remove(cur)
 
    if needs_processing:
        raise Exception(""Cycle detected among {}"".format(needs_processing))
    return sorted
 
if __name__ == ""__main__"":
    input = [
        ""des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee"",
        ""dw01             ieee dw01 dware gtech dw04"",
        ""dw02             ieee dw02 dware"",
        ""dw03             std synopsys dware dw03 dw02 dw01 ieee gtech"",
        ""dw04             dw04 ieee dw01 dware gtech"",
        ""dw05             dw05 ieee dware"",
        ""dw06             dw06 ieee dware"",
        ""dw07             ieee dware"",
        ""dware            ieee dware"",
        ""gtech            ieee gtech"",
        ""ramlib           std ieee"",
        ""std_cell_lib     ieee std_cell_lib"",
        ""synopsys"",
    ]
 
    libraries = build_libraries(input)
    print(topological_sort(libraries))",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Unicode_strings,Unicode strings,"As the world gets smaller each day, internationalization becomes more and more important.   For handling multiple languages, Unicode is your best friend.

It is a very capable tool, but also quite complex compared to older single- and double-byte character encodings.

How well prepared is your programming language for Unicode?



Task

Discuss and demonstrate its unicode awareness and capabilities.



Some suggested topics:

   How easy is it to present Unicode strings in source code? 
   Can Unicode literals be written directly, or be part of identifiers/keywords/etc?
   How well can the language communicate with the rest of the world? 
   Is it good at input/output with Unicode?
   Is it convenient to manipulate Unicode strings in the language?
   How broad/deep does the language support Unicode? 
   What encodings (e.g. UTF-8, UTF-16, etc) can be used? 
   Does it support normalization?


Note

This task is a bit unusual in that it encourages general discussion rather than clever coding.



See also

   Unicode variable names
   Terminal control/Display an extended character

",Python,"#!/usr/bin/env python
# -*- coding: latin-1 -*-
 
u = 'abcdé'
print(ord(u[-1]))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Galton_box_animation,Galton box animation," Example of a Galton Box at the end of animation.


A   Galton device   Sir Francis Galton's device   is also known as a   bean machine,   a   Galton Board,   or a   quincunx.



Description of operation

In a Galton box, there are a set of pins arranged in a triangular pattern.   A number of balls are dropped so that they fall in line with the top pin, deflecting to the left or the right of the pin.   The ball continues to fall to the left or right of lower pins before arriving at one of the collection points between and to the sides of the bottom row of pins.

Eventually the balls are collected into bins at the bottom   (as shown in the image),   the ball column heights in the bins approximate a   bell curve.   Overlaying   Pascal's triangle   onto the pins shows the number of different paths that can be taken to get to each bin.



Task

Generate an animated simulation of a Galton device.



Task requirements

   The box should have at least 5 pins on the bottom row. 
   A solution can use graphics or ASCII animation. 
   Provide a sample of the output/display such as a screenshot.
   There can be one or more balls in flight at the same time. 
   If multiple balls are in flight, ensure they don't interfere with each other.
   A solution should allow users to specify the number of balls, or it should run until full or a preset limit. 
   Optionally,   display the number of balls.

",Python,"# version 1.2.10
 
import random
 
boxW = 41       # Galton box width.
boxH = 37       # Galton box height.
pinsBaseW = 19  # Pins triangle base.
nMaxBalls = 55  # Number of balls.
 
centerH = pinsBaseW + (boxW - pinsBaseW * 2 + 1) / 2 - 1
rand = random.Random()
 
class Cell:
    def __init__(self, c):
        self.c = c
 
EMPTY = Cell(' ')
BALL = Cell('o')
WALL = Cell('|')
CORNER = Cell('+')
FLOOR = Cell('-')
PIN = Cell('.')
 
# Galton box. Will be printed upside down.
box = [[EMPTY for _ in range(boxW)] for _ in range(boxH)]
 
class Ball:
 
    def __init__(self, x, y):
        self.x = x
        self.y = y
        assert box[y][x] == EMPTY
        box[y][x] = BALL
 
    def doStep(self):
        if self.y <= 0: return  # Reached the bottom of the box.
        cell = box[self.y - 1][self.x]
        if cell == EMPTY:
            box[self.y][self.x] = EMPTY
            self.y -= 1
            box[self.y][self.x] = BALL
        elif cell == PIN:
            box[self.y][self.x] = EMPTY
            self.y -= 1
            if box[self.y][self.x - 1] == EMPTY and box[self.y][self.x + 1] == EMPTY:
                self.x += rand.randint(0, 1) * 2 - 1
                box[self.y][self.x] = BALL
                return
            elif box[self.y][self.x - 1] == EMPTY: self.x += 1
            else: self.x -= 1
            box[self.y][self.x] = BALL
        else:
            # It's frozen - it always piles on other balls.
            pass
 
def initializeBox():
    # Set ceiling and floor:
    box[0][0] = CORNER
    box[0][boxW - 1] = CORNER
    for i in range(1, boxW - 1): box[0][i] = FLOOR
    for i in range(boxW): box[boxH - 1][i] = box[0][i]
 
    # Set walls:
    for r in range(1, boxH - 1):
        box[r][0] = WALL
        box[r][boxW - 1] = WALL
 
    # Set pins:
    for nPins in range(1, pinsBaseW + 1):
        for pin in range(nPins):
            box[boxH - 2 - nPins][centerH + 1 - nPins + pin * 2] = PIN
 
def drawBox():
    for row in reversed(box):
        for i in range(len(row)): print(row[i].c, end='')
        print()
 
def main():
    initializeBox()
    balls = []
    for i in range(nMaxBalls + boxH):
        print(""\nStep"", i, "":"")
        if i < nMaxBalls: balls.append(Ball(centerH, boxH - 2))  # Add ball.
        drawBox()
 
        # Next step for the simulation.
        # Frozen balls are kept in balls list for simplicity
        for b in balls: b.doStep()
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Ramanujan%27s_constant,Ramanujan's constant,"Calculate Ramanujan's constant (as described on the OEIS site) with at least
32 digits of precision, by the method of your choice. Optionally, if using the 𝑒**(π*√x) approach,
show that when evaluated with the last four Heegner numbers
the result is almost an integer.
",Python,"from mpmath import mp
heegner = [19,43,67,163]
mp.dps = 50
x = mp.exp(mp.pi*mp.sqrt(163))
print(""calculated Ramanujan's constant: {}"".format(x))
print(""Heegner numbers yielding 'almost' integers:"")
for i in heegner:
    print("" for {}: {} ~ {} error: {}"".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))",Human_written,Python_from_Go
http://rosettacode.org/wiki/Hello_world/Line_printer,Hello world/Line printer,"Task

Cause a line printer attached to the computer to print a line containing the message:    Hello World! 



Note

A line printer is not the same as standard output.

A   line printer   was an older-style printer which prints one line at a time to a continuous ream of paper.

With some systems, a line printer can be any device attached to an appropriate port (such as a parallel port).



",Python,"lp = open(""/dev/lp0"")
lp.write(""Hello World!\n"")
lp.close()",Human_written,Python_from_Java
http://rosettacode.org/wiki/Distributed_programming,Distributed programming,"Write two programs (or one program with two modes) which run on networked computers, and send some messages between them.

The protocol used may be language-specific or not, and should be suitable for general distributed programming; that is, the protocol should be generic (not designed just for the particular example application), readily capable of handling the independent communications of many different components of a single application, and the transferring of arbitrary data structures natural for the language.

This task is intended to demonstrate high-level communication facilities beyond just creating sockets.
",Python,"import drb
import time
 
# The URI for the server to connect to
URI=""druby://localhost:8787""
 
class TimeServer:
 
  def get_current_time(self):
    return time.time()
 
# The object that handles requests on the server
FRONT_OBJECT = TimeServer()
 
# Start the server
drb.start_service(URI, FRONT_OBJECT)
# Wait for the drb server thread to finish before exiting.
drb.thread.join()",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Wieferich_primes,Wieferich primes,"

 This page uses content from Wikipedia. The original article was at Wieferich prime. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



In number theory, a Wieferich prime is a prime number  p  such that  p2  evenly divides  2(p − 1) − 1 .



It is conjectured that there are infinitely many Wieferich primes, but as of March 2021,only two have been identified.



Task 
 Write a routine (function procedure, whatever) to find Wieferich primes.
 Use that routine to identify and display all of the Wieferich primes less than 5000.


See also
 OEIS A001220 - Wieferich primes

",Python,"import math
 
def mod_pow(base, exp, mod):
    if mod == 1:
        return 0
 
    result = 1
    base %= mod
    while exp > 0:
        if exp & 1 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp >>= 1
    return result
 
def prime_sieve(limit):
    sieve = [True] * limit
 
    if limit > 0:
        sieve[0] = False
    if limit > 1:
        sieve[1] = False
 
    for i in range(4, limit, 2):
        sieve[i] = False
 
    for p in range(3, int(math.sqrt(limit)) + 1, 2):
        q = p * p
        if q >= limit:
            break
        if sieve[p]:
            inc = 2 * p
            for i in range(q, limit, inc):
                sieve[i] = False
 
    return sieve
 
def wiefreich_primes(limit):
    sieve = prime_sieve(limit)
    result = []
    for p in range(2, limit):
        if sieve[p] and mod_pow(2, p - 1, p * p) == 1:
            result.append(p)
    return result
 
if __name__ == '__main__':
    limit = 5000
    print('Wieferich primes less that {0}:'.format(limit))
    for p in wiefreich_primes(limit):
        print(p)",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Sort_three_variables,Sort three variables,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Task

Sort   (the values of)   three variables   (X,   Y,   and   Z)   that contain any value   (numbers and/or literals).

If that isn't possible in your language, then just sort numbers   (and note if they can be floating point, integer, or other).

I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  'lions, tigers, and'
                        y =  'bears, oh my!'
                        z =  '(from the ""Wizard of OZ"")'

After sorting, the three variables would hold:

                        x =  '(from the ""Wizard of OZ"")'
                        y =  'bears, oh my!'
                        z =  'lions, tigers, and'

For numeric value sorting, use:
I.E.:   (for the three variables   x,   y,   and   z),   where:

                        x =  77444
                        y =    -12
                        z =      0

After sorting, the three variables would hold:

                        x =    -12
                        y =      0
                        z =  77444

The variables should contain some form of a number, but specify if the algorithm
used can be for floating point or integers.   Note any limitations.

The values may or may not be unique.

The method used for sorting can be any algorithm;   the goal is to use the most idiomatic in the computer programming language used.

More than one algorithm could be shown if one isn't clearly the better choice.



One algorithm could be:

                        •  store the three variables   x, y, and z
                                 into an array (or a list)   A
                         
                        •  sort  (the three elements of)  the array   A
                         
                        •  extract the three elements from the array and place them in the
                                 variables x, y, and z   in order of extraction



Another algorithm   (only for numeric values):

       x= 77444 
       y=   -12 
       z=     0      
    low= x                                          
    mid= y                                          
   high= z 
      x= min(low,  mid,  high)            /*determine the lowest value of X,Y,Z. */    
      z= max(low,  mid,  high)            /*    ""      ""  highest  ""    "" "" "" ""  */    
      y=     low + mid + high - x - z     /*    ""      ""  middle   ""    "" "" "" ""  */      



Show the results of the sort here on this page using at least the values of those shown above.



",Python,"# The Ruby code.
x =  'lions, tigers, and'
y =  'bears, oh my!'
z =  '(from the ""Wizard of OZ"")'
x, y, z = [x, y, z].sort
puts x, y, z
 
x, y, z = 7.7444e4, -12, 18/2r # Float, Integer, Rational; taken from Perl 6
x, y, z = [x, y, z].sort
puts x, y, z
 
# The Python code.
x =  'lions, tigers, and'
y =  'bears, oh my!'
z =  '(from the ""Wizard of OZ"")'
x, y, z = sorted([x, y, z])
print x, y, z
 
x, y, z = 7.7444e4, -12, 18/2r # Float, Integer, Rational; taken from Perl 6
x, y, z = sorted([x, y, z])
print x, y, z",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Fivenum,Fivenum,"Many big data or scientific programs use boxplots to show distributions of data.   In addition, sometimes saving large arrays for boxplots can be impractical and use extreme amounts of RAM.   It can be useful to save large arrays as arrays with five numbers to save memory.

For example, the   R   programming language implements Tukey's five-number summary as the fivenum function.



Task

Given an array of numbers, compute the five-number summary.



Note
 
While these five numbers can be used to draw a boxplot,   statistical packages will typically need extra data.

Moreover, while there is a consensus about the ""box"" of the boxplot,   there are variations among statistical packages for the whiskers.



",Python,"import math
import numpy as np
import scipy.stats as stats
 
def fivenum(a):
    n = len(a)
    n4 = (n + 3) / 2 / 2
    d = [1, n4, (n + 1) / 2, n + 1 - n4, n]
    a = np.sort(a)
    return [a[int(math.floor(de - 1))] + a[int(math.ceil(de - 1))] / 2 for de in d]
 
x1 = [36, 40, 7, 39, 41, 15]
x2 = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]
x3 = [
    0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,
    0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,
    0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469,
    0.66206163, 1.04312009, -0.10305385, 0.75775634, 0.32566578,
]
 
print(fivenum(x1))
print(fivenum(x2))
print(fivenum(x3))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Function_composition,Function composition,"Task

Create a function, compose,   whose two arguments   f   and   g,   are both functions with one argument.



The result of compose is to be a function of one argument, (lets call the argument   x),   which works like applying function    f    to the result of applying function    g    to    x.



Example

 compose(f, g) (x) = f(g(x))



Reference: Function composition

Hint: In some languages, implementing compose correctly requires creating a closure.



",Python,"compose = lambda f, g: lambda x: f( g(x) )",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Sleeping_Beauty_problem,Sleeping Beauty problem,"Background on the task
In decision theory, The Sleeping Beauty Problem
is a problem invented by Arnold Zoboff and first publicized on Usenet. The experimental
subject, named Sleeping Beauty, agrees to an experiment as follows:
Sleeping Beauty volunteers to be put into a deep sleep on a Sunday. There is then a fair coin toss.
If this coin toss comes up heads, Sleeping Beauty wakes once (on Monday) and is asked to
estimate the probability that the coin toss was heads. Her estimate is recorded and she is
then put back to sleep for 2 days until Wednesday, at which time the experiment's results are tallied.



If instead the coin toss is tails, Sleeping Beauty wakes as before on Monday and asked to
estimate the probability the coin toss was heads, but is then given a drug which makes her forget
that she had been woken on Monday before being put back to sleep again. She then wakes only 1 day
later, on Tuesday. She is then asked (on Tuesday) again to guess the probability that the coin toss
was heads or tails. She is then put back to sleep and awakes as before 1 day later, on Wednesday.



Some decision makers have argued that since the coin toss was fair Sleeping Beauty should always
estimate the probability of heads as 1/2, since she does not have any additional information. Others
have disagreed, saying that if Sleeping Beauty knows the study design she also knows that she is twice
as likely to wake up and be asked to estimate the coin flip on tails than on heads, so the estimate
should be 1/3 heads.

Task
Given the above problem, create a Monte Carlo estimate of the actual results. The program should find the
proportion of heads on waking and asking Sleeping Beauty for an estimate, as a credence or as a percentage of the times Sleeping Beauty
is asked the question.


",Python,"from random import choice
 
def sleeping_beauty_experiment(repetitions):
    """"""
    Run the Sleeping Beauty Problem experiment `repetitions` times, checking to see
    how often we had heads on waking Sleeping Beauty.
    """"""
    gotheadsonwaking = 0
    wakenings = 0
    for _ in range(repetitions):
        coin_result = choice([""heads"", ""tails""])
 
        # On Monday, we check if we got heads.
        wakenings += 1
        if coin_result == ""heads"":
            gotheadsonwaking += 1
 
        # If tails, we do this again, but of course we will not add as if it was heads..
        if coin_result == ""tails"":
            wakenings += 1
            if coin_result == ""heads"":
                gotheadsonwaking += 1   # never done
 
 
    # Show the number of times she was wakened.
    print(""Wakenings over"", repetitions, ""experiments:"", wakenings)
 
    # Return the number of correct bets SB made out of the total number
    # of times she is awoken over all the experiments with that bet.
    return gotheadsonwaking / wakenings
 
 
CREDENCE = sleeping_beauty_experiment(1_000_000)
print(""Results of experiment:  Sleeping Beauty should estimate a credence of:"", CREDENCE)",Human_written,Python_from_C++
http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division,Sequence of primes by trial division,"Sequence of primes by trial division

You are encouraged to solve this task according to the task description, using any language you may know.
Task

Generate a sequence of primes by means of trial division.



Trial division is an algorithm where a candidate number is tested for being a prime by trying to divide it by other numbers.

You may use primes, or any numbers of your choosing, as long as the result is indeed a sequence of primes.

The sequence may be bounded (i.e. up to some limit), unbounded, starting from the start (i.e. 2) or above some given value.

Organize your function as you wish, in particular, it might resemble a filtering operation, or a sieving operation.

If you want to use a ready-made is_prime function, use one from the Primality by trial division page (i.e., add yours there if it isn't there already).



Related tasks

   count in factors
   prime decomposition
   factors of an integer
   Sieve of Eratosthenes
   primality by trial division
   factors of a Mersenne number
   trial factoring of a Mersenne number
   partition an integer X into N primes

",Python,"import sys
from threading import Thread
from Queue import Queue
 
def NumsFromBy(from_, by, ch):
  for i in range(from_, sys.maxint, by):
    ch.put(i)
 
def Filter(in_, out, prime):
  while True:
    i = in_.get()
    if i % prime!= 0:
      out.put(i)
 
def Sieve(out):
  out.put(3)
  q = 9
  ps = Queue()
  Thread(target=Sieve, args=(ps,)).start()
  p = ps.get()
  nums = Queue()
  Thread(target=NumsFromBy, args=(5, 2, nums)).start()
  while True:
    n = nums.get()
    if n < q:
      out.put(n)
    else:
      ch1 = Queue()
      Thread(target=Filter, args=(nums, ch1, p)).start()
      nums = ch1
      p = ps.get()
      q = p*p
 
def primes(c):
  c.put(2)
  Thread(target=Sieve, args=(c,)).start()
 
def main():
  ch = Queue()
  Thread(target=primes, args=(ch,)).start()
  print ""First twenty:"",
  for i in range(20):
    print ch.get(),
  print
 
if __name__ == ""__main__"":
  main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Base64_decode_data,Base64 decode data,"See Base64 encode data.

Now write a program that takes the output of the Base64 encode data task as input and regenerate the original file.

When working on the VBA implementation I found several 'solutions' on the net, including one from the software maker himself, that showed output with incorrect padding. Obviously with incorrect padding in the output you can not decode correctly to the original file again.
",Python,"import base64

data = ""SGVsbG8sIFdvcmxkIQ==""
decoded = base64.b64decode(data)
decoded_str = decoded.decode(""utf-8"")
print(decoded_str)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/24_game,24 game,"The 24 Game tests one's mental arithmetic.



Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.

The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression.

The goal is for the player to enter an expression that (numerically) evaluates to 24.

 Only the following operators/functions are allowed: multiplication, division, addition, subtraction
 Division should use floating point or rational arithmetic, etc, to preserve remainders.
 Brackets are allowed, if using an infix expression evaluator.
 Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
 The order of the digits when given does not have to be preserved.


Notes
 The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
 The task is not for the program to generate the expression, or test whether an expression is even possible.


Related tasks
 24 game/Solve


Reference
 The 24 Game on h2g2.

",Python,"import random
 
def op_type(x):
    if x in ['-','+']:
        return 1
    elif x in ['/','*']:
        return 2
    elif x in ['(',')']:
        return -1
    else:
        return 0
 
def to_rpn(input):
    rpn_string = ''
    rpn_stack = ''
    last_token = '#'
    for token in input:
        if token.isdigit():
            rpn_string += token
        elif op_type(token) == 0:
            continue
        elif op_type(token) > op_type(last_token) or token == '(':
            rpn_stack += token
            last_token = token
        else:
            while rpn_stack:
                top = rpn_stack[-1]
                rpn_stack = rpn_stack[:-1]
                if top == '(':
                    break
                rpn_string += top
            if token!= ')':
                rpn_stack += token
    while rpn_stack:
        top = rpn_stack[-1]
        rpn_stack = rpn_stack[:-1]
        rpn_string += top
    return rpn_string
 
def calculate(input, list):
    stack = []
    accumulator = 0.0
    for token in input:
        if token.isdigit():
            test = int(token)
            if test in list:
                list[list.index(test)] = 10
            else:
                print(""invalid digit: {}"".format(test))
            stack.append(accumulator)
            accumulator = test
        else:
            a = stack.pop()
            accumulator = {
                '-': a-accumulator,
                '+': a+accumulator,
                '/': a/accumulator,
                '*': a*accumulator,
            }.get(token, accumulator)
    return accumulator
 
if __name__ == '__main__':
    list = [random.randint(0,9) for i in range(4)]
    print(""form 24 with using + - / * {}"".format(list))
    #get user input
    input = input()
    #convert to rpn
    input = to_rpn(input)
    result = calculate(input, list)
    if 10 in list:
        print(""and you used all numbers"")
        if result == 24:
            print(""you won"")
        else:
            print(""but your formulla doesn't result in 24"")
    else:
        print(""you didn't use all the numbers"")",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Apply_a_callback_to_an_array,Apply a callback to an array,"Task

Take a combined set of elements and apply a function to each element.



",Python,"def square(n):
    return n * n
 
numbers = [1, 3, 5, 7]
 
squares1 = [square(n) for n in numbers]     # list comprehension
 
squares2a = map(square, numbers)            # functional form
 
squares2b = map(lambda x: x*x, numbers)     # functional form with `lambda`
 
squares3 = [n * n for n in numbers]         # no need for a function,
                                            # anonymous or otherwise
 
isquares1 = (n * n for n in numbers)        # iterator, lazy
 
import itertools
isquares2 = itertools.imap(square, numbers) # iterator, lazy",Human_written,Python_from_C++
http://rosettacode.org/wiki/Higher-order_functions,Higher-order functions,"Task

Pass a function     as an argument     to another function.



Related task

   First-class functions

",Python,"def func1(f):
    return f(""a string"")
def func2(s):
    return ""func2 called with "" + s
print(func1(func2))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Day_of_the_week,Day of the week,"A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).



Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?

Using any standard date handling libraries of your programming language;
compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.



",Python,"# version 1.0.6
 
from datetime import date
 
print(""Christmas day in the following years falls on a Sunday:\n"")
calendar = date(2008, 12, 25)
for year in range(2008, 2122):
    if calendar.weekday() == 6:
        print(year)
    calendar = calendar.replace(year=year + 1)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Modular_exponentiation,Modular exponentiation,"Find the last   40   decimal digits of   




a

b




{\displaystyle a^{b}}

,   where

   



a
=
2988348162058574136915891421498819466320163312926952423791023078876139


{\displaystyle a=2988348162058574136915891421498819466320163312926952423791023078876139}


   



b
=
2351399303373464486466122544523690094744975233415544072992656881240319


{\displaystyle b=2351399303373464486466122544523690094744975233415544072992656881240319}




A computer is too slow to find the entire value of   




a

b




{\displaystyle a^{b}}

.

Instead, the program must use a fast algorithm for modular exponentiation:   




a

b



mod


m


{\displaystyle a^{b}\mod m}

.

The algorithm must work for any integers   



a
,
b
,
m


{\displaystyle a,b,m}

,     where   



b
≥
0


{\displaystyle b\geq 0}

   and   



m
>
0


{\displaystyle m>0}

.



",Python,"a = 2988348162058574136915891421498819466320163312926952423791023078876139
b = 2351399303373464486466122544523690094744975233415544072992656881240319
m = 10 ** 40
print(pow(a, b, m))",Human_written,Python_from_Rust
http://rosettacode.org/wiki/Summarize_primes,Summarize primes,"Task

Considering in order of length, n, all sequences of consecutive
primes, p, from 2 onwards, where p < 1000 and n>0, select those
sequences whose sum is prime, and for these display the length of the
sequence, the last item in the sequence, and the sum.



",Python,"'''Prime sums of primes up to 1000'''
 
 
from itertools import accumulate, chain, takewhile
 
 
# primeSums :: [(Int, (Int, Int))]
def primeSums():
    '''Non finite stream of enumerated tuples,
       in which the first value is a prime,
       and the second the sum of that prime and all
       preceding primes.
    '''
    return (
        x for x in enumerate(
            accumulate(
                chain([(0, 0)], primes()),
                lambda a, p: (p, p + a[1])
            )
        ) if isPrime(x[1][1])
    )
 
 
# ------------------------- TEST -------------------------
# main :: IO ()
def main():
    '''Prime sums of primes below 1000'''
    for x in takewhile(
            lambda t: 1000 > t[1][0],
            primeSums()
    ):
        print(f'{x[0]} -> {x[1][1]}')
 
 
# ----------------------- GENERIC ------------------------
 
# isPrime :: Int -> Bool
def isPrime(n):
    '''True if n is prime.'''
    if n in (2, 3):
        return True
    if 2 > n or 0 == n % 2:
        return False
    if 9 > n:
        return True
    if 0 == n % 3:
        return False
 
    def p(x):
        return 0 == n % x or 0 == n % (2 + x)
 
    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))
 
 
# primes :: [Int]
def primes():
    ''' Non finite sequence of prime numbers.
    '''
    n = 2
    dct = {}
    while True:
        if n in dct:
            for p in dct[n]:
                dct.setdefault(n + p, []).append(p)
            del dct[n]
        else:
            yield n
            dct[n * n] = [n]
        n = 1 + n
 
 
# MAIN ---
if __name__ == '__main__':
    main()",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/Terminal_control/Coloured_text,Terminal control/Coloured text,"Task

Display a word in various colours on the terminal.

The system palette, or colours such as Red, Green, Blue, Magenta, Cyan, and Yellow can be used.



Optionally demonstrate:

 How the system should determine if the terminal supports colour
 Setting of the background colour
 How to cause blinking or flashing (if supported by the terminal)

",Python,"from colorama import init, Fore, Back, Style
init(autoreset=True)
 
print Fore.RED + ""FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic""
print Back.BLUE + Fore.YELLOW + ""What a cute console!""
print ""This is an %simportant%s word"" % (Style.BRIGHT, Style.NORMAL)
print Fore.YELLOW  + ""Rosetta Code!""
print Fore.CYAN    + ""Rosetta Code!""
print Fore.GREEN   + ""Rosetta Code!""
print Fore.MAGENTA + ""Rosetta Code!""
print Back.YELLOW + Fore.BLUE + Style.BRIGHT + "" "" * 40 + "" == Good Bye!""",Human_written,Python_from_C
http://rosettacode.org/wiki/Make_directory_path,Make directory path,"Task

Create a directory and any missing parents.

This task is named after the posix mkdir -p command, and several libraries which implement the same behavior.

Please implement a function of a single path string (for example ./path/to/dir) which has the above side-effect.
If the directory already exists, return successfully.
Ideally implementations will work equally well cross-platform (on windows, linux, and OS X).

It's likely that your language implements such a function as part of its standard library. If so, please also show how such a function would be implemented.



",Python,"# version 1.0.6
 
import os
 
def main(args):
    # using built-in delete() method
    success = os.remove(""./path/to/file.txt"")
    if success:
        print(""File was deleted successfully"")
    else:
        print(""Failed to delete file"")
 
if __name__ == ""__main__"":
    main(sys.argv)",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Sleep,Sleep,"Task

Write a program that does the following in this order:

 Input an amount of time to sleep in whatever units are most natural for your language (milliseconds, seconds, ticks, etc.). This unit should be noted in comments or in a description.
 Print ""Sleeping...""
 Sleep the main thread for the given amount of time.
 Print ""Awake!""
 End.


Related task

   Nautical bell

",Python,"import java.util.InputMismatchException;
import java.util.Scanner;

public class Sleep {
    public static void main(final String[] args) throws InterruptedException {
        try {
            int ms = new Scanner(System.in).nextInt(); //Java's sleep method accepts milliseconds
            System.out.println(""Sleeping..."");
            Thread.sleep(ms);
            System.out.println(""Awake!"");
        } catch (InputMismatchException inputMismatchException) {
            System.err.println(""Exception: "" + inputMismatchException);
        }
    }
}",Ai_generated,Python_from_Java
http://rosettacode.org/wiki/Averages/Mean_angle,Averages/Mean angle,"When calculating the average or mean of an angle one has to take into account how angles wrap around so that any angle in degrees plus any integer multiple of 360 degrees is a measure of the same angle.

If one wanted an average direction of the wind over two readings where the first reading was of 350 degrees and the second was of 10 degrees then the average of the numbers is 180 degrees, whereas if you can note that 350 degrees is equivalent to -10 degrees and so you have two readings at 10 degrees either side of zero degrees leading to a more fitting mean angle of zero degrees.

To calculate the mean angle of several angles:

 Assume all angles are on the unit circle and convert them to complex numbers expressed in real and imaginary form.
 Compute the mean of the complex numbers.
 Convert the complex mean to polar coordinates whereupon the phase of the complex mean is the required angular mean.


(Note that, since the mean is the sum divided by the number of numbers, and division by a positive real number does not affect the angle, you can also simply compute the sum for step 2.)

You can alternatively use this formula:

 Given the angles 




α

1


,
…
,

α

n




{\displaystyle \alpha _{1},\dots ,\alpha _{n}}

 the mean is computed by







α
¯



=
atan2
⁡

(


1
n


⋅

∑

j
=
1


n


sin
⁡

α

j


,


1
n


⋅

∑

j
=
1


n


cos
⁡

α

j


)



{\displaystyle {\bar {\alpha }}=\operatorname {atan2} \left({\frac {1}{n}}\cdot \sum _{j=1}^{n}\sin \alpha _{j},{\frac {1}{n}}\cdot \sum _{j=1}^{n}\cos \alpha _{j}\right)}


Task[edit]
 write a function/method/subroutine/... that given a list of angles in degrees returns their mean angle. 
 (You should use a built-in function if you have one that does this for degrees or radians). 
 Use the function to compute the means of these lists of angles (in degrees):
   [350, 10] 
   [90, 180, 270, 360] 
   [10, 20, 30]
 Show your output here.
See also
Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation





",Python,">>> from cmath import rect, phase
>>> from math import radians, degrees
>>> def mean_angle(deg):
...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))
... 
>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:
...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')
...     
The mean angle of [350, 10] is: -0.0 degrees
The mean angle of [90, 180, 270, 360] is: -90.0 degrees
The mean angle of [10, 20, 30] is: 20.0 degrees
>>>",Human_written,Python_from_Go
http://rosettacode.org/wiki/Determine_if_a_string_is_numeric,Determine if a string is numeric,"Task

Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet



",Python,"def is_numeric(s):
    try:
        float(s)
        return True
    except (ValueError, TypeError):
        return False
 
is_numeric('123.0')",Human_written,Python_from_C++
http://rosettacode.org/wiki/Fork,Fork,"Task

Spawn a new process which can run simultaneously with, and independently of, the original parent process.



",Python,"import os
 
def main():
    pid = os.fork()
    if pid == 0:
        print(""This is the new process(pid: {})."".format(os.getpid()))
    else:
        print(""This is the original process(pid: {}). New child has pid: {}"".format(os.getpid(), pid))
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Amb,Amb,"Define and give an example of the Amb operator.

The Amb operator (short for ""ambiguous"") expresses nondeterminism. This doesn't refer to randomness (as in ""nondeterministic universe"") but is closely related to the term as it is used in automata theory (""non-deterministic finite automaton"").

The Amb operator takes a variable number of expressions (or values if that's simpler in the language) and yields a correct one which will satisfy a constraint in some future computation, thereby avoiding failure.

Problems whose solution the Amb operator naturally expresses can be approached with other tools, such as explicit nested iterations over data sets, or with pattern matching. By contrast, the Amb operator appears integrated into the language. Invocations of Amb are not wrapped in any visible loops or other search patterns; they appear to be independent.

Essentially Amb(x, y, z) splits the computation into three possible futures: a future in which the value x is yielded, a future in which the value y is yielded and a future in which the value z is yielded. The future which leads to a successful subsequent computation is chosen. The other ""parallel universes"" somehow go away. Amb called with no arguments fails.

For simplicity, one of the domain values usable with Amb may denote failure, if that is convenient. For instance, it is convenient if a Boolean false denotes failure, so that Amb(false) fails, and thus constraints can be expressed using Boolean expressions like Amb(x * y == 8) which unless x and y add to four.

A pseudo-code program which satisfies this constraint might look like:

let x = Amb(1, 2, 3)
let y = Amb(7, 6, 4, 5)
Amb(x * y = 8)
print x, y
The output is 2 4 because Amb(1, 2, 3) correctly chooses the future in which x has value 2, Amb(7, 6, 4, 5) chooses 4 and consequently Amb(x * y = 8) produces a success.

Alternatively, failure could be represented using strictly Amb():

unless x * y = 8 do Amb()
Or else Amb could take the form of two operators or functions: one for producing values and one for enforcing constraints:

let x = Ambsel(1, 2, 3)
let y = Ambsel(4, 5, 6)
Ambassert(x * y = 8)
print x, y
where Ambassert behaves like Amb() if the Boolean expression is false, otherwise it allows the future computation to take place, without yielding any value.

The task is to somehow implement Amb, and demonstrate it with a program which chooses one word from each of the following four sets of character strings to generate a four-word sentence:

""the"" ""that"" ""a""
""frog"" ""elephant"" ""thing""
""walked"" ""treaded"" ""grows""
""slowly"" ""quickly""
The constraint to be satisfied is that the last character of each word (other than the last) is the same as the first character of its successor.

The only successful sentence is ""that thing grows slowly""; other combinations do not satisfy the constraint and thus fail.

The goal of this task isn't to simply process the four lists of words with explicit, deterministic program flow such as nested iteration, to trivially demonstrate the correct output. The goal is to implement the Amb operator, or a facsimile thereof that is possible within the language limitations.
",Python,"# version 1.2.41
import sys
import types
import copy
 
def main(args):
    amb(lambda: amb_main())
 
def amb_main():
    a = amb(""the"", ""that"", ""a"")
    b = amb(""frog"", ""elephant"", ""thing"")
    c = amb(""walked"", ""treaded"", ""grows"")
    d = amb(""slowly"", ""quickly"")
 
    if a[len(a) - 1]!= b[0]:
        amb()
    if b[len(b) - 1]!= c[0]:
        amb()
    if c[len(c) - 1]!= d[0]:
        amb()
 
    print([a, b, c, d])
 
    x = amb(1, 2, 3)
    y = amb(7, 6, 4, 5)
    if x * y!= 8:
        amb()
    print([x, y])
 
class AmbException(Exception):
    pass
 
class AmbPair(object):
    def __init__(self, cont, valuesLeft):
        self.cont = cont
        self.valuesLeft = valuesLeft
 
class AmbEnvironment(object):
    def __init__(self):
        self.ambList = []
 
    def amb(self, value, *rest):
        if len(rest) > 0:
            self.ambList.append(AmbPair(clone(self), list(rest)))
        return value
 
    def amb(self):
        raise AmbException()
 
def amb(block):
    result = None
    toThrow = None
 
    dist = AmbEnvironment()
    block(dist)
 
    while result is None and toThrow is None and len(dist.ambList) > 0:
        last = dist.ambList[len(dist.ambList) - 1]
 
        if len(last.valuesLeft) == 1:
            dist.ambList.pop()
            last.cont(last.valuesLeft[0])
        else:
            value = last.valuesLeft.pop()
            clone(last.cont)(value)
 
    if toThrow is not None:
        raise toThrow
    elif result is not None:
        return result
    else:
        raise AmbException()
 
def clone(obj):
    copy = copy.copy(obj)
    copy_declared_fields(obj, copy, type(obj))
    return copy
 
def copy_declared_fields(obj, copy, clazz):
    for field in clazz.__dict__:
        v = getattr(obj, field)
        setattr(copy, field, v if v is obj else v)
    if clazz.__bases__:
        copy_declared_fields(obj, copy, clazz.__bases__[0])",Ai_generated,Python_from_Kotlin
http://rosettacode.org/wiki/Tree_datastructures,Tree datastructures,"The following shows a tree of data with nesting denoted by visual levels of indentation:

RosettaCode
    rocks
        code
        comparison
        wiki
    mocks
        trolling
A common datastructure for trees is to define node structures having a name and a, (possibly empty), list of child nodes. The nesting of nodes captures the indentation of the tree. Lets call this the nest form.

# E.g. if child nodes are surrounded by brackets
#      and separated by commas then:
RosettaCode(rocks(code, ...), ...)
# But only an _example_
Another datastructure for trees is to construct from the root an ordered list of the nodes level of indentation and the name of that node. The indentation for the root node is zero; node 'rocks is indented by one level from the left, and so on. Lets call this the indent form.

0 RosettaCode
1 rocks
2 code
...
Task

 Create/use a nest datastructure format and textual representation for arbitrary trees.
 Create/use an indent datastructure format and textual representation for arbitrary trees.
 Create methods/classes/proceedures/routines etc to:
 Change from a nest tree datastructure to an indent one.
 Change from an indent tree datastructure to a nest one
 Use the above to encode the example at the start into the nest format, and show it.
 transform the initial nest format to indent format and show it.
 transform the indent format to final nest format and show it.
 Compare initial and final nest formats which should be the same.
Note

 It's all about showing aspects of the contrasting datastructures as they hold the tree.
 Comparing nested datastructures is secondary - saving formatted output as a string then a string compare would suffice for this task, if its easier.


Show all output on this page.
",Python,"from __future__ import print_function
import sys
 
class NNode(object):
    def __init__(self, name, children):
        self.name = name
        self.children = children
 
class INode(object):
    def __init__(self, level, name):
        self.level = level
        self.name = name
 
def print_nest(n, level, w):
    if level == 0:
        print(""\n==Nest form==\n"", file=w)
    print(""  "" * level + n.name, file=w)
    for c in n.children:
        print(""  "" * (level + 1), end="""", file=w)
        print_nest(c, level + 1, w)
 
def to_nest(i_nodes, start, level, n):
    if level == 0:
        n.name = i_nodes[0].name
    for i in range(start + 1, len(i_nodes)):
        if i_nodes[i].level == level + 1:
            c = NNode(i_nodes[i].name, [])
            to_nest(i_nodes, i, level + 1, c)
            n.children.append(c)
        elif i_nodes[i].level <= level:
            return
 
def print_indent(i_nodes, w):
    print(""\n==Indent form==\n"", file=w)
    for n in i_nodes:
        print(n.level, n.name, file=w)
 
def to_indent(n, level, i_nodes):
    i_nodes.append(INode(level, n.name))
    for c in n.children:
        to_indent(c, level + 1, i_nodes)
 
def main():
    n1 = NNode(""RosettaCode"", [])
    n2 = NNode(""rocks"", [NNode(""code"", []), NNode(""comparison"", []), NNode(""wiki"", [])])
    n3 = NNode(""mocks"", [NNode(""trolling"", [])])
    n1.children = [n2, n3]
 
    sb = []
    print_nest(n1, 0, sb)
    s1 = """".join(sb)
    print(s1)
 
    i_nodes = []
    to_indent(n1, 0, i_nodes)
    print_indent(i_nodes, sys.stdout)
 
    n = NNode("""", [])
    to_nest(i_nodes, 0, 0, n)
    sb = []
    print_nest(n, 0, sb)
    s2 = """".join(sb)
    print(s2)
 
    print(""\nRound trip test satisfied? "", s1 == s2)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Time_a_function,Time a function,"Task

Write a program which uses a timer (with the least granularity available
on your system) to time how long a function takes to execute.

Whenever possible, use methods which measure only the processing time used
by the current process; instead of the difference in system time
between start and finish, which could include time used by
other processes on the computer.

This task is intended as a subtask for Measure relative performance of sorting algorithms implementations.



",Python,"import sys, timeit
def usec(function, arguments):
    modname, funcname = __name__, function.__name__
    timer = timeit.Timer(stmt='%(funcname)s(*args)' % vars(),
                         setup='from %(modname)s import %(funcname)s; args=%(arguments)r' % vars())
    try:
        t, N = 0, 1
        while t < 0.2:            
            t = min(timer.repeat(repeat=3, number=N))            
            N *= 10
        microseconds = round(10000000 * t / N, 1) # per loop
        return microseconds 
    except:
        timer.print_exc(file=sys.stderr)
        raise
 
from math import pow
def nothing(): pass
def identity(x): return x",Human_written,Python_from_JavaScript
http://rosettacode.org/wiki/Leap_year,Leap year,"Task

Determine whether a given year is a leap year in the Gregorian calendar.



See also

 Leap year (wiki)

",Python,"import calendar
calendar.isleap(year)",Human_written,Python_from_Ruby
http://rosettacode.org/wiki/CSV_to_HTML_translation,CSV to HTML translation,"Consider a simplified CSV format where all rows are separated by a newline
and all columns are separated by commas.

No commas are allowed as field data, but the data may contain
other characters and character sequences that would
normally be   escaped   when converted to HTML



Task

Create a function that takes a string representation of the CSV data
and returns a text string of an HTML table representing the CSV data.

Use the following data as the CSV text to convert, and show your output.

 Character,Speech
 The multitude,The messiah! Show us the messiah!
 Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
 The multitude,Who are you?
 Brians mother,I'm his mother; that's who!
 The multitude,Behold his mother! Behold his mother!


Extra credit

Optionally allow special formatting for the first row of the table as if it is the tables header row
(via <thead> preferably; CSS if you must).



",Python,"csvtxt = '''\
Character,Speech
The multitude,The messiah! Show us the messiah!
Brians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>
The multitude,Who are you?
Brians mother,I'm his mother; that's who!
The multitude,Behold his mother! Behold his mother!\
'''
 
from cgi import escape
 
def _row2tr(row, attr=None):
    cols = escape(row).split(',')
    return ('<TR>'
            + ''.join('<TD>%s</TD>' % data for data in cols)
            + '</TR>')
 
def csv2html(txt):
    htmltxt = '<TABLE summary=""csv2html program output"">\n'
    for rownum, row in enumerate(txt.split('\n')):
        htmlrow = _row2tr(row)
        htmlrow = '  <TBODY>%s</TBODY>\n' % htmlrow
        htmltxt += htmlrow
    htmltxt += '</TABLE>\n'
    return htmltxt
 
htmltxt = csv2html(csvtxt)
print(htmltxt)",Human_written,Python_from_Rust
http://rosettacode.org/wiki/The_sieve_of_Sundaram,The sieve of Sundaram,"The sieve of Eratosthenes: you've been there; done that; have the T-shirt. The sieve of Eratosthenes was ancient history when Euclid was a schoolboy. You are ready for something less than 3000 years old. You are ready for The sieve of Sundaram.

Starting with the ordered set of +ve integers, mark every third starting at 4 (4;7;10...).

Step through the set and if the value is not marked output 2*n+1. So from 1 to 4 output 3 5 7.

4 is marked so skip for 5 and 6 output 11 and 13.

7 is marked, so no output but now also mark every fifth starting at 12 (12;17;22...)

as per to 10 and now mark every seventh starting at 17 (17;24;31....)

as per for every further third element (13;16;19...) mark every (9th;11th;13th;...) element.

The output will be the ordered set of odd primes.

Using your function find and output the first 100 and the millionth Sundaram prime.

The faithless amongst you may compare the results with those generated by The sieve of Eratosthenes.

References

 The article on Wikipedia.

",Python,"import time
from itertools import count
 
def sundaram(n):
    comps = [False] * (n // 2 + 1)
    for i in range(1, n // 2):
        for j in range(i, n // 2):
            t = i + j + 2 * i * j
            if t >= n // 2:
                break
            comps[t] = True
    for i in range(1, n // 2):
        if not comps[i]:
            yield 2 * i + 1
 
def fmt(a):
    return''.join(f'{x:5}' if i % 10!= 9 else f'{x:5}\n' for i, x in enumerate(a))
 
def main():
    start = time.time()
    pr = list(sundaram(15_500_000))[:1_000_000]
    end = time.time()
    print(f'The first 100 odd prime numbers:\n{fmt(pr[:100])}\n')
    print(f'The millionth odd prime number: {pr[-1]}')
    print(f'{(end - start) * 1000:.0f} ms')
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/Find_Chess960_starting_position_identifier,Find Chess960 starting position identifier,"As described on the Chess960 page, Chess960 (a.k.a Fischer Random Chess, Chess9LX) is a variant of chess where the array of pieces behind the pawns is randomized at the start of the game to minimize the value of opening theory ""book knowledge"". That task is to generate legal starting positions, and some of the solutions accept a standard Starting Position Identifier number (""SP-ID""), and generate the corresponding position.

Task

This task is to go the other way: given a starting array of pieces (provided in any form that suits your implementation, whether string or list or array, of letters or Unicode chess symbols or enum values, etc.), derive its unique SP-ID. For example, given the starting array QNRBBNKR (or ♕♘♖♗♗♘♔♖ or ♛♞♜♝♝♞♚♜), your (sub)program should return 105; given the starting lineup of standard chess, it should return 518.

You may assume the input is a valid Chess960 position; detecting invalid input (including illegal characters or starting arrays with the bishops on the same color square or the king not between the two rooks) is optional.

Algorithm

The derivation is the inverse of the algorithm given at Wikipedia, and goes like this (we'll use the standard chess setup as an example):

1. Ignoring the Queen and Bishops, find the positions of the Knights within the remaining five spaces (in the standard array they're in the second and fourth positions), and then find the index number of that combination. There's a table at the above Wikipedia article, but it's just the possible positions sorted left to right and numbered 0 to 9: 0=NN---, 1=N-N--, 2=N--N-, 3=N---N, 4=-NN--, etc; our pair is combination number 5. Call this number N. N=5

2. Now ignoring the Knights (but including the Queen and Bishops), find the position of the Queen in the remaining 6 spaces; number them 0..5 from left to right and call the index of the Queen's position Q. In our example, Q=2.

3. Finally, find the positions of the two bishops within their respective sets of four like-colored squares. It's important to note here that the board in chess is placed such that the leftmost position on the home row is on a dark square and the rightmost a light. So if we number the squares of each color 0..3 from left to right, the dark bishop in the standard position is on square 1 (D=1), and the light bishop is on square 2 (L=2).

4. Then the position number is given by 4(4(6N + Q)+D)+L, which reduces to 96N + 16Q + 4D + L. In our example, that's 96×5 + 16×2 + 4×1 + 2 = 480 + 32 + 4 + 2 = 518.
",Python,"import sys
import re
import logging
 
logging.basicConfig(level=logging.INFO)
 
glyphs = ""♜♞♝♛♚♖♘♗♕♔""
names = {'R': ""rook"", 'N': ""knight"", 'B': ""bishop"", 'Q': ""queen"", 'K': ""king""}
g2lMap = {
    '♜': ""R"", '♞': ""N"", '♝': ""B"", '♛': ""Q"", '♚': ""K"",
    '♖': ""R"", '♘': ""N"", '♗': ""B"", '♕': ""Q"", '♔': ""K"",
}
ntable = {""01"": 0, ""02"": 1, ""03"": 2, ""04"": 3, ""12"": 4, ""13"": 5, ""14"": 6, ""23"": 7, ""24"": 8, ""34"": 9}
 
def g2l(pieces):
    lets = """"
    for p in pieces:
        lets += g2lMap[p]
    return lets
 
def spid(pieces):
    pieces = g2l(pieces) # convert glyphs to letters
 
    # check for errors
    if len(pieces)!= 8:
        logging.error(""There must be exactly 8 pieces."")
        sys.exit(1)
    for one in ""KQ"":
        count = 0
        for p in pieces:
            if p == one:
                count += 1
        if count!= 1:
            logging.error(""There must be one %s."", names[one])
            sys.exit(1)
    for two in ""RNB"":
        count = 0
        for p in pieces:
            if p == two:
                count += 1
        if count!= 2:
            logging.error(""There must be two %s."", names[two])
            sys.exit(1)
    r1 = pieces.index(""R"")
    r2 = pieces[r1+1:].index(""R"") + r1 + 1
    k = pieces.index(""K"")
    if k < r1 or k > r2:
        logging.error(""The king must be between the rooks."")
        sys.exit(1)
    b1 = pieces.index(""B"")
    b2 = pieces[b1+1:].index(""B"") + b1 + 1
    if (b2-b1)%2 == 0:
        logging.error(""The bishops must be on opposite color squares."")
        sys.exit(1)
 
    # compute SP_ID
    piecesN = pieces.replace(""Q"", """")
    piecesN = piecesN.replace(""B"", """")
    n1 = piecesN.index(""N"")
    n2 = piecesN[n1+1:].index(""N"") + n1 + 1
    np = f""{n1}{n2}""
    N = ntable[np]
 
    piecesQ = pieces.replace(""N"", """")
    Q = piecesQ.index(""Q"")
 
    D = ""0246"".find(str(b1))
    L = ""1357"".find(str(b2))
    if D == -1:
        D = ""0246"".find(str(b2))
        L = ""1357"".find(str(b1))
 
    return 96*N + 16*Q + 4*D + L
 
if __name__ == ""__main__"":
    for pieces in [""♕♘♖♗♗♘♔♖"", ""♖♘♗♕♔♗♘♖""]:
        print(f""{pieces} or {g2l(pieces)} has SP-ID of {spid(pieces)}"")",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Flatten_a_list,Flatten a list,"Task

Write a function to flatten the nesting in an arbitrary list of values.

Your program should work on the equivalent of this list:

  [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]

Where the correct result would be the list:

   [1, 2, 3, 4, 5, 6, 7, 8]

Related task

   Tree traversal

",Python,"def list(*args):
    return list(args)
 
def flatten(s):
    r = []
    for e in s:
        if isinstance(e, int):
            r.append(e)
        elif isinstance(e, list):
            r.extend(flatten(e))
    return r
 
s = list(list(1),
        2,
        list(list(3, 4), 5),
        list(list(list())),
        list(list(list(6))),
        7,
        8,
        list(),
    )
print(s)
print(flatten(s))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Remove_duplicate_elements,Remove duplicate elements,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Given an Array, derive a sequence of elements in which all duplicates are removed.

There are basically three approaches seen here:

 Put the elements into a hash table which does not allow duplicates. The complexity is O(n) on average, and O(n2) worst case. This approach requires a hash function for your type (which is compatible with equality), either built-in to your language, or provided by the user.
 Sort the elements and remove consecutive duplicate elements. The complexity of the best sorting algorithms is O(n log n). This approach requires that your type be ""comparable"", i.e., have an ordering. Putting the elements into a self-balancing binary search tree is a special case of sorting.
 Go through the list, and for each element, check the rest of the list to see if it appears again, and discard it if it does. The complexity is O(n2). The up-shot is that this always works on any type (provided that you can test for equality).

",Python,"from typing import List, TypeVar
from collections import OrderedDict
 
T = TypeVar('T')
 
def remove_duplicate_elements_hashing(elements: List[T]) -> List[T]:
    return list(OrderedDict.fromkeys(elements))
 
def remove_duplicate_elements_sorting(elements: List[T]) -> List[T]:
    return list(OrderedDict.fromkeys(sorted(elements)))
 
if __name__ == '__main__':
    sample_elements = [0, 0, 1, 1, 2, 3, 2]
    print(f'Before removal of duplicates : {sample_elements}')
    sample_elements = remove_duplicate_elements_sorting(sample_elements)
    print(f'After removal of duplicates : {sample_elements}')",Ai_generated,Python_from_Rust
http://rosettacode.org/wiki/Law_of_cosines_-_triples,Law of cosines - triples,"The Law of cosines states that for an angle γ, (gamma) of any triangle, if the sides adjacent to the angle are A and B and the side opposite is C; then the lengths of the sides are related by this formula:

           A2 + B2 - 2ABcos(γ) = C2 

Specific angles

For an angle of of   90º   this becomes the more familiar ""Pythagoras equation"":

           A2 + B2  =  C2           

For an angle of   60º   this becomes the less familiar equation:

           A2 + B2 - AB  =  C2       

And finally for an angle of   120º   this becomes the equation:

           A2 + B2 + AB  =  C2      



Task

   Find all integer solutions (in order) to the three specific cases, distinguishing between each angle being considered.
   Restrain all sides to the integers   1..13   inclusive.
   Show how many results there are for each of the three angles mentioned above.
   Display results on this page.


Note: Triangles with the same length sides but different order are to be treated as the same.

Optional Extra credit

 How many 60° integer triples are there for sides in the range 1..10_000 where the sides are not all of the same length.


Related Task
 Pythagorean triples


See also

 Visualising Pythagoras: ultimate proofs and crazy contortions Mathlogger Video

",Python,"N = 13
 
def method1(N=N):
    squares = [x**2 for x in range(0, N+1)]
    sqrset = set(squares)
    tri90, tri60, tri120 = (set() for _ in range(3))
    for a in range(1, N+1):
        a2 = squares[a]
        for b in range(1, a + 1):
            b2 = squares[b]
            c2 = a2 + b2
            if c2 in sqrset:
                tri90.add(tuple(sorted((a, b, int(c2**0.5)))))
            ab = a * b
            c2 -= ab
            if c2 in sqrset:
                tri60.add(tuple(sorted((a, b, int(c2**0.5)))))
            c2 += 2 * ab
            if c2 in sqrset:
                tri120.add(tuple(sorted((a, b, int(c2**0.5)))))
    return  sorted(tri90), sorted(tri60), sorted(tri120)
#%%
if __name__ == '__main__':
    print(f'Integer triangular triples for sides 1..{N}:')
    for angle, triples in zip([90, 60, 120], method1(N)):
        print(f'  {angle:3}° has {len(triples)} solutions:\n    {triples}')
    _, t60, _ = method1(10_000)
    notsame = sum(1 for a, b, c in t60 if a != b or b != c)
    print('Extra credit:', notsame)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Simple_database,Simple database,"Task

Write a simple tool to track a small set of data.

The tool should have a command-line interface to enter at least two different values.

The entered data should be stored in a structured format and saved to disk.

It does not matter what kind of data is being tracked.   It could be a collection (CDs, coins, baseball cards, books), a diary, an electronic organizer (birthdays/anniversaries/phone numbers/addresses), etc.



You should track the following details:

 A description of the item. (e.g., title, name)
 A category or tag (genre, topic, relationship such as “friend” or “family”)
 A date (either the date when the entry was made or some other date that is meaningful, like the birthday); the date may be generated or entered manually
 Other optional fields


The command should support the following Command-line arguments to run:

 Add a new entry
 Print the latest entry
 Print the latest entry for each category
 Print all entries sorted by a date


The category may be realized as a tag or as structure (by making all entries in that category subitems)

The file format on disk should be human readable, but it need not be standardized.   A natively available format that doesn't need an external library is preferred.   Avoid developing your own format if you can use an already existing one.   If there is no existing format available, pick one of:

   JSON
   S-Expressions
   YAML
   others


Related task

   Take notes on the command line 

",Python,"# -*- coding: utf-8 -*-
""""""
Created on Wed Oct 14 10:42:00 2020

@author: 
""""""

#importing the libraries
import pandas as pd
import numpy as np

#importing the dataset
dataset = pd.read_csv('books.csv')

#creating the matrix of features
X = dataset.iloc[:, :-1].values

#creating the dependent variable vector
y = dataset.iloc[:, -1].values

#encoding categorical data
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
X[:, 0] = le.fit_transform(X[:, 0])
X[:, 1] = le.fit_transform(X[:, 1])
X[:, 2] = le.fit_transform(X[:, 2])

#splitting the dataset into the training set and test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

#feature scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

#training the multiple linear regression model on the training set
from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train, y_train)

#predicting the test set results
y_pred = regressor.predict(X_test)
np.set_printoptions(precision=2)
print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))

#building the optimal model using backward elimination
import statsmodels.api as sm
X = np.append(arr = np.ones((10, 1)).astype(int), values = X, axis = 1)
X_opt = X[:, [0, 1, 2, 3, 4, 5]]
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()
X_opt = X[:, [0, 1, 2, 3, 5]]
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()
X_opt = X[:, [0, 1, 2, 5]]
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()
X_opt = X[:, [0, 1, 5]]
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()
X_opt = X[:, [0, 1]]
regressor_OLS = sm.OLS(endog = y, exog = X_opt).fit()
regressor_OLS.summary()

#training the multiple linear regression model on the training set
from sklearn.linear_model import LinearRegression
regressor = LinearRegression()
regressor.fit(X_train[:, [0, 1]], y_train)

#predicting the test set results
y_pred = regressor.predict(X_test[:, [0, 1]])
np.set_printoptions(precision=2)
print(np.concatenate((y_pred.reshape(len(y_pred),1), y_test.reshape(len(y_test),1)),1))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem,Dinesman's multiple-dwelling problem,"Task
Solve Dinesman's multiple dwelling problem but in a way that most naturally follows the problem statement given below.

Solutions are allowed (but not required) to parse and interpret the problem text, but should remain flexible and should state what changes to the problem text are allowed. Flexibility and ease of expression are valued.

Examples may be be split into ""setup"", ""problem statement"", and ""output"" sections where the ease and naturalness of stating the problem and getting an answer, as well as the ease and flexibility of modifying the problem are the primary concerns.

Example output should be shown here, as well as any comments on the examples flexibility.



The problem
Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that contains only five floors.


   Baker does not live on the top floor.
   Cooper does not live on the bottom floor. 
   Fletcher does not live on either the top or the bottom floor.
   Miller lives on a higher floor than does Cooper.
   Smith does not live on a floor adjacent to Fletcher's. 
   Fletcher does not live on a floor adjacent to Cooper's.

Where does everyone live?
",Python,"import re
from itertools import product
 
problem_re = re.compile(r""""""(?msx)(?:
 
# Multiple names of form n1, n2, n3, ... , and nK
(?P<namelist> [a-zA-Z]+ (?: , \s+ [a-zA-Z]+)* (?: ,? \s+ and) \s+ [a-zA-Z]+ )
 
# Flexible floor count (2 to 10 floors)
| (?:  .* house \s+ that \s+ contains \s+ only \s+
  (?P<floorcount> two|three|four|five|six|seven|eight|nine|ten ) \s+ floors \s* \.)
 
# Constraint: ""does not live on the n'th floor"" 
|(?: (?P<not_live>  \b [a-zA-Z]+ \s+ does \s+ not \s+ live \s+ on \s+ the \s+
  (?: top|bottom|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth) \s+ floor \s* \. ))
 
# Constraint: ""does not live on either the I'th or the J'th [ or the K'th ...] floor
|(?P<not_either> \b [a-zA-Z]+ \s+ does \s+ not \s+ live \s+ on \s+ either
  (?: \s+ (?: or \s+)? the \s+       
    (?: top|bottom|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth))+ \s+ floor \s* \. )
 
# Constraint: ""P1 lives on a higher/lower floor than P2 does""
|(?P<hi_lower> \b  [a-zA-Z]+ \s+ lives \s+ on \s+ a \s (?: higher|lower)
   \s+ floor \s+ than (?: \s+ does)  \s+  [a-zA-Z]+ \s* \. )
 
# Constraint: ""P1 does/does not live on a floor adjacent to P2's""
|(?P<adjacency>  \b [a-zA-Z]+ \s+ does (?:\s+ not)? \s+ live \s+ on \s+ a \s+
   floor \s+ adjacent \s+ to \s+  [a-zA-Z]+ (?: 's )? \s* \. )
 
# Ask for the solution
|(?P<question> Where \s+ does \s+ everyone \s+ live \s* \?)
 
)
"""""")
 
names, lennames = None, None
floors = None
constraint_expr = 'len(set(alloc)) == lennames' # Start with all people on different floors
 
def do_namelist(txt):
    "" E.g. 'Baker, Cooper, Fletcher, Miller, and Smith'""
    global names, lennames
    names = txt.replace(' and ', ' ').split(', ')
    lennames = len(names)
 
def do_floorcount(txt):
    "" E.g. 'five'""
    global floors
    floors = '||two|three|four|five|six|seven|eight|nine|ten'.split('|').index(txt)
 
def do_not_live(txt):
    "" E.g. 'Baker does not live on the top floor.'""
    global constraint_expr
    t = txt.strip().split()
    who, floor = t[0], t[-2]
    w, f = (names.index(who),
            ('|first|second|third|fourth|fifth|sixth|' +
             'seventh|eighth|ninth|tenth|top|bottom|').split('|').index(floor)
            )
    if f == 11: f = floors
    if f == 12: f = 1
    constraint_expr += ' and alloc[%i] != %i' % (w, f)
 
def do_not_either(txt):
    "" E.g. 'Fletcher does not live on either the top or the bottom floor.'""
    global constraint_expr
    t = txt.replace(' or ', ' ').replace(' the ', ' ').strip().split()
    who, floor = t[0], t[6:-1]
    w, fl = (names.index(who),
             [('|first|second|third|fourth|fifth|sixth|' +
               'seventh|eighth|ninth|tenth|top|bottom|').split('|').index(f)
              for f in floor]
             )
    for f in fl:
        if f == 11: f = floors
        if f == 12: f = 1
        constraint_expr += ' and alloc[%i] != %i' % (w, f)
 
 
def do_hi_lower(txt):
    "" E.g. 'Miller lives on a higher floor than does Cooper.'""
    global constraint_expr
    t = txt.replace('.', '').strip().split()
    name_indices = [names.index(who) for who in (t[0], t[-1])]
    if 'lower' in t:
        name_indices = name_indices[::-1]
    constraint_expr += ' and alloc[%i] > alloc[%i]' % tuple(name_indices)
 
def do_adjacency(txt):
    ''' E.g. ""Smith does not live on a floor adjacent to Fletcher's.""'''
    global constraint_expr
    t = txt.replace('.', '').replace(""'s"", '').strip().split()
    name_indices = [names.index(who) for who in (t[0], t[-1])]
    constraint_expr += ' and abs(alloc[%i] - alloc[%i]) > 1' % tuple(name_indices)
 
def do_question(txt):
    global constraint_expr, names, lennames
 
    exec_txt = '''
for alloc in product(range(1,floors+1), repeat=len(names)):
    if %s:
        break
else:
    alloc = None
''' % constraint_expr
    exec(exec_txt, globals(), locals())
    a = locals()['alloc']
    if a:
        output= ['Floors are numbered from 1 to %i inclusive.' % floors]
        for a2n in zip(a, names):
            output += ['  Floor %i is occupied by %s' % a2n]
        output.sort(reverse=True)
        print('\n'.join(output))
    else:
        print('No solution found.')
    print()
 
handler = {
    'namelist': do_namelist,
    'floorcount': do_floorcount,
    'not_live': do_not_live,
    'not_either': do_not_either,
    'hi_lower': do_hi_lower,
    'adjacency': do_adjacency,
    'question': do_question,
    }
def parse_and_solve(problem):
    p = re.sub(r'\s+', ' ', problem).strip()
    for x in problem_re.finditer(p):
        groupname, txt = [(k,v) for k,v in x.groupdict().items() if v][0]
        #print (""%r, %r"" % (groupname, txt))
        handler[groupname](txt)",Human_written,Python_from_C#
http://rosettacode.org/wiki/Character_codes,Character codes,"

Task

Given a character value in your language, print its code   (could be ASCII code, Unicode code, or whatever your language uses).



Example

The character   'a'   (lowercase letter A)   has a code of 97 in ASCII   (as well as Unicode, as ASCII forms the beginning of Unicode).

Conversely, given a code, print out the corresponding character.



",Python,"print ord('a') # prints ""97""
print chr(97)  # prints ""a""",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/Arithmetic-geometric_mean,Arithmetic-geometric mean,"

 This page uses content from Wikipedia. The original article was at Arithmetic-geometric mean. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Write a function to compute the arithmetic-geometric mean of two numbers.



The arithmetic-geometric mean of two numbers can be (usefully) denoted as 




a
g
m

(
a
,
g
)


{\displaystyle \mathrm {agm} (a,g)}

, and is equal to the limit of the sequence:

 




a

0


=
a
;


g

0


=
g


{\displaystyle a_{0}=a;\qquad g_{0}=g}


 




a

n
+
1


=



1
2



(

a

n


+

g

n


)
;


g

n
+
1


=



a

n



g

n




.


{\displaystyle a_{n+1}={\tfrac {1}{2}}(a_{n}+g_{n});\quad g_{n+1}={\sqrt {a_{n}g_{n}}}.}


Since the limit of 




a

n


−

g

n




{\displaystyle a_{n}-g_{n}}

 tends (rapidly) to zero with iterations, this is an efficient method.

Demonstrate the function by calculating:






a
g
m

(
1
,
1

/



2


)


{\displaystyle \mathrm {agm} (1,1/{\sqrt {2}})}




Also see

   mathworld.wolfram.com/Arithmetic-Geometric Mean

",Python,"from math import sqrt
 
def agm(a0, g0, tolerance=1e-10):
    """"""
    Calculating the arithmetic-geometric mean of two numbers a0, g0.
 
    tolerance     the tolerance for the converged 
                  value of the arithmetic-geometric mean
                  (default value = 1e-10)
    """"""
    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)
    while abs(an - gn) > tolerance:
        an, gn = (an + gn) / 2.0, sqrt(an * gn)
    return an
 
print agm(1, 1 / sqrt(2))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Read_a_configuration_file,Read a configuration file,"The task is to read a configuration file in standard configuration file format,
and set variables accordingly.

For this task, we have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines beginning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# This is the fullname parameter
FULLNAME Foo Barber

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# Configuration option names are not case sensitive, but configuration parameter
# data is case sensitive and may be preserved by the application program.

# An optional equals sign can be used to separate configuration parameter data
# from the option name. This is dropped by the parser. 

# A configuration option may take multiple parameters separated by commas.
# Leading and trailing whitespace around parameter names and parameter data fields
# are ignored by the application program.

OTHERFAMILY Rhu Barber, Harry Barber



For the task we need to set four variables according to the configuration entries as follows:

fullname = Foo Barber
favouritefruit = banana
needspeeling = true
seedsremoved = false


We also have an option that contains multiple parameters. These may be stored in an array.

 otherfamily(1) = Rhu Barber
 otherfamily(2) = Harry Barber


Related tasks
 Update a configuration file

",Python,"fullname = favouritefruit = """"
needspeeling = seedsremoved = False
otherfamily = []
 
for line in open(""config.file""):
  line = line.rstrip()
  key, value = line.split(None, 1)
  if key.startswith((""#"", "";"")):
    continue
  elif key == ""FULLNAME"":
    fullname = value
  elif key == ""FAVOURITEFRUIT"":
    favouritefruit = value
  elif key == ""NEEDSPEELING"":
    needspeeling = True
  elif key == ""SEEDSREMOVED"":
    seedsremoved = True
  elif key == ""OTHERFAMILY"":
    otherfamily = [name.strip() for name in value.split("","")]
  elif key.startswith("".""):
    print ""%s: unknown key"" % key
 
print ""fullname       = %s"" % fullname
print ""favouritefruit = %s"" % favouritefruit
print ""needspeeling   = %s"" % needspeeling
print ""seedsremoved   = %s"" % seedsremoved
for i, name in enumerate(otherfamily):
  print ""otherfamily(%d) = %s"" % (i+1, name)",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Call_a_function_in_a_shared_library,Call a function in a shared library,"Show how to call a function in a shared library (without dynamically linking to it at compile-time). In particular, show how to call the shared library function if the library is available, otherwise use an internal equivalent function.

This is a special case of calling a foreign language function where the focus is close to the ABI level and not at the normal API level.



Related task

 OpenGL -- OpenGL is usually maintained as a shared library.

",Python,"import ctypes
 
user32_dll = ctypes.cdll.LoadLibrary('User32.dll')
print user32_dll.GetDoubleClickTime()",Human_written,Python_from_Go
http://rosettacode.org/wiki/Huffman_coding,Huffman coding,"Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.

For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and less frequently occurring letters such as q and x with longer bit strings.

Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).

A Huffman encoding can be computed by first creating a tree of nodes:


 Create a leaf node for each symbol and add it to the priority queue.
 While there is more than one node in the queue:
 Remove the node of highest priority (lowest probability) twice to get two nodes.
 Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
 Add the new node to the queue.
 The remaining node is the root node and the tree is complete.


Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:



Task

Using the characters and their frequency from the string:

     this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.



",Python,"from priority_queue import PriorityQueue
 
def huffman_encoding(str):
    char_count = {}
    for c in str:
        char_count[c] = char_count.get(c, 0) + 1
 
    pq = PriorityQueue()
    # chars with fewest count have highest priority
    for char, count in char_count.items():
        pq.push(char, count)
 
    while pq.length > 1:
        key1, prio1 = pq.delete_min()
        key2, prio2 = pq.delete_min()
        pq.push([key1, key2], prio1 + prio2)
 
    return dict(generate_encoding(pq.min_key))
 
def generate_encoding(ary, prefix=""""):
    if isinstance(ary, list):
        return generate_encoding(ary[0], prefix + ""0"") + generate_encoding(ary[1], prefix + ""1"")
    else:
        return [(ary, prefix)]
 
def encode(str, encoding):
    return """".join(encoding[char] for char in str)
 
def decode(encoded, encoding):
    rev_enc = {v: k for k, v in encoding.items()}
    decoded = """"
    pos = 0
    while pos < len(encoded):
        key = """"
        while key not in rev_enc:
            key += encoded[pos]
            pos += 1
        decoded += rev_enc[key]
    return decoded
 
str = ""this is an example for huffman encoding""
encoding = huffman_encoding(str)
for x in sorted(encoding.items()):
    print(x)
 
enc = encode(str, encoding)
dec = decode(enc, encoding)
print(""success!"" if str == dec else ""failure!"")",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Circles_of_given_radius_through_two_points,Circles of given radius through two points,"
Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.

Exceptions

 r==0.0 should be treated as never describing circles (except in the case where the points are coincident).
 If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point.
 If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language.
 If the points are too far apart then no circles can be drawn.


Task detail

 Write a function/subroutine/method/... that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned.
 Show here the output for the following inputs:
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0



Related task

   Total circles area.


See also

   Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel

",Python,"from collections import namedtuple
from math import sqrt
 
Pt = namedtuple('Pt', 'x, y')
Circle = Cir = namedtuple('Circle', 'x, y, r')
 
def circles_from_p1p2r(p1, p2, r):
    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'
    if r == 0.0:
        raise ValueError('radius of zero')
    (x1, y1), (x2, y2) = p1, p2
    if p1 == p2:
        raise ValueError('coincident points gives infinite number of Circles')
    # delta x, delta y between points
    dx, dy = x2 - x1, y2 - y1
    # dist between points
    q = sqrt(dx**2 + dy**2)
    if q > 2.0*r:
        raise ValueError('separation of points > diameter')
    # halfway point
    x3, y3 = (x1+x2)/2, (y1+y2)/2
    # distance along the mirror line
    d = sqrt(r**2-(q/2)**2)
    # One answer
    c1 = Cir(x = x3 - d*dy/q,
             y = y3 + d*dx/q,
             r = abs(r))
    # The other answer
    c2 = Cir(x = x3 + d*dy/q,
             y = y3 - d*dx/q,
             r = abs(r))
    return c1, c2
 
if __name__ == '__main__':
    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),
                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),
                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),
                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),
                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:
        print('Through points:\n  %r,\n  %r\n  and radius %f\nYou can construct the following circles:'
              % (p1, p2, r))
        try:
            print('  %r\n  %r\n' % circles_from_p1p2r(p1, p2, r))
        except ValueError as v:
            print('  ERROR: %s\n' % (v.args[0],))",Human_written,Python_from_Kotlin
http://rosettacode.org/wiki/SHA-256,SHA-256,"SHA-256 is the recommended stronger alternative to SHA-1. See FIPS PUB 180-4 for implementation details.

Either by using a dedicated library or implementing the algorithm in your language, show that the SHA-256 digest of the string ""Rosetta code"" is: 764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf
",Python,">>> import hashlib
>>> hashlib.sha256( ""Rosetta code"".encode() ).hexdigest()
'764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf'
>>>",Human_written,Python_from_Java
http://rosettacode.org/wiki/Semiprime,Semiprime,"Semiprime numbers are natural numbers that are products of exactly two (possibly equal) prime numbers.


Semiprimes   are also known as:

   semi-primes
   biprimes
   bi-primes
    2-almost    primes
   or simply:    P2  


Example
 
   1679  =  23 × 73  

(This particular number was chosen as the length of the Arecibo message).



Task

Write a function determining whether a given number is semiprime.



See also

 The Wikipedia article:  semiprime.
 The Wikipedia article:  almost prime.
 The OEIS sequence:  A001358: semiprimes  which has a shorter definition: the product of two primes.

",Python,"from prime_decomposition import decompose
 
def semiprime(n):
    d = decompose(n)
    try:
        return next(d) * next(d) == n
    except StopIteration:
        return False",Human_written,Python_from_Java
http://rosettacode.org/wiki/Search_a_list_of_records,Search a list of records,"Many programming languages provide convenient ways to look for a known value in a simple list of strings or numbers.

But what if the elements of the list are themselves compound records/objects/data-structures, and the search condition is more complex than a simple equality test?

Task[edit]
Write a function/method/etc. that can find the first element in a given list matching a given condition.

It should be as generic and reusable as possible.

(Of course if your programming language already provides such a feature, you can use that instead of recreating it.)

Then to demonstrate its functionality, create the data structure specified under #Data set, and perform on it the searches specified under #Test cases.

Data set
The data structure to be used contains the names and populations (in millions) of the 10 largest metropolitan areas in Africa, and looks as follows when represented in JSON:

[
  { ""name"": ""Lagos"",                ""population"": 21.0  },
  { ""name"": ""Cairo"",                ""population"": 15.2  },
  { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
  { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
  { ""name"": ""Mogadishu"",            ""population"":  5.85 },
  { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
  { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
  { ""name"": ""Alexandria"",           ""population"":  4.58 },
  { ""name"": ""Abidjan"",              ""population"":  4.4  },
  { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
However, you shouldn't parse it from JSON, but rather represent it natively in your programming language.

 The top-level data structure should be an ordered collection (i.e. a list, array, vector, or similar).
 Each element in this list should be an associative collection that maps from keys to values (i.e. a struct, object, hash map, dictionary, or similar).
 Each of them has two entries: One string value with key ""name"", and one numeric value with key ""population"".
 You may rely on the list being sorted by population count, as long as you explain this to readers.


If any of that is impossible or unreasonable in your programming language, then feel free to deviate, as long as you explain your reasons in a comment above your solution.

Test cases


 Search

 Expected result


 Find the (zero-based) index of the first city in the list whose name is ""Dar Es Salaam""

 6


 Find the name of the first city in this list whose population is less than 5 million

 Khartoum-Omdurman


 Find the population of the first city in this list whose name starts with the letter ""A""

 4.58

Guidance
If your programming language supports higher-order programming, then the most elegant way to implement the requested functionality in a generic and reusable way, might be to write a function (maybe called ""find_index"" or similar), that takes two arguments:

 The list to search through.
 A function/lambda/closure (the so-called ""predicate""), which will be applied in turn to each element in the list, and whose boolean return value defines whether that element matches the search requirement.
If this is not the approach which would be most natural or idiomatic in your language, explain why, and show what is.

Related tasks
 Search a list
",Python,"cities = [
    { ""name"": ""Lagos"",                ""population"": 21.0  },
    { ""name"": ""Cairo"",                ""population"": 15.2  },
    { ""name"": ""Kinshasa-Brazzaville"", ""population"": 11.3  },
    { ""name"": ""Greater Johannesburg"", ""population"":  7.55 },
    { ""name"": ""Mogadishu"",            ""population"":  5.85 },
    { ""name"": ""Khartoum-Omdurman"",    ""population"":  4.98 },
    { ""name"": ""Dar Es Salaam"",        ""population"":  4.7  },
    { ""name"": ""Alexandria"",           ""population"":  4.58 },
    { ""name"": ""Abidjan"",              ""population"":  4.4  },
    { ""name"": ""Casablanca"",           ""population"":  3.98 }
]
 
def first(query):
    return next(query, None)
 
print(
    first(index for index, city in enumerate(cities)
        if city['name'] == ""Dar Es Salaam""),
    first(city['name'] for city in cities if city['population'] < 5),
    first(city['population'] for city in cities if city['name'][0] == 'A'),
    sep='\n')",Human_written,Python_from_C++
http://rosettacode.org/wiki/Arbitrary-precision_integers_(included),Arbitrary-precision integers (included),"Using the in-built capabilities of your language, calculate the integer value of:

        
  
    
      
        
          5
          
            
              4
              
                
                  3
                  
                    2
                  
                
              
            
          
        
      
    
    {\displaystyle 5^{4^{3^{2}}}}
  


 Confirm that the first and last twenty digits of the answer are: 
     62060698786608744707...92256259918212890625

 Find and show the number of decimal digits in the answer.


Note: Do not submit an implementation of arbitrary precision arithmetic. The intention is to show the capabilities of the language as supplied. If a language has a single, overwhelming, library of varied modules that is endorsed by its home site – such as CPAN for Perl or Boost for C++ – then that may be used instead.
Strictly speaking, this should not be solved by fixed-precision numeric libraries where the precision has to be manually set to a large value; although if this is the only recourse then it may be used with a note explaining that the precision must be set manually to a large enough value.


Related tasks

   Long multiplication
   Exponentiation order
   exponentiation operator
   Exponentiation with infix operators in (or operating on) the base

",Python,"import math
import sys
import unittest
 
def main():
    n = math.pow(5, math.pow(4, math.pow(3, 2)))
    result = str(n)
 
    assert len(result) == 183231
    assert result.startswith(""62060698786608744707"")
    assert result.endswith(""92256259918212890625"")
 
    print(""n = 5^4^3^2"")
    print(""n = {0}...{1}"".format(result[:20], result[-20:]))
 
    print(""n digits = {0}"".format(len(result)))
 
if __name__ == '__main__':
    main()",Ai_generated,Python_from_C#
http://rosettacode.org/wiki/I_before_E_except_after_C,I before E except after C,"The phrase      ""I before E, except after C""     is a
widely known mnemonic which is supposed to help when spelling English words.



Task

Using the word list from   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt,

check if the two sub-clauses of the phrase are plausible individually:

   ""I before E when not preceded by C""
   ""E before I when preceded by C""


If both sub-phrases are plausible then the original phrase can be said to be plausible.

Something is plausible if the number of words having the feature is more than two times the number of words having the opposite feature (where feature is 'ie' or 'ei' preceded or not by 'c' as appropriate).



Stretch goal

As a stretch goal use the entries from the table of Word Frequencies in Written and Spoken English: based on the British National Corpus, (selecting those rows with three space or tab separated words only), to see if the phrase is plausible when word frequencies are taken into account.


Show your output here as well as your program.




Other tasks related to string operations:

Metrics
 Array length
 String length
 Copy a string
 Empty string  (assignment)
Counting
 Word frequency
 Letter frequency
 Jewels and stones
 I before E except after C
 Bioinformatics/base count
 Count occurrences of a substring
 Count how many vowels and consonants occur in a string
Remove/replace
 XXXX redacted
 Conjugate a Latin verb
 Remove vowels from a string
 String interpolation (included)
 Strip block comments
 Strip comments from a string
 Strip a set of characters from a string
 Strip whitespace from a string -- top and tail
 Strip control codes and extended characters from a string
Anagrams/Derangements/shuffling
 Word wheel
 ABC problem
 Sattolo cycle
 Knuth shuffle
 Ordered words
 Superpermutation minimisation
 Textonyms (using a phone text pad)
 Anagrams
 Anagrams/Deranged anagrams
 Permutations/Derangements
Find/Search/Determine
 ABC words
 Odd words
 Word ladder
 Semordnilap
 Word search
 Wordiff  (game)
 String matching
 Tea cup rim text
 Alternade words
 Changeable words
 State name puzzle
 String comparison
 Unique characters
 Unique characters in each string
 Extract file extension
 Levenshtein distance
 Palindrome detection
 Common list elements
 Longest common suffix
 Longest common prefix
 Compare a list of strings 
 Longest common substring
 Find common directory path
 Words from neighbour ones
 Change e letters to i in words
 Non-continuous subsequences
 Longest common subsequence
 Longest palindromic substrings
 Longest increasing subsequence
 Words containing ""the"" substring
 Sum of the digits of n is substring of n
 Determine if a string is numeric
 Determine if a string is collapsible
 Determine if a string is squeezable
 Determine if a string has all unique characters
 Determine if a string has all the same characters
 Longest substrings without repeating characters
 Find words which contains all the vowels
 Find words which contains most consonants
 Find words which contains more than 3 vowels
 Find words which first and last three letters are equals
 Find words which odd letters are consonants and even letters are vowels or vice_versa
Formatting
 Substring
 Rep-string
 Word wrap
 String case
 Align columns
 Literals/String
 Repeat a string
 Brace expansion
 Brace expansion using ranges
 Reverse a string
 Phrase reversals
 Comma quibbling
 Special characters
 String concatenation
 Substring/Top and tail
 Commatizing numbers
 Reverse words in a string
 Suffixation of decimal numbers
 Long literals, with continuations 
 Numerical and alphabetical suffixes
 Abbreviations, easy
 Abbreviations, simple
 Abbreviations, automatic
Song lyrics/poems/Mad Libs/phrases
 Mad Libs
 Magic 8-ball
 99 Bottles of Beer
 The Name Game (a song)
 The Old lady swallowed a fly
 The Twelve Days of Christmas
Tokenize
 Text between
 Tokenize a string
 Word break problem
 Tokenize a string with escaping
 Split a character string based on change of character
Sequences
 Show ASCII table
 De Bruijn sequences
 Self-referential sequences
 Generate lower case ASCII alphabet




cf.

 Schools to rethink 'i before e' - BBC news, 20 June 2009
 I Before E Except After C - QI Series 8 Ep 14, (humorous)
 Companion website for the book: ""Word Frequencies in Written and Spoken English: based on the British National Corpus"".

",Python,"import re
cie = 0
cei = 0
ie = 0
ei = 0

def YYLex():
    global cie, cei, ie, ei
    while True:
        line = input()
        if line == """":
            break
        cie += len(re.findall(r'cie', line, re.IGNORECASE))
        cei += len(re.findall(r'cei', line, re.IGNORECASE))
        ie += len(re.findall(r'ie', line, re.IGNORECASE))
        ei += len(re.findall(r'ei', line, re.IGNORECASE))

YYLex()
print(""I before E when not preceded by C: "" + (""plausible"" if 2*ei < ie else ""implausible""))
print(""E before I when preceded by C: "" + (""plausible"" if 2*cie < cei else ""implausible""))
print(""Overall, the rule is: "" + (""plausible"" if 2*(cie+ei) < (cei+ie) else ""implausible""))",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Egyptian_division,Egyptian division,"Egyptian division is a method of dividing integers using addition and
doubling that is similar to the algorithm of Ethiopian multiplication

Algorithm:

Given two numbers where the dividend is to be divided by the divisor:

 Start the construction of a table of two columns: powers_of_2, and doublings; by a first row of a 1 (i.e. 2^0) in the first column and 1 times the divisor in the first row second column.
 Create the second row with columns of 2 (i.e 2^1), and 2 * divisor in order.
 Continue with successive i’th rows of 2^i and 2^i * divisor.
 Stop adding rows, and keep only those rows, where 2^i * divisor is less than or equal to the dividend.
 We now assemble two separate sums that both start as zero, called here answer and accumulator
 Consider each row of the table, in the reverse order of its construction.
 If the current value of the accumulator added to the doublings cell would be less than or equal to the dividend then add it to the accumulator, as well as adding the powers_of_2 cell value to the answer.
 When the first row has been considered as above, then the integer division of dividend by divisor is given by answer.
 (And the remainder is given by the absolute value of accumulator - dividend).


Example: 580 / 34

 Table creation: 



 powers_of_2

 doublings


 1

 34


 2

 68


 4

 136


 8

 272


 16

 544

 Initialization of sums: 



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544










 0

 0

 Considering table rows, bottom-up: 

When a row is considered it is shown crossed out if it is not accumulated, or bold if the row causes summations.



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272






 16

 544

 16

 544



 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136






 8

 272

 16

 544


 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68






 4

 136

 16

 544


 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34






 2

 68

 16

 544


 4

 136






 8

 272






 16

 544







 powers_of_2

 doublings

 answer

 accumulator


 1

 34

 17

 578


 2

 68






 4

 136






 8

 272






 16

 544





Answer

So 580 divided by 34 using the Egyptian method is 17 remainder (578 - 580) or 2.



Task

The task is to create a function that does Egyptian division. The function should

closely follow the description above in using a list/array of powers of two, and

another of doublings.

 Functions should be clear interpretations of the algorithm.
 Use the function to divide 580 by 34 and show the answer here, on this page.


Related tasks

   Egyptian fractions


References

   Egyptian Number System

",Python,"from itertools import product
 
def egyptian_divmod(dividend, divisor):
    assert divisor != 0
    pwrs, dbls = [1], [divisor]
    while dbls[-1] <= dividend:
        pwrs.append(pwrs[-1] * 2)
        dbls.append(pwrs[-1] * divisor)
    ans, accum = 0, 0
    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):
        if accum + dbl <= dividend:
            accum += dbl
            ans += pwr
    return ans, abs(accum - dividend)
 
if __name__ == ""__main__"":
    # Test it gives the same results as the divmod built-in
    for i, j in product(range(13), range(1, 13)):
            assert egyptian_divmod(i, j) == divmod(i, j)
    # Mandated result
    i, j = 580, 34
    print(f'{i} divided by {j} using the Egyption method is %i remainder %i'
          % egyptian_divmod(i, j))",Human_written,Python_from_C
"http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence","Hofstadter-Conway $10,000 sequence","The definition of the sequence is colloquially described as:

   Starting with the list [1,1],
   Take the last number in the list so far: 1, I'll call it x.
   Count forward x places from the beginning of the list to find the first number to add (1)
   Count backward x places from the end of the list to find the second number to add (1)
   Add the two indexed numbers from the list and the result becomes the next number in the list (1+1)
   This would then produce [1,1,2] where 2 is the third element of the sequence.

Note that indexing for the description above starts from alternately the left and right ends of the list and starts from an index of one.

A less wordy description of the sequence is:

   a(1)=a(2)=1
   a(n)=a(a(n-1))+a(n-a(n-1))

The sequence begins:

   1, 1, 2, 2, 3, 4, 4, 4, 5, ...

Interesting features of the sequence are that:

   a(n)/n   tends to   0.5   as   n   grows towards infinity.
   a(n)/n   where   n   is a power of   2   is   0.5
   For   n>4   the maximal value of   a(n)/n   between successive powers of 2 decreases.



The sequence is so named because John Conway offered a prize of $10,000 to the first person who could
find the first position,   p   in the sequence where

   │a(n)/n│ < 0.55  for all  n > p

It was later found that Hofstadter had also done prior work on the sequence.

The 'prize' was won quite quickly by Dr. Colin L. Mallows who proved the properties of the sequence and allowed him to find the value of   n   (which is much smaller than the 3,173,375,556 quoted in the NYT article).



Task

   Create a routine to generate members of the Hofstadter-Conway $10,000 sequence.
   Use it to show the maxima of   a(n)/n   between successive powers of two up to   2**20
   As a stretch goal:   compute the value of   n   that would have won the prize and confirm it is true for   n   up to 2**20


Also see

   Conways Challenge Sequence, Mallows' own account.
   Mathworld Article.

",Python,"from collections import deque
import math
 
def hcseq(n):
    seq = deque([1, 1])
    while len(seq) < n:
        x = seq[-1]
        seq.append(seq[x-1] + seq[len(seq)-x])
    return seq[n-1]
 
pow2 = 1
for i in range(20):
    pow2next = 2*pow2
    max = 0
    for n in range(pow2, pow2next):
        anon = hcseq(n)/float(n)
        if anon > max:
            max = anon
    print ""maximum of a(n)/n between 2^"" + str(i) + "" ("" + str(pow2) + "") and 2^"" + str(i+1) + "" ("" + str(pow2next) + "") is "" + str(max)
    pow2 = pow2next",Ai_generated,Python_from_C++
http://rosettacode.org/wiki/Permutations,Permutations,"Task

Write a program that generates all   permutations   of   n   different objects.   (Practically numerals!)



Related tasks
 
   Find the missing permutation
   Permutations/Derangements



 The number of samples of size k from n objects.


With   combinations and permutations   generation tasks. 






 Order Unimportant

 Order Important


 Without replacement








(


n
k


)




=

n



C

k


=



n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1





{\displaystyle {\binom {n}{k}}=^{n}\operatorname {C} _{k}={\frac {n(n-1)\ldots (n-k+1)}{k(k-1)\dots 1}}}










n



P

k


=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^{n}\operatorname {P} _{k}=n\cdot (n-1)\cdot (n-2)\cdots (n-k+1)}




Task: Combinations

Task: Permutations


 With replacement








(



n
+
k
−
1

k


)




=

n
+
k
−
1



C

k


=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle {\binom {n+k-1}{k}}=^{n+k-1}\operatorname {C} _{k}={(n+k-1)! \over (n-1)!k!}}








n

k




{\displaystyle n^{k}}




Task: Combinations with repetitions

Task: Permutations with repetitions


",Python,"import itertools
for values in itertools.permutations([1,2,3]):
    print (values)",Human_written,Python_from_Go
http://rosettacode.org/wiki/GUI_component_interaction,GUI component interaction,"

Almost every application needs to communicate with the user in some way.
Therefore, a substantial part of the code deals with the interaction
of program logic with GUI components.

Typically, the following is needed:

 put values into input fields under program control
 read and check input from the user
 pop up dialogs to query the user for further information


Task

For a minimal ""application"", write a program that presents a form with three components to the user:

 a numeric input field (""Value"") 
 a button (""increment"")
 a button (""random"")


The field is initialized to zero.

The user may manually enter a new value into the field,
or increment its value with the ""increment"" button.

Entering a non-numeric value should be either impossible,
or issue an error message.

Pressing the ""random"" button presents a confirmation dialog,
and resets the field's value to a random value if the answer is ""Yes"".

(This task may be regarded as an extension of the task Simple windowed application).


",Python,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
    char *s = ""Hello World!"";
    printf(""%s\n"", s);
    return 0;
}",Ai_generated,Python_from_C
http://rosettacode.org/wiki/Dragon_curve,Dragon curve,"

Create and display a dragon curve fractal.

(You may either display the curve directly or write it to an image file.)



Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

 Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle. And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
 The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
 The curl direction right or left can be a parameter instead of two separate routines.
 Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
 This can be seen in the SVG example. This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
 Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
 Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side. If the segment is an even position then on the left. The process is then repeated on the new doubled list of segments. This constructs a full set of line segments before any drawing.
 The effect of the splitting is a kind of bottom-up version of the recursions. See the Asymptote example for code doing this.
 Iteratively the curve always turns 90-degrees left or right at each point. The direction of the turn is given by the bit above the lowest 1-bit of n. Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
 The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
 If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead. This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
 Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
 If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
 Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
 This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
 Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate. This is done in the gnuplot code. This might suit things similar to Gnuplot which want to calculate each point independently.
 Predicate test for whether a given X,Y point or segment is on the curve can be done. This might suit line-by-line output rather than building an entire image before printing. See M4 for an example of this.
 A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient. Why it works is slightly subtle but the calculation is not difficult. (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1. Check vertex by whether the segment either East or West is on the curve.)
 The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points. The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
 As a Lindenmayer system of expansions. The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd. Eg. after 3 levels F_S_F_S_F_S_F_S. The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above. Read more at for instance Joel Castellanos' L-system page.

Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code. The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.

The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level. See for example C by IFS Drawing code. The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 


",Python,"from shoes import *
from struct import *

class Point(Structure):
    _fields_ = [(""x"", c_int), (""y"", c_int)]

class Line(Structure):
    _fields_ = [(""start"", Point), (""stop"", Point)]

def split_segments(n):
    dir = 1
    segments = []
    for l in @segments:
        a, b, c, d = l.start.x, l.start.y, l.stop.x, l.stop.y

        mid_x = a + (c-a)/2.0 - (d-b)/2.0*dir
        mid_y = b + (d-b)/2.0 + (c-a)/2.0*dir
        mid_p = Point(mid_x, mid_y)

        dir *= -1
        segments.append(Line(l.start, mid_p))
        segments.append(Line(mid_p, l.stop))
    return segments

@segments = [Line(Point(200,200), Point(600,200))]
for n in range(15):
    print ""calculating frame %d"" % n
    @segments = split_segments(n)

app(width=800, height=600, resizable=False)
stack do
    for l in @segments:
        line l.start.x, l.start.y, l.stop.x, l.stop.y
end",Ai_generated,Python_from_Ruby
http://rosettacode.org/wiki/Euler_method,Euler method,"Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value.   It is an explicit method for solving initial value problems (IVPs), as described in the wikipedia page.

The ODE has to be provided in the following form:

 






d
y
(
t
)


d
t



=
f
(
t
,
y
(
t
)
)


{\displaystyle {\frac {dy(t)}{dt}}=f(t,y(t))}


with an initial value

 



y
(

t

0


)
=

y

0




{\displaystyle y(t_{0})=y_{0}}


To get a numeric solution, we replace the derivative on the   LHS   with a finite difference approximation:

 






d
y
(
t
)


d
t



≈



y
(
t
+
h
)
−
y
(
t
)

h




{\displaystyle {\frac {dy(t)}{dt}}\approx {\frac {y(t+h)-y(t)}{h}}}


then solve for 



y
(
t
+
h
)


{\displaystyle y(t+h)}

:

 



y
(
t
+
h
)
≈
y
(
t
)
+
h




d
y
(
t
)


d
t





{\displaystyle y(t+h)\approx y(t)+h\,{\frac {dy(t)}{dt}}}


which is the same as

 



y
(
t
+
h
)
≈
y
(
t
)
+
h

f
(
t
,
y
(
t
)
)


{\displaystyle y(t+h)\approx y(t)+h\,f(t,y(t))}


The iterative solution rule is then:

 




y

n
+
1


=

y

n


+
h

f
(

t

n


,

y

n


)


{\displaystyle y_{n+1}=y_{n}+h\,f(t_{n},y_{n})}


where   



h


{\displaystyle h}

   is the step size, the most relevant parameter for accuracy of the solution.   A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.


Example: Newton's Cooling Law

Newton's cooling law describes how an object of initial temperature   



T
(

t

0


)
=

T

0




{\displaystyle T(t_{0})=T_{0}}

   cools down in an environment of temperature   




T

R




{\displaystyle T_{R}}

:

 






d
T
(
t
)


d
t



=
−
k

Δ
T


{\displaystyle {\frac {dT(t)}{dt}}=-k\,\Delta T}


or

 






d
T
(
t
)


d
t



=
−
k

(
T
(
t
)
−

T

R


)


{\displaystyle {\frac {dT(t)}{dt}}=-k\,(T(t)-T_{R})}




It says that the cooling rate   






d
T
(
t
)


d
t





{\displaystyle {\frac {dT(t)}{dt}}}

   of the object is proportional to the current temperature difference   



Δ
T
=
(
T
(
t
)
−

T

R


)


{\displaystyle \Delta T=(T(t)-T_{R})}

   to the surrounding environment.

The analytical solution, which we will compare to the numerical approximation, is

 



T
(
t
)
=

T

R


+
(

T

0


−

T

R


)


e

−
k
t




{\displaystyle T(t)=T_{R}+(T_{0}-T_{R})\;e^{-kt}}




Task

Implement a routine of Euler's method and then to use it to solve the given example of Newton's cooling law with it for three different step sizes of:

   2 s
   5 s       and 
   10 s 
and to compare with the analytical solution.



Initial values

   initial temperature   




T

0




{\displaystyle T_{0}}

   shall be   100 °C
   room temperature   




T

R




{\displaystyle T_{R}}

   shall be   20 °C
   cooling constant     



k


{\displaystyle k}

     shall be   0.07 
   time interval to calculate shall be from   0 s   ──►   100 s


A reference solution (Common Lisp) can be seen below.   We see that bigger step sizes lead to reduced approximation accuracy.

",Python,"import math
 
# fdy is a type for function f used in Euler's method.
# eulerStep computes a single new value using Euler's method.
# Note that step size h is a parameter, so a variable step size
# could be used.
def eulerStep(f, x, y, h):
    return y + h*f(x, y)
 
# Definition of cooling rate.  Note that this has general utility and
# is not specific to use in Euler's method.
 
# newCoolingRate returns a function that computes cooling rate
# for a given cooling rate constant k.
def newCoolingRate(k):
    def coolingRate(deltaTemp):
        return -k * deltaTemp
    return coolingRate
 
# newTempFunc returns a function that computes the analytical solution
# of cooling rate integrated over time.
def newTempFunc(k, ambientTemp, initialTemp):
    def tempFunc(time):
        return ambientTemp + (initialTemp-ambientTemp)*math.exp(-k*time)
    return tempFunc
 
# newCoolingRateDy returns a function of the kind needed for Euler's method.
# That is, a function representing dy(x, y(x)).
#
# Parameters to newCoolingRateDy are cooling constant k and ambient
# temperature.
def newCoolingRateDy(k, ambientTemp):
    crf = newCoolingRate(k)
    # note that result is dependent only on the object temperature.
    # there are no additional dependencies on time, so the x parameter
    # provided by eulerStep is unused.
    def coolingRateDy(_, objectTemp):
        return crf(objectTemp - ambientTemp)
    return coolingRateDy
 
if __name__ == '__main__':
    k =.07
    tempRoom = 20.
    tempObject = 100.
    fcr = newCoolingRateDy(k, tempRoom)
    analytic = newTempFunc(k, tempRoom, tempObject)
    for deltaTime in [2, 5, 10]:
        print(""Step size = %.1f"" % deltaTime)
        print("" Time Euler's Analytic"")
        temp = tempObject
        for time in range(0, 101, deltaTime):
            print(""%5.1f %7.3f %7.3f"" % (time, temp, analytic(time)))
            temp = eulerStep(fcr, time, temp, deltaTime)
        print()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Elementary_cellular_automaton,Elementary cellular automaton,"An elementary cellular automaton is a one-dimensional cellular automaton where there are two possible states (labeled 0 and 1) and the rule to determine the state of a cell in the next generation depends only on the current state of the cell and its two immediate neighbors. Those three values can be encoded with three bits.

The rules of evolution are then encoded with eight bits indicating the outcome of each of the eight possibilities 111, 110, 101, 100, 011, 010, 001 and 000 in this order. Thus for instance the rule 13 means that a state is updated to 1 only in the cases 011, 010 and 000, since 13 in binary is 0b00001101.



Task

Create a subroutine, program or function that allows to create and visualize the evolution of any of the 256 possible elementary cellular automaton of arbitrary space length and for any given initial state. You can demonstrate your solution with any automaton of your choice.

The space state should wrap: this means that the left-most cell should be considered as the right neighbor of the right-most cell, and reciprocally.

This task is basically a generalization of one-dimensional cellular automata.



See also
 Cellular automata (natureofcode.com)

",Python,"def eca(cells, rule):
    lencells = len(cells)
    c = ""0"" + cells + ""0""    # Zero pad the ends
    rulebits = '{0:08b}'.format(rule)
    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}
    yield c[1:-1]
    while True:
        c = ''.join(['0',
                     ''.join(neighbours2next[c[i-1:i+2]]
                             for i in range(1,lencells+1)),
                     '0'])
        yield c[1:-1]
 
if __name__ == '__main__':
    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)
    zipped = [range(lines)] + [eca(start, rule) for rule in rules]
    print('\n   Rules: %r' % (rules,))
    for data in zip(*zipped):
        i = data[0]
        cells = data[1:]
        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '#')))",Human_written,Python_from_Java
http://rosettacode.org/wiki/Floyd-Warshall_algorithm,Floyd-Warshall algorithm,"The Floyd–Warshall algorithm is an algorithm for finding shortest paths in a weighted graph with positive or negative edge weights.




Task
Find the lengths of the shortest paths between all pairs of vertices of the given directed graph. Your code may assume that the input has already been checked for loops, parallel edges and negative cycles.


Print the pair, the distance and (optionally) the path.




Example
pair     dist    path
1 -> 2    -1     1 -> 3 -> 4 -> 2
1 -> 3    -2     1 -> 3
1 -> 4     0     1 -> 3 -> 4
2 -> 1     4     2 -> 1
2 -> 3     2     2 -> 1 -> 3
2 -> 4     4     2 -> 1 -> 3 -> 4
3 -> 1     5     3 -> 4 -> 2 -> 1
3 -> 2     1     3 -> 4 -> 2
3 -> 4     2     3 -> 4
4 -> 1     3     4 -> 2 -> 1
4 -> 2    -1     4 -> 2
4 -> 3     1     4 -> 2 -> 1 -> 3


See also
 Floyd-Warshall Algorithm - step by step guide (youtube)

",Python,"from collections import defaultdict
from itertools import product
 
def floyd_warshall(graph):
    """"""
    Floyd-Warshall algorithm for finding shortest paths in a graph.
    """"""
    dist = defaultdict(lambda: defaultdict(lambda: float('inf')))
    next = defaultdict(lambda: defaultdict(lambda: None))
    for u, v, w in graph:
        dist[u][v] = w
        next[u][v] = v
    for u in dist:
        dist[u][u] = 0
    for u, v, w in product(dist, dist, dist):
        if dist[u][v] > dist[u][w] + dist[w][v]:
            dist[u][v] = dist[u][w] + dist[w][v]
            next[u][v] = next[u][w]
    return dist, next
 
def path(u, v, next):
    """"""
    Reconstruct the path from u to v using the next dictionary.
    """"""
    if next[u][v] is None:
        return []
    path = [u]
    while u!= v:
        u = next[u][v]
        path.append(u)
    return path
 
if __name__ == '__main__':
    graph = [
        (1, 3, -2),
        (3, 4, 2),
        (4, 2, -1),
        (2, 1, 4),
        (2, 3, 3),
    ]
    dist, next = floyd_warshall(graph)
    for u, m in dist.items():
        for v, d in m.items():
            if u!= v:
                print('{} -> {}: {} {}'.format(u, v, d, path(u, v, next)))",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Smith_numbers,Smith numbers,"Smith numbers are numbers such that the sum of the decimal digits of the integers that make up that number is the same as the sum of the decimal digits of its prime factors excluding 1.

By definition, all primes are excluded as they (naturally) satisfy this condition!

Smith numbers are also known as   joke   numbers.



Example
Using the number 166

Find the prime factors of 166 which are: 2 x 83

Then, take those two prime factors and sum all their decimal digits: 2 + 8 + 3 which is 13

Then, take the decimal digits of 166 and add their decimal digits: 1 + 6 + 6 which is 13

Therefore, the number 166 is a Smith number.



Task
Write a program to find all Smith numbers below 10000.



See also
 from Wikipedia:   [Smith number].
 from MathWorld:   [Smith number]. 
 from OEIS A6753:   [OEIS sequence A6753].
 from OEIS A104170:   [Number of Smith numbers below 10^n]. 
 from The Prime pages:   [Smith numbers].

",Python,"from sys import stdout
 
 
def factors(n):
    rt = []
    f = 2
    if n == 1:
        rt.append(1);
    else:
        while 1:
            if 0 == ( n % f ):
                rt.append(f);
                n //= f
                if n == 1:
                    return rt
            else:
                f += 1
    return rt
 
 
def sum_digits(n):
    sum = 0
    while n > 0:
        m = n % 10
        sum += m
        n -= m
        n //= 10
 
    return sum
 
 
def add_all_digits(lst):
    sum = 0
    for i in range (len(lst)):
        sum += sum_digits(lst[i])
 
    return sum
 
 
def list_smith_numbers(cnt):
    for i in range(4, cnt):
        fac = factors(i)
        if len(fac) > 1:
            if sum_digits(i) == add_all_digits(fac):
                stdout.write(""{0} "".format(i) )
 
# entry point
list_smith_numbers(10_000)",Human_written,Python_from_Go
http://rosettacode.org/wiki/Order_by_pair_comparisons,Order by pair comparisons,"
Sorting Algorithm

This is a sorting algorithm.   It may be applied to a set of data in order to sort it.    
For comparing various sorts, see compare sorts.  
For other sorting algorithms,   see sorting algorithms,   or:

O(n logn) sorts
Heap sort |
Merge sort |
Patience sort |
Quick sort
O(n log2n) sorts
Shell Sort
O(n2) sorts
Bubble sort |
Cocktail sort |
Cocktail sort with shifting bounds |
Comb sort |
Cycle sort |
Gnome sort |
Insertion sort |
Selection sort |
Strand sort
other sorts
Bead sort |
Bogo sort |
Common sorted list |
Composite structures sort |
Custom comparator sort |
Counting sort |
Disjoint sublist sort |
External sort |
Jort sort |
Lexicographical sort |
Natural sorting |
Order by pair comparisons |
Order disjoint list items |
Order two numerical lists |
Object identifier (OID) sort |
Pancake sort |
Quickselect |
Permutation sort |
Radix sort |
Ranking methods |
Remove duplicate elements |
Sleep sort |
Stooge sort |
[Sort letters of a string] |
Three variable sort |
Topological sort |
Tree sort


Assume we have a set of items that can be sorted into an order by the user.

The user is presented with pairs of items from the set in no order,
the user states which item
is less than, equal to, or greater than the other (with respect to their
relative positions if fully ordered).

Write a function that given items that the user can order, asks the user to
give the result of comparing two items at a time and uses the comparison results
to eventually return the items in order.

Try and minimise the comparisons the user is asked for.

Show on this page, the function ordering the colours of the rainbow:

   violet red green indigo blue yellow orange

The correct ordering being:

   red orange yellow green blue indigo violet

Note:

 Asking for/receiving user comparisons is a part of the task.
 Code inputs should not assume an ordering.
 The seven colours can form twenty-one different pairs.
 A routine that does not ask the user ""too many"" comparison questions should be used.

",Python,"import sys
 
def interactive_compare(s1, s2):
    print(""Is %s < %s? "" % (s1, s2), end="""")
    response = input()
    return response.startswith(""y"")
 
def main():
    items = [""violet"", ""red"", ""green"", ""indigo"", ""blue"", ""yellow"", ""orange""]
 
    sorted_items = []
 
    # Use a binary insertion sort to order the items.  It should ask for
    # close to the minimum number of questions required
    for item in items:
        print(""Inserting '%s' into %s"" % (item, sorted_items))
        # sort.Search performs the binary search using interactiveCompare to
        # rank the items
        spot_to_insert = 0
        while spot_to_insert < len(sorted_items) and not interactive_compare(item, sorted_items[spot_to_insert]):
            spot_to_insert += 1
        sorted_items.insert(spot_to_insert, item)
    print(sorted_items)
 
if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Go
http://rosettacode.org/wiki/Self_numbers,Self numbers,"A number n is a self number if there is no number g such that g + the sum of g's digits = n. So 18 is not a self number because 9+9=18, 43 is not a self number because 35+5+3=43.


The task is:

 Display the first 50 self numbers;
 I believe that the 100000000th self number is 1022727208. You should either confirm or dispute my conjecture.

224036583-1 is a Mersenne prime, claimed to also be a self number. Extra credit to anyone proving it.


See also
 
OEIS: A003052 - Self numbers or Colombian numbers
Wikipedia: Self numbers",Python,"import math

MC = 103 * 1000 * 10000 + 11 * 9 + 1
SV = [False] * (MC + 1)

def sieve():
    dS = [0] * 10_000
    for a in range(9, -1, -1):
        for b in range(9, -1, -1):
            for c in range(9, -1, -1):
                for d in range(9, -1, -1):
                    dS[a * 1000 + b * 100 + c * 10 + d] = a + b + c + d
    for a in range(0, 103):
        for b in range(0, 1000):
            for c in range(0, 10000):
                SV[dS[a * 1000 + b] + dS[c] + a * 10000 + b * 1000 + c] = True

def main():
    sieve()
    print(""The first 50 self numbers are:"")
    count = 0
    for i in range(0, MC):
        if not SV[i]:
            count += 1
            if count <= 50:
                print(i, end="" "")
            else:
                print(""\n\n       Index     Self number"")
    limit = 1
    count = 0
    for i in range(0, MC):
        if not SV[i]:
            count += 1
            if count == limit:
                print(f""{count:12,d}   {i:13,d}"")
                limit *= 10

if __name__ == ""__main__"":
    main()",Ai_generated,Python_from_Java
